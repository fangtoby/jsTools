cscope 15 $HOME/Desktop/T/yiban -q 0000004979 0001381513
	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/fsevents.cc

6 
	~"n.h
"

7 
	~"uv.h
"

8 
	~"v8.h
"

9 
	~"had.h
"

10 
	~"CeFoundi/CeFoundi.h
"

11 
	~"CeSvis/CeSvis.h
"

12 
	~<ioam
>

13 
	~<ve
>

15 
	~"c/age.cc
"

16 
mea
 
	gf
 {

17 as
	cFSEvts
 : 
public
 
node
::
ObjeWp
 {

18 
public
:

19 
FSEvts
(cڡ *
th
, 
N
::
Clback
 *
hdr
);

20 ~
FSEvts
();

23 
bo
 
	glockSed
;

24 
had_mux_t
 
	glockmux
;

25 
lockgS
();

26 
lock
();

27 
uock
();

28 
lockgSt
();

31 
uv_async_t
 
	gasync
;

32 
asyncS
();

33 
asyncTrigg
();

34 
asyncSt
();

37 
had_t
 
	gthad
;

38 
CFRunLoRef
 
	gthadlo
;

39 
thadS
();

40 *
thadRun
(*
x
);

41 
thadSt
();

44 
	gN
::
Clback
 *
hdr
;

45 
emEvt
(cڡ *
th
, 
UI32
 
ags
, 
UI64
 
id
);

48 
CFAayRef
 
	gths
;

49 
	gd
::
ve
<
f_evt
*> 
evts
;

50 
Inlize
(
v8
::
Hd
<v8::
Obje
> 
expts
);

53 
NAN_METHOD
(
New
);

54 
NAN_METHOD
(
St
);

55 
NAN_METHOD
(
S
);

60 
usg
 
mea
 
	gf
;

62 
	gFSEvts
::
	$FSEvts
(cڡ *
th
, 
N
::
Clback
 *
hdr
): 
	$hdr
(
hdr
) {

63 
CFSgRef
 
ds
[] = { 
	`CFSgCeWhCSg
(
NULL
, 
th
, 
kCFSgEncodgUTF8
) };

64 
ths
 = 
	`CFAayCe
(
NULL
, (cڡ **)&
ds
, 1, NULL);

65 
thadlo
 = 
NULL
;

66 
	`lockgS
();

67 
	}
}

68 
	gFSEvts
::~
	$FSEvts
() {

69 
d
::
cout
 << "YIKES" << std::
dl
;

70 
	`lockgSt
();

71 
de
 
hdr
;

72 
hdr
 = 
NULL
;

74 
	`CFR
(
ths
);

75 
	}
}

77 #ide
kFSEvtSmEvtFgImCed


78 
	#kFSEvtSmEvtFgImCed
 0x00000010

	)

81 
	~"c/lockg.cc
"

82 
	~"c/async.cc
"

83 
	~"c/thad.cc
"

84 
	~"c/cڡts.cc
"

85 
	~"c/mhods.cc
"

87 
	gFSEvts
::
Inlize
(
v8
::
Hd
<v8::
Obje
> 
expts
) {

88 
v8
::
Lol
<v8::
FuniTeme
> 
l
 = 
N
::
New
<v8::FuniTeme>(
FSEvts
::New);

89 
	gl
->
SCssName
(
N
::
New
<
v8
::
Sg
>("FSEvts").
ToLolChecked
());

90 
	gl
->
InTeme
()->
SIlFldCou
(1);

91 
	gl
->
PryTeme
()->
S
(

92 
N
::
New
<
v8
::
Sg
>("t").
ToLolChecked
(),

93 
N
::
New
<
v8
::
FuniTeme
>(
FSEvts
::
S
));

94 
	gl
->
PryTeme
()->
S
(

95 
N
::
New
<
v8
::
Sg
>("").
ToLolChecked
(),

96 
N
::
New
<
v8
::
FuniTeme
>(
FSEvts
::
St
));

97 
	gexpts
->
S
(
N
::
New
<
v8
::
Sg
>("Cڡts").
ToLolChecked
(), 
Cڡts
());

98 
	gexpts
->
S
(
N
::
New
<
v8
::
Sg
>("FSEvts").
ToLolChecked
(),

99 
l
->
GFuni
());

102 
NODE_MODULE
(
f
, 
FSEvts
::
Inlize
)

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan.h

20 #ide
NAN_H_


21 
	#NAN_H_


	)

23 
	~<node_vsi.h
>

25 
	#NODE_0_10_MODULE_VERSION
 11

	)

26 
	#NODE_0_12_MODULE_VERSION
 14

	)

27 
	#ATOM_0_21_MODULE_VERSION
 41

	)

28 
	#IOJS_1_0_MODULE_VERSION
 42

	)

29 
	#IOJS_1_1_MODULE_VERSION
 43

	)

30 
	#IOJS_2_0_MODULE_VERSION
 44

	)

31 
	#IOJS_3_0_MODULE_VERSION
 45

	)

32 
	#NODE_4_0_MODULE_VERSION
 46

	)

33 
	#NODE_5_0_MODULE_VERSION
 47

	)

34 
	#NODE_6_0_MODULE_VERSION
 48

	)

36 #ifde
_MSC_VER


37 
	#NAN_HAS_CPLUSPLUS_11
 (
_MSC_VER
 >1800)

	)

39 
	#NAN_HAS_CPLUSPLUS_11
 (
__lulus
 >201103L)

	)

42 #i
NODE_MODULE_VERSION
 >
IOJS_3_0_MODULE_VERSION
 && !
NAN_HAS_CPLUSPLUS_11


43 #r 
This
 
vsi
 
of
 
node
/
NAN
/
v8
 
ques
 
a
 
C
++11 
comp


46 
	~<uv.h
>

47 
	~<node.h
>

48 
	~<node_bufr.h
>

49 
	~<node_obje_wp.h
>

50 
	~<gܙhm
>

51 
	~<crg
>

52 
	~<ims
>

53 
	~<cdlib
>

54 #i
defed
(
_MSC_VER
)

55 #agm
wng

push
 )

56 #agm
wng

dib
 : 4530 )

57 
	~<rg
>

58 
	~<ve
>

59 #agm
wng

p
 )

61 
	~<rg
>

62 
	~<ve
>

66 #ifde
UV_VERSION_MAJOR


67 #ide
UV_VERSION_PATCH


68 
	#UV_VERSION_PATCH
 0

	)

70 
	#NAUV_UVVERSION
 ((
UV_VERSION_MAJOR
 << 16) | \

71 (
UV_VERSION_MINOR
 << 8) | \

72 (
UV_VERSION_PATCH
))

	)

74 
	#NAUV_UVVERSION
 0x000b00

	)

77 #i
NAUV_UVVERSION
 < 0x000b0b

78 #ifde
WIN32


79 
	~<wdows.h
>

81 
	~<had.h
>

85 
mea
 
	gN
 {

87 #i
defed
(
__GNUC__
&& !(defed(
DEBUG
) && DEBUG)

88 
	#NAN_INLINE
 
le
 
	`__ibu__
((
ways_le
))

	)

89 #i
defed
(
_MSC_VER
&& !(defed(
DEBUG
) && DEBUG)

90 
	#NAN_INLINE
 
__fle


	)

92 
	#NAN_INLINE
 
le


	)

95 #i
defed
(
__GNUC__
) && \

96 !(
defed
(
V8_DISABLE_DEPRECATIONS
&& 
	gV8_DISABLE_DEPRECATIONS
)

97 
	#NAN_DEPRECATED
 
	`__ibu__
((
dd
))

	)

98 #i
defed
(
_MSC_VER
) && \

99 !(
defed
(
V8_DISABLE_DEPRECATIONS
&& 
	gV8_DISABLE_DEPRECATIONS
)

100 
	#NAN_DEPRECATED
 
	`__deec
(
dd
)

	)

102 
	#NAN_DEPRECATED


	)

105 #i
NAN_HAS_CPLUSPLUS_11


106 
	#NAN_DISALLOW_ASSIGN
(
CLASS

ݔ
=(cڡ CLASS&
de
;

	)

107 
	#NAN_DISALLOW_COPY
(
CLASS

	`CLASS
(cڡ CLASS&
de
;

	)

108 
	#NAN_DISALLOW_MOVE
(
CLASS
) \

109 
	`CLASS
(
CLASS
&&
de
; \

110 
ݔ
=(
CLASS
&&
de
;

	)

112 
	#NAN_DISALLOW_ASSIGN
(
CLASS

ݔ
=(cڡ CLASS&);

	)

113 
	#NAN_DISALLOW_COPY
(
CLASS

	`CLASS
(cڡ CLASS&);

	)

114 
	#NAN_DISALLOW_MOVE
(
CLASS
)

	)

117 
	#NAN_DISALLOW_ASSIGN_COPY
(
CLASS
) \

118 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

119 
	`NAN_DISALLOW_COPY
(
CLASS
)

	)

121 
	#NAN_DISALLOW_ASSIGN_MOVE
(
CLASS
) \

122 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

123 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

125 
	#NAN_DISALLOW_COPY_MOVE
(
CLASS
) \

126 
	`NAN_DISALLOW_COPY
(
CLASS
) \

127 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

129 
	#NAN_DISALLOW_ASSIGN_COPY_MOVE
(
CLASS
) \

130 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

131 
	`NAN_DISALLOW_COPY
(
CLASS
) \

132 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

134 
	#TYPE_CHECK
(
T
, 
S
) \

135 
l
) { \

136 *(
ic_
<
T
 *vީ*>(0)ic_<
S
*>(0); \

137 }

	)

141 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


142 
	gv8
::
	tHd
<
	tv8
::
	tObje
> 
	tADDON_REGISTER_FUNCTION_ARGS_TYPE
;

144 
	gv8
::
	tLol
<
	tv8
::
	tObje
> 
	tADDON_REGISTER_FUNCTION_ARGS_TYPE
;

147 
	#NAN_MODULE_INIT
(
me
) \

148 
	`me
(
N
::
ADDON_REGISTER_FUNCTION_ARGS_TYPE
 
rg
)

	)

152 
	~"n_backs.h
"

156 #i(
NODE_MODULE_VERSION
 < 
NODE_0_12_MODULE_VERSION
)

157 
	gv8
::
	tSt
 
	tUnboundSt
;

158 
	gv8
::
	tSt
 
	tBoundSt
;

160 
	gv8
::
	tUnboundSt
 UnboundScript;

161 
	gv8
::
	tSt
 
	tBoundSt
;

164 #i(
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION
)

165 
	gv8
::
	tSg
::
	tExAsciiSgResour


166 
	tExOBySgResour
;

168 
	gv8
::
	tSg
::
	tExOBySgResour


169 
	tExOBySgResour
;

172 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

173 
	gme
<
tyme
 
	gT
>

174 
ass
 
	gNCyabPsitTs
 :

175 
public
 
v8
::
NCyabPsitTs
<
T
> {};

176 
	gme
<
tyme
 
	gT
>

177 
ass
 
	gCyabPsitTs
 :

178 
public
 
v8
::
CyabPsitTs
<
T
> {};

180 
	gme
<
tyme
 
	gT
>

181 
ass
 
	gPsitBa
 :

182 
public
 
v8
::
PsitBa
<
T
> {};

184 
	gme
<
tyme
 
	gT
,ym
	gM
 = 
v8
::
NCyabPsitTs
<
T
> >

185 
ass
 
Psit
;

187 
	gme
<
tyme
 
	gT
> 
ass
 
	gNCyabPsitTs
;

188 
	gme
<
tyme
 
	gT
> 
ass
 
	gPsitBa
;

189 
	gme
<
tyme
 
	gT
,ym
	gP
> 
ass
 
	gWkClbackDa
;

190 
	gme
<
tyme
 
	gT
,ym
	gM
 = 
NCyabPsitTs
<
T
> >

191 
ass
 
Psit
;

194 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

195 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

196 
	~"n_maybe_43_l.h
"

198 
	~"n_maybe_e_43_l.h
"

201 
	~"n_cvrs.h
"

202 
	~"n_w.h
"

204 #i
NAUV_UVVERSION
 < 0x000b17

205 
	#NAUV_WORK_CB
(
func
) \

206 
	`func
(
uv_async_t
 *
async
, )

	)

208 
	#NAUV_WORK_CB
(
func
) \

209 
	`func
(
uv_async_t
 *
async
)

	)

212 #i
NAUV_UVVERSION
 >= 0x000b0b

214 
uv_key_t
 
	tuv_key_t
;

216 
le
 
uv_key_
(
uv_key_t
 *
key
) {

217  
uv_key_
(
key
);

220 
le
 
uv_key_de
(
uv_key_t
 *
key
) {

221 
uv_key_de
(
key
);

224 
le
 * 
uv_key_g
(
uv_key_t
 *
key
) {

225  
uv_key_g
(
key
);

228 
le
 
uv_key_t
(
uv_key_t
 *
key
, *
vue
) {

229 
uv_key_t
(
key
, 
vue
);

239 #ide
WIN32


241 
had_key_t
 
	tuv_key_t
;

243 
le
 
uv_key_
(
uv_key_t
* 
key
) {

244  -
had_key_
(
key
, 
NULL
);

247 
le
 
uv_key_de
(
uv_key_t
* 
key
) {

248 i(
had_key_de
(*
key
))

249 
abt
();

252 
le
 * 
uv_key_g
(
uv_key_t
* 
key
) {

253  
had_gecific
(*
key
);

256 
le
 
uv_key_t
(
uv_key_t
* 
key
, * 
vue
) {

257 i(
had_tecific
(*
key
, 
vue
))

258 
abt
();

264 
DWORD
 
	gs_dex
;

265 } 
	tuv_key_t
;

267 
le
 
uv_key_
(
uv_key_t
* 
key
) {

268 
	gkey
->
	gs_dex
 = 
TlsAoc
();

269 i(
	gkey
->
	gs_dex
 =
TLS_OUT_OF_INDEXES
)

270  
UV_ENOMEM
;

274 
le
 
uv_key_de
(
uv_key_t
* 
key
) {

275 i(
TlsFe
(
key
->
s_dex
=
FALSE
)

276 
abt
();

277 
	gkey
->
	gs_dex
 = 
TLS_OUT_OF_INDEXES
;

280 
le
 * 
uv_key_g
(
uv_key_t
* 
key
) {

281 * 
	gvue
 = 
TlsGVue
(
key
->
s_dex
);

282 i(
	gvue
 =
NULL
)

283 i(
GLaE
(!
ERROR_SUCCESS
)

284 
abt
();

285  
	gvue
;

288 
le
 
uv_key_t
(
uv_key_t
* 
key
, * 
vue
) {

289 i(
TlsSVue
(
key
->
s_dex
, 
vue
=
FALSE
)

290 
abt
();

296 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


297 
	gme
<
tyme
 
	gT
>

298 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T>);

301 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

302 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

303 
v8
::
	tWkClbackTy
 WeakCallbackType;

305 
	sWkClbackTy
 {

306 
	eE
 {
	gkPam
, 
	gkIlFlds
};

307 
E
 
	gty
;

308 
WkClbackTy
(
E
 
h
: 
ty
(other) {}

309 
le
 
bo
 
ݔ
==(
E
 
h
{  oth =
this
->
ty
; }

310 
le
 
bo
 
	gݔ
!=(
E
 
h
{  !
ݔ
==(other); }

314 
	gme
<
tyme
 
	gP
> 
ass
 
	gWkClbackInfo
;

316 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


317 
	~"n_rsit_12_l.h
"

319 
	~"n_rsit_e_12_l.h
"

322 
mea
 
	gimp
 {

323 cڡ 
size_t
 
	gkMaxLgth
 = 0x3fffffff;

326 #i
NODE_MAJOR_VERSION
 > 0 || \

327 
	gNODE_MINOR_VERSION
 > 10 || \

328 
	gNODE_MINOR_VERSION
 =10 && 
NODE_PATCH_VERSION
 >= 29 || \

329 
NODE_MINOR_VERSION
 =8 && 
NODE_PATCH_VERSION
 >= 27

330 cڡ 
kRInvidUtf8
 = 
v8
::
Sg
::
REPLACE_INVALID_UTF8
;

332 cڡ 
	gkRInvidUtf8
 = 0;

338 as
	cHdSce
 {

339 
	gv8
::
HdSce
 
sce
;

341 
	gpublic
:

342 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


343 
le
 
HdSce
(: 
sce
(
v8
::
Isީe
::
GCut
()) {}

344 
le
 
NumbOfHds
() {

345  
v8
::
HdSce
::
NumbOfHds
(v8::
Isީe
::
GCut
());

348 
le
 
HdSce
(: 
sce
() {}

349 
le
 
NumbOfHds
() {

350  
v8
::
HdSce
::
NumbOfHds
();

354 
	give
:

357 
HdSce
(const HandleScope &);

358 
	gݔ
=(cڡ 
HdSce
 &);

359 *
ݔ
 
w
(
size_t
 
size
);

360 
ݔ
 
de
(*, 
size_t
);

363 as
	cEsbHdSce
 {

364 
	gpublic
:

365 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


366 
le
 
EsbHdSce
(: 
sce
(
v8
::
Isީe
::
GCut
()) {}

368 
le
 
NumbOfHds
() {

369  
v8
::
EsbHdSce
::
NumbOfHds
(v8::
Isީe
::
GCut
());

372 
	gme
<
tyme
 
	gT
>

373 
le
 
	gv8
::
Lol
<
T
> 
Es
(
v8
::Lol<T> 
vue
) {

374  
sce
.
Es
(
vue
);

377 
	give
:

378 
v8
::
EsbHdSce
 
sce
;

380 
le
 
EsbHdSce
(: 
sce
() {}

382 
le
 
NumbOfHds
() {

383  
v8
::
HdSce
::
NumbOfHds
();

386 
	gme
<
tyme
 
	gT
>

387 
le
 
	gv8
::
Lol
<
T
> 
Es
(
v8
::Lol<T> 
vue
) {

388  
sce
.
Clo
(
vue
);

391 
	give
:

392 
v8
::
HdSce
 
sce
;

395 
	give
:

398 
EsbHdSce
(const EscapableHandleScope &);

399 
	gݔ
=(cڡ 
EsbHdSce
 &);

400 *
ݔ
 
w
(
size_t
 
size
);

401 
ݔ
 
de
(*, 
size_t
);

406 as
	cTryCch
 {

407 
	gv8
::
TryCch
 
y_tch_
;

408 
nd
 
FExi
(cڡ 
TryCch
&);

410 
	gpublic
:

411 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


412 
TryCch
(: 
y_tch_
(
v8
::
Isީe
::
GCut
()) {}

415 
NAN_INLINE
 
bo
 
HasCaught
(cڡ {  
y_tch_
.HasCaught(); }

417 
NAN_INLINE
 
bo
 
CCtue
(cڡ {  
	gy_tch_
.CanContinue(); }

419 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
ReThrow
() {

420 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


421  
New
(
y_tch_
.
ReThrow
());

423  
	gy_tch_
.
ReThrow
();

427 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
Exi
() const {

428  
y_tch_
.
Exi
();

431 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

432 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

433 
NAN_INLINE
 
v8
::
MaybeLol
<v8::
Vue
> 
SckT
() const {

434  
y_tch_
.
SckT
(
GCutCڋxt
());

437 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
SckT
() const {

438  
MaybeLol
<
v8
::
Vue
>(
y_tch_
.
SckT
());

442 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Mesge
> Message() const {

443  
y_tch_
.
Mesge
();

446 
NAN_INLINE
 
Ret
({ 
	gy_tch_
.Reset(); }

448 
NAN_INLINE
 
SVbo
(
bo
 
vue
{ 
	gy_tch_
.SetVerbose(value); }

450 
NAN_INLINE
 
SCtuMesge
(
bo
 
vue
) {

451 
	gy_tch_
.
SCtuMesge
(
vue
);

458 #i
NODE_MODULE_VERSION
 >
NODE_0_12_MODULE_VERSION


459 
NAN_INLINE


460 
	$SCouFuni
(
v8
::
CouLookupClback
 
cb
) {

461 
v8
::
Isީe
::
	`GCut
()->
	`SCouFuni
(
cb
);

462 
	}
}

464 
NAN_INLINE


465 
	$SCeHiogmFuni
(
v8
::
CeHiogmClback
 
cb
) {

466 
v8
::
Isީe
::
	`GCut
()->
	`SCeHiogmFuni
(
cb
);

467 
	}
}

469 
NAN_INLINE


470 
	$SAddHiogmSameFuni
(
v8
::
AddHiogmSameClback
 
cb
) {

471 
v8
::
Isީe
::
	`GCut
()->
	`SAddHiogmSameFuni
(
cb
);

472 
	}
}

474 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

475 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

476 
NAN_INLINE
 
bo
 
	$IdNifiti
(
id_time__ms
) {

477  
v8
::
Isީe
::
	`GCut
()->
	`IdNifitiDdle
(

478 
id_time__ms
 * 0.001);

479 
	}
}

481 
NAN_INLINE
 
bo
 
	$IdNifiti
(
id_time__ms
) {

482  
v8
::
Isީe
::
	`GCut
()->
	`IdNifiti
(
id_time__ms
);

483 
	}
}

486 
NAN_INLINE
 
	$LowMemyNifiti
() {

487 
v8
::
Isީe
::
	`GCut
()->
	`LowMemyNifiti
();

488 
	}
}

490 
NAN_INLINE
 
	$CڋxtDiodNifiti
() {

491 
v8
::
Isީe
::
	`GCut
()->
	`CڋxtDiodNifiti
();

492 
	}
}

494 
NAN_INLINE


495 
	$SCouFuni
(
v8
::
CouLookupClback
 
cb
) {

496 
v8
::
V8
::
	`SCouFuni
(
cb
);

497 
	}
}

499 
NAN_INLINE


500 
	$SCeHiogmFuni
(
v8
::
CeHiogmClback
 
cb
) {

501 
v8
::
V8
::
	`SCeHiogmFuni
(
cb
);

502 
	}
}

504 
NAN_INLINE


505 
	$SAddHiogmSameFuni
(
v8
::
AddHiogmSameClback
 
cb
) {

506 
v8
::
V8
::
	`SAddHiogmSameFuni
(
cb
);

507 
	}
}

509 
NAN_INLINE
 
bo
 
	$IdNifiti
(
id_time__ms
) {

510  
v8
::
V8
::
	`IdNifiti
(
id_time__ms
);

511 
	}
}

513 
NAN_INLINE
 
	$LowMemyNifiti
() {

514 
v8
::
V8
::
	`LowMemyNifiti
();

515 
	}
}

517 
NAN_INLINE
 
	$CڋxtDiodNifiti
() {

518 
v8
::
V8
::
	`CڋxtDiodNifiti
();

519 
	}
}

522 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

523 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Undefed
() {

524 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


525 
EsbHdSce
 
sce
;

526  
sce
.
	`Es
(
	`New
(
v8
::
	`Undefed
(v8::
Isީe
::
	`GCut
())));

528  
v8
::
	`Undefed
(v8::
Isީe
::
	`GCut
());

530 
	}
}

532 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Nu
() {

533 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


534 
EsbHdSce
 
sce
;

535  
sce
.
	`Es
(
	`New
(
v8
::
	`Nu
(v8::
Isީe
::
	`GCut
())));

537  
v8
::
	`Nu
(v8::
Isީe
::
	`GCut
());

539 
	}
}

541 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$True
() {

542 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


543 
EsbHdSce
 
sce
;

544  
sce
.
	`Es
(
	`New
(
v8
::
	`True
(v8::
Isީe
::
	`GCut
())));

546  
v8
::
	`True
(v8::
Isީe
::
	`GCut
());

548 
	}
}

550 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$F
() {

551 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


552 
EsbHdSce
 
sce
;

553  
sce
.
	`Es
(
	`New
(
v8
::
	`F
(v8::
Isީe
::
	`GCut
())));

555  
v8
::
	`F
(v8::
Isީe
::
	`GCut
());

557 
	}
}

559 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Sg
> 
	$EmySg
() {

560  
v8
::
Sg
::
	`Emy
(v8::
Isީe
::
	`GCut
());

561 
	}
}

563 
NAN_INLINE
 
	$AdjuExMemy
(
bc
) {

564  
ic_
<>(

565 
v8
::
Isީe
::
	`GCut
()->
	`AdjuAmouOfExAodMemy
(
bc
));

566 
	}
}

568 
NAN_INLINE
 
STeme
(

569 
v8
::
Lol
<v8::
Teme
> 
m


570 , cڡ *
me


571 , 
v8
::
Lol
<v8::
Da
> 
vue
) {

572 
m
->
S
(
v8
::
Isީe
::
GCut
(), 
me
, 
vue
);

575 
NAN_INLINE
 
STeme
(

576 
v8
::
Lol
<v8::
Teme
> 
m


577 , 
v8
::
Lol
<v8::
Sg
> 
me


578 , 
v8
::
Lol
<v8::
Da
> 
vue


579 , 
v8
::
PrݔtyAribu
 
ibus
) {

580 
m
->
S
(
me
, 
vue
, 
ibus
);

583 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
	$GCutCڋxt
() {

584  
v8
::
Isީe
::
	`GCut
()->
	`GCutCڋxt
();

585 
	}
}

587 
NAN_INLINE
 * 
GIlFldPor
(

588 
v8
::
Lol
<v8::
Obje
> 
obje


589 , 
dex
) {

590  
	gobje
->
GAligdPorFromIlFld
(
dex
);

593 
NAN_INLINE
 
SIlFldPor
(

594 
v8
::
Lol
<v8::
Obje
> 
obje


595 , 
dex


596 , * 
vue
) {

597 
	gobje
->
SAligdPorInIlFld
(
dex
, 
vue
);

600 
	#NAN_GC_CALLBACK
(
me
) \

601 
	$me
(
v8
::
Isީe
 *
isީe
, v8::
GCTy
 
ty
, v8::
GCClbackFgs
 
ags
)

	)

603 #i
NODE_MODULE_VERSION
 <
NODE_4_0_MODULE_VERSION


604 
v8
::
	tIsީe
::
	tGCEpogueClback
 GCEpilogueCallback;

605 
v8
::
	tIsީe
::
	tGCProgueClback
 GCPrologueCallback;

607 
v8
::
	tIsީe
::
	tGCClback
 
	tGCEpogueClback
;

608 
v8
::
	tIsީe
::
	tGCClback
 
	tGCProgueClback
;

611 
NAN_INLINE
 
	$AddGCEpogueClback
(

612 
GCEpogueClback
 
back


613 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

614 
v8
::
Isީe
::
	`GCut
()->
	`AddGCEpogueClback
(
back
, 
gc_ty_fr
);

615 
	}
}

617 
NAN_INLINE
 
	$RemoveGCEpogueClback
(

618 
GCEpogueClback
 
back
) {

619 
v8
::
Isީe
::
	`GCut
()->
	`RemoveGCEpogueClback
(
back
);

620 
	}
}

622 
NAN_INLINE
 
	$AddGCProgueClback
(

623 
GCProgueClback
 
back


624 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

625 
v8
::
Isީe
::
	`GCut
()->
	`AddGCProgueClback
(
back
, 
gc_ty_fr
);

626 
	}
}

628 
NAN_INLINE
 
	$RemoveGCProgueClback
(

629 
GCProgueClback
 
back
) {

630 
v8
::
Isީe
::
	`GCut
()->
	`RemoveGCProgueClback
(
back
);

631 
	}
}

633 
NAN_INLINE
 
	$GHpStiics
(

634 
v8
::
HpStiics
 *
hp_iics
) {

635 
v8
::
Isީe
::
	`GCut
()->
	`GHpStiics
(
hp_iics
);

636 
	}
}

638 
	#X
(
NAME
) \

639 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	$NAME
(cڡ *
msg
) { \

640 
EsbHdSce
 
sce
; \

641  
sce
.
	`Es
(
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

642 
	}
} \

644 
NAN_INLINE
 \

645 
v8
::
Lol
<v8::
Vue
> 
	`NAME
(v8::Lol<v8::
Sg
> 
msg
) { \

646  
v8
::
Exi
::
	`NAME
(
msg
); \

649 
NAN_INLINE
 
Throw
 ## 
	$NAME
(cڡ *
msg
) { \

650 
HdSce
 
sce
; \

651 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
( \

652 
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

653 
	}
} \

655 
NAN_INLINE
 
Throw
 ## 
	`NAME
(
v8
::
Lol
<v8::
Sg
> 
msg
) { \

656 
HdSce
 
sce
; \

657 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
( \

658 
v8
::
Exi
::
	`NAME
(
msg
)); \

659 }

	)

661 
	$X
(
E
)

662 
	$X
(
RgeE
)

663 
	$X
(
RenE
)

664 
	$X
(
SyaxE
)

665 
	$X
(
TyE
)

667 #unde
X


669 
NAN_INLINE
 
	`ThrowE
(
v8
::
Lol
<v8::
Vue
> 
r
) {

670 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
(
r
);

671 
	}
}

673 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
NewBufr
(

674 *
da


675 , 
size_t
 
ngth


676 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


677 , 
node
::
Bufr
::
FeClback
 
back


679 , 
node
::
smloc
::
FeClback
 
back


681 , *
ht


685 
as
(
ngth
 <
imp
::
kMaxLgth
 && "tooarge buffer");

686 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


687  
	gnode
::
Bufr
::
New
(

688 
v8
::
Isީe
::
GCut
(), 
da
, 
ngth
, 
back
, 
ht
);

690  
	gMaybeLol
<
	gv8
::
Obje
>(
node
::
Bufr
::
New
(

691 
v8
::
Isީe
::
GCut
(), 
da
, 
ngth
, 
back
, 
ht
));

695 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$CyBufr
(

696 cڡ *
da


697 , 
ut32_t
 
size


701 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

702 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


703  
node
::
Bufr
::
	`Cy
(

704 
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

706  
MaybeLol
<
v8
::
Obje
>(
node
::
Bufr
::
	`New
(

707 
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
));

709 
	}
}

711 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(
ut32_t
 
size
) {

714 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

715 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


716  
node
::
Bufr
::
	`New
(

717 
v8
::
Isީe
::
	`GCut
(), 
size
);

719  
MaybeLol
<
v8
::
Obje
>(
node
::
Bufr
::
	`New
(

720 
v8
::
Isީe
::
	`GCut
(), 
size
));

722 
	}
}

724 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

725 * 
da


726 , 
ut32_t
 
size


730 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

731 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


732  
node
::
Bufr
::
	`New
(
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

734  
MaybeLol
<
v8
::
Obje
>(

735 
node
::
Bufr
::
	`U
(
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
));

737 
	}
}

739 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

740 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

741 
NAN_INLINE
 
MaybeLol
<
v8
::
Sg
>

742 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

743  
v8
::
Sg
::
NewFromOBy
(v8::
Isީe
::
GCut
(), 
vue
,

744 
v8
::
NewSgTy
::
kNm
, 
ngth
);

747 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

748 
v8
::
Lol
<v8::
Sg
> 
s


749 , cڡ 
v8
::
StOrig
& 
ig


751 
v8
::
StComp
::
Sour
 
sour
(
s
, 
ig
);

752  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
sour
);

755 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

756 
v8
::
Lol
<v8::
Sg
> 
s


758 
v8
::
StComp
::
Sour
 
sour
(
s
);

759  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
sour
);

762 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

763 
v8
::
Lol
<
UnboundSt
> 
st


765  
st
->
BdToCutCڋxt
()->
Run
(
GCutCڋxt
());

768 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

769 
v8
::
Lol
<
BoundSt
> 
st


771  
st
->
Run
(
GCutCڋxt
());

774 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
>

775 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

776  
MaybeLol
<
v8
::
Sg
>(

777 
v8
::
Sg
::
NewFromOBy
(

778 
v8
::
Isީe
::
GCut
()

779 , 
vue


780 , 
v8
::
Sg
::
kNmSg
, 
ngth
));

783 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

784 
v8
::
Lol
<v8::
Sg
> 
s


785 , cڡ 
v8
::
StOrig
& 
ig


787 
v8
::
StComp
::
Sour
 
sour
(
s
, 
ig
);

788  
	gMaybeLol
<
	gBoundSt
>(

789 
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
sour
));

792 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

793 
v8
::
Lol
<v8::
Sg
> 
s


795 
v8
::
StComp
::
Sour
 
sour
(
s
);

796  
	gMaybeLol
<
	gBoundSt
>(

797 
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
sour
));

800 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

801 
v8
::
Lol
<
UnboundSt
> 
st


803  
MaybeLol
<
v8
::
Vue
>(
st
->
BdToCutCڋxt
()->
Run
());

806 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

807 
v8
::
Lol
<
BoundSt
> 
st


809  
MaybeLol
<
v8
::
Vue
>(
st
->
Run
());

813 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

814 
v8
::
Lol
<v8::
Obje
> 
rg


815 , 
v8
::
Lol
<v8::
Funi
> 
func


816 , 
gc


817 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

818 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


819  
New
(
node
::
MakeClback
(

820 
v8
::
Isީe
::
GCut
(), 
rg
, 
func
, 
gc
, 
gv
));

822  
	gnode
::
MakeClback
(

823 
v8
::
Isީe
::
GCut
(), 
rg
, 
func
, 
gc
, 
gv
);

827 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

828 
v8
::
Lol
<v8::
Obje
> 
rg


829 , 
v8
::
Lol
<v8::
Sg
> 
symb


830 , 
gc


831 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

832 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


833  
New
(
node
::
MakeClback
(

834 
v8
::
Isީe
::
GCut
(), 
rg
, 
symb
, 
gc
, 
gv
));

836  
	gnode
::
MakeClback
(

837 
v8
::
Isީe
::
GCut
(), 
rg
, 
symb
, 
gc
, 
gv
);

841 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

842 
v8
::
Lol
<v8::
Obje
> 
rg


843 , cڡ * 
mhod


844 , 
gc


845 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

846 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


847  
New
(
node
::
MakeClback
(

848 
v8
::
Isީe
::
GCut
(), 
rg
, 
mhod
, 
gc
, 
gv
));

850  
	gnode
::
MakeClback
(

851 
v8
::
Isީe
::
GCut
(), 
rg
, 
mhod
, 
gc
, 
gv
);

855 
NAN_INLINE
 
	$FExi
(cڡ 
TryCch
& 
y_tch
) {

856 
node
::
	`FExi
(
v8
::
Isީe
::
	`GCut
(), 
y_tch
.
y_tch_
);

857 
	}
}

859 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$EnoExi
(

860 
rno


861 , cڡ * 
sys
 = 
NULL


862 , cڡ * 
mesge
 = 
NULL


863 , cڡ * 
th
 = 
NULL
) {

864  
node
::
	`EnoExi
(
v8
::
Isީe
::
	`GCut
(), 
rno
, 
sys
,

865 
mesge
, 
th
);

866 
	}
}

868 
NAN_DEPRECATED
 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$NEnoExi
(

869 
rno


870 , cڡ * 
sys
 = 
NULL


871 , cڡ * 
mesge
 = 
NULL


872 , cڡ * 
th
 = 
NULL
) {

873  
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

874 
	}
}

876 
	gme
<
tyme
 
	gT
>

877 
NAN_INLINE
 
	$SIsީeDa
(

878 
v8
::
Isީe
 *
isީe


879 , 
T
 *
da


881 
isީe
->
	`SDa
(0, 
da
);

882 
	}
}

884 
	gme
<
tyme
 
	gT
>

885 
NAN_INLINE
 
T
 *
	$GIsީeDa
(

886 
v8
::
Isީe
 *
isީe


888  
ic_
<
T
*>(
isީe
->
	`GDa
(0));

889 
	}
}

891 as
	cUtf8Sg
 {

892 
	gpublic
:

893 
NAN_INLINE
 
exic
 
Utf8Sg
(
v8
::
Lol
<v8::
Vue
> 
om
) :

894 
ngth_
(0), 
r_
(
r__
) {

895 i(!
	gom
.
IsEmy
()) {

896 
	gv8
::
Lol
<
v8
::
Sg
> 
rg
 = 
om
->
ToSg
();

897 i(!
	grg
.
IsEmy
()) {

898 
size_t
 
	gn
 = 3 * 
rg
->
Lgth
() + 1;

899 
as
(
n
 <
INT_MAX
);

900 i(
	gn
 >  (
	gr__
)) {

901 
	gr_
 = 
ic_
<*>(
mloc
(
n
));

902 
as
(
r_
 != 0);

904 cڡ 
	gags
 =

905 
v8
::
Sg
::
NO_NULL_TERMINATION
 | 
imp
::
kRInvidUtf8
;

906 
	gngth_
 = 
rg
->
WreUtf8
(
r_
, 
ic_
<>(
n
), 0, 
ags
);

907 
	gr_
[
ngth_
] = '\0';

912 
NAN_INLINE
 
ngth
() const {

913  
	gngth_
;

916 
NAN_INLINE
 * 
	gݔ
*({  
	gr_
; }

917 
NAN_INLINE
 cڡ * 
	gݔ
*(cڡ {  
	gr_
; }

919 
	gNAN_INLINE
 ~
Utf8Sg
() {

920 i(
	gr_
 !
r__
) {

921 

(
r_
);

925 
	give
:

926 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Utf8Sg
)

928 
ngth_
;

929 *
	gr_
;

930 
	gr__
[1024];

934 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Undefed
() {

935 
EsbHdSce
 
sce
;

936  
sce
.
	`Es
(
	`New
(
v8
::
	`Undefed
()));

937 
	}
}

939 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Nu
() {

940 
EsbHdSce
 
sce
;

941  
sce
.
	`Es
(
	`New
(
v8
::
	`Nu
()));

942 
	}
}

944 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$True
() {

945 
EsbHdSce
 
sce
;

946  
sce
.
	`Es
(
	`New
(
v8
::
	`True
()));

947 
	}
}

949 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$F
() {

950 
EsbHdSce
 
sce
;

951  
sce
.
	`Es
(
	`New
(
v8
::
	`F
()));

952 
	}
}

954 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Sg
> 
	$EmySg
() {

955  
v8
::
Sg
::
	`Emy
();

956 
	}
}

958 
NAN_INLINE
 
	$AdjuExMemy
(
bc
) {

959  
ic_
<>(
v8
::
V8
::
	`AdjuAmouOfExAodMemy
(
bc
));

960 
	}
}

962 
NAN_INLINE
 
STeme
(

963 
v8
::
Lol
<v8::
Teme
> 
m


964 , cڡ *
me


965 , 
v8
::
Lol
<v8::
Da
> 
vue
) {

966 
m
->
S
(
me
, 
vue
);

969 
NAN_INLINE
 
STeme
(

970 
v8
::
Lol
<v8::
Teme
> 
m


971 , 
v8
::
Lol
<v8::
Sg
> 
me


972 , 
v8
::
Lol
<v8::
Da
> 
vue


973 , 
v8
::
PrݔtyAribu
 
ibus
) {

974 
m
->
S
(
me
, 
vue
, 
ibus
);

977 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
	$GCutCڋxt
() {

978  
v8
::
Cڋxt
::
	`GCut
();

979 
	}
}

981 
NAN_INLINE
 * 
GIlFldPor
(

982 
v8
::
Lol
<v8::
Obje
> 
obje


983 , 
dex
) {

984  
	gobje
->
GPorFromIlFld
(
dex
);

987 
NAN_INLINE
 
SIlFldPor
(

988 
v8
::
Lol
<v8::
Obje
> 
obje


989 , 
dex


990 , * 
vue
) {

991 
	gobje
->
SPorInIlFld
(
dex
, 
vue
);

994 
	#NAN_GC_CALLBACK
(
me
) \

995 
	$me
(
v8
::
GCTy
 
ty
, v8::
GCClbackFgs
 
ags
)

	)

997 
NAN_INLINE
 
	$AddGCEpogueClback
(

998 
v8
::
GCEpogueClback
 
back


999 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

1000 
v8
::
V8
::
	`AddGCEpogueClback
(
back
, 
gc_ty_fr
);

1001 
	}
}

1002 
NAN_INLINE
 
	$RemoveGCEpogueClback
(

1003 
v8
::
GCEpogueClback
 
back
) {

1004 
v8
::
V8
::
	`RemoveGCEpogueClback
(
back
);

1005 
	}
}

1006 
NAN_INLINE
 
	$AddGCProgueClback
(

1007 
v8
::
GCProgueClback
 
back


1008 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

1009 
v8
::
V8
::
	`AddGCProgueClback
(
back
, 
gc_ty_fr
);

1010 
	}
}

1011 
NAN_INLINE
 
	$RemoveGCProgueClback
(

1012 
v8
::
GCProgueClback
 
back
) {

1013 
v8
::
V8
::
	`RemoveGCProgueClback
(
back
);

1014 
	}
}

1015 
NAN_INLINE
 
	$GHpStiics
(

1016 
v8
::
HpStiics
 *
hp_iics
) {

1017 
v8
::
V8
::
	`GHpStiics
(
hp_iics
);

1018 
	}
}

1020 
	#X
(
NAME
) \

1021 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	$NAME
(cڡ *
msg
) { \

1022 
EsbHdSce
 
sce
; \

1023  
sce
.
	`Es
(
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

1024 
	}
} \

1026 
NAN_INLINE
 \

1027 
v8
::
Lol
<v8::
Vue
> 
	`NAME
(v8::Lol<v8::
Sg
> 
msg
) { \

1028  
v8
::
Exi
::
	`NAME
(
msg
); \

1031 
NAN_INLINE
 
Throw
 ## 
	$NAME
(cڡ *
msg
) { \

1032 
HdSce
 
sce
; \

1033 
v8
::
	`ThrowExi
(v8::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

1034 
	}
} \

1036 
NAN_INLINE
 \

1037 
Throw
 ## 
	`NAME
(
v8
::
Lol
<v8::
Sg
> 
rmsg
) { \

1038 
v8
::
	`ThrowExi
(v8::
Exi
::
	`NAME
(
rmsg
)); \

1039 }

	)

1041 
	$X
(
E
)

1042 
	$X
(
RgeE
)

1043 
	$X
(
RenE
)

1044 
	$X
(
SyaxE
)

1045 
	$X
(
TyE
)

1047 #unde
X


1049 
NAN_INLINE
 
	`ThrowE
(
v8
::
Lol
<v8::
Vue
> 
r
) {

1050 
v8
::
	`ThrowExi
(
r
);

1051 
	}
}

1053 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

1054 *
da


1055 , 
size_t
 
ngth


1056 , 
node
::
Bufr
::
_back
 
back


1057 , *
ht


1059 
EsbHdSce
 
sce
;

1062 
	`as
(
ngth
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1063  
MaybeLol
<
v8
::
Obje
>(
sce
.
	`Es
(

1064 
	`New
(
node
::
Bufr
::New(
da
, 
ngth
, 
back
, 
ht
)->
hd_
)));

1065 
	}
}

1067 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$CyBufr
(

1068 cڡ *
da


1069 , 
ut32_t
 
size


1071 
EsbHdSce
 
sce
;

1074 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1075 #i
NODE_MODULE_VERSION
 >
NODE_0_10_MODULE_VERSION


1076  
MaybeLol
<
v8
::
Obje
>(

1077 
sce
.
	`Es
(
	`New
(
node
::
Bufr
::New(
da
, 
size
)->
hd_
)));

1079  
MaybeLol
<
v8
::
Obje
>(
sce
.
	`Es
(

1080 
	`New
(
node
::
Bufr
::New(
cڡ_
<*>(
da
), 
size
)->
hd_
)));

1082 
	}
}

1084 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(
ut32_t
 
size
) {

1087 
EsbHdSce
 
sce
;

1088 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1089  
MaybeLol
<
v8
::
Obje
>(

1090 
sce
.
	`Es
(
	`New
(
node
::
Bufr
::New(
size
)->
hd_
)));

1091 
	}
}

1093 
NAN_INLINE
 
	$FeDa
(*
da
, *
ht
) {

1094 (
ht
;

1095 
de
[] 
da
;

1096 
	}
}

1098 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

1099 * 
da


1100 , 
ut32_t
 
size


1102 
EsbHdSce
 
sce
;

1105 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1106  
MaybeLol
<
v8
::
Obje
>(
sce
.
	`Es
(
	`New
(

1107 
node
::
Bufr
::
	`New
(
da
, 
size
, 
FeDa
, 
NULL
)->
hd_
)));

1108 
	}
}

1110 
mea
 
	gimp
 {

1111 
NAN_INLINE
 

1112 
widSg
(
d
::
ve
<
ut16_t
> *
ws
, cڡ 
ut8_t
 *
s
, 
l
) {

1113 
size_t
 
	gn
 = 
ic_
<size_t>(
l
);

1114 i(
	gl
 < 0) {

1115 
	gn
 = 

(
t_
<cڡ *>(
s
));

1117 
as
(
n
 <
INT_MAX
 && "stringooong");

1118 
	gws
->
size
(
n
);

1119 
	gd
::
cy
(
s
, s + 
n
, 
ws
->
beg
());

1123 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
>

1124 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

1125 
d
::
ve
<
ut16_t
> 
wideSg
;

1126 
	gimp
::
widSg
(&
wideSg
, 
vue
, 
ngth
);

1127  
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
New
(

1128 &
wideSg
.
t
(), 
ic_
<>(wideSg.
size
())));

1131 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

1132 
v8
::
Lol
<v8::
Sg
> 
s


1133 , cڡ 
v8
::
StOrig
& 
ig


1135  
MaybeLol
<
BoundSt
>(

1136 
v8
::
St
::
Compe
(
s
, 
cڡ_
<v8::
StOrig
 *>(&
ig
)));

1139 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

1140 
v8
::
Lol
<v8::
Sg
> 
s


1142  
MaybeLol
<
BoundSt
>(
v8
::
St
::
Compe
(
s
));

1145 
NAN_INLINE


1146 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(
v8
::
Lol
<v8::
St
> 
st
) {

1147  
MaybeLol
<
v8
::
Vue
>(
st
->
Run
());

1150 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1151 
v8
::
Lol
<v8::
Obje
> 
rg


1152 , 
v8
::
Lol
<v8::
Funi
> 
func


1153 , 
gc


1154 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1155  
New
(
node
::
MakeClback
(
rg
, 
func
, 
gc
, 
gv
));

1158 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1159 
v8
::
Lol
<v8::
Obje
> 
rg


1160 , 
v8
::
Lol
<v8::
Sg
> 
symb


1161 , 
gc


1162 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1163  
New
(
node
::
MakeClback
(
rg
, 
symb
, 
gc
, 
gv
));

1166 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1167 
v8
::
Lol
<v8::
Obje
> 
rg


1168 , cڡ * 
mhod


1169 , 
gc


1170 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1171  
New
(
node
::
MakeClback
(
rg
, 
mhod
, 
gc
, 
gv
));

1174 
NAN_INLINE
 
	$FExi
(cڡ 
TryCch
& 
y_tch
) {

1175 
node
::
	`FExi
(
cڡ_
<
v8
::
TryCch
 &>(
y_tch
.
y_tch_
));

1176 
	}
}

1178 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$EnoExi
(

1179 
rno


1180 , cڡ * 
sys
 = 
NULL


1181 , cڡ * 
mesge
 = 
NULL


1182 , cڡ * 
th
 = 
NULL
) {

1183  
node
::
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

1184 
	}
}

1186 
NAN_DEPRECATED
 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$NEnoExi
(

1187 
rno


1188 , cڡ * 
sys
 = 
NULL


1189 , cڡ * 
mesge
 = 
NULL


1190 , cڡ * 
th
 = 
NULL
) {

1191  
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

1192 
	}
}

1195 
	gme
<
tyme
 
	gT
>

1196 
NAN_INLINE
 
	$SIsީeDa
(

1197 
v8
::
Isީe
 *
isީe


1198 , 
T
 *
da


1200 
isީe
->
	`SDa
(
da
);

1201 
	}
}

1203 
	gme
<
tyme
 
	gT
>

1204 
NAN_INLINE
 
T
 *
	$GIsީeDa
(

1205 
v8
::
Isީe
 *
isީe


1207  
ic_
<
T
*>(
isީe
->
	`GDa
());

1208 
	}
}

1210 as
	cUtf8Sg
 {

1211 
	gpublic
:

1212 
NAN_INLINE
 
exic
 
Utf8Sg
(
v8
::
Lol
<v8::
Vue
> 
om
) :

1213 
ngth_
(0), 
r_
(
r__
) {

1214 i(!
	gom
.
IsEmy
()) {

1215 
	gv8
::
Lol
<
v8
::
Sg
> 
rg
 = 
om
->
ToSg
();

1216 i(!
	grg
.
IsEmy
()) {

1217 
size_t
 
	gn
 = 3 * 
rg
->
Lgth
() + 1;

1218 
as
(
n
 <
INT_MAX
);

1219 i(
	gn
 >  (
	gr__
)) {

1220 
	gr_
 = 
ic_
<*>(
mloc
(
n
));

1221 
as
(
r_
 != 0);

1223 cڡ 
	gags
 =

1224 
v8
::
Sg
::
NO_NULL_TERMINATION
 | 
imp
::
kRInvidUtf8
;

1225 
	gngth_
 = 
rg
->
WreUtf8
(
r_
, 
ic_
<>(
n
), 0, 
ags
);

1226 
	gr_
[
ngth_
] = '\0';

1231 
NAN_INLINE
 
ngth
() const {

1232  
	gngth_
;

1235 
NAN_INLINE
 * 
	gݔ
*({  
	gr_
; }

1236 
NAN_INLINE
 cڡ * 
	gݔ
*(cڡ {  
	gr_
; }

1238 
	gNAN_INLINE
 ~
Utf8Sg
() {

1239 i(
	gr_
 !
r__
) {

1240 

(
r_
);

1244 
	give
:

1245 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Utf8Sg
)

1247 
ngth_
;

1248 *
	gr_
;

1249 
	gr__
[1024];

1254 (*
	tFeClback
)(*
	tda
, *
	tht
);

1256 cڡ 
	tFuniClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_METHOD_ARGS_TYPE
;

1257 
	tNAN_METHOD_RETURN_TYPE
;

1259 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_GETTER_ARGS_TYPE
;

1260 
	tNAN_GETTER_RETURN_TYPE
;

1262 cڡ 
	tPrݔtyClbackInfo
<>& 
	tNAN_SETTER_ARGS_TYPE
;

1263 
	tNAN_SETTER_RETURN_TYPE
;

1265 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&

1266 
	tNAN_PROPERTY_GETTER_ARGS_TYPE
;

1267 
	tNAN_PROPERTY_GETTER_RETURN_TYPE
;

1269 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&

1270 
	tNAN_PROPERTY_SETTER_ARGS_TYPE
;

1271 
	tNAN_PROPERTY_SETTER_RETURN_TYPE
;

1273 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&

1274 
	tNAN_PROPERTY_ENUMERATOR_ARGS_TYPE
;

1275 
	tNAN_PROPERTY_ENUMERATOR_RETURN_TYPE
;

1277 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&

1278 
	tNAN_PROPERTY_DELETER_ARGS_TYPE
;

1279 
	tNAN_PROPERTY_DELETER_RETURN_TYPE
;

1281 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&

1282 
	tNAN_PROPERTY_QUERY_ARGS_TYPE
;

1283 
	tNAN_PROPERTY_QUERY_RETURN_TYPE
;

1285 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_INDEX_GETTER_ARGS_TYPE
;

1286 
	tNAN_INDEX_GETTER_RETURN_TYPE
;

1288 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_INDEX_SETTER_ARGS_TYPE
;

1289 
	tNAN_INDEX_SETTER_RETURN_TYPE
;

1291 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&

1292 
	tNAN_INDEX_ENUMERATOR_ARGS_TYPE
;

1293 
	tNAN_INDEX_ENUMERATOR_RETURN_TYPE
;

1295 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&

1296 
	tNAN_INDEX_DELETER_ARGS_TYPE
;

1297 
	tNAN_INDEX_DELETER_RETURN_TYPE
;

1299 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&

1300 
	tNAN_INDEX_QUERY_ARGS_TYPE
;

1301 
	tNAN_INDEX_QUERY_RETURN_TYPE
;

1303 
	#NAN_METHOD
(
me
) \

1304 
N
::
NAN_METHOD_RETURN_TYPE
 
	$me
(
N
::
NAN_METHOD_ARGS_TYPE
 
fo
)

	)

1305 
	#NAN_GETTER
(
me
) \

1306 
N
::
NAN_GETTER_RETURN_TYPE
 
	`me
( \

1307 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1308 , 
N
::
NAN_GETTER_ARGS_TYPE
 
fo
)

	)

1309 
	#NAN_SETTER
(
me
) \

1310 
N
::
NAN_SETTER_RETURN_TYPE
 
	`me
( \

1311 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1312 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1313 , 
N
::
NAN_SETTER_ARGS_TYPE
 
fo
)

	)

1314 
	#NAN_PROPERTY_GETTER
(
me
) \

1315 
N
::
NAN_PROPERTY_GETTER_RETURN_TYPE
 
	`me
( \

1316 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1317 , 
N
::
NAN_PROPERTY_GETTER_ARGS_TYPE
 
fo
)

	)

1318 
	#NAN_PROPERTY_SETTER
(
me
) \

1319 
N
::
NAN_PROPERTY_SETTER_RETURN_TYPE
 
	`me
( \

1320 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1321 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1322 , 
N
::
NAN_PROPERTY_SETTER_ARGS_TYPE
 
fo
)

	)

1323 
	#NAN_PROPERTY_ENUMERATOR
(
me
) \

1324 
N
::
NAN_PROPERTY_ENUMERATOR_RETURN_TYPE
 
	`me
( \

1325 
N
::
NAN_PROPERTY_ENUMERATOR_ARGS_TYPE
 
fo
)

	)

1326 
	#NAN_PROPERTY_DELETER
(
me
) \

1327 
N
::
NAN_PROPERTY_DELETER_RETURN_TYPE
 
	`me
( \

1328 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1329 , 
N
::
NAN_PROPERTY_DELETER_ARGS_TYPE
 
fo
)

	)

1330 
	#NAN_PROPERTY_QUERY
(
me
) \

1331 
N
::
NAN_PROPERTY_QUERY_RETURN_TYPE
 
	`me
( \

1332 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1333 , 
N
::
NAN_PROPERTY_QUERY_ARGS_TYPE
 
fo
)

	)

1334 
	#NAN_INDEX_GETTER
(
me
) \

1335 
N
::
NAN_INDEX_GETTER_RETURN_TYPE
 
	`me
( \

1336 
ut32_t
 
dex
 \

1337 , 
N
::
NAN_INDEX_GETTER_ARGS_TYPE
 
fo
)

	)

1338 
	#NAN_INDEX_SETTER
(
me
) \

1339 
N
::
NAN_INDEX_SETTER_RETURN_TYPE
 
	`me
( \

1340 
ut32_t
 
dex
 \

1341 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1342 , 
N
::
NAN_INDEX_SETTER_ARGS_TYPE
 
fo
)

	)

1343 
	#NAN_INDEX_ENUMERATOR
(
me
) \

1344 
N
::
NAN_INDEX_ENUMERATOR_RETURN_TYPE
 \

1345 
	$me
(
N
::
NAN_INDEX_ENUMERATOR_ARGS_TYPE
 
fo
)

	)

1346 
	#NAN_INDEX_DELETER
(
me
) \

1347 
N
::
NAN_INDEX_DELETER_RETURN_TYPE
 
	`me
( \

1348 
ut32_t
 
dex
 \

1349 , 
N
::
NAN_INDEX_DELETER_ARGS_TYPE
 
fo
)

	)

1350 
	#NAN_INDEX_QUERY
(
me
) \

1351 
N
::
NAN_INDEX_QUERY_RETURN_TYPE
 
	`me
( \

1352 
ut32_t
 
dex
 \

1353 , 
N
::
NAN_INDEX_QUERY_ARGS_TYPE
 
fo
)

	)

1355 as
	cClback
 {

1356 
public
:

1357 
	`Clback
() {

1358 
HdSce
 
sce
;

1359 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
New
<v8::Object>();

1360 
hd
.
	`Ret
(
obj
);

1363 
exic
 
	`Clback
(cڡ 
v8
::
Lol
<v8::
Funi
> &

) {

1364 
HdSce
 
sce
;

1365 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
New
<v8::Object>();

1366 
hd
.
	`Ret
(
obj
);

1367 
	`SFuni
(

);

1370 ~
	`Clback
() {

1371 i(
hd
.
	`IsEmy
()) ;

1372 
hd
.
	`Ret
();

1375 
bo
 
ݔ
==(cڡ 
Clback
 &
h
) const {

1376 
HdSce
 
sce
;

1377 
v8
::
Lol
<v8::
Vue
> 
a
 = 
	`New
(
hd
)->
	`G
(
kClbackIndex
);

1378 
v8
::
Lol
<v8::
Vue
> 
b
 = 
	`New
(
h
.
hd
)->
	`G
(
kClbackIndex
);

1379  
a
->
	`SiEqus
(
b
);

1382 
bo
 
ݔ
!=(cڡ 
Clback
 &
h
) const {

1383  !
this
->
ݔ
==(
h
);

1386 
NAN_INLINE


1387 
v8
::
Lol
<v8::
Funi
> 
ݔ
*(cڡ {  
this
->
	`GFuni
(); }

1389 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	`ݔ
()(

1390 
v8
::
Lol
<v8::
Obje
> 
rg


1391 , 
gc
 = 0

1392 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1393  
this
->
	`Cl
(
rg
, 
gc
, 
gv
);

1396 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	`ݔ
()(

1397 
gc
 = 0

1398 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1399  
this
->
	`Cl
(
gc
, 
gv
);

1402 
NAN_INLINE
 
	`SFuni
(cڡ 
v8
::
Lol
<v8::
Funi
> &

) {

1403 
HdSce
 
sce
;

1404 
	`S
(
	`New
(
hd
), 
kClbackIndex
, 

);

1407 
NAN_INLINE
 
v8
::
Lol
<v8::
Funi
> 
	`GFuni
() const {

1408 
EsbHdSce
 
sce
;

1409  
sce
.
	`Es
(
	`New
(
hd
)->
	`G
(
kClbackIndex
)

1410 .
As
<
v8
::
Funi
>());

1413 
NAN_INLINE
 
bo
 
	`IsEmy
() const {

1414 
HdSce
 
sce
;

1415  
	`New
(
hd
)->
	`G
(
kClbackIndex
)->
	`IsUndefed
();

1418 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
>

1419 
	`Cl
(
v8
::
Lol
<v8::
Obje
> 
rg


1420 , 
gc


1421 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1422 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1423 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1424  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
);

1426  
	`Cl_
(
rg
, 
gc
, 
gv
);

1430 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
>

1431 
	`Cl
(
gc
, 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1432 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1433 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1434  
	`Cl_
(
isީe
, isީe->
	`GCutCڋxt
()->
	`Glob
(), 
gc
, 
gv
);

1436  
	`Cl_
(
v8
::
Cڋxt
::
	`GCut
()->
	`Glob
(), 
gc
, 
gv
);

1440 
ive
:

1441 
	`NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Clback
)

1442 
Psit
<
v8
::
Obje
> 
hd
;

1443 cڡ 
ut32_t
 
kClbackIndex
 = 0;

1445 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1446 
v8
::
Lol
<v8::
Vue
> 
	`Cl_
(v8::
Isީe
 *
isީe


1447 , 
v8
::
Lol
<v8::
Obje
> 
rg


1448 , 
gc


1449 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1450 
EsbHdSce
 
sce
;

1452 
v8
::
Lol
<v8::
Funi
> 
back
 = 
	`New
(
hd
)->

1453 
	`G
(
kClbackIndex
).
As
<
v8
::
Funi
>();

1454 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


1455  
sce
.
	`Es
(
	`New
(
node
::
	`MakeClback
(

1456 
isީe


1457 , 
rg


1458 , 
back


1459 , 
gc


1460 , 
gv


1463  
sce
.
	`Es
(
node
::
	`MakeClback
(

1464 
isީe


1465 , 
rg


1466 , 
back


1467 , 
gc


1468 , 
gv


1473 
v8
::
Lol
<v8::
Vue
> 
	`Cl_
(v8::Lol<v8::
Obje
> 
rg


1474 , 
gc


1475 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1476 
EsbHdSce
 
sce
;

1478 
v8
::
Lol
<v8::
Funi
> 
back
 = 
	`New
(
hd
)->

1479 
	`G
(
kClbackIndex
).
As
<
v8
::
Funi
>();

1480  
sce
.
	`Es
(
	`New
(
node
::
	`MakeClback
(

1481 
rg


1482 , 
back


1483 , 
gc


1484 , 
gv


1488 
	}
};

1490  cs
	cAsyncWk
 {

1491 
	gpublic
:

1492 
exic
 
AsyncWk
(
Clback
 *
back_
)

1493 : 
back
(
back_
), 
rmsg_
(
NULL
) {

1494 
	gque
.
	gda
 = 
this
;

1496 
HdSce
 
	gsce
;

1497 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
New
<v8::Object>();

1498 
	grsitHd
.
Ret
(
obj
);

1501 
	gvtu
 ~
AsyncWk
() {

1502 
HdSce
 
	gsce
;

1504 i(!
	grsitHd
.
IsEmy
())

1505 
	grsitHd
.
Ret
();

1506 
de
 
	gback
;

1507 
	gde
[] 
	grmsg_
;

1510 
vtu
 
WkCome
() {

1511 
HdSce
 
	gsce
;

1513 i(
	grmsg_
 =
NULL
)

1514 
HdOKClback
();

1516 
HdEClback
();

1517 
de
 
	gback
;

1518 
	gback
 = 
NULL
;

1521 
NAN_INLINE
 
SaveToPsit
(

1522 cڡ *
key
, cڡ 
v8
::
Lol
<v8::
Vue
> &
vue
) {

1523 
HdSce
 
sce
;

1524 
New
(
rsitHd
)->
S
(New(
key
).
ToLolChecked
(), 
vue
);

1527 
NAN_INLINE
 
SaveToPsit
(

1528 cڡ 
v8
::
Lol
<v8::
Sg
> &
key
, cڡ v8::Lol<v8::
Vue
> &
vue
) {

1529 
HdSce
 
sce
;

1530 
New
(
rsitHd
)->
S
(
key
, 
vue
);

1533 
NAN_INLINE
 
SaveToPsit
(

1534 
ut32_t
 
dex
, cڡ 
v8
::
Lol
<v8::
Vue
> &
vue
) {

1535 
HdSce
 
sce
;

1536 
New
(
rsitHd
)->
S
(
dex
, 
vue
);

1539 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
GFromPsit
(cڡ *
key
) const {

1540 
EsbHdSce
 
sce
;

1541  
	gsce
.
Es
(

1542 
New
(
rsitHd
)->
G
(New(
key
).
ToLolChecked
()));

1545 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
>

1546 
GFromPsit
(cڡ 
v8
::
Lol
<v8::
Sg
> &
key
) const {

1547 
EsbHdSce
 
sce
;

1548  
	gsce
.
Es
(
New
(
rsitHd
)->
G
(
key
));

1551 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
GFromPsit
(
ut32_t
 
dex
) const {

1552 
EsbHdSce
 
sce
;

1553  
	gsce
.
Es
(
New
(
rsitHd
)->
G
(
dex
));

1556 
vtu
 
Execu
() = 0;

1558 
uv_wk_t
 
	gque
;

1560 
vtu
 
Deroy
() {

1561 
de
 
	gthis
;

1564 
	geed
:

1565 
Psit
<
v8
::
Obje
> 
rsitHd
;

1566 
Clback
 *
	gback
;

1568 
vtu
 
HdOKClback
() {

1569 
	gback
->
Cl
(0, 
NULL
);

1572 
vtu
 
HdEClback
() {

1573 
HdSce
 
	gsce
;

1575 
	gv8
::
Lol
<
v8
::
Vue
> 
gv
[] = {

1576 
v8
::
Exi
::
E
(
New
<v8::
Sg
>(
EMesge
()).
ToLolChecked
())

1578 
	gback
->
Cl
(1, 
gv
);

1581 
SEMesge
(cڡ *
msg
) {

1582 
	gde
[] 
	grmsg_
;

1584 
size_t
 
	gsize
 = 

(
msg
) + 1;

1585 
	grmsg_
 = 
w
 [
size
];

1586 
memy
(
rmsg_
, 
msg
, 
size
);

1589 cڡ * 
EMesge
() const {

1590  
	grmsg_
;

1593 
	give
:

1594 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
AsyncWk
)

1595 *
rmsg_
;

1598  cs
	cAsyncProgssWk
 : 
public
 
AsyncWk
 {

1599 
public
:

1600 
exic
 
AsyncProgssWk
(
Clback
 *
back_
)

1601 : 
AsyncWk
(
back_
), 
asyncda_
(
NULL
), 
asyncsize_
(0) {

1602 
	gasync
 = 
w
 
uv_async_t
;

1603 
uv_async_
(

1604 
uv_deu_lo
()

1605 , 
async


1606 , 
AsyncProgss_


1608 
	gasync
->
	gda
 = 
this
;

1610 
uv_mux_
(&
async_lock
);

1613 
	gvtu
 ~
AsyncProgssWk
() {

1614 
uv_mux_deroy
(&
async_lock
);

1616 
	gde
[] 
	gasyncda_
;

1619 
WkProgss
() {

1620 
uv_mux_lock
(&
async_lock
);

1621 *
	gda
 = 
asyncda_
;

1622 
size_t
 
	gsize
 = 
asyncsize_
;

1623 
	gasyncda_
 = 
NULL
;

1624 
uv_mux_uock
(&
async_lock
);

1627 i(
	gback
) {

1628 
HdProgssClback
(
da
, 
size
);

1630 
	gde
[] 
	gda
;

1633 as
	cExecutiProgss
 {

1634 
nd
 
ass
 
	gAsyncProgssWk
;

1635 
	gpublic
:

1636 
Sigl
() const {

1637 
uv_async_nd
(
th_
->
async
);

1640 
Sd
(cڡ * 
da
, 
size_t
 
size
) const {

1641 
	gth_
->
SdProgss_
(
da
, 
size
);

1644 
	give
:

1645 
exic
 
ExecutiProgss
(
AsyncProgssWk
* 
th
: 
th_
(that) {}

1646 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
ExecutiProgss
)

1647 
AsyncProgssWk
* cڡ 
th_
;

1650 
vtu
 
Execu
(cڡ 
ExecutiProgss
& 
ogss
) = 0;

1651 
vtu
 
HdProgssClback
(cڡ *
da
, 
size_t
 
size
) = 0;

1653 
vtu
 
Deroy
() {

1654 
uv_o
(
t_
<
uv_hd_t
*>(
async
), 
AsyncClo_
);

1657 
	give
:

1658 
Execu
() {

1659 
ExecutiProgss
 
ogss
(
this
);

1660 
Execu
(
ogss
);

1663 
SdProgss_
(cڡ *
da
, 
size_t
 
size
) {

1664 *
	gw_da
 = 
w
 [
size
];

1665 
memy
(
w_da
, 
da
, 
size
);

1667 
uv_mux_lock
(&
async_lock
);

1668 *
	gd_da
 = 
asyncda_
;

1669 
	gasyncda_
 = 
w_da
;

1670 
	gasyncsize_
 = 
size
;

1671 
uv_mux_uock
(&
async_lock
);

1673 
	gde
[] 
	gd_da
;

1674 
uv_async_nd
(
async
);

1677 
NAN_INLINE
 
NAUV_WORK_CB
(
AsyncProgss_
) {

1678 
AsyncProgssWk
 *
	gwk
 =

1679 
ic_
<
AsyncProgssWk
*>(
async
->
da
);

1680 
	gwk
->
WkProgss
();

1683 
NAN_INLINE
 
AsyncClo_
(
uv_hd_t
* 
hd
) {

1684 
AsyncProgssWk
 *
	gwk
 =

1685 
ic_
<
AsyncProgssWk
*>(
hd
->
da
);

1686 
de
 
	gt_
<
	guv_async_t
*>(
	ghd
);

1687 
de
 
	gwk
;

1690 
uv_async_t
 *
	gasync
;

1691 
uv_mux_t
 
	gasync_lock
;

1692 *
	gasyncda_
;

1693 
size_t
 
	gasyncsize_
;

1696 
NAN_INLINE
 
	$AsyncExecu
 (
uv_wk_t
* 
q
) {

1697 
AsyncWk
 *
wk
 = 
ic_
<AsyncWk*>(
q
->
da
);

1698 
wk
->
	`Execu
();

1699 
	}
}

1701 
NAN_INLINE
 
	$AsyncExecuCome
 (
uv_wk_t
* 
q
) {

1702 
AsyncWk
* 
wk
 = 
ic_
<AsyncWk*>(
q
->
da
);

1703 
wk
->
	`WkCome
();

1704 
wk
->
	`Deroy
();

1705 
	}
}

1707 
NAN_INLINE
 
	$AsyncQueueWk
 (
AsyncWk
* 
wk
) {

1708 
	`uv_queue_wk
(

1709 
	`uv_deu_lo
()

1710 , &
wk
->
que


1711 , 
AsyncExecu


1712 , 
t_
<
uv_a_wk_cb
>(
AsyncExecuCome
)

1714 
	}
}

1716 
mea
 
	gimp
 {

1718 
le


1719 
ExOBySgResour
 const*

1720 
GExResour
(
v8
::
Lol
<v8::
Sg
> 
r
) {

1721 #i
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION


1722  
r
->
GExAsciiSgResour
();

1724  
	gr
->
GExOBySgResour
();

1728 
le


1729 
bo


1730 
IsEx
(
v8
::
Lol
<v8::
Sg
> 
r
) {

1731 #i
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION


1732  
r
->
IsExAscii
();

1734  
	gr
->
IsExOBy
();

1740 
	eEncodg
 {
	gASCII
, 
	gUTF8
, 
	gBASE64
, 
	gUCS2
, 
	gBINARY
, 
	gHEX
, 
	gBUFFER
};

1742 #i
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION


1743 
	~"n_rg_bys.h
"

1746 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Encode
(

1747 cڡ *
buf
, 
size_t
 
n
, 
Encodg
 
codg
 = 
BINARY
) {

1748 #i(
NODE_MODULE_VERSION
 >
ATOM_0_21_MODULE_VERSION
)

1749 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
	`GCut
();

1750 
node
::
codg
 
node_c
 = 
ic_
<node::encoding>(encoding);

1752 i(
codg
 =
UCS2
) {

1753  
node
::
	`Encode
(

1754 
isީe


1755 , 
t_
<cڡ 
ut16_t
 *>(
buf
)

1756 , 
n
 / 2);

1758  
node
::
	`Encode
(

1759 
isީe


1760 , 
t_
<cڡ *>(
buf
)

1761 , 
n


1762 , 
node_c
);

1764 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1765  
node
::
	`Encode
(

1766 
v8
::
Isީe
::
	`GCut
()

1767 , 
buf
, 
n


1768 , 
ic_
<
node
::
codg
>(encoding));

1770 #i
NODE_MODULE_VERSION
 >
NODE_0_10_MODULE_VERSION


1771  
node
::
	`Encode
(
buf
, 
n
, 
ic_
<node::
codg
>(encoding));

1773  
imp
::
	`Encode
(
t_
<cڡ *>(
buf
), 
n
, 
codg
);

1776 
	}
}

1778 
NAN_INLINE
 
ssize_t
 
DecodeBys
(

1779 
v8
::
Lol
<v8::
Vue
> 
v
, 
Encodg
 
codg
 = 
BINARY
) {

1780 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1781  
node
::
DecodeBys
(

1782 
v8
::
Isީe
::
GCut
()

1783 , 
v


1784 , 
ic_
<
node
::
codg
>(encoding));

1786 #i(
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION
)

1787 i(
	gcodg
 =
BUFFER
) {

1788  
node
::
DecodeBys
(
v
,ode::
BINARY
);

1791  
	gnode
::
DecodeBys
(
v
, 
ic_
<
node
::
codg
>(encoding));

1795 
NAN_INLINE
 
ssize_t
 
DecodeWre
(

1796 *
buf


1797 , 
size_t
 
n


1798 , 
v8
::
Lol
<v8::
Vue
> 
v


1799 , 
Encodg
 
codg
 = 
BINARY
) {

1800 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1801  
node
::
DecodeWre
(

1802 
v8
::
Isީe
::
GCut
()

1803 , 
buf


1804 , 
n


1805 , 
v


1806 , 
ic_
<
node
::
codg
>(encoding));

1808 #i(
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION
)

1809 i(
	gcodg
 =
BUFFER
) {

1810  
node
::
DecodeWre
(
buf
, 
n
, 
v
,ode::
BINARY
);

1813  
	gnode
::
DecodeWre
(

1814 
buf


1815 , 
n


1816 , 
v


1817 , 
ic_
<
node
::
codg
>(encoding));

1821 
NAN_INLINE
 
SPryTeme
(

1822 
v8
::
Lol
<v8::
FuniTeme
> 
m


1823 , cڡ *
me


1824 , 
v8
::
Lol
<v8::
Da
> 
vue


1826 
STeme
(
m
->
PryTeme
(), 
me
, 
vue
);

1829 
NAN_INLINE
 
SPryTeme
(

1830 
v8
::
Lol
<v8::
FuniTeme
> 
m


1831 , 
v8
::
Lol
<v8::
Sg
> 
me


1832 , 
v8
::
Lol
<v8::
Da
> 
vue


1833 , 
v8
::
PrݔtyAribu
 
ibus


1835 
STeme
(
m
->
PryTeme
(), 
me
, 
vue
, 
ibus
);

1838 
NAN_INLINE
 
SInTeme
(

1839 
v8
::
Lol
<v8::
FuniTeme
> 
m


1840 , cڡ *
me


1841 , 
v8
::
Lol
<v8::
Da
> 
vue


1843 
STeme
(
m
->
InTeme
(), 
me
, 
vue
);

1846 
NAN_INLINE
 
SInTeme
(

1847 
v8
::
Lol
<v8::
FuniTeme
> 
m


1848 , 
v8
::
Lol
<v8::
Sg
> 
me


1849 , 
v8
::
Lol
<v8::
Da
> 
vue


1850 , 
v8
::
PrݔtyAribu
 
ibus


1852 
STeme
(
m
->
InTeme
(), 
me
, 
vue
, 
ibus
);

1855 
mea
 
	gimp
 {

1861 
	gme
 <
tyme
 
	gT
>

1862 
NAN_INLINE


1864 
SMhodAux
(
T
 
cv
,

1865 
v8
::
Lol
<v8::
Sg
> 
me
,

1866 
v8
::
Lol
<v8::
FuniTeme
> 
l
,

1867 
v8
::
Teme
 *) {

1868 
cv
->
S
(
me
, 
l
);

1871 
	gme
 <
tyme
 
	gT
>

1872 
NAN_INLINE


1874 
SMhodAux
(
T
 
cv
,

1875 
v8
::
Lol
<v8::
Sg
> 
me
,

1876 
v8
::
Lol
<v8::
FuniTeme
> 
l
,

1878 
	gcv
->
S
(
me
, 
GFuni
(
l
).
ToLolChecked
());

1883 
	gme
 <
tyme
 
	gT
,em<
	gtyme
> 
ass
 
	gHdTy
>

1884 
NAN_INLINE
 
SMhod
(

1885 
HdTy
<
T
> 
cv


1886 , cڡ *
me


1887 , 
FuniClback
 
back
) {

1888 
HdSce
 
	gsce
;

1889 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
t
 = 
New
<v8::FuniTeme>(
back
);

1890 
	gv8
::
Lol
<
v8
::
Sg
> 
_me
 = 
New
(
me
).
ToLolChecked
();

1891 
	gt
->
SCssName
(
_me
);

1894 
	gimp
::
SMhodAux
(
cv
, 
_me
, 
t
, 
ic_
<
T
*>(0));

1897 
NAN_INLINE
 
SPryMhod
(

1898 
v8
::
Lol
<v8::
FuniTeme
> 
cv


1899 , cڡ * 
me
, 
FuniClback
 
back
) {

1900 
HdSce
 
	gsce
;

1901 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
t
 = 
New
<v8::FunctionTemplate>(

1902 
back


1903 , 
	gv8
::
Lol
<
v8
::
Vue
>()

1904 , 
	gNew
<
	gv8
::
Sigtu
>(
cv
));

1905 
	gv8
::
Lol
<
v8
::
Sg
> 
_me
 = 
New
(
me
).
ToLolChecked
();

1906 
	gcv
->
PryTeme
()->
S
(
_me
, 
t
);

1907 
	gt
->
SCssName
(
_me
);

1912 
le
 
SAcss
(

1913 
v8
::
Lol
<v8::
ObjeTeme
> 
l


1914 , 
v8
::
Lol
<v8::
Sg
> 
me


1915 , 
GrClback
 
gr


1916 , 
SrClback
 

 = 0

1917 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

1918 , 
v8
::
AcssCڌ
 
gs
 = v8::
DEFAULT


1919 , 
v8
::
PrݔtyAribu
 
ibu
 = v8::
Ne


1920 , 
imp
::
Sig
 
sigtu
 = imp::
	$Sig
()) {

1921 
HdSce
 
sce
;

1923 
imp
::
NiveGr
 
gr_
 =

1924 
imp
::
GrClbackW
;

1925 
imp
::
NiveSr
 
_
 =

1926 

 ? 
imp
::
SrClbackW
 : 0;

1928 
v8
::
Lol
<v8::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

1929 
ٶ
->
	`SIlFldCou
(
imp
::
kAcssFldCou
);

1930 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
	`NewIn
(
ٶ
).
	`ToLolChecked
();

1932 
obj
->
	`SIlFld
(

1933 
imp
::
kGrIndex


1934 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

1936 i(

 != 0) {

1937 
obj
->
	`SIlFld
(

1938 
imp
::
kSrIndex


1939 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

1942 i(!
da
.
	`IsEmy
()) {

1943 
obj
->
	`SIlFld
(
imp
::
kDaIndex
, 
da
);

1946 
l
->
	`SAcss
(

1947 
me


1948 , 
gr_


1949 , 
_


1950 , 
obj


1951 , 
gs


1952 , 
ibu


1953 , 
sigtu
);

1954 
	}
}

1956 
le
 
bo
 
SAcss
(

1957 
v8
::
Lol
<v8::
Obje
> 
obj


1958 , 
v8
::
Lol
<v8::
Sg
> 
me


1959 , 
GrClback
 
gr


1960 , 
SrClback
 

 = 0

1961 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

1962 , 
v8
::
AcssCڌ
 
gs
 = v8::
DEFAULT


1963 , 
v8
::
PrݔtyAribu
 
ibu
 = v8::
Ne
) {

1964 
EsbHdSce
 
sce
;

1966 
	gimp
::
NiveGr
 
gr_
 =

1967 
imp
::
GrClbackW
;

1968 
	gimp
::
NiveSr
 
_
 =

1969 

 ? 
imp
::
SrClbackW
 : 0;

1971 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

1972 
	gٶ
->
SIlFldCou
(
imp
::
kAcssFldCou
);

1973 
	gv8
::
Lol
<
v8
::
Obje
> 
daobj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

1975 
	gdaobj
->
SIlFld
(

1976 
imp
::
kGrIndex


1977 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

1979 i(!
	gda
.
IsEmy
()) {

1980 
	gdaobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

1983 i(
	g
) {

1984 
	gdaobj
->
SIlFld
(

1985 
imp
::
kSrIndex


1986 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

1989  
	gobj
->
SAcss
(

1990 
me


1991 , 
gr_


1992 , 
_


1993 , 
daobj


1994 , 
gs


1995 , 
ibu
);

1998 
le
 
SNamedPrݔtyHdr
(

1999 
v8
::
Lol
<v8::
ObjeTeme
> 
l


2000 , 
PrݔtyGrClback
 
gr


2001 , 
PrݔtySrClback
 

 = 0

2002 , 
PrݔtyQuyClback
 
quy
 = 0

2003 , 
PrݔtyDClback
 
d
 = 0

2004 , 
PrݔtyEnumClback
 
um
 = 0

2005 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2006 
HdSce
 
sce
;

2008 
	gimp
::
NivePrݔtyGr
 
gr_
 =

2009 
imp
::
PrݔtyGrClbackW
;

2010 
	gimp
::
NivePrݔtySr
 
_
 =

2011 

 ? 
imp
::
PrݔtySrClbackW
 : 0;

2012 
	gimp
::
NivePrݔtyQuy
 
quy_
 =

2013 
quy
 ? 
imp
::
PrݔtyQuyClbackW
 : 0;

2014 
	gimp
::
NivePrݔtyD
 *
d_
 =

2015 
d
 ? 
imp
::
PrݔtyDClbackW
 : 0;

2016 
	gimp
::
NivePrݔtyEnum
 
um_
 =

2017 
um
 ? 
imp
::
PrݔtyEnumClbackW
 : 0;

2019 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2020 
	gٶ
->
SIlFldCou
(
imp
::
kPrݔtyFldCou
);

2021 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2022 
	gobj
->
SIlFld
(

2023 
imp
::
kPrݔtyGrIndex


2024 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2026 i(
	g
) {

2027 
	gobj
->
SIlFld
(

2028 
imp
::
kPrݔtySrIndex


2029 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2032 i(
	gquy
) {

2033 
	gobj
->
SIlFld
(

2034 
imp
::
kPrݔtyQuyIndex


2035 , 
New
<
v8
::
Ex
>(
t_
<*>(
quy
)));

2038 i(
	gd
) {

2039 
	gobj
->
SIlFld
(

2040 
imp
::
kPrݔtyDIndex


2041 , 
New
<
v8
::
Ex
>(
t_
<*>(
d
)));

2044 i(
	gum
) {

2045 
	gobj
->
SIlFld
(

2046 
imp
::
kPrݔtyEnumIndex


2047 , 
New
<
v8
::
Ex
>(
t_
<*>(
um
)));

2050 i(!
	gda
.
IsEmy
()) {

2051 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2054 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


2055 
	gl
->
SHdr
(
v8
::
NamedPrݔtyHdrCfiguti
(

2056 
gr_
, 
_
, 
quy_
, 
d_
, 
um_
, 
obj
));

2058 
	gl
->
SNamedPrݔtyHdr
(

2059 
gr_


2060 , 
_


2061 , 
quy_


2062 , 
d_


2063 , 
um_


2064 , 
obj
);

2068 
le
 
SIndexedPrݔtyHdr
(

2069 
v8
::
Lol
<v8::
ObjeTeme
> 
l


2070 , 
IndexGrClback
 
gr


2071 , 
IndexSrClback
 

 = 0

2072 , 
IndexQuyClback
 
quy
 = 0

2073 , 
IndexDClback
 
d
 = 0

2074 , 
IndexEnumClback
 
um
 = 0

2075 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2076 
HdSce
 
sce
;

2078 
	gimp
::
NiveIndexGr
 
gr_
 =

2079 
imp
::
IndexGrClbackW
;

2080 
	gimp
::
NiveIndexSr
 
_
 =

2081 

 ? 
imp
::
IndexSrClbackW
 : 0;

2082 
	gimp
::
NiveIndexQuy
 
quy_
 =

2083 
quy
 ? 
imp
::
IndexQuyClbackW
 : 0;

2084 
	gimp
::
NiveIndexD
 
d_
 =

2085 
d
 ? 
imp
::
IndexDClbackW
 : 0;

2086 
	gimp
::
NiveIndexEnum
 
um_
 =

2087 
um
 ? 
imp
::
IndexEnumClbackW
 : 0;

2089 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2090 
	gٶ
->
SIlFldCou
(
imp
::
kIndexPrݔtyFldCou
);

2091 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2092 
	gobj
->
SIlFld
(

2093 
imp
::
kIndexPrݔtyGrIndex


2094 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2096 i(
	g
) {

2097 
	gobj
->
SIlFld
(

2098 
imp
::
kIndexPrݔtySrIndex


2099 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2102 i(
	gquy
) {

2103 
	gobj
->
SIlFld
(

2104 
imp
::
kIndexPrݔtyQuyIndex


2105 , 
New
<
v8
::
Ex
>(
t_
<*>(
quy
)));

2108 i(
	gd
) {

2109 
	gobj
->
SIlFld
(

2110 
imp
::
kIndexPrݔtyDIndex


2111 , 
New
<
v8
::
Ex
>(
t_
<*>(
d
)));

2114 i(
	gum
) {

2115 
	gobj
->
SIlFld
(

2116 
imp
::
kIndexPrݔtyEnumIndex


2117 , 
New
<
v8
::
Ex
>(
t_
<*>(
um
)));

2120 i(!
	gda
.
IsEmy
()) {

2121 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2124 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


2125 
	gl
->
SHdr
(
v8
::
IndexedPrݔtyHdrCfiguti
(

2126 
gr_
, 
_
, 
quy_
, 
d_
, 
um_
, 
obj
));

2128 
	gl
->
SIndexedPrݔtyHdr
(

2129 
gr_


2130 , 
_


2131 , 
quy_


2132 , 
d_


2133 , 
um_


2134 , 
obj
);

2138 
le
 
SClHdr
(

2139 
v8
::
Lol
<v8::
FuniTeme
> 
l


2140 , 
FuniClback
 
back


2141 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2142 
HdSce
 
sce
;

2144 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2145 
	gٶ
->
SIlFldCou
(
imp
::
kFuniFldCou
);

2146 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2148 
	gobj
->
SIlFld
(

2149 
imp
::
kFuniIndex


2150 , 
New
<
v8
::
Ex
>(
t_
<*>(
back
)));

2152 i(!
	gda
.
IsEmy
()) {

2153 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2156 
	gl
->
SClHdr
(
imp
::
FuniClbackW
, 
obj
);

2160 
le
 
SClAsFuniHdr
(

2161 
v8
::
Lol
<v8::
ObjeTeme
> 
l
,

2162 
FuniClback
 
back
,

2163 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2164 
HdSce
 
sce
;

2166 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2167 
	gٶ
->
SIlFldCou
(
imp
::
kFuniFldCou
);

2168 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2170 
	gobj
->
SIlFld
(

2171 
imp
::
kFuniIndex


2172 , 
New
<
v8
::
Ex
>(
t_
<*>(
back
)));

2174 i(!
	gda
.
IsEmy
()) {

2175 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2178 
	gl
->
SClAsFuniHdr
(
imp
::
FuniClbackW
, 
obj
);

2183 
	~"n_wk.h
"

2187 
	~"n_obje_wp.h
"

2191 
le


2193 
	$Expt
(
ADDON_REGISTER_FUNCTION_ARGS_TYPE
 
rg
, cڡ *
me
,

2194 
FuniClback
 
f
) {

2195 
	`S
(
rg
, 
New
<
v8
::
Sg
>(
me
).
	`ToLolChecked
(),

2196 
	`GFuni
(
New
<
v8
::
FuniTeme
>(
f
)).
	`ToLolChecked
());

2197 
	}
}

2201 
	sT
 {

2202 
exic
 
T
(
v8
::
Lol
<v8::
Vue
> 
t
: 
t_
() {

2203 
t_
.
Ret
(
To
<
v8
::
Obje
>(
t
).
ToLolChecked
());

2206 ~
T
({ 
	gt_
.
Ret
(); }

2208 
le
 

(
i
) {

2209 
	gv8
::
Lol
<
v8
::
Vue
> 
g
 = 
New
(
i
);

2210 
MakeClback
(
New
(
t_
), "", 1, &
g
);

2213 
le
 
ok
(
bo
 
isOk
, cڡ *
msg
 = 
NULL
) {

2214 
v8
::
Lol
<v8::
Vue
> 
gs
[2];

2215 
	ggs
[0] = 
New
(
isOk
);

2216 i(
	gmsg

	ggs
[1] = 
New
(
msg
).
ToLolChecked
();

2217 
MakeClback
(
New
(
t_
), "ok", 
msg
 ? 2 : 1, 
gs
);

2220 
le
 
ss
(cڡ * 
msg
 = 
NULL
) {

2221 
v8
::
Lol
<v8::
Vue
> 
hmsg
;

2222 i(
	gmsg

	ghmsg
 = 
New
(
msg
).
ToLolChecked
();

2223 
MakeClback
(
New
(
t_
), "ss", 
msg
 ? 1 : 0, &
hmsg
);

2226 
	give
:

2227 
Psit
<
v8
::
Obje
> 
t_
;

2230 
	#NAN_STRINGIZE2
(
x
#x

	)

2231 
	#NAN_STRINGIZE
(
x

	$NAN_STRINGIZE2
(
x
)

	)

2232 
	#NAN_TEST_EXPRESSION
(
exessi
) \

2233 
exessi
 ), 
__FILE__
 ":" 
	`NAN_STRINGIZE
(
__LINE__
": " #exessi

	)

2235 
	#NAN_EXPORT
(
rg
, 
funi

	`Expt
Ѭg, #funi, funi)

	)

2237 #unde
TYPE_CHECK


2241 
mea
 
imp
 {

2243 
me
 <
tyme
 
T
> 
Maybefr
;

2245 
me
 <
tyme
 
T
> 
Maybefr
<
v8
::
Lol
<T> > {

2246 
MaybeLol
<
T
> 
	`cvt
(
v8
::
Lol
<T> 
v
) {

2247  
MaybeLol
<
T
>(
v
);

2251 
me
 <
tyme
 
T
> 
Maybefr
<
MaybeLol
<T> > {

2252 
MaybeLol
<
T
> 
	`cvt
(MaybeLol<T> 
v
) {

2253  
v
;

2257 
	}
}

2259 
	gme
 <
tyme
 
	gT
,em<
	gtyme
> 
ass
 
	gMaybeMaybe
>

2260 
	gMaybeLol
<
	gT
>

2261 
MakeMaybe
(
MaybeMaybe
<
T
> 
v
) {

2262  
	gimp
::
Maybefr
<
MaybeMaybe
<
T
> >::
cvt
(
v
);

2267 
	~"n_tydy_cڋs.h
"

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_callbacks.h

9 #ide
NAN_CALLBACKS_H_


10 
	#NAN_CALLBACKS_H_


	)

12 
	gme
<
tyme
 
	gT
> 
ass
 
	gFuniClbackInfo
;

13 
	gme
<
tyme
 
	gT
> 
ass
 
	gPrݔtyClbackInfo
;

14 
	gme
<
tyme
 
	gT
> 
ass
 
	gGlob
;

16 (*
	tFuniClback
)(cڡ 
	tFuniClbackInfo
<
	tv8
::
	tVue
>&);

17 (*
	tGrClback
)

18 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ 
	tPrݔtyClbackInfo
<v8::
	tVue
>&);

19 (*
	tSrClback
)(

20 
	tv8
::
	tLol
<v8::
	tSg
>,

21 
	tv8
::
	tLol
<v8::
	tVue
>,

22 cڡ 
	tPrݔtyClbackInfo
<>&);

23 (*
	tPrݔtyGrClback
)(

24 
	tv8
::
	tLol
<v8::
	tSg
>,

25 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

26 (*
	tPrݔtySrClback
)(

27 
	tv8
::
	tLol
<v8::
	tSg
>,

28 
	tv8
::
	tLol
<v8::
	tVue
>,

29 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

30 (*
	tPrݔtyEnumClback
)

31 (cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&);

32 (*
	tPrݔtyDClback
)(

33 
	tv8
::
	tLol
<v8::
	tSg
>,

34 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&);

35 (*
	tPrݔtyQuyClback
)(

36 
	tv8
::
	tLol
<v8::
	tSg
>,

37 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&);

38 (*
	tIndexGrClback
)(

39 
	tut32_t
,

40 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

41 (*
	tIndexSrClback
)(

42 
	tut32_t
,

43 
	tv8
::
	tLol
<v8::
	tVue
>,

44 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

45 (*
	tIndexEnumClback
)

46 (cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&);

47 (*
	tIndexDClback
)(

48 
	tut32_t
,

49 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&);

50 (*
	tIndexQuyClback
)(

51 
	tut32_t
,

52 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&);

54 
mea
 
imp
 {

55 
v8
::
	tLol
<
	tv8
::
	tAcssSigtu
> 
	tSig
;

57 cڡ 
kDaIndex
 = 0;

59 cڡ 
kFuniIndex
 = 1;

60 cڡ 
kFuniFldCou
 = 2;

62 cڡ 
kGrIndex
 = 1;

63 cڡ 
kSrIndex
 = 2;

64 cڡ 
kAcssFldCou
 = 3;

66 cڡ 
kPrݔtyGrIndex
 = 1;

67 cڡ 
kPrݔtySrIndex
 = 2;

68 cڡ 
kPrݔtyEnumIndex
 = 3;

69 cڡ 
kPrݔtyDIndex
 = 4;

70 cڡ 
kPrݔtyQuyIndex
 = 5;

71 cڡ 
kPrݔtyFldCou
 = 6;

73 cڡ 
kIndexPrݔtyGrIndex
 = 1;

74 cڡ 
kIndexPrݔtySrIndex
 = 2;

75 cڡ 
kIndexPrݔtyEnumIndex
 = 3;

76 cڡ 
kIndexPrݔtyDIndex
 = 4;

77 cڡ 
kIndexPrݔtyQuyIndex
 = 5;

78 cڡ 
kIndexPrݔtyFldCou
 = 6;

80 
	}
}

82 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


83 
	~"n_backs_12_l.h
"

85 
	~"n_backs_e_12_l.h
"

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_callbacks_12_inl.h

9 #ide
NAN_CALLBACKS_12_INL_H_


10 
	#NAN_CALLBACKS_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cRuVue
 {

14 
	mv8
::
RuVue
<
T
> 
vue_
;

16 
	mpublic
:

17 
me
 <
ass
 
S
>

18 
exic
 
le
 
RuVue
(cڡ 
v8
::RuVue<
S
> &
vue
) :

19 
	$vue_
(
vue
) {}

20 
me
 <
ass
 
S
>

21 
exic
 
le
 
	`RuVue
(cڡ 
RuVue
<
S
>& 
th
)

22 : 
	$vue_
(
th
.
vue_
) {

23 
	`TYPE_CHECK
(
T
, 
S
);

24 
	}
}

27 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
v8
::
Lol
<
S
> &
hd
) {

28 
TYPE_CHECK
(
T
, 
S
);

29 
	gvue_
.
S
(
hd
);

32 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
Glob
<
S
> &
hd
) {

33 
TYPE_CHECK
(
T
, 
S
);

34 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

35 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && \

36 (
V8_MINOR_VERSION
 > 5 || (V8_MINOR_VERSION == 5 && \

37 
defed
(
V8_BUILD_NUMBER
) && V8_BUILD_NUMBER >= 8))))

38 
vue_
.
S
(
hd
);

40 
	gvue_
.
S
(*
t_
<cڡ 
v8
::
Psit
<
S
>*>(&
hd
));

41 
	gcڡ_
<
	gGlob
<
	gS
> &>(
	ghd
).
Ret
();

46 
le
 
	$S
(
bo
 
vue
) {

47 
	`TYPE_CHECK
(
T
, 
v8
::
Boޗn
);

48 
vue_
.
	`S
(
vue
);

49 
	}
}

51 
le
 
	$S
(
i
) {

52 
	`TYPE_CHECK
(
T
, 
v8
::
Numb
);

53 
vue_
.
	`S
(
i
);

54 
	}
}

56 
le
 
	$S
(
t32_t
 
i
) {

57 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

58 
vue_
.
	`S
(
i
);

59 
	}
}

61 
le
 
	$S
(
ut32_t
 
i
) {

62 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

63 
vue_
.
	`S
(
i
);

64 
	}
}

67 
le
 
	$SNu
() {

68 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

69 
vue_
.
	`SNu
();

70 
	}
}

72 
le
 
	$SUndefed
() {

73 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

74 
vue_
.
	`SUndefed
();

75 
	}
}

77 
le
 
	$SEmySg
() {

78 
	`TYPE_CHECK
(
T
, 
v8
::
Sg
);

79 
vue_
.
	`SEmySg
();

80 
	}
}

83 
le
 
	gv8
::
Isީe
 *
	$GIsީe
() const {

84  
vue_
.
	`GIsީe
();

85 
	}
}

88 
	gme
<
tyme
 
	gS
>

89 
le
 
	$S
(
S
 *
whev
{ 
	`TYPE_CHECK
(S*, 
v8
::
Primive
); 
	}
}

92 
	gme
<
tyme
 
	gT
>

93 as
	cFuniClbackInfo
 {

94 cڡ 
	mv8
::
FuniClbackInfo
<
T
> &
fo_
;

95 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

97 
	mpublic
:

98 
exic
 
le
 
FuniClbackInfo
(

99 cڡ 
v8
::
FuniClbackInfo
<
T
> &
fo


100 , 
v8
::
Lol
<v8::
Vue
> 
da
) :

101 
fo_
(
fo
)

102 , 
	$da_
(
da
) {}

104 
le
 
RuVue
<
T
> 
	$GRuVue
() const {

105  
RuVue
<
T
>(
fo_
.
	`GRuVue
());

106 
	}
}

108 
le
 
	gv8
::
Lol
<
v8
::
Funi
> 
	$Ce
(cڡ {  
fo_
.
	`Ce
(); 
	}
}

109 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

110 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

111 
le
 
bo
 
	$IsCڡruCl
(cڡ {  
fo_
.
	`IsCڡruCl
(); 
	}
}

112 
le
 
	$Lgth
(cڡ {  
fo_
.
	`Lgth
(); 
	}
}

113 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
ݔ
[](
i
cڡ {  
fo_
[i]; }

114 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

115 
le
 
	gv8
::
Isީe
 *
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

118 
	geed
:

119 cڡ 
kHdIndex
 = 0;

120 cڡ 
	gkIsީeIndex
 = 1;

121 cڡ 
	gkRuVueDeuVueIndex
 = 2;

122 cڡ 
	gkRuVueIndex
 = 3;

123 cڡ 
	gkDaIndex
 = 4;

124 cڡ 
	gkCeIndex
 = 5;

125 cڡ 
	gkCڋxtSaveIndex
 = 6;

126 cڡ 
	gkArgsLgth
 = 7;

128 
	give
:

129 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
FuniClbackInfo
)

132 
	gme
<
tyme
 
	gT
>

133 as
	cPrݔtyClbackInfo
 {

134 cڡ 
	mv8
::
PrݔtyClbackInfo
<
T
> &
fo_
;

135 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

137 
	mpublic
:

138 
exic
 
le
 
PrݔtyClbackInfo
(

139 cڡ 
v8
::
PrݔtyClbackInfo
<
T
> &
fo


140 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

141 
fo_
(
fo
)

142 , 
	$da_
(
da
) {}

144 
le
 
v8
::
Isީe
* 
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

145 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

146 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

147 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

148 
le
 
	gRuVue
<
	gT
> 
	$GRuVue
() const {

149  
RuVue
<
T
>(
fo_
.
	`GRuVue
());

150 
	}
}

152 
	geed
:

153 cڡ 
kHdIndex
 = 0;

154 cڡ 
	gkIsީeIndex
 = 1;

155 cڡ 
	gkRuVueDeuVueIndex
 = 2;

156 cڡ 
	gkRuVueIndex
 = 3;

157 cڡ 
	gkDaIndex
 = 4;

158 cڡ 
	gkThisIndex
 = 5;

159 cڡ 
	gkArgsLgth
 = 6;

161 
	give
:

162 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
PrݔtyClbackInfo
)

165 
mea
 
	gimp
 {

167 
FuniClbackW
(cڡ 
v8
::
FuniClbackInfo
<v8::
Vue
> &
fo
) {

168 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

169 
FuniClback
 
	gback
 = 
t_
<FunctionCallback>(

170 
t_
<
_t
>(

171 
obj
->
GIlFld
(
kFuniIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

172 
	gFuniClbackInfo
<
	gv8
::
Vue
>

173 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

174 
back
(
cbfo
);

177 (*
	gNiveFuni
)(cڡ 
	tv8
::
	tFuniClbackInfo
<v8::
	tVue
> &);

179 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


181 
GrClbackW
(

182 
v8
::
Lol
<v8::
Name
> 
ݔty


183 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

184 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

185 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

186 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

187 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

188 
t_
<
_t
>(

189 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

190 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

193 (*
	gNiveGr
)

194 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

197 
SrClbackW
(

198 
v8
::
Lol
<v8::
Name
> 
ݔty


199 , 
v8
::
Lol
<v8::
Vue
> 
vue


200 , cڡ 
v8
::
PrݔtyClbackInfo
<> &
fo
) {

201 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

202 
	gPrݔtyClbackInfo
<>

203 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

204 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

205 
t_
<
_t
>(

206 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

207 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
vue
, 
cbfo
);

210 (*
	gNiveSr
)(

211 
	tv8
::
	tLol
<v8::
	tName
>

212 , 
	tv8
::
	tLol
<v8::
	tVue
>

213 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<> &);

216 
GrClbackW
(

217 
v8
::
Lol
<v8::
Sg
> 
ݔty


218 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

219 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

220 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

221 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

222 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

223 
t_
<
_t
>(

224 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

225 
back
(
ݔty
, 
cbfo
);

228 (*
	gNiveGr
)

229 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

232 
SrClbackW
(

233 
v8
::
Lol
<v8::
Sg
> 
ݔty


234 , 
v8
::
Lol
<v8::
Vue
> 
vue


235 , cڡ 
v8
::
PrݔtyClbackInfo
<> &
fo
) {

236 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

237 
	gPrݔtyClbackInfo
<>

238 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

239 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

240 
t_
<
_t
>(

241 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

242 
back
(
ݔty
, 
vue
, 
cbfo
);

245 (*
	gNiveSr
)(

246 
	tv8
::
	tLol
<v8::
	tSg
>

247 , 
	tv8
::
	tLol
<v8::
	tVue
>

248 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<> &);

251 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


253 
PrݔtyGrClbackW
(

254 
v8
::
Lol
<v8::
Name
> 
ݔty


255 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

256 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

257 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

258 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

259 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

260 
t_
<
_t
>(

261 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

262 .
As
<
v8
::
Ex
>()->
Vue
()));

263 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

266 (*
	gNivePrݔtyGr
)

267 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

270 
PrݔtySrClbackW
(

271 
v8
::
Lol
<v8::
Name
> 
ݔty


272 , 
v8
::
Lol
<v8::
Vue
> 
vue


273 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

274 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

275 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

276 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

277 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

278 
t_
<
_t
>(

279 
obj
->
GIlFld
(
kPrݔtySrIndex
)

280 .
As
<
v8
::
Ex
>()->
Vue
()));

281 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
vue
, 
cbfo
);

284 (*
	gNivePrݔtySr
)(

285 
	tv8
::
	tLol
<v8::
	tName
>

286 , 
	tv8
::
	tLol
<v8::
	tVue
>

287 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

290 
PrݔtyEnumClbackW
(

291 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

292 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

293 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

294 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

295 
PrݔtyEnumClback
 
	gback
 =

296 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

297 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

298 .
As
<
v8
::
Ex
>()->
Vue
()));

299 
back
(
cbfo
);

302 (*
	gNivePrݔtyEnum
)

303 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

306 
PrݔtyDClbackW
(

307 
v8
::
Lol
<v8::
Name
> 
ݔty


308 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

309 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

310 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

311 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

312 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

313 
t_
<
_t
>(

314 
obj
->
GIlFld
(
kPrݔtyDIndex
)

315 .
As
<
v8
::
Ex
>()->
Vue
()));

316 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

319 (
	gNivePrݔtyD
)

320 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

323 
PrݔtyQuyClbackW
(

324 
v8
::
Lol
<v8::
Name
> 
ݔty


325 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

326 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

327 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

328 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

329 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

330 
t_
<
_t
>(

331 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

332 .
As
<
v8
::
Ex
>()->
Vue
()));

333 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

336 (*
	gNivePrݔtyQuy
)

337 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

340 
PrݔtyGrClbackW
(

341 
v8
::
Lol
<v8::
Sg
> 
ݔty


342 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

343 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

344 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

345 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

346 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

347 
t_
<
_t
>(

348 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

349 .
As
<
v8
::
Ex
>()->
Vue
()));

350 
back
(
ݔty
, 
cbfo
);

353 (*
	gNivePrݔtyGr
)

354 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

357 
PrݔtySrClbackW
(

358 
v8
::
Lol
<v8::
Sg
> 
ݔty


359 , 
v8
::
Lol
<v8::
Vue
> 
vue


360 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

361 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

362 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

363 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

364 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

365 
t_
<
_t
>(

366 
obj
->
GIlFld
(
kPrݔtySrIndex
)

367 .
As
<
v8
::
Ex
>()->
Vue
()));

368 
back
(
ݔty
, 
vue
, 
cbfo
);

371 (*
	gNivePrݔtySr
)(

372 
	tv8
::
	tLol
<v8::
	tSg
>

373 , 
	tv8
::
	tLol
<v8::
	tVue
>

374 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

377 
PrݔtyEnumClbackW
(

378 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

379 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

380 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

381 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

382 
PrݔtyEnumClback
 
	gback
 =

383 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

384 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

385 .
As
<
v8
::
Ex
>()->
Vue
()));

386 
back
(
cbfo
);

389 (*
	gNivePrݔtyEnum
)

390 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

393 
PrݔtyDClbackW
(

394 
v8
::
Lol
<v8::
Sg
> 
ݔty


395 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

396 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

397 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

398 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

399 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

400 
t_
<
_t
>(

401 
obj
->
GIlFld
(
kPrݔtyDIndex
)

402 .
As
<
v8
::
Ex
>()->
Vue
()));

403 
back
(
ݔty
, 
cbfo
);

406 (
	gNivePrݔtyD
)

407 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

410 
PrݔtyQuyClbackW
(

411 
v8
::
Lol
<v8::
Sg
> 
ݔty


412 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

413 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

414 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

415 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

416 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

417 
t_
<
_t
>(

418 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

419 .
As
<
v8
::
Ex
>()->
Vue
()));

420 
back
(
ݔty
, 
cbfo
);

423 (*
	gNivePrݔtyQuy
)

424 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

428 
IndexGrClbackW
(

429 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

430 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

431 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

432 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

433 
IndexGrClback
 
	gback
 = 
t_
<IndexGetterCallback>(

434 
t_
<
_t
>(

435 
obj
->
GIlFld
(
kIndexPrݔtyGrIndex
)

436 .
As
<
v8
::
Ex
>()->
Vue
()));

437 
back
(
dex
, 
cbfo
);

440 (*
	gNiveIndexGr
)

441 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

444 
IndexSrClbackW
(

445 
ut32_t
 
dex


446 , 
v8
::
Lol
<v8::
Vue
> 
vue


447 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

448 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

449 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

450 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

451 
IndexSrClback
 
	gback
 = 
t_
<IndexSetterCallback>(

452 
t_
<
_t
>(

453 
obj
->
GIlFld
(
kIndexPrݔtySrIndex
)

454 .
As
<
v8
::
Ex
>()->
Vue
()));

455 
back
(
dex
, 
vue
, 
cbfo
);

458 (*
	gNiveIndexSr
)(

459 
	tut32_t


460 , 
	tv8
::
	tLol
<v8::
	tVue
>

461 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

464 
IndexEnumClbackW
(

465 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

466 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

467 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

468 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

469 
IndexEnumClback
 
	gback
 = 
t_
<IndexEnumeratorCallback>(

470 
t_
<
_t
>(

471 
obj
->
GIlFld
(

472 
kIndexPrݔtyEnumIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

473 
back
(
cbfo
);

476 (*
	gNiveIndexEnum
)

477 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

480 
IndexDClbackW
(

481 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

482 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

483 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

484 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

485 
IndexDClback
 
	gback
 = 
t_
<IndexDeleterCallback>(

486 
t_
<
_t
>(

487 
obj
->
GIlFld
(
kIndexPrݔtyDIndex
)

488 .
As
<
v8
::
Ex
>()->
Vue
()));

489 
back
(
dex
, 
cbfo
);

492 (*
	gNiveIndexD
)

493 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

496 
IndexQuyClbackW
(

497 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

498 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

499 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

500 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

501 
IndexQuyClback
 
	gback
 = 
t_
<IndexQueryCallback>(

502 
t_
<
_t
>(

503 
obj
->
GIlFld
(
kIndexPrݔtyQuyIndex
)

504 .
As
<
v8
::
Ex
>()->
Vue
()));

505 
back
(
dex
, 
cbfo
);

508 (*
	gNiveIndexQuy
)

509 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_callbacks_pre_12_inl.h

9 #ide
NAN_CALLBACKS_PRE_12_INL_H_


10 
	#NAN_CALLBACKS_PRE_12_INL_H_


	)

12 
mea
 
	gimp
 {

13 
	gme
<
tyme
 
	gT
> 
ass
 
	gRuVueImp
;

16 
	gme
<
tyme
 
	gT
>

17 as
	cRuVue
 {

18 
	mv8
::
Isީe
 *
isީe_
;

19 
	mv8
::
Psit
<
T
> *
vue_
;

20 
nd
 
ass
 
	mimp
::
RuVueImp
<
T
>;

22 
	mpublic
:

23 
me
 <
ass
 
S
>

24 
exic
 
le
 
RuVue
(
v8
::
Isީe
 *
isީe
, v8::
Psit
<
S
> *
p
) :

25 
isީe_
(
isީe
), 
	$vue_
(
p
) {}

26 
me
 <
ass
 
S
>

27 
exic
 
le
 
	`RuVue
(cڡ 
RuVue
<
S
>& 
th
)

28 : 
	`isީe_
(
th
.
isީe_
), 
	$vue_
(
th
.
vue_
) {

29 
	`TYPE_CHECK
(
T
, 
S
);

30 
	}
}

33 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
v8
::
Lol
<
S
> &
hd
) {

34 
TYPE_CHECK
(
T
, 
S
);

35 
	gvue_
->
Dio
();

36 *
	gvue_
 = 
v8
::
Psit
<
T
>::
New
(
hd
);

39 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
Glob
<
S
> &
hd
) {

40 
TYPE_CHECK
(
T
, 
S
);

41 
	gvue_
->
Dio
();

42 *
	gvue_
 = 
v8
::
Psit
<
T
>::
New
(
hd
.
rsit
);

43 
	gcڡ_
<
	gGlob
<
	gS
> &>(
	ghd
).
Ret
();

47 
le
 
	$S
(
bo
 
vue
) {

48 
	`TYPE_CHECK
(
T
, 
v8
::
Boޗn
);

49 
vue_
->
	`Dio
();

50 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Boޗn
::New(
vue
));

51 
	}
}

53 
le
 
	$S
(
i
) {

54 
	`TYPE_CHECK
(
T
, 
v8
::
Numb
);

55 
vue_
->
	`Dio
();

56 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Numb
::New(
i
));

57 
	}
}

59 
le
 
	$S
(
t32_t
 
i
) {

60 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

61 
vue_
->
	`Dio
();

62 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
I32
::New(
i
));

63 
	}
}

65 
le
 
	$S
(
ut32_t
 
i
) {

66 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

67 
vue_
->
	`Dio
();

68 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Ut32
::
	`NewFromUnsigd
(
i
));

69 
	}
}

72 
le
 
	$SNu
() {

73 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

74 
vue_
->
	`Dio
();

75 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
	`Nu
());

76 
	}
}

78 
le
 
	$SUndefed
() {

79 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

80 
vue_
->
	`Dio
();

81 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
	`Undefed
());

82 
	}
}

84 
le
 
	$SEmySg
() {

85 
	`TYPE_CHECK
(
T
, 
v8
::
Sg
);

86 
vue_
->
	`Dio
();

87 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Sg
::
	`Emy
());

88 
	}
}

91 
le
 
	gv8
::
Isީe
 *
	$GIsީe
() const {

92  
isީe_
;

93 
	}
}

96 
	gme
<
tyme
 
	gS
>

97 
le
 
	$S
(
S
 *
whev
{ 
	`TYPE_CHECK
(S*, 
v8
::
Primive
); 
	}
}

100 
	gme
<
tyme
 
	gT
>

101 as
	cFuniClbackInfo
 {

102 cڡ 
	mv8
::
Argumts
 &
gs_
;

103 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

104 
	mRuVue
<
	mT
> 
	mtu_vue_
;

105 
	mv8
::
Psit
<
T
> 
tv_
;

107 
	mpublic
:

108 
exic
 
le
 
FuniClbackInfo
(

109 cڡ 
v8
::
Argumts
 &
gs


110 , 
v8
::
Lol
<v8::
Vue
> 
da
) :

111 
gs_
(
gs
)

112 , 
da_
(
da
)

113 , 
tu_vue_
(
gs
.
GIsީe
(), &
tv_
)

114 , 
tv_
(
v8
::
Psit
<
T
>::
New
(v8::
	$Undefed
())) {}

116 
le
 ~
	$FuniClbackInfo
() {

117 
tv_
.
	`Dio
();

118 
tv_
.
	`Cˬ
();

119 
	}
}

121 
le
 
	gRuVue
<
	gT
> 
	$GRuVue
() const {

122  
RuVue
<
T
>(
tu_vue_
);

123 
	}
}

125 
le
 
	gv8
::
Lol
<
v8
::
Funi
> 
	$Ce
(cڡ {  
gs_
.
	`Ce
(); 
	}
}

126 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

127 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
gs_
.
	`Hd
(); 
	}
}

128 
le
 
bo
 
	$IsCڡruCl
(cڡ {  
gs_
.
	`IsCڡruCl
(); 
	}
}

129 
le
 
	$Lgth
(cڡ {  
gs_
.
	`Lgth
(); 
	}
}

130 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
ݔ
[](
i
cڡ {  
gs_
[i]; }

131 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
gs_
.
	`This
(); 
	}
}

132 
le
 
	gv8
::
Isީe
 *
	$GIsީe
(cڡ {  
gs_
.
	`GIsީe
(); 
	}
}

135 
	geed
:

136 cڡ 
kHdIndex
 = 0;

137 cڡ 
	gkIsީeIndex
 = 1;

138 cڡ 
	gkRuVueDeuVueIndex
 = 2;

139 cڡ 
	gkRuVueIndex
 = 3;

140 cڡ 
	gkDaIndex
 = 4;

141 cڡ 
	gkCeIndex
 = 5;

142 cڡ 
	gkCڋxtSaveIndex
 = 6;

143 cڡ 
	gkArgsLgth
 = 7;

145 
	give
:

146 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
FuniClbackInfo
)

149 
	gme
<
tyme
 
	gT
>

150 as
	cPrݔtyClbackInfoBa
 {

151 cڡ 
	mv8
::
AcssInfo
 &
fo_
;

152 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

154 
	mpublic
:

155 
exic
 
le
 
PrݔtyClbackInfoBa
(

156 cڡ 
v8
::
AcssInfo
 &
fo


157 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

158 
fo_
(
fo
)

159 , 
	$da_
(
da
) {}

161 
le
 
v8
::
Isީe
* 
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

162 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

163 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

164 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

166 
	geed
:

167 cڡ 
kHdIndex
 = 0;

168 cڡ 
	gkIsީeIndex
 = 1;

169 cڡ 
	gkRuVueDeuVueIndex
 = 2;

170 cڡ 
	gkRuVueIndex
 = 3;

171 cڡ 
	gkDaIndex
 = 4;

172 cڡ 
	gkThisIndex
 = 5;

173 cڡ 
	gkArgsLgth
 = 6;

175 
	give
:

176 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
PrݔtyClbackInfoBa
)

179 
	gme
<
tyme
 
	gT
>

180 
ass
 
	gPrݔtyClbackInfo
 : 
public
 
PrݔtyClbackInfoBa
<
T
> {

181 
RuVue
<
T
> 
tu_vue_
;

182 
	gv8
::
Psit
<
T
> 
tv_
;

184 
	gpublic
:

185 
exic
 
le
 
PrݔtyClbackInfo
(

186 cڡ 
v8
::
AcssInfo
 &
fo


187 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

188 
PrݔtyClbackInfoBa
<
T
>(
fo
, 
	gda
)

189 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

190 , 
tv_
(
v8
::
Psit
<
T
>::
New
(v8::
Undefed
())) {}

192 
le
 ~
PrݔtyClbackInfo
() {

193 
tv_
.
Dio
();

194 
	gtv_
.
Cˬ
();

197 
le
 
	gRuVue
<
	gT
> 
GRuVue
(cڡ {  
	gtu_vue_
; }

200 
	gme
<>

201 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
> :

202 
public
 
PrݔtyClbackInfoBa
<
v8
::
Aay
> {

203 
RuVue
<
v8
::
Aay
> 
tu_vue_
;

204 
	gv8
::
Psit
<
v8
::
Aay
> 
tv_
;

206 
	gpublic
:

207 
exic
 
le
 
PrݔtyClbackInfo
(

208 cڡ 
v8
::
AcssInfo
 &
fo


209 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

210 
PrݔtyClbackInfoBa
<
v8
::
Aay
>(
fo
, 
	gda
)

211 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

212 , 
tv_
(
v8
::
Psit
<v8::
Aay
>::
New
(v8::
Lol
<v8::Array>())) {}

214 
le
 ~
PrݔtyClbackInfo
() {

215 
tv_
.
Dio
();

216 
	gtv_
.
Cˬ
();

219 
le
 
	gRuVue
<
	gv8
::
Aay
> 
GRuVue
() const {

220  
tu_vue_
;

224 
	gme
<>

225 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
> :

226 
public
 
PrݔtyClbackInfoBa
<
v8
::
Boޗn
> {

227 
RuVue
<
v8
::
Boޗn
> 
tu_vue_
;

228 
	gv8
::
Psit
<
v8
::
Boޗn
> 
tv_
;

230 
	gpublic
:

231 
exic
 
le
 
PrݔtyClbackInfo
(

232 cڡ 
v8
::
AcssInfo
 &
fo


233 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

234 
PrݔtyClbackInfoBa
<
v8
::
Boޗn
>(
fo
, 
	gda
)

235 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

236 , 
tv_
(
v8
::
Psit
<v8::
Boޗn
>::
New
(v8::
Lol
<v8::Boolean>())) {}

238 
le
 ~
PrݔtyClbackInfo
() {

239 
tv_
.
Dio
();

240 
	gtv_
.
Cˬ
();

243 
le
 
	gRuVue
<
	gv8
::
Boޗn
> 
GRuVue
() const {

244  
tu_vue_
;

248 
	gme
<>

249 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
> :

250 
public
 
PrݔtyClbackInfoBa
<
v8
::
Ieg
> {

251 
RuVue
<
v8
::
Ieg
> 
tu_vue_
;

252 
	gv8
::
Psit
<
v8
::
Ieg
> 
tv_
;

254 
	gpublic
:

255 
exic
 
le
 
PrݔtyClbackInfo
(

256 cڡ 
v8
::
AcssInfo
 &
fo


257 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

258 
PrݔtyClbackInfoBa
<
v8
::
Ieg
>(
fo
, 
	gda
)

259 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

260 , 
tv_
(
v8
::
Psit
<v8::
Ieg
>::
New
(v8::
Lol
<v8::Integer>())) {}

262 
le
 ~
PrݔtyClbackInfo
() {

263 
tv_
.
Dio
();

264 
	gtv_
.
Cˬ
();

267 
le
 
	gRuVue
<
	gv8
::
Ieg
> 
GRuVue
() const {

268  
tu_vue_
;

272 
mea
 
	gimp
 {

273 
	gme
<
tyme
 
	gT
>

274 
ass
 
	gRuVueImp
 : 
public
 
RuVue
<
T
> {

275 
public
:

276 
exic
 
RuVueImp
(
RuVue
<
T
> 
th
) :

277 
RuVue
<
T
>(
th
) {}

278 
NAN_INLINE
 
v8
::
Hd
<
T
> 
Vue
() {

279  *
RuVue
<
T
>::
vue_
;

284 
	gv8
::
Hd
<
v8
::
Vue
> 
FuniClbackW
(cڡ v8::
Argumts
 &
gs
) {

285 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
gs
.
Da
().
As
<v8::Object>();

286 
FuniClback
 
	gback
 = 
t_
<FunctionCallback>(

287 
t_
<
_t
>(

288 
obj
->
GIlFld
(
kFuniIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

289 
	gFuniClbackInfo
<
	gv8
::
Vue
>

290 
cbfo
(
gs
, 
obj
->
GIlFld
(
kDaIndex
));

291 
back
(
cbfo
);

292  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

295 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveFuni
)(cڡ v8::
	tArgumts
 &);

298 
	gv8
::
Hd
<
v8
::
Vue
> 
GrClbackW
(

299 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

300 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

301 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

302 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

303 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

304 
t_
<
_t
>(

305 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

306 
back
(
ݔty
, 
cbfo
);

307  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

310 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveGr
)

311 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

314 
SrClbackW
(

315 
v8
::
Lol
<v8::
Sg
> 
ݔty


316 , 
v8
::
Lol
<v8::
Vue
> 
vue


317 , cڡ 
v8
::
AcssInfo
 &
fo
) {

318 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

319 
	gPrݔtyClbackInfo
<>

320 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

321 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

322 
t_
<
_t
>(

323 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

324 
back
(
ݔty
, 
vue
, 
cbfo
);

327 (*
	gNiveSr
)

328 (
	tv8
::
	tLol
<v8::
	tSg
>, v8::Lol<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

331 
	gv8
::
Hd
<
v8
::
Vue
> 
PrݔtyGrClbackW
(

332 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

333 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

334 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

335 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

336 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

337 
t_
<
_t
>(

338 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

339 .
As
<
v8
::
Ex
>()->
Vue
()));

340 
back
(
ݔty
, 
cbfo
);

341  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

344 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNivePrݔtyGr
)

345 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

348 
	gv8
::
Hd
<
v8
::
Vue
> 
PrݔtySrClbackW
(

349 
v8
::
Lol
<v8::
Sg
> 
ݔty


350 , 
v8
::
Lol
<v8::
Vue
> 
vue


351 , cڡ 
v8
::
AcssInfo
 &
fo
) {

352 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

353 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

354 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

355 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

356 
t_
<
_t
>(

357 
obj
->
GIlFld
(
kPrݔtySrIndex
)

358 .
As
<
v8
::
Ex
>()->
Vue
()));

359 
back
(
ݔty
, 
vue
, 
cbfo
);

360  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

363 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNivePrݔtySr
)

364 (
	tv8
::
	tLol
<v8::
	tSg
>, v8::Lol<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

367 
	gv8
::
Hd
<
v8
::
Aay
> 
PrݔtyEnumClbackW
(

368 cڡ 
v8
::
AcssInfo
 &
fo
) {

369 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

370 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

371 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

372 
PrݔtyEnumClback
 
	gback
 =

373 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

374 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

375 .
As
<
v8
::
Ex
>()->
Vue
()));

376 
back
(
cbfo
);

377  
	gRuVueImp
<
	gv8
::
Aay
>(
cbfo
.
GRuVue
()).
Vue
();

380 
	gv8
::
	tHd
<
	tv8
::
	tAay
> (*
	tNivePrݔtyEnum
)

381 (cڡ 
	tv8
::
	tAcssInfo
 &);

384 
	gv8
::
Hd
<
v8
::
Boޗn
> 
PrݔtyDClbackW
(

385 
v8
::
Lol
<v8::
Sg
> 
ݔty


386 , cڡ 
v8
::
AcssInfo
 &
fo
) {

387 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

388 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

389 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

390 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

391 
t_
<
_t
>(

392 
obj
->
GIlFld
(
kPrݔtyDIndex
)

393 .
As
<
v8
::
Ex
>()->
Vue
()));

394 
back
(
ݔty
, 
cbfo
);

395  
	gRuVueImp
<
	gv8
::
Boޗn
>(
cbfo
.
GRuVue
()).
Vue
();

398 
	gv8
::
	tHd
<
	tv8
::
	tBoޗn
> (
	tNivePrݔtyD
)

399 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

402 
	gv8
::
Hd
<
v8
::
Ieg
> 
PrݔtyQuyClbackW
(

403 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

404 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

405 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

406 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

407 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

408 
t_
<
_t
>(

409 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

410 .
As
<
v8
::
Ex
>()->
Vue
()));

411 
back
(
ݔty
, 
cbfo
);

412  
	gRuVueImp
<
	gv8
::
Ieg
>(
cbfo
.
GRuVue
()).
Vue
();

415 
	gv8
::
	tHd
<
	tv8
::
	tIeg
> (*
	tNivePrݔtyQuy
)

416 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

419 
	gv8
::
Hd
<
v8
::
Vue
> 
IndexGrClbackW
(

420 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

421 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

422 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

423 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

424 
IndexGrClback
 
	gback
 = 
t_
<IndexGetterCallback>(

425 
t_
<
_t
>(

426 
obj
->
GIlFld
(
kIndexPrݔtyGrIndex
)

427 .
As
<
v8
::
Ex
>()->
Vue
()));

428 
back
(
dex
, 
cbfo
);

429  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

432 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveIndexGr
)

433 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

436 
	gv8
::
Hd
<
v8
::
Vue
> 
IndexSrClbackW
(

437 
ut32_t
 
dex


438 , 
v8
::
Lol
<v8::
Vue
> 
vue


439 , cڡ 
v8
::
AcssInfo
 &
fo
) {

440 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

441 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

442 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

443 
IndexSrClback
 
	gback
 = 
t_
<IndexSetterCallback>(

444 
t_
<
_t
>(

445 
obj
->
GIlFld
(
kIndexPrݔtySrIndex
)

446 .
As
<
v8
::
Ex
>()->
Vue
()));

447 
back
(
dex
, 
vue
, 
cbfo
);

448  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

451 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveIndexSr
)

452 (
	tut32_t
, 
	tv8
::
	tLol
<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

455 
	gv8
::
Hd
<
v8
::
Aay
> 
IndexEnumClbackW
(

456 cڡ 
v8
::
AcssInfo
 &
fo
) {

457 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

458 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

459 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

460 
IndexEnumClback
 
	gback
 = 
t_
<IndexEnumeratorCallback>(

461 
t_
<
_t
>(

462 
obj
->
GIlFld
(
kIndexPrݔtyEnumIndex
)

463 .
As
<
v8
::
Ex
>()->
Vue
()));

464 
back
(
cbfo
);

465  
	gRuVueImp
<
	gv8
::
Aay
>(
cbfo
.
GRuVue
()).
Vue
();

468 
	gv8
::
	tHd
<
	tv8
::
	tAay
> (*
	tNiveIndexEnum
)

469 (cڡ 
	tv8
::
	tAcssInfo
 &);

472 
	gv8
::
Hd
<
v8
::
Boޗn
> 
IndexDClbackW
(

473 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

474 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

475 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

476 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

477 
IndexDClback
 
	gback
 = 
t_
<IndexDeleterCallback>(

478 
t_
<
_t
>(

479 
obj
->
GIlFld
(
kIndexPrݔtyDIndex
)

480 .
As
<
v8
::
Ex
>()->
Vue
()));

481 
back
(
dex
, 
cbfo
);

482  
	gRuVueImp
<
	gv8
::
Boޗn
>(
cbfo
.
GRuVue
()).
Vue
();

485 
	gv8
::
	tHd
<
	tv8
::
	tBoޗn
> (*
	tNiveIndexD
)

486 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

489 
	gv8
::
Hd
<
v8
::
Ieg
> 
IndexQuyClbackW
(

490 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

491 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

492 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

493 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

494 
IndexQuyClback
 
	gback
 = 
t_
<IndexQueryCallback>(

495 
t_
<
_t
>(

496 
obj
->
GIlFld
(
kIndexPrݔtyQuyIndex
)

497 .
As
<
v8
::
Ex
>()->
Vue
()));

498 
back
(
dex
, 
cbfo
);

499  
	gRuVueImp
<
	gv8
::
Ieg
>(
cbfo
.
GRuVue
()).
Vue
();

502 
	gv8
::
	tHd
<
	tv8
::
	tIeg
> (*
	tNiveIndexQuy
)

503 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_converters.h

9 #ide
NAN_CONVERTERS_H_


10 
	#NAN_CONVERTERS_H_


	)

12 
mea
 
	gimp
 {

13 
	gme
<
tyme
 
	gT
> 
	sToFayBa
 {

14 
	gMaybeLol
<
	tT
> 
	ttu_t
;

16 
	gme
<
tyme
 
	gT
> 
	sVueFayBa
 { 
	gMaybe
<
	tT
> 
	ttu_t
; };

18 
	gme
<
tyme
 
	gT
> 
	gToFay
;

20 
	#X
(
TYPE
) \

21 
me
<> \

22 
ToFay
<
v8
::
TYPE
> : 
ToFayBa
<v8::TYPE> { \

23 
le
 
tu_t
 
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
); \

24 };

	)

26 
X
(
Boޗn
)

27 
X
(
Numb
)

28 
X
(
Sg
)

29 
X
(
Obje
)

30 
X
(
Ieg
)

31 
X
(
Ut32
)

32 
X
(
I32
)

34 #unde
X


36 
	#X
(
TYPE
) \

37 
me
<> \

38 
ToFay
<
TYPE
> : 
VueFayBa
<TYPE> { \

39 
le
 
tu_t
 
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
); \

40 };

	)

42 
X
(
bo
)

43 
X
()

44 
X
(
t64_t
)

45 
X
(
ut32_t
)

46 
X
(
t32_t
)

48 #unde
X


51 
	gme
<
tyme
 
	gT
>

52 
NAN_INLINE


53 
tyme
 
	gimp
::
ToFay
<
T
>::
tu_t
 
To
(
v8
::
Lol
<v8::
Vue
> 
v
) {

54  
imp
::
ToFay
<
T
>::
cvt
(
v
);

57 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

58 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

59 
	~"n_cvrs_43_l.h
"

61 
	~"n_cvrs_e_43_l.h
"

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_converters_43_inl.h

9 #ide
NAN_CONVERTERS_43_INL_H_


10 
	#NAN_CONVERTERS_43_INL_H_


	)

12 
	#X
(
TYPE
) \

13 
imp
::
ToFay
<
v8
::
TYPE
>::
tu_t
 \

14 
imp
::
ToFay
<
v8
::
TYPE
>::
	`cvt
(v8::
Lol
<v8::
Vue
> 
v
) { \

15  
v
->
To
 ## 
	`TYPE
(
	`GCutCڋxt
()); \

16 }

	)

18 
	$X
(
Boޗn
)

19 
	$X
(
Numb
)

20 
	$X
(
Sg
)

21 
	$X
(
Obje
)

22 
	$X
(
Ieg
)

23 
	$X
(
Ut32
)

24 
	$X
(
I32
)

26 #unde
X


28 
	#X
(
TYPE
, 
NAME
) \

29 
imp
::
ToFay
<
TYPE
>::
tu_t
 \

30 
imp
::
ToFay
<
TYPE
>::
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) { \

31  
v
->
NAME
 ## 
	`Vue
(
	`GCutCڋxt
()); \

32 
	}

	)
}

34 
	$X
(
bo
, 
Boޗn
)

35 
	$X
(, 
Numb
)

36 
	$X
(
t64_t
, 
Ieg
)

37 
	$X
(
ut32_t
, 
Ut32
)

38 
	$X
(
t32_t
, 
I32
)

40 #unde
X


	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_converters_pre_43_inl.h

9 #ide
NAN_CONVERTERS_PRE_43_INL_H_


10 
	#NAN_CONVERTERS_PRE_43_INL_H_


	)

12 
	#X
(
TYPE
) \

13 
imp
::
ToFay
<
v8
::
TYPE
>::
tu_t
 \

14 
imp
::
ToFay
<
v8
::
TYPE
>::
	`cvt
(v8::
Lol
<v8::
Vue
> 
v
) { \

15  
MaybeLol
<
v8
::
TYPE
>(
v
->
To
 ## 
	`TYPE
()); \

16 }

	)

18 
	$X
(
Boޗn
)

19 
	$X
(
Numb
)

20 
	$X
(
Sg
)

21 
	$X
(
Obje
)

22 
	$X
(
Ieg
)

23 
	$X
(
Ut32
)

24 
	$X
(
I32
)

26 #unde
X


28 
	#X
(
TYPE
, 
NAME
) \

29 
imp
::
ToFay
<
TYPE
>::
tu_t
 \

30 
imp
::
ToFay
<
TYPE
>::
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) { \

31  
Ju
<
TYPE
>(
v
->
NAME
 ##
	`Vue
()); \

32 
	}

	)
}

34 
	$X
(
bo
, 
Boޗn
)

35 
	$X
(, 
Numb
)

36 
	$X
(
t64_t
, 
Ieg
)

37 
	$X
(
ut32_t
, 
Ut32
)

38 
	$X
(
t32_t
, 
I32
)

40 #unde
X


	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_implementation_12_inl.h

9 #ide
NAN_IMPLEMENTATION_12_INL_H_


10 
	#NAN_IMPLEMENTATION_12_INL_H_


	)

15 
mea
 
	gimp
 {

19 
	gFay
<
	gv8
::
Aay
>::
tu_t


20 
Fay
<
v8
::
Aay
>::
New
() {

21  
v8
::
Aay
::
New
(v8::
Isީe
::
GCut
());

24 
	gFay
<
	gv8
::
Aay
>::
tu_t


25 
Fay
<
v8
::
Aay
>::
New
(
ngth
) {

26  
v8
::
Aay
::
New
(v8::
Isީe
::
GCut
(), 
ngth
);

31 
	gFay
<
	gv8
::
Boޗn
>::
tu_t


32 
Fay
<
v8
::
Boޗn
>::
New
(
bo
 
vue
) {

33  
v8
::
Boޗn
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

38 
	gFay
<
	gv8
::
BoޗnObje
>::
tu_t


39 
Fay
<
v8
::
BoޗnObje
>::
New
(
bo
 
vue
) {

40  
v8
::
BoޗnObje
::
New
(
vue
).
As
<v8::BooleanObject>();

45 
	gFay
<
	gv8
::
Cڋxt
>::
tu_t


46 
Fay
<
v8
::
Cڋxt
>::
New
v8::
ExnsiCfiguti
* 
exnsis


47 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm


48 , 
v8
::
Lol
<v8::
Vue
> 
obj
) {

49  
v8
::
Cڋxt
::
New
(v8::
Isީe
::
GCut
(), 
exnsis
, 
tm
, 
obj
);

54 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

55 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

56 
Fay
<
v8
::
De
>::
tu_t


57 
Fay
<
v8
::
De
>::
New
(
vue
) {

58 
v8
::
Lol
<v8::
De
> 
t
;

59 i(
	gv8
::
De
::
New
(
GCutCڋxt
(), 
vue
).

60 
ToLol
(
t_
<
v8
::
Lol
<v8::
Vue
>*>(&
t
))) {

61  
v8
::
MaybeLol
<v8::
De
>(
t
);

63  
	gv8
::
MaybeLol
<
v8
::
De
>(
t
);

67 
	gFay
<
	gv8
::
De
>::
tu_t


68 
Fay
<
v8
::
De
>::
New
(
vue
) {

69  
Fay
<
v8
::
De
>::
tu_t
(

70 
v8
::
De
::
New
(v8::
Isީe
::
GCut
(), 
vue
).
As
<v8::Date>());

76 
	gFay
<
	gv8
::
Ex
>::
tu_t


77 
Fay
<
v8
::
Ex
>::
New
(* 
vue
) {

78  
v8
::
Ex
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

83 
	gFay
<
	gv8
::
Funi
>::
tu_t


84 
Fay
<
v8
::
Funi
>::
New

FuniClback
 
back


85 , 
v8
::
Lol
<v8::
Vue
> 
da
) {

86 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

87 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

88 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
(
isީe
);

89 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

90 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
l
).
ToLolChecked
();

92 
	gobj
->
SIlFld
(

93 
imp
::
kFuniIndex


94 , 
v8
::
Ex
::
New
(
isީe
, 
t_
<*>(
back
)));

96 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
isީe
, 
da
);

98 i(!
	gv
.
IsEmy
()) {

99 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

102  
	gsce
.
Es
(
v8
::
Funi
::
New

isީe


103 , 
imp
::
FuniClbackW


104 , 
obj
));

109 
	gFay
<
	gv8
::
FuniTeme
>::
tu_t


110 
Fay
<
v8
::
FuniTeme
>::
New

FuniClback
 
back


111 , 
v8
::
Lol
<v8::
Vue
> 
da


112 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
) {

113 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

114 i(
	gback
) {

115 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

116 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
(
isީe
);

117 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

118 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
l
).
ToLolChecked
();

120 
	gobj
->
SIlFld
(

121 
imp
::
kFuniIndex


122 , 
v8
::
Ex
::
New
(
isީe
, 
t_
<*>(
back
)));

123 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
isީe
, 
da
);

125 i(!
	gv
.
IsEmy
()) {

126 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

129  
	gsce
.
Es
(
v8
::
FuniTeme
::
New

isީe


130 , 
imp
::
FuniClbackW


131 , 
obj


132 , 
sigtu
));

134  
	gv8
::
FuniTeme
::
New
(
isީe
, 0, 
da
, 
sigtu
);

140 
	gFay
<
	gv8
::
Numb
>::
tu_t


141 
Fay
<
v8
::
Numb
>::
New
(
vue
) {

142  
v8
::
Numb
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

147 
	gFay
<
	gv8
::
NumbObje
>::
tu_t


148 
Fay
<
v8
::
NumbObje
>::
New
(
vue
) {

149  
v8
::
NumbObje
::
New
v8::
Isީe
::
GCut
()

150 , 
vue
).
	gAs
<
	gv8
::
NumbObje
>();

155 
	gme
 <
tyme
 
	gT
>

156 
tyme
 
	gIegFay
<
	gT
>::
tu_t


157 
IegFay
<
T
>::
New
(
t32_t
 
vue
) {

158  
To
<
T
>(T::
New
(
v8
::
Isީe
::
GCut
(), 
vue
));

161 
	gme
 <
tyme
 
	gT
>

162 
tyme
 
	gIegFay
<
	gT
>::
tu_t


163 
IegFay
<
T
>::
New
(
ut32_t
 
vue
) {

164  
To
<
T
>(T::
NewFromUnsigd
(
v8
::
Isީe
::
GCut
(), 
vue
));

167 
	gFay
<
	gv8
::
Ut32
>::
tu_t


168 
Fay
<
v8
::
Ut32
>::
New
(
t32_t
 
vue
) {

169  
To
<
v8
::
Ut32
>(

170 
v8
::
Ut32
::
NewFromUnsigd
(v8::
Isީe
::
GCut
(), 
vue
));

173 
	gFay
<
	gv8
::
Ut32
>::
tu_t


174 
Fay
<
v8
::
Ut32
>::
New
(
ut32_t
 
vue
) {

175  
To
<
v8
::
Ut32
>(

176 
v8
::
Ut32
::
NewFromUnsigd
(v8::
Isީe
::
GCut
(), 
vue
));

181 
	gFay
<
	gv8
::
Obje
>::
tu_t


182 
Fay
<
v8
::
Obje
>::
New
() {

183  
v8
::
Obje
::
New
(v8::
Isީe
::
GCut
());

188 
	gFay
<
	gv8
::
ObjeTeme
>::
tu_t


189 
Fay
<
v8
::
ObjeTeme
>::
New
() {

190  
v8
::
ObjeTeme
::
New
(v8::
Isީe
::
GCut
());

195 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

196 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

197 
Fay
<
v8
::
RegExp
>::
tu_t


198 
Fay
<
v8
::
RegExp
>::
New
(

199 
v8
::
Lol
<v8::
Sg
> 
n


200 , 
v8
::
RegExp
::
Fgs
 
ags
) {

201  
v8
::
RegExp
::
New
(
GCutCڋxt
(), 
n
, 
ags
);

204 
	gFay
<
	gv8
::
RegExp
>::
tu_t


205 
Fay
<
v8
::
RegExp
>::
New
(

206 
v8
::
Lol
<v8::
Sg
> 
n


207 , 
v8
::
RegExp
::
Fgs
 
ags
) {

208  
Fay
<
v8
::
RegExp
>::
tu_t
(v8::RegExp::
New
(
n
, 
ags
));

214 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

215 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

216 
Fay
<
v8
::
St
>::
tu_t


217 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

218 
v8
::
StComp
::
Sour
 
c
(
sour
);

219  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
c
);

222 
	gFay
<
	gv8
::
St
>::
tu_t


223 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


224 , 
v8
::
StOrig
 cڡ& 
ig
) {

225 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

226  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
c
);

229 
	gFay
<
	gv8
::
St
>::
tu_t


230 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

231 
v8
::
StComp
::
Sour
 
c
(
sour
);

232  
	gFay
<
	gv8
::
St
>::
tu_t
(

233 
v8
::
StComp
::
Compe
(v8::
Isީe
::
GCut
(), &
c
));

236 
	gFay
<
	gv8
::
St
>::
tu_t


237 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


238 , 
v8
::
StOrig
 cڡ& 
ig
) {

239 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

240  
	gFay
<
	gv8
::
St
>::
tu_t
(

241 
v8
::
StComp
::
Compe
(v8::
Isީe
::
GCut
(), &
c
));

247 
	gFay
<
	gv8
::
Sigtu
>::
tu_t


248 
Fay
<
v8
::
Sigtu
>::
New
(Fay<v8::Sigtu>::
FTH
 
iv
) {

249  
v8
::
Sigtu
::
New
(v8::
Isީe
::
GCut
(), 
iv
);

254 
	gFay
<
	gv8
::
Sg
>::
tu_t


255 
Fay
<
v8
::
Sg
>::
New
() {

256  
Fay
<
v8
::
Sg
>::
tu_t
(

257 
v8
::
Sg
::
Emy
(v8::
Isީe
::
GCut
()));

260 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

261 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

262 
Fay
<
v8
::
Sg
>::
tu_t


263 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

264  
	gv8
::
Sg
::
NewFromUtf8
(

265 
v8
::
Isީe
::
GCut
(), 
vue
, v8::
NewSgTy
::
kNm
, 
ngth
);

268 
	gFay
<
	gv8
::
Sg
>::
tu_t


269 
Fay
<
v8
::
Sg
>::
New
(
d
::
rg
 cڡ& 
vue
) {

270 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

271  
	gv8
::
Sg
::
NewFromUtf8
(
v8
::
Isީe
::
GCut
(),

272 
vue
.
da
(), 
v8
::
NewSgTy
::
kNm
, 
ic_
<>(vue.
size
()));

275 
	gFay
<
	gv8
::
Sg
>::
tu_t


276 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

277  
	gv8
::
Sg
::
NewFromTwoBy
(
v8
::
Isީe
::
GCut
(), 
vue
,

278 
v8
::
NewSgTy
::
kNm
, 
ngth
);

281 
	gFay
<
	gv8
::
Sg
>::
tu_t


282 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

283  
v8
::
Sg
::
NewExTwoBy
(v8::
Isީe
::
GCut
(), 
vue
);

286 
	gFay
<
	gv8
::
Sg
>::
tu_t


287 
Fay
<
v8
::
Sg
>::
New
(
ExOBySgResour
 * 
vue
) {

288  
v8
::
Sg
::
NewExOBy
(v8::
Isީe
::
GCut
(), 
vue
);

291 
	gFay
<
	gv8
::
Sg
>::
tu_t


292 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

293  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

294 
v8
::
Sg
::
NewFromUtf8
(

295 
v8
::
Isީe
::
GCut
()

296 , 
vue


297 , 
v8
::
Sg
::
kNmSg


298 , 
ngth
));

301 
	gFay
<
	gv8
::
Sg
>::
tu_t


302 
Fay
<
v8
::
Sg
>::
New
(

303 
d
::
rg
 cڡ& 
vue
) {

304 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

305  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

306 
v8
::
Sg
::
NewFromUtf8
(

307 
v8
::
Isީe
::
GCut
()

308 , 
vue
.
da
()

309 , 
v8
::
Sg
::
kNmSg


310 , 
ic_
<>(
vue
.
size
())));

313 
	gFay
<
	gv8
::
Sg
>::
tu_t


314 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

315  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

316 
v8
::
Sg
::
NewFromTwoBy
(

317 
v8
::
Isީe
::
GCut
()

318 , 
vue


319 , 
v8
::
Sg
::
kNmSg


320 , 
ngth
));

323 
	gFay
<
	gv8
::
Sg
>::
tu_t


324 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

325  
Fay
<
v8
::
Sg
>::
tu_t
(

326 
v8
::
Sg
::
NewEx
(v8::
Isީe
::
GCut
(), 
vue
));

329 
	gFay
<
	gv8
::
Sg
>::
tu_t


330 
Fay
<
v8
::
Sg
>::
New
(
ExOBySgResour
 * 
vue
) {

331  
Fay
<
v8
::
Sg
>::
tu_t
(

332 
v8
::
Sg
::
NewEx
(v8::
Isީe
::
GCut
(), 
vue
));

338 
	gFay
<
	gv8
::
SgObje
>::
tu_t


339 
Fay
<
v8
::
SgObje
>::
New
(v8::
Lol
<v8::
Sg
> 
vue
) {

340  
v8
::
SgObje
::
New
(
vue
).
As
<v8::StringObject>();

345 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

346 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

347 
Fay
<
v8
::
UnboundSt
>::
tu_t


348 
Fay
<
v8
::
UnboundSt
>::
New
(v8::
Lol
<v8::
Sg
> 
sour
) {

349 
v8
::
StComp
::
Sour
 
c
(
sour
);

350  
	gv8
::
StComp
::
CompeUnboundSt
(

351 
v8
::
Isީe
::
GCut
(), &
c
);

354 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


355 
Fay
<
v8
::
UnboundSt
>::
New
v8::
Lol
<v8::
Sg
> 
sour


356 , 
v8
::
StOrig
 cڡ& 
ig
) {

357 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

358  
	gv8
::
StComp
::
CompeUnboundSt
(

359 
v8
::
Isީe
::
GCut
(), &
c
);

362 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


363 
Fay
<
v8
::
UnboundSt
>::
New
(v8::
Lol
<v8::
Sg
> 
sour
) {

364 
v8
::
StComp
::
Sour
 
c
(
sour
);

365  
	gFay
<
	gv8
::
UnboundSt
>::
tu_t
(

366 
v8
::
StComp
::
CompeUnbound
(v8::
Isީe
::
GCut
(), &
c
));

369 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


370 
Fay
<
v8
::
UnboundSt
>::
New
v8::
Lol
<v8::
Sg
> 
sour


371 , 
v8
::
StOrig
 cڡ& 
ig
) {

372 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

373  
	gFay
<
	gv8
::
UnboundSt
>::
tu_t
(

374 
v8
::
StComp
::
CompeUnbound
(v8::
Isީe
::
GCut
(), &
c
));

382 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


383 
	gme
 <
tyme
 
	gT
>

384 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
) {

385  
v8
::
Lol
<
T
>::
New
(v8::
Isީe
::
GCut
(), 
h
);

389 
	gme
 <
tyme
 
	gT
,ym
	gM
>

390 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T, 
M
> cڡ& 
p
) {

391  
	gv8
::
Lol
<
T
>::
New
(
v8
::
Isީe
::
GCut
(), 
p
);

394 
	gme
 <
tyme
 
	gT
,ym
	gM
>

395 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
) {

396  
	gv8
::
Lol
<
T
>::
New
(
v8
::
Isީe
::
GCut
(), 
p
);

399 
	gme
 <
tyme
 
	gT
>

400 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
) {

401  
v8
::
Lol
<
T
>::
New
(v8::
Isީe
::
GCut
(), 
p
);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_implementation_pre_12_inl.h

9 #ide
NAN_IMPLEMENTATION_PRE_12_INL_H_


10 
	#NAN_IMPLEMENTATION_PRE_12_INL_H_


	)

16 
mea
 
	gimp
 {

20 
	gFay
<
	gv8
::
Aay
>::
tu_t


21 
Fay
<
v8
::
Aay
>::
New
() {

22  
v8
::
Aay
::
New
();

25 
	gFay
<
	gv8
::
Aay
>::
tu_t


26 
Fay
<
v8
::
Aay
>::
New
(
ngth
) {

27  
v8
::
Aay
::
New
(
ngth
);

32 
	gFay
<
	gv8
::
Boޗn
>::
tu_t


33 
Fay
<
v8
::
Boޗn
>::
New
(
bo
 
vue
) {

34  
v8
::
Boޗn
::
New
(
vue
)->
ToBoޗn
();

39 
	gFay
<
	gv8
::
BoޗnObje
>::
tu_t


40 
Fay
<
v8
::
BoޗnObje
>::
New
(
bo
 
vue
) {

41  
v8
::
BoޗnObje
::
New
(
vue
).
As
<v8::BooleanObject>();

46 
	gFay
<
	gv8
::
Cڋxt
>::
tu_t


47 
Fay
<
v8
::
Cڋxt
>::
New
v8::
ExnsiCfiguti
* 
exnsis


48 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm


49 , 
v8
::
Lol
<v8::
Vue
> 
obj
) {

50 
v8
::
Psit
<v8::
Cڋxt
> 
x
 = v8::Cڋxt::
New
(
exnsis
, 
tm
, 
obj
);

51 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
lx
 = v8::Lol<v8::Cڋxt>::
New
(
x
);

52 
	gx
.
Dio
();

53  
	glx
;

58 
	gFay
<
	gv8
::
De
>::
tu_t


59 
Fay
<
v8
::
De
>::
New
(
vue
) {

60  
Fay
<
v8
::
De
>::
tu_t
(v8::De::
New
(
vue
).
As
<v8::Date>());

65 
	gFay
<
	gv8
::
Ex
>::
tu_t


66 
Fay
<
v8
::
Ex
>::
New
(* 
vue
) {

67  
v8
::
Ex
::
New
(
vue
);

72 
	gFay
<
	gv8
::
Funi
>::
tu_t


73 
Fay
<
v8
::
Funi
>::
New

FuniClback
 
back


74 , 
v8
::
Lol
<v8::
Vue
> 
da
) {

75  
Fay
<
v8
::
FuniTeme
>::
New

back


76 , 
da


77 , 
v8
::
Lol
<v8::
Sigtu
>()

78 )->
GFuni
();

84 
	gFay
<
	gv8
::
FuniTeme
>::
tu_t


85 
Fay
<
v8
::
FuniTeme
>::
New

FuniClback
 
back


86 , 
v8
::
Lol
<v8::
Vue
> 
da


87 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
) {

88 i(
back
) {

89 
v8
::
HdSce
 
sce
;

91 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
();

92 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

93 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
l
->
NewIn
();

95 
	gobj
->
SIlFld
(

96 
imp
::
kFuniIndex


97 , 
v8
::
Ex
::
New
(
t_
<*>(
back
)));

99 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
da
);

101 i(!
	gv
.
IsEmy
()) {

102 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

107  
	gsce
.
Clo
(

108 
v8
::
FuniTeme
::
New
(
imp
::
FuniClbackW


109 , 
obj


110 , 
sigtu
));

112  
	gv8
::
FuniTeme
::
New
(0, 
da
, 
sigtu
);

118 
	gFay
<
	gv8
::
Numb
>::
tu_t


119 
Fay
<
v8
::
Numb
>::
New
(
vue
) {

120  
v8
::
Numb
::
New
(
vue
);

125 
	gFay
<
	gv8
::
NumbObje
>::
tu_t


126 
Fay
<
v8
::
NumbObje
>::
New
(
vue
) {

127  
v8
::
NumbObje
::
New
(
vue
).
As
<v8::NumberObject>();

132 
	gme
 <
tyme
 
	gT
>

133 
tyme
 
	gIegFay
<
	gT
>::
tu_t


134 
IegFay
<
T
>::
New
(
t32_t
 
vue
) {

135  
To
<
T
>(T::
New
(
vue
));

138 
	gme
 <
tyme
 
	gT
>

139 
tyme
 
	gIegFay
<
	gT
>::
tu_t


140 
IegFay
<
T
>::
New
(
ut32_t
 
vue
) {

141  
To
<
T
>(T::
NewFromUnsigd
(
vue
));

144 
	gFay
<
	gv8
::
Ut32
>::
tu_t


145 
Fay
<
v8
::
Ut32
>::
New
(
t32_t
 
vue
) {

146  
To
<
v8
::
Ut32
>(v8::Ut32::
NewFromUnsigd
(
vue
));

149 
	gFay
<
	gv8
::
Ut32
>::
tu_t


150 
Fay
<
v8
::
Ut32
>::
New
(
ut32_t
 
vue
) {

151  
To
<
v8
::
Ut32
>(v8::Ut32::
NewFromUnsigd
(
vue
));

157 
	gFay
<
	gv8
::
Obje
>::
tu_t


158 
Fay
<
v8
::
Obje
>::
New
() {

159  
v8
::
Obje
::
New
();

164 
	gFay
<
	gv8
::
ObjeTeme
>::
tu_t


165 
Fay
<
v8
::
ObjeTeme
>::
New
() {

166  
v8
::
ObjeTeme
::
New
();

171 
	gFay
<
	gv8
::
RegExp
>::
tu_t


172 
Fay
<
v8
::
RegExp
>::
New
(

173 
v8
::
Lol
<v8::
Sg
> 
n


174 , 
v8
::
RegExp
::
Fgs
 
ags
) {

175  
Fay
<
v8
::
RegExp
>::
tu_t
(v8::RegExp::
New
(
n
, 
ags
));

180 
	gFay
<
	gv8
::
St
>::
tu_t


181 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

182  
Fay
<
v8
::
St
>::
tu_t
(v8::St::
New
(
sour
));

184 
	gFay
<
	gv8
::
St
>::
tu_t


185 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


186 , 
v8
::
StOrig
 cڡ& 
ig
) {

187  
Fay
<
v8
::
St
>::
tu_t
(

188 
v8
::
St
::
New
(
sour
, 
cڡ_
<v8::
StOrig
*>(&
ig
)));

193 
	gFay
<
	gv8
::
Sigtu
>::
tu_t


194 
Fay
<
v8
::
Sigtu
>::
New
(Fay<v8::Sigtu>::
FTH
 
iv
) {

195  
v8
::
Sigtu
::
New
(
iv
);

200 
	gFay
<
	gv8
::
Sg
>::
tu_t


201 
Fay
<
v8
::
Sg
>::
New
() {

202  
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
Emy
());

205 
	gFay
<
	gv8
::
Sg
>::
tu_t


206 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

207  
	gFay
<
	gv8
::
Sg
>::
tu_t
(
v8
::Sg::
New
(
vue
, 
ngth
));

210 
	gFay
<
	gv8
::
Sg
>::
tu_t


211 
Fay
<
v8
::
Sg
>::
New
(

212 
d
::
rg
 cڡ& 
vue
) {

213 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

214  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

215 
v8
::
Sg
::
New

vue
.
da
(), 
ic_
<>(vue.
size
())));

218 
	gFay
<
	gv8
::
Sg
>::
tu_t


219 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

220  
	gFay
<
	gv8
::
Sg
>::
tu_t
(
v8
::Sg::
New
(
vue
, 
ngth
));

223 
	gFay
<
	gv8
::
Sg
>::
tu_t


224 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

225  
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
NewEx
(
vue
));

228 
	gFay
<
	gv8
::
Sg
>::
tu_t


229 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExAsciiSgResour
 * 
vue
) {

230  
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
NewEx
(
vue
));

235 
	gFay
<
	gv8
::
SgObje
>::
tu_t


236 
Fay
<
v8
::
SgObje
>::
New
(v8::
Lol
<v8::
Sg
> 
vue
) {

237  
v8
::
SgObje
::
New
(
vue
).
As
<v8::StringObject>();

244 
	gme
 <
tyme
 
	gT
>

245 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
) {

246  
v8
::
Lol
<
T
>::
New
(
h
);

249 
	gme
 <
tyme
 
	gT
>

250 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T> cڡ& 
p
) {

251  
v8
::
Lol
<
T
>::
New
(
p
);

254 
	gme
 <
tyme
 
	gT
,ym
	gM
>

255 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
) {

256  
	gv8
::
Lol
<
T
>::
New
(
p
.
rsit
);

259 
	gme
 <
tyme
 
	gT
>

260 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
) {

261  
v8
::
Lol
<
T
>::
New
(
p
.
rsit
);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_maybe_43_inl.h

9 #ide
NAN_MAYBE_43_INL_H_


10 
	#NAN_MAYBE_43_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 
usg
 
	gMaybeLol
 = 
v8
::
MaybeLol
<
T
>;

15 
	gme
<
tyme
 
	gT
>

16 
usg
 
	gMaybe
 = 
v8
::
Maybe
<
T
>;

18 
	gme
<
tyme
 
	gT
>

19 
NAN_INLINE
 
	gMaybe
<
	gT
> 
	$Nhg
() {

20  
v8
::
Nhg
<
T
>();

21 
	}
}

23 
	gme
<
tyme
 
	gT
>

24 
NAN_INLINE
 
	gMaybe
<
	gT
> 
	$Ju
(cڡ 
T
& 
t
) {

25  
v8
::
Ju
<
T
>(
t
);

26 
	}
}

28 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
GCutCڋxt
();

30 
NAN_INLINE


31 
	gMaybeLol
<
	gv8
::
Sg
> 
ToDaSg
(
v8
::
Lol
<v8::
Vue
> 
v
) {

32  
v
->
ToDaSg
(
GCutCڋxt
());

35 
NAN_INLINE


36 
	gMaybeLol
<
	gv8
::
Ut32
> 
ToAayIndex
(
v8
::
Lol
<v8::
Vue
> 
v
) {

37  
v
->
ToAayIndex
(
GCutCڋxt
());

40 
NAN_INLINE


41 
	gMaybe
<
	gbo
> 
Equs
(
v8
::
Lol
<v8::
Vue
> 
a
, v8::Lol<v8::Vue>(
b
)) {

42  
a
->
Equs
(
GCutCڋxt
(), 
b
);

45 
NAN_INLINE


46 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Lol
<v8::
Funi
> 
h
) {

47  
h
->
NewIn
(
GCutCڋxt
());

50 
NAN_INLINE


51 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(

52 
v8
::
Lol
<v8::
Funi
> 
h


53 , 
gc


54 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

55  
h
->
NewIn
(
GCutCڋxt
(), 
gc
, 
gv
);

58 
NAN_INLINE


59 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Lol
<v8::
ObjeTeme
> 
h
) {

60  
h
->
NewIn
(
GCutCڋxt
());

64 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Funi
> 
GFuni
(

65 
v8
::
Lol
<v8::
FuniTeme
> 
t
) {

66  
t
->
GFuni
(
GCutCڋxt
());

69 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

70 
v8
::
Lol
<v8::
Obje
> 
obj


71 , 
v8
::
Lol
<v8::
Vue
> 
key


72 , 
v8
::
Lol
<v8::
Vue
> 
vue
) {

73  
obj
->
S
(
GCutCڋxt
(), 
key
, 
vue
);

76 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

77 
v8
::
Lol
<v8::
Obje
> 
obj


78 , 
ut32_t
 
dex


79 , 
v8
::
Lol
<v8::
Vue
> 
vue
) {

80  
obj
->
S
(
GCutCڋxt
(), 
dex
, 
vue
);

83 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
FS
(

84 
v8
::
Lol
<v8::
Obje
> 
obj


85 , 
v8
::
Lol
<v8::
Vue
> 
key


86 , 
v8
::
Lol
<v8::
Vue
> 
vue


87 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

88  
obj
->
FS
(
GCutCڋxt
(), 
key
, 
vue
, 
ibs
);

91 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

92 
v8
::
Lol
<v8::
Obje
> 
obj


93 , 
v8
::
Lol
<v8::
Vue
> 
key
) {

94  
obj
->
G
(
GCutCڋxt
(), 
key
);

97 
NAN_INLINE


98 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

99  
	gobj
->
G
(
GCutCڋxt
(), 
dex
);

102 
NAN_INLINE
 
	gv8
::
PrݔtyAribu
 
GPrݔtyAribus
(

103 
v8
::
Lol
<v8::
Obje
> 
obj


104 , 
v8
::
Lol
<v8::
Vue
> 
key
) {

105  
obj
->
GPrݔtyAribus
(
GCutCڋxt
(), 
key
).
FromJu
();

108 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(

109 
v8
::
Lol
<v8::
Obje
> 
obj


110 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

111  
obj
->
Has
(
GCutCڋxt
(), 
key
);

114 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

115  
	gobj
->
Has
(
GCutCڋxt
(), 
dex
);

118 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
De
(

119 
v8
::
Lol
<v8::
Obje
> 
obj


120 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

121  
obj
->
De
(
GCutCڋxt
(), 
key
);

124 
NAN_INLINE


125 
	gMaybe
<
	gbo
> 
De
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

126  
	gobj
->
De
(
GCutCڋxt
(), 
dex
);

129 
NAN_INLINE


130 
	gMaybeLol
<
	gv8
::
Aay
> 
GPrݔtyNames
(
v8
::
Lol
<v8::
Obje
> 
obj
) {

131  
obj
->
GPrݔtyNames
(
GCutCڋxt
());

134 
NAN_INLINE


135 
	gMaybeLol
<
	gv8
::
Aay
> 
GOwnPrݔtyNames
(
v8
::
Lol
<v8::
Obje
> 
obj
) {

136  
obj
->
GOwnPrݔtyNames
(
GCutCڋxt
());

139 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
SPry
(

140 
v8
::
Lol
<v8::
Obje
> 
obj


141 , 
v8
::
Lol
<v8::
Vue
> 
y
) {

142  
obj
->
SPry
(
GCutCڋxt
(), 
y
);

145 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
> 
ObjeProToSg
(

146 
v8
::
Lol
<v8::
Obje
> 
obj
) {

147  
obj
->
ObjeProToSg
(
GCutCڋxt
());

150 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasOwnPrݔty
(

151 
v8
::
Lol
<v8::
Obje
> 
obj


152 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

153  
obj
->
HasOwnPrݔty
(
GCutCڋxt
(), 
key
);

156 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedPrݔty
(

157 
v8
::
Lol
<v8::
Obje
> 
obj


158 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

159  
obj
->
HasRlNamedPrݔty
(
GCutCڋxt
(), 
key
);

162 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlIndexedPrݔty
(

163 
v8
::
Lol
<v8::
Obje
> 
obj


164 , 
ut32_t
 
dex
) {

165  
	gobj
->
HasRlIndexedPrݔty
(
GCutCڋxt
(), 
dex
);

168 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedClbackPrݔty
(

169 
v8
::
Lol
<v8::
Obje
> 
obj


170 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

171  
obj
->
HasRlNamedClbackPrݔty
(
GCutCڋxt
(), 
key
);

174 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔtyInPryCha
(

175 
v8
::
Lol
<v8::
Obje
> 
obj


176 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

177  
obj
->
GRlNamedPrݔtyInPryCha
(
GCutCڋxt
(), 
key
);

180 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔty
(

181 
v8
::
Lol
<v8::
Obje
> 
obj


182 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

183  
obj
->
GRlNamedPrݔty
(
GCutCڋxt
(), 
key
);

186 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsFuni
(

187 
v8
::
Lol
<v8::
Obje
> 
obj


188 , 
v8
::
Lol
<v8::
Obje
> 
cv


189 , 
gc


190 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

191  
obj
->
ClAsFuni
(
GCutCڋxt
(), 
cv
, 
gc
, 
gv
);

194 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsCڡru
(

195 
v8
::
Lol
<v8::
Obje
> 
obj


196 , 
gc
, 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

197  
obj
->
ClAsCڡru
(
GCutCڋxt
(), 
gc
, 
gv
);

200 
NAN_INLINE


201 
	gMaybeLol
<
	gv8
::
Sg
> 
GSourLe
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

202  
msg
->
GSourLe
(
GCutCڋxt
());

205 
NAN_INLINE
 
	gMaybe
<> 
GLeNumb
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

206  
msg
->
GLeNumb
(
GCutCڋxt
());

209 
NAN_INLINE
 
	gMaybe
<> 
GSCumn
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

210  
msg
->
GSCumn
(
GCutCڋxt
());

213 
NAN_INLINE
 
	gMaybe
<> 
GEndCumn
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

214  
msg
->
GEndCumn
(
GCutCڋxt
());

217 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
CleEmtAt
(

218 
v8
::
Lol
<v8::
Aay
> 
y


219 , 
ut32_t
 
dex
) {

220  
	gy
->
CleEmtAt
(
GCutCڋxt
(), 
dex
);

223 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

224 
v8
::
Lol
<v8::
Funi
> 
fun


225 , 
v8
::
Lol
<v8::
Obje
> 
cv


226 , 
gc


227 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

228  
fun
->
Cl
(
GCutCڋxt
(), 
cv
, 
gc
, 
gv
);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_maybe_pre_43_inl.h

9 #ide
NAN_MAYBE_PRE_43_INL_H_


10 
	#NAN_MAYBE_PRE_43_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cMaybeLol
 {

14 
	mpublic
:

15 
NAN_INLINE
 
	$MaybeLol
(: 
	`v_
(
v8
::
Lol
<
T
>()) {}

17 
me
<
tyme
 
S
>

18 #i
NODE_MODULE_VERSION
 >
NODE_0_12_MODULE_VERSION


19 
NAN_INLINE
 
	`MaybeLol
(
v8
::
Lol
<
S
> 
th
: 
	$v_
(
th
{
	}
}

21 
NAN_INLINE
 
MaybeLol
(
v8
::
Lol
<
S
> 
th
) :

22 
v_
(*
t_
<
v8
::
Lol
<
T
>*>(&
th
)) {}

25 
NAN_INLINE
 
bo
 
	$IsEmy
(cڡ {  
v_
.
	`IsEmy
(); 
	}
}

27 
	gme
<
tyme
 
	gS
>

28 
NAN_INLINE
 
bo
 
ToLol
(
v8
::
Lol
<
S
> *
out
) const {

29 *
out
 = 
v_
;

30  !
IsEmy
();

33 
NAN_INLINE
 
	gv8
::
Lol
<
T
> 
	$ToLolChecked
() const {

34 #i
	`defed
(
V8_ENABLE_CHECKS
)

35 
	`as
(!
	`IsEmy
() && "ToLocalChecked is Empty");

37  
v_
;

38 
	}
}

40 
	gme
<
tyme
 
	gS
>

41 
NAN_INLINE
 
	gv8
::
Lol
<
S
> 
FromMaybe
(
v8
::Lol<S> 
deu_vue
) const {

42  
IsEmy
(? 
deu_vue
 : 
v_
;

45 
	give
:

46 
v8
::
Lol
<
T
> 
v_
;

49 
	gme
<
tyme
 
	gT
>

50 as
	cMaybe
 {

51 
	mpublic
:

52 
NAN_INLINE
 
bo
 
	$IsNhg
(cڡ {  !
has_vue_
; }

53 
NAN_INLINE
 
bo
 
	$IsJu
(cڡ {  
has_vue_
; 
	}
}

55 
NAN_INLINE
 
T
 
	$FromJu
() const {

56 #i
	`defed
(
V8_ENABLE_CHECKS
)

57 
	`as
(
	`IsJu
() && "FromJust is Nothing");

59  
vue_
;

60 
	}
}

62 
NAN_INLINE
 
T
 
	$FromMaybe
(cڡ 
T
& 
deu_vue
) const {

63  
has_vue_
 ? 
vue_
 : 
deu_vue
;

64 
	}
}

66 
NAN_INLINE
 
bo
 
	gݔ
==(cڡ 
Maybe
 &
h
) const {

67  (
IsJu
(=
h
.IsJust()) &&

68 (!
IsJu
(|| 
FromJu
(=
h
.FromJust());

71 
NAN_INLINE
 
bo
 
	gݔ
!=(cڡ 
Maybe
 &
h
) const {

72  !
ݔ
==(
h
);

75 
	give
:

76 
	$Maybe
(: 
	$has_vue_
(
l
{
	}
}

77 
exic
 
	$Maybe
(cڡ 
T
& 
t
: 
	`has_vue_
(
ue
), 
	$vue_
(
t
{
	}
}

78 
bo
 
	ghas_vue_
;

79 
T
 
	gvue_
;

81 
	gme
<
tyme
 
	gU
>

82 
nd
 
	gMaybe
<
	gU
> 
Nhg
();

83 
	gme
<
tyme
 
	gU
>

84 
nd
 
	gMaybe
<
	gU
> 
Ju
(cڡ 
U
& 
u
);

87 
	gme
<
tyme
 
	gT
>

88 
le
 
	gMaybe
<
	gT
> 
	$Nhg
() {

89  
Maybe
<
T
>();

90 
	}
}

92 
	gme
<
tyme
 
	gT
>

93 
le
 
	gMaybe
<
	gT
> 
	$Ju
(cڡ 
T
& 
t
) {

94  
Maybe
<
T
>(
t
);

95 
	}
}

97 
NAN_INLINE


98 
	gMaybeLol
<
	gv8
::
Sg
> 
ToDaSg
(
v8
::
Hd
<v8::
Vue
> 
v
) {

99  
MaybeLol
<
v8
::
Sg
>(
v
->
ToDaSg
());

102 
NAN_INLINE


103 
	gMaybeLol
<
	gv8
::
Ut32
> 
ToAayIndex
(
v8
::
Hd
<v8::
Vue
> 
v
) {

104  
MaybeLol
<
v8
::
Ut32
>(
v
->
ToAayIndex
());

107 
NAN_INLINE


108 
	gMaybe
<
	gbo
> 
Equs
(
v8
::
Hd
<v8::
Vue
> 
a
, v8::Hd<v8::Vue>(
b
)) {

109  
Ju
<
bo
>(
a
->
Equs
(
b
));

112 
NAN_INLINE


113 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Hd
<v8::
Funi
> 
h
) {

114  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
());

117 
NAN_INLINE


118 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(

119 
v8
::
Lol
<v8::
Funi
> 
h


120 , 
gc


121 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

122  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
(
gc
, 
gv
));

125 
NAN_INLINE


126 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Hd
<v8::
ObjeTeme
> 
h
) {

127  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
());

130 
NAN_INLINE


131 
	gMaybeLol
<
	gv8
::
Funi
> 
GFuni
(
v8
::
Hd
<v8::
FuniTeme
> 
t
) {

132  
MaybeLol
<
v8
::
Funi
>(
t
->
GFuni
());

135 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

136 
v8
::
Hd
<v8::
Obje
> 
obj


137 , 
v8
::
Hd
<v8::
Vue
> 
key


138 , 
v8
::
Hd
<v8::
Vue
> 
vue
) {

139  
Ju
<
bo
>(
obj
->
S
(
key
, 
vue
));

142 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

143 
v8
::
Hd
<v8::
Obje
> 
obj


144 , 
ut32_t
 
dex


145 , 
v8
::
Hd
<v8::
Vue
> 
vue
) {

146  
Ju
<
bo
>(
obj
->
S
(
dex
, 
vue
));

149 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
FS
(

150 
v8
::
Hd
<v8::
Obje
> 
obj


151 , 
v8
::
Hd
<v8::
Vue
> 
key


152 , 
v8
::
Hd
<v8::
Vue
> 
vue


153 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

154  
Ju
<
bo
>(
obj
->
FS
(
key
, 
vue
, 
ibs
));

157 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

158 
v8
::
Hd
<v8::
Obje
> 
obj


159 , 
v8
::
Hd
<v8::
Vue
> 
key
) {

160  
MaybeLol
<
v8
::
Vue
>(
obj
->
G
(
key
));

163 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

164 
v8
::
Hd
<v8::
Obje
> 
obj


165 , 
ut32_t
 
dex
) {

166  
	gMaybeLol
<
	gv8
::
Vue
>(
obj
->
G
(
dex
));

169 
NAN_INLINE
 
	gMaybe
<
	gv8
::
PrݔtyAribu
> 
GPrݔtyAribus
(

170 
v8
::
Hd
<v8::
Obje
> 
obj


171 , 
v8
::
Hd
<v8::
Vue
> 
key
) {

172  
Ju
<
v8
::
PrݔtyAribu
>(
obj
->
GPrݔtyAribus
(
key
));

175 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(

176 
v8
::
Hd
<v8::
Obje
> 
obj


177 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

178  
Ju
<
bo
>(
obj
->
Has
(
key
));

181 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(

182 
v8
::
Hd
<v8::
Obje
> 
obj


183 , 
ut32_t
 
dex
) {

184  
	gJu
<
	gbo
>(
	gobj
->
Has
(
dex
));

187 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
De
(

188 
v8
::
Hd
<v8::
Obje
> 
obj


189 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

190  
Ju
<
bo
>(
obj
->
De
(
key
));

193 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
De
(

194 
v8
::
Hd
<v8::
Obje
> 
obj


195 , 
ut32_t
 
dex
) {

196  
	gJu
<
	gbo
>(
	gobj
->
De
(
dex
));

199 
NAN_INLINE


200 
	gMaybeLol
<
	gv8
::
Aay
> 
GPrݔtyNames
(
v8
::
Hd
<v8::
Obje
> 
obj
) {

201  
MaybeLol
<
v8
::
Aay
>(
obj
->
GPrݔtyNames
());

204 
NAN_INLINE


205 
	gMaybeLol
<
	gv8
::
Aay
> 
GOwnPrݔtyNames
(
v8
::
Hd
<v8::
Obje
> 
obj
) {

206  
MaybeLol
<
v8
::
Aay
>(
obj
->
GOwnPrݔtyNames
());

209 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
SPry
(

210 
v8
::
Hd
<v8::
Obje
> 
obj


211 , 
v8
::
Hd
<v8::
Vue
> 
y
) {

212  
Ju
<
bo
>(
obj
->
SPry
(
y
));

215 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
> 
ObjeProToSg
(

216 
v8
::
Hd
<v8::
Obje
> 
obj
) {

217  
MaybeLol
<
v8
::
Sg
>(
obj
->
ObjeProToSg
());

220 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasOwnPrݔty
(

221 
v8
::
Hd
<v8::
Obje
> 
obj


222 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

223  
Ju
<
bo
>(
obj
->
HasOwnPrݔty
(
key
));

226 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedPrݔty
(

227 
v8
::
Hd
<v8::
Obje
> 
obj


228 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

229  
Ju
<
bo
>(
obj
->
HasRlNamedPrݔty
(
key
));

232 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlIndexedPrݔty
(

233 
v8
::
Hd
<v8::
Obje
> 
obj


234 , 
ut32_t
 
dex
) {

235  
	gJu
<
	gbo
>(
	gobj
->
HasRlIndexedPrݔty
(
dex
));

238 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedClbackPrݔty
(

239 
v8
::
Hd
<v8::
Obje
> 
obj


240 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

241  
Ju
<
bo
>(
obj
->
HasRlNamedClbackPrݔty
(
key
));

244 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔtyInPryCha
(

245 
v8
::
Hd
<v8::
Obje
> 
obj


246 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

247  
MaybeLol
<
v8
::
Vue
>(

248 
obj
->
GRlNamedPrݔtyInPryCha
(
key
));

251 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔty
(

252 
v8
::
Hd
<v8::
Obje
> 
obj


253 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

254  
MaybeLol
<
v8
::
Vue
>(
obj
->
GRlNamedPrݔty
(
key
));

257 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsFuni
(

258 
v8
::
Hd
<v8::
Obje
> 
obj


259 , 
v8
::
Hd
<v8::
Obje
> 
cv


260 , 
gc


261 , 
v8
::
Hd
<v8::
Vue
> 
gv
[]) {

262  
MaybeLol
<
v8
::
Vue
>(
obj
->
ClAsFuni
(
cv
, 
gc
, 
gv
));

265 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsCڡru
(

266 
v8
::
Hd
<v8::
Obje
> 
obj


267 , 
gc


268 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

269  
MaybeLol
<
v8
::
Vue
>(
obj
->
ClAsCڡru
(
gc
, 
gv
));

272 
NAN_INLINE


273 
	gMaybeLol
<
	gv8
::
Sg
> 
GSourLe
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

274  
MaybeLol
<
v8
::
Sg
>(
msg
->
GSourLe
());

277 
NAN_INLINE
 
	gMaybe
<> 
GLeNumb
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

278  
Ju
<>(
msg
->
GLeNumb
());

281 
NAN_INLINE
 
	gMaybe
<> 
GSCumn
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

282  
Ju
<>(
msg
->
GSCumn
());

285 
NAN_INLINE
 
	gMaybe
<> 
GEndCumn
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

286  
Ju
<>(
msg
->
GEndCumn
());

289 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
CleEmtAt
(

290 
v8
::
Hd
<v8::
Aay
> 
y


291 , 
ut32_t
 
dex
) {

292  
	gMaybeLol
<
	gv8
::
Obje
>(
y
->
CleEmtAt
(
dex
));

295 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

296 
v8
::
Lol
<v8::
Funi
> 
fun


297 , 
v8
::
Lol
<v8::
Obje
> 
cv


298 , 
gc


299 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

300  
MaybeLol
<
v8
::
Vue
>(
fun
->
Cl
(
cv
, 
gc
, 
gv
));

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_new.h

9 #ide
NAN_NEW_H_


10 
	#NAN_NEW_H_


	)

12 
mea
 
	gimp
 {

15 
	gme
 <
tyme
 
	gT
> 
	gv8
::
Lol
<
T
> 
To
(
v8
::Lol<v8::
Ieg
> 
i
);

17 
	gme
 <>

18 
le


19 
	gv8
::
Lol
<
v8
::
Ieg
>

20 
To
<
v8
::
Ieg
>(v8::
Lol
<v8::Ieg> 
i
) {

21  
N
::
To
<
v8
::
Ieg
>(
i
).
ToLolChecked
();

24 
	gme
 <>

25 
le


26 
	gv8
::
Lol
<
v8
::
I32
>

27 
To
<
v8
::
I32
>(v8::
Lol
<v8::
Ieg
> 
i
) {

28  
N
::
To
<
v8
::
I32
>(
i
).
ToLolChecked
();

31 
	gme
 <>

32 
le


33 
	gv8
::
Lol
<
v8
::
Ut32
>

34 
To
<
v8
::
Ut32
>(v8::
Lol
<v8::
Ieg
> 
i
) {

35  
N
::
To
<
v8
::
Ut32
>(
i
).
ToLolChecked
();

38 
	gme
 <
tyme
 
	gT
> 
	sFayBa
 {

39 
	gv8
::
	tLol
<
	tT
> 
	ttu_t
;

42 
	gme
 <
tyme
 
	gT
> 
	sMaybeFayBa
 {

43 
	gMaybeLol
<
	tT
> 
	ttu_t
;

46 
	gme
 <
tyme
 
	gT
> 
	gFay
;

48 
	gme
 <>

49 
	gFay
<
	gv8
::
Aay
> : 
FayBa
<
v8
::Array> {

50 
le
 
tu_t
 
New
();

51 
le
 
tu_t
 
New
(
ngth
);

54 
	gme
 <>

55 
	gFay
<
	gv8
::
Boޗn
> : 
FayBa
<
v8
::Boolean> {

56 
le
 
tu_t
 
New
(
bo
 
vue
);

59 
	gme
 <>

60 
	gFay
<
	gv8
::
BoޗnObje
> : 
FayBa
<
v8
::BooleanObject> {

61 
le
 
tu_t
 
New
(
bo
 
vue
);

64 
	gme
 <>

65 
	gFay
<
	gv8
::
Cڋxt
> : 
FayBa
<
v8
::Context> {

66 
le


67 
tu_t


68 
New

v8
::
ExnsiCfiguti
* 
exnsis
 = 
NULL


69 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm
 = v8::Local<v8::ObjectTemplate>()

70 , 
v8
::
Lol
<v8::
Vue
> 
obj
 = v8::Local<v8::Value>());

73 
	gme
 <>

74 
	gFay
<
	gv8
::
De
> : 
MaybeFayBa
<
v8
::Date> {

75 
le
 
tu_t
 
New
(
vue
);

78 
	gme
 <>

79 
	gFay
<
	gv8
::
Ex
> : 
FayBa
<
v8
::External> {

80 
le
 
tu_t
 
New
(*
vue
);

83 
	gme
 <>

84 
	gFay
<
	gv8
::
Funi
> : 
FayBa
<
v8
::Function> {

85 
le


86 
tu_t


87 
New

FuniClback
 
back


88 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>());

91 
	gme
 <>

92 
	gFay
<
	gv8
::
FuniTeme
> : 
FayBa
<
v8
::FunctionTemplate> {

93 
le


94 
tu_t


95 
New

FuniClback
 
back
 = 
NULL


96 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

97 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
 = v8::Local<v8::Signature>());

100 
	gme
 <>

101 
	gFay
<
	gv8
::
Numb
> : 
FayBa
<
v8
::Number> {

102 
le
 
tu_t
 
New
(
vue
);

105 
	gme
 <>

106 
	gFay
<
	gv8
::
NumbObje
> : 
FayBa
<
v8
::NumberObject> {

107 
le
 
tu_t
 
New
(
vue
);

110 
	gme
 <
tyme
 
	gT
>

111 
	gIegFay
 : 
FayBa
<
T
> {

112 
tyme
 
	tFayBa
<
	tT
>::
	ttu_t
eturn_t;

113 
le
 
tu_t
 
New
(
t32_t
 
vue
);

114 
le
 
tu_t
 
New
(
ut32_t
 
vue
);

117 
	gme
 <>

118 
	gFay
<
	gv8
::
Ieg
> : 
IegFay
<
v8
::Integer> {};

120 
	gme
 <>

121 
	gFay
<
	gv8
::
I32
> : 
IegFay
<
v8
::Int32> {};

123 
	gme
 <>

124 
	gFay
<
	gv8
::
Ut32
> : 
FayBa
<
v8
::Uint32> {

125 
le
 
tu_t
 
New
(
t32_t
 
vue
);

126 
le
 
tu_t
 
New
(
ut32_t
 
vue
);

129 
	gme
 <>

130 
	gFay
<
	gv8
::
Obje
> : 
FayBa
<
v8
::Object> {

131 
le
 
tu_t
 
New
();

134 
	gme
 <>

135 
	gFay
<
	gv8
::
ObjeTeme
> : 
FayBa
<
v8
::ObjectTemplate> {

136 
le
 
tu_t
 
New
();

139 
	gme
 <>

140 
	gFay
<
	gv8
::
RegExp
> : 
MaybeFayBa
<
v8
::RegExp> {

141 
le
 
tu_t
 
New
(

142 
v8
::
Lol
<v8::
Sg
> 
n
, v8::
RegExp
::
Fgs
 
ags
);

145 
	gme
 <>

146 
	gFay
<
	gv8
::
St
> : 
MaybeFayBa
<
v8
::Script> {

147 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour
);

148 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour


149 , 
v8
::
StOrig
 cڡ& 
ig
);

152 
	gme
 <>

153 
	gFay
<
	gv8
::
Sigtu
> : 
FayBa
<
v8
::Signature> {

154 
v8
::
	tLol
<
	tv8
::
	tFuniTeme
> 
	tFTH
;

155 
le
 
tu_t
 
New
(
FTH
 
iv
 = FTH());

158 
	gme
 <>

159 
	gFay
<
	gv8
::
Sg
> : 
MaybeFayBa
<
v8
::String> {

160 
le
 
tu_t
 
New
();

161 
le
 
tu_t
 
New
(cڡ *
vue
, 
ngth
 = -1);

162 
le
 
tu_t
 
New
(cڡ 
ut16_t
 *
vue
, 
ngth
 = -1);

163 
le
 
tu_t
 
New
(
d
::
rg
 cڡ& 
vue
);

165 
le
 
tu_t
 
New
(
v8
::
Sg
::
ExSgResour
 * 
vue
);

166 
le
 
tu_t
 
New
(
ExOBySgResour
 * 
vue
);

169 
	gme
 <>

170 
	gFay
<
	gv8
::
SgObje
> : 
FayBa
<
v8
::StringObject> {

171 
le
 
tu_t
 
New
(
v8
::
Lol
<v8::
Sg
> 
vue
);

176 #i(
NODE_MODULE_VERSION
 >= 12)

178 
mea
 
	gimp
 {

180 
	gme
 <>

181 
	gFay
<
	gv8
::
UnboundSt
> : 
MaybeFayBa
<
v8
::UnboundScript> {

182 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour
);

183 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour


184 , 
v8
::
StOrig
 cڡ& 
ig
);

189 
	~"n_imemti_12_l.h
"

193 
	~"n_imemti_e_12_l.h
"

199 
	gme
 <
tyme
 
	gT
>

200 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


201 
	$New
() {

202  
imp
::
Fay
<
T
>::
	`New
();

203 
	}
}

205 
	gme
 <
tyme
 
	gT
,ym
	gA0
>

206 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


207 
	$New
(
A0
 
g0
) {

208  
imp
::
Fay
<
T
>::
	`New
(
g0
);

209 
	}
}

211 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
>

212 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


213 
	$New
(
A0
 
g0
, 
A1
 
g1
) {

214  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
);

215 
	}
}

217 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
,ym
	gA2
>

218 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


219 
	$New
(
A0
 
g0
, 
A1
 
g1
, 
A2
 
g2
) {

220  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
, 
g2
);

221 
	}
}

223 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
,ym
	gA2
,ym
	gA3
>

224 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


225 
	$New
(
A0
 
g0
, 
A1
 
g1
, 
A2
 
g2
, 
A3
 
g3
) {

226  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
, 
g2
, 
g3
);

227 
	}
}

235 
	gme
 <
tyme
 
	gT
>

236 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


237 
New

FuniClback
 
back


238 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

239  
imp
::
Fay
<
T
>::
New
(
back
, 
da
);

243 
	gme
 <
tyme
 
	gT
,ym
	gA2
>

244 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


245 
New

FuniClback
 
back


246 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

247 , 
A2
 
a2
 = 
	$A2
()) {

248  
imp
::
Fay
<
T
>::
	`New
(
back
, 
da
, 
a2
);

249 
	}
}

253 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


254 
	gme
 <
tyme
 
	gT
> 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
);

257 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


258 
	gme
 <
tyme
 
	gT
,ym
	gM
>

259 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T, 
M
> cڡ& 
p
);

261 
	gme
 <
tyme
 
	gT
> 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T> cڡ& 
p
);

263 
	gme
 <
tyme
 
	gT
,ym
	gM
>

264 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
);

265 
	gme
 <
tyme
 
	gT
>

266 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
);

268 
le


269 
	gimp
::
Fay
<
v8
::
Boޗn
>::
tu_t


270 
	$New
(
bo
 
vue
) {

271  
New
<
v8
::
Boޗn
>(
vue
);

272 
	}
}

274 
le


275 
	gimp
::
Fay
<
v8
::
I32
>::
tu_t


276 
	$New
(
t32_t
 
vue
) {

277  
New
<
v8
::
I32
>(
vue
);

278 
	}
}

280 
le


281 
	gimp
::
Fay
<
v8
::
Ut32
>::
tu_t


282 
	$New
(
ut32_t
 
vue
) {

283  
New
<
v8
::
Ut32
>(
vue
);

284 
	}
}

286 
le


287 
	gimp
::
Fay
<
v8
::
Numb
>::
tu_t


288 
	$New
(
vue
) {

289  
New
<
v8
::
Numb
>(
vue
);

290 
	}
}

292 
le


293 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


294 
	$New
(
d
::
rg
 cڡ& 
vue
) {

295  
New
<
v8
::
Sg
>(
vue
);

296 
	}
}

298 
le


299 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


300 
	$New
(cڡ * 
vue
, 
ngth
) {

301  
New
<
v8
::
Sg
>(
vue
, 
ngth
);

302 
	}
}

304 
le


305 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


306 
	$New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

307  
New
<
v8
::
Sg
>(
vue
, 
ngth
);

308 
	}
}

310 
le


311 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


312 
	$New
(cڡ * 
vue
) {

313  
New
<
v8
::
Sg
>(
vue
);

314 
	}
}

316 
le


317 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


318 
	$New
(cڡ 
ut16_t
 * 
vue
) {

319  
New
<
v8
::
Sg
>(
vue
);

320 
	}
}

322 
le


323 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


324 
	$New
(
v8
::
Sg
::
ExSgResour
 * 
vue
) {

325  
New
<
v8
::
Sg
>(
vue
);

326 
	}
}

328 
le


329 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


330 
	$New
(
ExOBySgResour
 * 
vue
) {

331  
New
<
v8
::
Sg
>(
vue
);

332 
	}
}

334 
le


335 
	gimp
::
Fay
<
v8
::
RegExp
>::
tu_t


336 
New
(
v8
::
Lol
<v8::
Sg
> 
n
, v8::
RegExp
::
Fgs
 
ags
) {

337  
New
<
v8
::
RegExp
>(
n
, 
	gags
);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_object_wrap.h

9 #ide
NAN_OBJECT_WRAP_H_


10 
	#NAN_OBJECT_WRAP_H_


	)

12 as
	cObjeWp
 {

13 
	mpublic
:

14 
	$ObjeWp
() {

15 
fs_
 = 0;

19 
vtu
 ~
	$ObjeWp
() {

20 i(
	`rsit
().
	`IsEmy
()) {

24 
	`as
(
	`rsit
().
	`IsNrDth
());

25 
	`rsit
().
	`CˬWk
();

26 
	`rsit
().
	`Ret
();

27 
	}
}

30 
	gme
 <
ass
 
	gT
>

31 
le
 
T
* 
Unwp
(
v8
::
Lol
<v8::
Obje
> 
obje
) {

32 
as
(!
obje
.
IsEmy
());

33 
as
(
obje
->
IlFldCou
() > 0);

36 * 
	gr
 = 
GIlFldPor
(
obje
, 0);

37 
ObjeWp
* 
	gwp
 = 
ic_
<ObjeWp*>(
r
);

38  
	gic_
<
	gT
*>(
	gwp
);

42 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$hd
() {

43  
	`New
(
	`rsit
());

44 
	}
}

47 
le
 
	gPsit
<
	gv8
::
Obje
>& 
	$rsit
() {

48  
hd_
;

49 
	}
}

52 
	geed
:

53 
le
 
Wp
(
v8
::
Lol
<v8::
Obje
> 
obje
) {

54 
as
(
rsit
().
IsEmy
());

55 
as
(
obje
->
IlFldCou
() > 0);

56 
SIlFldPor
(
obje
, 0, 
this
);

57 
rsit
().
Ret
(
obje
);

58 
MakeWk
();

61 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

62 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

64 
le
 
	$MakeWk
() {

65 
	`rsit
().
v8
::
PsitBa
<v8::
Obje
>::
	`SWk
(

66 
this
, 
WkClback
, 
v8
::
WkClbackTy
::
kPam
);

67 
	`rsit
().
	`MkInddt
();

68 
	}
}

70 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


72 
le
 
	$MakeWk
() {

73 
	`rsit
().
v8
::
PsitBa
<v8::
Obje
>::
	`SWk
(
this
, 
WkClback
);

74 
	`rsit
().
	`MkInddt
();

75 
	}
}

79 
le
 
	$MakeWk
() {

80 
	`rsit
().
rsit
.
	`MakeWk
(
this
, 
WkClback
);

81 
	`rsit
().
	`MkInddt
();

82 
	}
}

90 
vtu
 
	$Ref
() {

91 
	`as
(!
	`rsit
().
	`IsEmy
());

92 
	`rsit
().
	`CˬWk
();

93 
fs_
++;

94 
	}
}

105 
vtu
 
	$Uef
() {

106 
	`as
(!
	`rsit
().
	`IsEmy
());

107 
	`as
(!
	`rsit
().
	`IsWk
());

108 
	`as
(
fs_
 > 0);

109 i(--
fs_
 == 0)

110 
	`MakeWk
();

111 
	}
}

113 
	gfs_
;

115 
	give
:

116 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
ObjeWp
)

117 #i
	`defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

118 (
V8_MAJOR_VERSION
 =4 && 
	`defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

121 
	`WkClback
(
v8
::
WkClbackInfo
<
ObjeWp
> cڡ& 
fo
) {

122 
ObjeWp
* 
wp
 = 
fo
.
	`GPam
();

123 
	`as
(
wp
->
fs_
 == 0);

124 
	`as
(
wp
->
hd_
.
	`IsNrDth
());

125 
wp
->
hd_
.
	`Ret
();

126 
de
 
wp
;

127 
	}
}

129 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


132 
WkClback
(
v8
::
WkClbackDa
<v8::
Obje
, 
ObjeWp
> cڡ& 
da
) {

133 
ObjeWp
* 
	gwp
 = 
da
.
GPam
();

134 
as
(
wp
->
fs_
 == 0);

135 
as
(
wp
->
hd_
.
IsNrDth
());

136 
	gwp
->
	ghd_
.
Ret
();

137 
de
 
	gwp
;

142 
WkClback
(
v8
::
Psit
<v8::
Vue
> 
vue
, *
da
) {

143 
ObjeWp
 *
	gwp
 = 
ic_
<ObjeWp*>(
da
);

144 
as
(
wp
->
fs_
 == 0);

145 
as
(
wp
->
hd_
.
IsNrDth
());

146 
	gwp
->
	ghd_
.
Ret
();

147 
de
 
	gwp
;

151 
	gPsit
<
	gv8
::
Obje
> 
hd_
;

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_persistent_12_inl.h

9 #ide
NAN_PERSISTENT_12_INL_H_


10 
	#NAN_PERSISTENT_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
,ym
	gM
> 
ass
 
	gPsit
 :

13 
public
 
v8
::
Psit
<
T
, 
	gM
> {

14 
	gpublic
:

15 
NAN_INLINE
 
Psit
(: 
v8
::Psit<
T
, 
	gM
>() {}

17 
	gme
<
tyme
 
	gS
> 
NAN_INLINE
 
Psit
(
v8
::
Lol
<
S
> 
th
) :

18 
v8
::
Psit
<
T
, 
	gM
>(
	gv8
::
Isީe
::
GCut
(), 
	gth
) {}

20 
	gme
<
tyme
 
	gS
,ym
	gM2
>

21 
NAN_INLINE
 
Psit
(cڡ 
v8
::Psit<
S
, 
M2
> &
th
) :

22 
v8
::
Psit
<
T
, 
	gM2
>(
	gv8
::
Isީe
::
GCut
(), 
	gth
) {}

24 
NAN_INLINE
 
Ret
({ 
	gv8
::
PsitBa
<
T
>::Reset(); }

26 
	gme
 <
tyme
 
	gS
>

27 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

28 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

31 
	gme
 <
tyme
 
	gS
>

32 
NAN_INLINE
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

33 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

36 
	gme
<
tyme
 
	gP
>

37 
NAN_INLINE
 
SWk
(

38 
P
 *
m


39 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


40 , 
WkClbackTy
 
ty
);

42 
	give
:

43 
NAN_INLINE
 
T
 *
ݔ
*(cڡ {  *
PsitBa
<T>::
rsit
; }

45 
	gme
<
tyme
 
	gS
,ym
	gM2
>

46 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M2
> &
th
) {

47 
TYPE_CHECK
(
T
, 
S
);

49 
	gthis
->
Ret
();

51 i(!
	gth
.
IsEmy
()) {

52 
	gthis
->
Ret
(
th
);

53 
	gM
::
Cy
(
th
, 
this
);

58 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

59 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

60 
me
<
tyme
 
T
>

61 
ass
 
Glob
 : 
public
 
v8
::Glob<
T
> {

62 
public
:

63 
NAN_INLINE
 
Glob
(: 
v8
::Glob<
T
>() {}

65 
me
<
tyme
 
S
> 
NAN_INLINE
 
Glob
(
v8
::
Lol
<S> 
th
) :

66 
v8
::
Glob
<
T
>(v8::
Isީe
::
GCut
(), 
th
) {}

68 
me
<
tyme
 
S
>

69 
NAN_INLINE
 
Glob
(cڡ 
v8
::
PsitBa
<
S
> &
th
) :

70 
v8
::
Glob
<
S
>(v8::
Isީe
::
GCut
(), 
th
) {}

72 
NAN_INLINE
 
Ret
({ 
v8
::
PsitBa
<
T
>::Reset(); }

74 
	gme
 <
tyme
 
	gS
>

75 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

76 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

79 
	gme
 <
tyme
 
	gS
>

80 
NAN_INLINE
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

81 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

84 
	gme
<
tyme
 
	gP
>

85 
NAN_INLINE
 
SWk
(

86 
P
 *
m


87 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


88 , 
WkClbackTy
 
ty
) {

89 
	gt_
<
	gPsit
<
	gT
>*>(
	gthis
)->
SWk
(

90 
m
, 
back
, 
ty
);

94 
	gme
<
tyme
 
	gT
>

95 
ass
 
	gGlob
 : 
public
 
v8
::
UniquePsit
<
T
> {

96 
public
:

97 
NAN_INLINE
 
Glob
(: 
v8
::
UniquePsit
<
T
>() {}

99 
me
<
tyme
 
S
> 
NAN_INLINE
 
Glob
(
v8
::
Lol
<S> 
th
) :

100 
v8
::
UniquePsit
<
T
>(v8::
Isީe
::
GCut
(), 
	gth
) {}

102 
	gme
<
tyme
 
	gS
>

103 
NAN_INLINE
 
Glob
(cڡ 
v8
::
PsitBa
<
S
> &
th
) :

104 
v8
::
UniquePsit
<
S
>(v8::
Isީe
::
GCut
(), 
	gth
) {}

106 
NAN_INLINE
 
Ret
({ 
	gv8
::
PsitBa
<
T
>::Reset(); }

108 
	gme
 <
tyme
 
	gS
>

109 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

110 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

113 
	gme
 <
tyme
 
	gS
>

114 
NAN_INLINE
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

115 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

118 
	gme
<
tyme
 
	gP
>

119 
NAN_INLINE
 
SWk
(

120 
P
 *
m


121 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


122 , 
WkClbackTy
 
ty
) {

123 
	gt_
<
	gPsit
<
	gT
>*>(
	gthis
)->
SWk
(

124 
m
, 
back
, 
ty
);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_persistent_pre_12_inl.h

9 #ide
NAN_PERSISTENT_PRE_12_INL_H_


10 
	#NAN_PERSISTENT_PRE_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cPsitBa
 {

14 
	mv8
::
Psit
<
T
> 
rsit
;

15 
	mme
<
tyme
 
	mU
>

16 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
PsitBa
<U> &
p
);

17 
	mme
<
tyme
 
	mU
,ym
	mM
>

18 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
Psit
<U, 
M
> &
p
);

19 
	mme
<
tyme
 
	mU
>

20 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
Glob
<U> &
p
);

21 
	mme
<
tyme
 
	mS
> 
nd
 
ass
 
	mRuVue
;

23 
	mpublic
:

24 
NAN_INLINE
 
	$PsitBa
() :

25 
	$rsit
() {}

27 
NAN_INLINE
 
	$Ret
() {

28 
rsit
.
	`Dio
();

29 
rsit
.
	`Cˬ
();

30 
	}
}

32 
	gme
<
tyme
 
	gS
>

33 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

34 
TYPE_CHECK
(
T
, 
S
);

36 i(!
	grsit
.
IsEmy
()) {

37 
	grsit
.
Dio
();

40 i(
	gh
.
IsEmy
()) {

41 
	grsit
.
Cˬ
();

43 
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
h
);

47 
	gme
<
tyme
 
	gS
>

48 
NAN_INLINE
 
Ret
(cڡ 
PsitBa
<
S
> &
h
) {

49 
TYPE_CHECK
(
T
, 
S
);

51 i(!
	grsit
.
IsEmy
()) {

52 
	grsit
.
Dio
();

55 i(
	gh
.
IsEmy
()) {

56 
	grsit
.
Cˬ
();

58 
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
h
.
rsit
);

62 
NAN_INLINE
 
bo
 
	$IsEmy
(cڡ {  
rsit
.
	`IsEmy
(); 
	}
}

64 
NAN_INLINE
 
	$Emy
({ 
rsit
.
	`Cˬ
(); 
	}
}

66 
	gme
<
tyme
 
	gS
>

67 
NAN_INLINE
 
bo
 
	gݔ
==(cڡ 
PsitBa
<
S
> &
th
) {

68  
this
->
rsit
 =
th
.persistent;

71 
	gme
<
tyme
 
	gS
>

72 
NAN_INLINE
 
bo
 
	gݔ
==(cڡ 
v8
::
Lol
<
S
> &
th
) {

73  
this
->
rsit
 =
th
;

76 
	gme
<
tyme
 
	gS
>

77 
NAN_INLINE
 
bo
 
	gݔ
!=(cڡ 
PsitBa
<
S
> &
th
) {

78  !
ݔ
==(
th
);

81 
	gme
<
tyme
 
	gS
>

82 
NAN_INLINE
 
bo
 
	gݔ
!=(cڡ 
v8
::
Lol
<
S
> &
th
) {

83  !
ݔ
==(
th
);

86 
	gme
<
tyme
 
	gP
>

87 
NAN_INLINE
 
SWk
(

88 
P
 *
m


89 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


90 , 
WkClbackTy
 
ty
);

92 
NAN_INLINE
 
	$CˬWk
({ 
rsit
.
	`CˬWk
(); 
	}
}

94 
NAN_INLINE
 
	$MkInddt
({ 
rsit
.
	`MkInddt
(); 
	}
}

96 
NAN_INLINE
 
bo
 
	$IsInddt
(cڡ {  
rsit
.
	`IsInddt
(); 
	}
}

98 
NAN_INLINE
 
bo
 
	$IsNrDth
(cڡ {  
rsit
.
	`IsNrDth
(); 
	}
}

100 
NAN_INLINE
 
bo
 
	$IsWk
(cڡ {  
rsit
.
	`IsWk
(); 
	}
}

102 
	give
:

103 
NAN_INLINE
 
exic
 
PsitBa
(
v8
::
Psit
<
T
> 
th
) :

104 
	$rsit
(
th
{ 
	}
}

105 
NAN_INLINE
 
exic
 
	$PsitBa
(
T
 *
v
: 
	$rsit
(
v
{
	}
}

106 
me
<
tyme
 
S
,ym
	gM
> 
nd
 
ass
 
	gPsit
;

107 
	gme
<
tyme
 
	gS
> 
nd
 
ass
 
	gGlob
;

108 
nd
 
ass
 
	gObjeWp
;

111 
	gme
<
tyme
 
	gT
>

112 as
	cNCyabPsitTs
 {

113 
	mpublic
:

114 
Psit
<
	tT
, 
	tNCyabPsitTs
<T> >

115 
	tNCyabPsit
;

116 cڡ 
bo
 
	mkRetInDeru
 = 
l
;

117 
	mme
<
tyme
 
	mS
,ym
	mM
>

118 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M
> &
sour
,

119 
NCyabPsit
 *
de
) {

120 
	mUncompab
<
	mv8
::
Obje
>();

123 
	gme
<
tyme
 
	gO
> 
NAN_INLINE
 
	$Uncompab
() {

124 
	`TYPE_CHECK
(
O
, 
v8
::
Primive
);

125 
	}
}

128 
	gme
<
tyme
 
	gT
>

129 
	sCyabPsitTs
 {

130 
	mPsit
<
	tT
, 
	tCyabPsitTs
<T> > 
	tCyabPsit
;

131 cڡ 
bo
 
	mkRetInDeru
 = 
ue
;

132 
	mme
<
tyme
 
	mS
,ym
	mM
>

133 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M
> &
sour
,

134 
CyabPsit
 *
de
) {}

137 
	gme
<
tyme
 
	gT
,ym
	gM
> 
ass
 
	gPsit
 :

138 
public
 
PsitBa
<
T
> {

139 
public
:

140 
NAN_INLINE
 
Psit
() {}

142 
me
<
tyme
 
S
> 
NAN_INLINE
 
Psit
(
v8
::
Hd
<S> 
th
)

143 : 
PsitBa
<
T
>(
v8
::
Psit
<T>::
New
(
th
)) {

144 
TYPE_CHECK
(
T
, 
S
);

147 
NAN_INLINE
 
Psit
(cڡ Psi&
th
: 
PsitBa
<
T
>() {

148 
Cy
(
th
);

151 
	gme
<
tyme
 
	gS
,ym
	gM2
>

152 
NAN_INLINE
 
Psit
(cڡ Psit<
S
, 
M2
> &
th
) :

153 
PsitBa
<
T
>() {

154 
Cy
(
th
);

157 
NAN_INLINE
 
	gPsit
 &
	gݔ
=(cڡ 
Psit
 &
th
) {

158 
Cy
(
th
);

159  *
	gthis
;

162 
	gme
 <
ass
 
	gS
, cs
	gM2
>

163 
NAN_INLINE
 
	gPsit
 &
	gݔ
=(cڡ 
Psit
<
S
, 
	gM2
> &
	gth
) {

164 
Cy
(
th
);

165  *
	gthis
;

168 
	gNAN_INLINE
 ~
Psit
() {

169 i(
	gM
::
kRetInDeru

this
->
Ret
();

172 
	give
:

173 
NAN_INLINE
 
T
 *
ݔ
*(cڡ {  *
PsitBa
<T>::
rsit
; }

175 
	gme
<
tyme
 
	gS
,ym
	gM2
>

176 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M2
> &
th
) {

177 
TYPE_CHECK
(
T
, 
S
);

179 
	gthis
->
Ret
();

181 i(!
	gth
.
IsEmy
()) {

182 
	gthis
->
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
th
.
rsit
);

183 
	gM
::
Cy
(
th
, 
this
);

188 
	gme
<
tyme
 
	gT
>

189 
ass
 
	gGlob
 : 
public
 
PsitBa
<
T
> {

190 
	sRVue
 {

191 
NAN_INLINE
 
exic
 
RVue
(
Glob
* 
obj
: 
obje
(obj) {}

192 
Glob
* 
obje
;

195 
	gpublic
:

196 
NAN_INLINE
 
Glob
(: 
PsitBa
<
T
>(0) { }

198 
me
 <
tyme
 
S
>

199 
NAN_INLINE
 
Glob
(
v8
::
Lol
<
S
> 
th
)

200 : 
PsitBa
<
T
>(
v8
::
Psit
<T>::
New
(
th
)) {

201 
TYPE_CHECK
(
T
, 
S
);

204 
	gme
 <
tyme
 
	gS
>

205 
NAN_INLINE
 
Glob
(cڡ 
PsitBa
<
S
> &
th
)

206 : 
PsitBa
<
T
>(
th
) {

207 
TYPE_CHECK
(
T
, 
S
);

212 
NAN_INLINE
 
Glob
(
RVue
 
rvue
)

213 : 
PsitBa
<
T
>(
rvue
.
obje
->
rsit
) {

214 
rvue
.
obje
->
Ret
();

216 
	gNAN_INLINE
 ~
Glob
({ 
	gthis
->
Ret
(); }

220 
	gme
<
tyme
 
	gS
>

221 
NAN_INLINE
 
	gGlob
 &
	gݔ
=(
Glob
<
S
> 
rhs
) {

222 
TYPE_CHECK
(
T
, 
S
);

223 
	gthis
->
Ret
(
rhs
.
rsit
);

224 
	grhs
.
Ret
();

225  *
	gthis
;

230 
NAN_INLINE
 
ݔ
 
RVue
({  RVue(
this
); }

234 
Glob
 
Pass
({  Glob(
RVue
(
this
)); }

236 
	give
:

237 
Glob
(Global &);

238 
	gݔ
=(
Glob
 &);

239 
	gme
<
tyme
 
	gS
> 
nd
 
ass
 
	gRuVue
;

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_string_bytes.h

22 #ide
NAN_STRING_BYTES_H_


23 
	#NAN_STRING_BYTES_H_


	)

27 
mea
 
	gimp
 {

29 
usg
 
	gv8
::
Lol
;

30 
usg
 
	gv8
::
Obje
;

31 
usg
 
	gv8
::
Sg
;

32 
usg
 
	gv8
::
Vue
;

37 
	#ba64_coded_size
(
size
((siz+ 2 - ((siz+ 2% 3)/ 3 * 4)

	)

43 
bo
 
cڏs_n_ascii_ow
(cڡ * 
buf
, 
size_t
 
n
) {

44 
size_t
 
	gi
 = 0; i < 
	gn
; ++i) {

45 i(
	gbuf
[
i
] & 0x80 
	gue
;

47  
	gl
;

51 
bo
 
cڏs_n_ascii
(cڡ * 
c
, 
size_t
 
n
) {

52 i(
	gn
 < 16) {

53  
cڏs_n_ascii_ow
(
c
, 
n
);

56 cڡ 
	gbys_r_wd
 = (*);

57 cڡ 
	gign_mask
 = 
bys_r_wd
 - 1;

58 cڡ 
	guligd
 = 
t_
<
u_t
>(
c
& 
ign_mask
;

60 i(
	guligd
 > 0) {

61 cڡ 
	gn
 = 
bys_r_wd
 - 
uligd
;

62 i(
cڏs_n_ascii_ow
(
c
, 
n
) 
	gue
;

63 
	gc
 +
n
;

64 
	gn
 -
n
;

68 #i
defed
(
__x86_64__
|| defed(
_WIN64
)

69 cڡ 
u_t
 
	gmask
 = 0x8080808080808080ll;

71 cڡ 
u_t
 
	gmask
 = 0x80808080l;

74 cڡ 
u_t
* 
	gcw
 = 
t_
<cڡ u_t*>(
c
);

76 
size_t
 
	gi
 = 0, 
	gn
 = 
n
 / 
bys_r_wd
; i <; ++i) {

77 i(
	gcw
[
i
] & 
	gmask
 
	gue
;

80 cڡ 
	gmad
 = 
n
 & 
ign_mask
;

81 i(
	gmad
 > 0) {

82 cڡ 
size_t
 
	gofft
 = 
n
 - 
mad
;

83 i(
cڏs_n_ascii_ow
(
c
 + 
offt
, 
mad
) 
	gue
;

86  
	gl
;

90 
f_ascii_ow
(cڡ * 
c
, * 
d
, 
size_t
 
n
) {

91 
size_t
 
	gi
 = 0; i < 
	gn
; ++i) {

92 
	gd
[
i
] = 
c
[i] & 0x7f;

97 
f_ascii
(cڡ * 
c
, * 
d
, 
size_t
 
n
) {

98 i(
	gn
 < 16) {

99 
f_ascii_ow
(
c
, 
d
, 
n
);

103 cڡ 
	gbys_r_wd
 = (*);

104 cڡ 
	gign_mask
 = 
bys_r_wd
 - 1;

105 cڡ 
	gc_ulign
 = 
t_
<
u_t
>(
c
& 
ign_mask
;

106 cڡ 
	gd_ulign
 = 
t_
<
u_t
>(
d
& 
ign_mask
;

108 i(
	gc_ulign
 > 0) {

109 i(
	gc_ulign
 =
d_ulign
) {

110 cڡ 
ulign
 = 
bys_r_wd
 - 
c_ulign
;

111 
f_ascii_ow
(
c
, 
d
, 
ulign
);

112 
	gc
 +
ulign
;

113 
	gd
 +
ulign
;

114 
	gn
 -
c_ulign
;

116 
f_ascii_ow
(
c
, 
d
, 
n
);

121 #i
defed
(
__x86_64__
|| defed(
_WIN64
)

122 cڡ 
u_t
 
	gmask
 = ~0x8080808080808080ll;

124 cڡ 
u_t
 
	gmask
 = ~0x80808080l;

127 cڡ 
u_t
* 
	gcw
 = 
t_
<cڡ u_t*>(
c
);

128 
u_t
* 
	gdw
 = 
t_
<u_t*>(
d
);

130 
size_t
 
	gi
 = 0, 
	gn
 = 
n
 / 
bys_r_wd
; i <; ++i) {

131 
	gdw
[
i
] = 
cw
[i] & 
mask
;

134 cڡ 
	gmad
 = 
n
 & 
ign_mask
;

135 i(
	gmad
 > 0) {

136 cڡ 
size_t
 
	gofft
 = 
n
 - 
mad
;

137 
f_ascii_ow
(
c
 + 
offt
, 
d
 + offt, 
mad
);

142 
size_t
 
ba64_code
(cڡ * 
c
,

143 
size_t
 

,

144 * 
d
,

145 
size_t
 
dn
) {

147 
as
(
dn
 >
ba64_coded_size
(

) &&

150 
	gdn
 = 
ba64_coded_size
(

);

152 
	ga
;

153 
	gb
;

154 
	gc
;

155 
	gi
;

156 
	gk
;

157 
	gn
;

159 cڡ 
	gb
[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

163 
	gi
 = 0;

164 
	gk
 = 0;

165 
	gn
 = 

 / 3 * 3;

167 
	gi
 < 
	gn
) {

168 
	ga
 = 
c
[
i
 + 0] & 0xff;

169 
	gb
 = 
c
[
i
 + 1] & 0xff;

170 
	gc
 = 
c
[
i
 + 2] & 0xff;

172 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

173 
	gd
[
k
 + 1] = 
b
[((
a
 & 3<< 4| (
b
 >> 4)];

174 
	gd
[
k
 + 2] = 
b
[((
b
 & 0x0f<< 2| (
c
 >> 6)];

175 
	gd
[
k
 + 3] = 
b
[
c
 & 0x3f];

177 
	gi
 += 3;

178 
	gk
 += 4;

181 i(
	gn
 !

) {

182 

 - 
n
) {

184 
a
 = 
c
[
i
 + 0] & 0xff;

185 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

186 
	gd
[
k
 + 1] = 
b
[(
a
 & 3) << 4];

187 
	gd
[
k
 + 2] = '=';

188 
	gd
[
k
 + 3] = '=';

192 
a
 = 
c
[
i
 + 0] & 0xff;

193 
	gb
 = 
c
[
i
 + 1] & 0xff;

194 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

195 
	gd
[
k
 + 1] = 
b
[((
a
 & 3<< 4| (
b
 >> 4)];

196 
	gd
[
k
 + 2] = 
b
[(
b
 & 0x0f) << 2];

197 
	gd
[
k
 + 3] = '=';

202  
	gdn
;

206 
size_t
 
hex_code
(cڡ * 
c
, size_

, * 
d
, size_
dn
) {

208 
as
(
dn
 >

 * 2 &&

211 
	gdn
 = 

 * 2;

212 
ut32_t
 
	gi
 = 0, 
	gk
 = 0; k < 
	gdn
; i += 1, k += 2) {

213 cڡ 
hex
[] = "0123456789abcdef";

214 
ut8_t
 
	gv
 = 
ic_
<ut8_t>(
c
[
i
]);

215 
	gd
[
k
 + 0] = 
hex
[
v
 >> 4];

216 
	gd
[
k
 + 1] = 
hex
[
v
 & 15];

219  
	gdn
;

224 
	gLol
<
	gVue
> 
Encode
(cڡ * 
buf
,

225 
size_t
 
bu
,

226 
Encodg
 
codg
) {

227 
as
(
bu
 <
node
::
Bufr
::
kMaxLgth
);

228 i(!
	gbu
 && 
	gcodg
 !
BUFFER
)

229  
New
("").
ToLolChecked
();

231 
	gLol
<
	gSg
> 
	gv
;

232 
	gcodg
) {

233 
	gBUFFER
:

234  
CyBufr
(
buf
, 
bu
).
ToLolChecked
();

236 
	gASCII
:

237 i(
cڏs_n_ascii
(
buf
, 
bu
)) {

238 * 
	gout
 = 
w
 [
bu
];

239 
f_ascii
(
buf
, 
out
, 
bu
);

240 
	gv
 = 
New
<
Sg
>(
out
, 
	gbu
).
ToLolChecked
();

241 
	gde
[] 
	gout
;

243 
	gv
 = 
New
<
Sg
>(
buf
, 
	gbu
).
ToLolChecked
();

247 
	gUTF8
:

248 
v
 = 
New
<
Sg
>(
buf
, 
	gbu
).
ToLolChecked
();

251 
	gBINARY
: {

253 cڡ *
cbuf
 = 
t_
<cڡ *>(
buf
);

254 
ut16_t
 * 
	gtwobybuf
 = 
w
 ut16_t[
bu
];

255 
size_t
 
	gi
 = 0; i < 
	gbu
; i++) {

257 
	gtwobybuf
[
i
] = 
cbuf
[i];

259 
	gv
 = 
New
<
Sg
>(
twobybuf
, 
	gbu
).
ToLolChecked
();

260 
	gde
[] 
	gtwobybuf
;

264 
	gBASE64
: {

265 
size_t
 
dn
 = 
ba64_coded_size
(
bu
);

266 * 
	gd
 = 
w
 [
dn
];

268 
size_t
 
	gwrn
 = 
ba64_code
(
buf
, 
bu
, 
d
, 
dn
);

269 
as
(
wrn
 =
dn
);

271 
	gv
 = 
New
<
Sg
>(
d
, 
	gdn
).
ToLolChecked
();

272 
	gde
[] 
	gd
;

276 
	gUCS2
: {

277 cڡ 
ut16_t
* 
da
 = 
t_
<cڡ ut16_t*>(
buf
);

278 
	gv
 = 
New
<
Sg
>(
da
, 
	gbu
 / 2).
ToLolChecked
();

282 
	gHEX
: {

283 
size_t
 
dn
 = 
bu
 * 2;

284 * 
	gd
 = 
w
 [
dn
];

285 
size_t
 
	gwrn
 = 
hex_code
(
buf
, 
bu
, 
d
, 
dn
);

286 
as
(
wrn
 =
dn
);

288 
	gv
 = 
New
<
Sg
>(
d
, 
	gdn
).
ToLolChecked
();

289 
	gde
[] 
	gd
;

294 
as
(0 && "unknownncoding");

298  
	gv
;

301 #unde
ba64_coded_size


	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_typedarray_contents.h

9 #ide
NAN_TYPEDARRAY_CONTENTS_H_


10 
	#NAN_TYPEDARRAY_CONTENTS_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cTydAayCڋs
 {

14 
	mpublic
:

15 
NAN_INLINE
 
exic
 
TydAayCڋs
(
v8
::
Lol
<v8::
Vue
> 
om
) :

16 
ngth_
(0), 
	$da_
(
NULL
) {

18 
size_t
 
ngth
 = 0;

19 * 
da
 = 
NULL
;

21 #i
	`defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

22 (
V8_MAJOR_VERSION
 =4 && 
	`defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

24 i(
om
->
	`IsAayBufrVw
()) {

25 
v8
::
Lol
<v8::
AayBufrVw
> 
y
 =

26 
v8
::
Lol
<v8::
AayBufrVw
>::
	`Ca
(
om
);

28 cڡ 
size_t
 
by_ngth
 = 
y
->
	`ByLgth
();

29 cڡ 
rdiff_t
 
by_offt
 = 
y
->
	`ByOfft
();

30 
v8
::
Lol
<v8::
AayBufr
> 
bufr
 = 
y
->
	`Bufr
();

32 
ngth
 = 
by_ngth
 / (
T
);

33 
da
 = 
ic_
<*>(
bufr
->
	`GCڋs
().
	`Da
()+ 
by_offt
;

38 i(
om
->
	`IsObje
(&& !om->
	`IsNu
()) {

39 
v8
::
Lol
<v8::
Obje
> 
y
 = v8::Lol<v8::Obje>::
	`Ca
(
om
);

41 
MaybeLol
<
v8
::
Vue
> 
bufr
 = 
	`G
(
y
,

42 
New
<
v8
::
Sg
>("bufr").
	`ToLolChecked
());

43 
MaybeLol
<
v8
::
Vue
> 
by_ngth
 = 
	`G
(
y
,

44 
New
<
v8
::
Sg
>("byLgth").
	`ToLolChecked
());

45 
MaybeLol
<
v8
::
Vue
> 
by_offt
 = 
	`G
(
y
,

46 
New
<
v8
::
Sg
>("byOfft").
	`ToLolChecked
());

48 i(!
bufr
.
	`IsEmy
() &&

49 !
by_ngth
.
	`IsEmy
(&& by_ngth.
	`ToLolChecked
()->
	`IsUt32
() &&

50 !
by_offt
.
	`IsEmy
(&& by_offt.
	`ToLolChecked
()->
	`IsUt32
()) {

51 
da
 = 
y
->
	`GIndexedPrݔtsExAayDa
();

52 if(
da
) {

53 
ngth
 = 
by_ngth
.
	`ToLolChecked
()->
	`Ut32Vue
(/ (
T
);

60 #i
	`defed
(
_MSC_VER
&& _MSC_VER >1900 || 
__lulus
 >= 201103L

61 
	`as
(
t_
<
u_t
>(
da
% 
	`ignof
 (
T
) == 0);

62 #i
	`defed
(
_MSC_VER
&& _MSC_VER >1600 || defed(
__GNUC__
)

63 
	`as
(
t_
<
u_t
>(
da
% 
	`__ignof
(
T
) == 0);

65 
	`as
(
t_
<
u_t
>(
da
%  (
T
) == 0);

68 
ngth_
 = 
ngth
;

69 
da_
 = 
ic_
<
T
*>(
da
);

72 
NAN_INLINE
 
size_t
 
	$ngth
(cڡ {  
ngth_
; 
	}
}

73 
NAN_INLINE
 
T
* 
	gݔ
*({  
	gda_
; }

74 
NAN_INLINE
 cڡ 
T
* 
	gݔ
*(cڡ {  
	gda_
; }

76 
	give
:

77 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
TydAayCڋs
)

80 *
ݔ
 
	`w
(
size_t
 
size
);

81 
ݔ
 
	`de
(*, 
size_t
);

83 
size_t
 
ngth_
;

84 
T
* 
da_
;

85 
	}
};

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_weak.h

9 #ide
NAN_WEAK_H_


10 
	#NAN_WEAK_H_


	)

12 cڡ 
	gkIlFldsInWkClback
 = 2;

13 cڡ 
	gkNoIlFldIndex
 = -1;

15 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

16 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

17 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

18 
v8
::
WkClbackInfo
<WkClbackInfo<
T
> > cڡ&

	)

19 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

20 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

21 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

22 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

23 #i
NODE_MODULE_VERSION
 > 
IOJS_1_1_MODULE_VERSION


24 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

25 
v8
::
PhtomClbackDa
<
WkClbackInfo
<
T
> > cڡ&

	)

26 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

27 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

28 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

29 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

30 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


31 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

32 
v8
::
PhtomClbackDa
<
WkClbackInfo
<
T
> > cڡ&

	)

33 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

34 
v8
::
IlFldsClbackDa
<
WkClbackInfo
<
T
>, > cڡ&

	)

35 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

36 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

37 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


38 
	#NAN_WEAK_CALLBACK_DATA_TYPE_
 \

39 
v8
::
WkClbackDa
<
S
, 
WkClbackInfo
<
T
> > cڡ&

	)

40 
	#NAN_WEAK_CALLBACK_SIG_
 
NAN_WEAK_CALLBACK_DATA_TYPE_


	)

42 
	#NAN_WEAK_CALLBACK_DATA_TYPE_
 *

	)

43 
	#NAN_WEAK_CALLBACK_SIG_
 \

44 
v8
::
Psit
<v8::
Vue
>, 
NAN_WEAK_CALLBACK_DATA_TYPE_


	)

47 
	gme
<
tyme
 
	gT
>

48 as
	cWkClbackInfo
 {

49 
	mpublic
:

50 (*
	tClback
)(cڡ 
	tWkClbackInfo
<
	tT
>& 
	tda
);

51 
	`WkClbackInfo
(

52 
Psit
<
v8
::
Vue
> *
rsit


53 , 
Clback
 
back


54 , *
m


55 , *
fld1
 = 0

56 , *
fld2
 = 0) :

57 
	`back_
(
back
), 
	`isީe_
(0), 
	$m_
(
m
) {

58 
d
::
	`memy
(&
rsit_
, 
rsit
,  (
v8
::
Psit
<v8::
Vue
>));

59 
_flds_
[0] = 
fld1
;

60 
_flds_
[1] = 
fld2
;

62 
NAN_INLINE
 
v8
::
Isީe
 *
	$GIsީe
(cڡ {  
isީe_
; 
	}
}

63 
NAN_INLINE
 
T
 *
	$GPam
(cڡ {  
ic_
<
T
*>(
m_
); 
	}
}

64 
NAN_INLINE
 *
	$GIlFld
(
dex
) const {

65 
	`as
((
dex
 == 0 || index == 1) && "internal field index out of bounds");

66 i(
dex
 == 0) {

67  
_flds_
[0];

69  
_flds_
[1];

71 
	}
}

73 
	give
:

74 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
WkClbackInfo
)

75 
Clback
 
back_
;

76 
v8
::
Isީe
 *
isީe_
;

77 *
m_
;

78 *
_flds_
[
kIlFldsInWkClback
];

79 
v8
::
Psit
<v8::
Vue
> 
rsit_
;

80 
me
<
tyme
 
S
,ym
M
> 
nd
 
ass
 
Psit
;

81 
me
<
tyme
 
S
> 
nd
 
ass
 
PsitBa
;

82 #i
NODE_MODULE_VERSION
 <
NODE_0_12_MODULE_VERSION


83 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


84 
me
<
tyme
 
S
>

85 
	`voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
);

86 
me
<
tyme
 
S
>

87 
WkClbackInfo
 *
	`unwp
(
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
);

89 
	`voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
);

90 
WkClbackInfo
 *
	`unwp
(
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
);

93 
	`vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
);

94 
	`vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
);

95 
WkClbackInfo
 *
	`unwam
(

96 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
);

97 
WkClbackInfo
 *
	`unwwofld
(

98 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
);

100 
	}
};

103 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

104 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

106 
me
<
tyme
 
T
>

108 
WkClbackInfo
<
T
>::
	$vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
) {

109 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwam
(
da
);

110 i(
da
.
	`IsFPass
()) {

111 
cbfo
->
rsit_
.
	`Ret
();

112 
da
.
	`SSecdPassClback
(
vokam
);

114 
cbfo
->
	`back_
(*cbinfo);

115 
de
 
cbfo
;

117 
	}
}

119 
	gme
<
tyme
 
	gT
>

121 
	gWkClbackInfo
<
	gT
>::
	$vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
) {

122 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwwofld
(
da
);

123 i(
da
.
	`IsFPass
()) {

124 
cbfo
->
rsit_
.
	`Ret
();

125 
da
.
	`SSecdPassClback
(
vokwofld
);

127 
cbfo
->
	`back_
(*cbinfo);

128 
de
 
cbfo
;

130 
	}
}

132 
	gme
<
tyme
 
	gT
>

133 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwam
(

134 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
) {

135 
WkClbackInfo
<
T
> *
cbfo
 =

136 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GPam
());

137 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

138  
cbfo
;

139 
	}
}

141 
	gme
<
tyme
 
	gT
>

142 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwwofld
(

143 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
) {

144 
WkClbackInfo
<
T
> *
cbfo
 =

145 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GIlFld
(0));

146 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

147  
cbfo
;

148 
	}
}

150 #unde
NAN_WEAK_PARAMETER_CALLBACK_SIG_


151 #unde
NAN_WEAK_TWOFIELD_CALLBACK_SIG_


152 #unde
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


153 #unde
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


154 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


156 
	gme
<
tyme
 
	gT
>

158 
	gWkClbackInfo
<
	gT
>::
	$vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
) {

159 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwam
(
da
);

160 
cbfo
->
rsit_
.
	`Ret
();

161 
cbfo
->
	`back_
(*cbinfo);

162 
de
 
cbfo
;

163 
	}
}

165 
	gme
<
tyme
 
	gT
>

167 
	gWkClbackInfo
<
	gT
>::
	$vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
) {

168 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwwofld
(
da
);

169 
cbfo
->
rsit_
.
	`Ret
();

170 
cbfo
->
	`back_
(*cbinfo);

171 
de
 
cbfo
;

172 
	}
}

174 
	gme
<
tyme
 
	gT
>

175 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwam
(

176 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
) {

177 
WkClbackInfo
<
T
> *
cbfo
 =

178 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GPam
());

179 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

180  
cbfo
;

181 
	}
}

183 
	gme
<
tyme
 
	gT
>

184 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwwofld
(

185 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
) {

186 
WkClbackInfo
<
T
> *
cbfo
 =

187 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GIlFld1
());

188 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

189  
cbfo
;

190 
	}
}

192 #unde
NAN_WEAK_PARAMETER_CALLBACK_SIG_


193 #unde
NAN_WEAK_TWOFIELD_CALLBACK_SIG_


194 #unde
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


195 #unde
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


196 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


198 
	gme
<
tyme
 
	gT
>

199 
	gme
<
tyme
 
	gS
>

200 
	gWkClbackInfo
<
	gT
>::
	$voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
) {

201 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwp
(
da
);

202 
cbfo
->
rsit_
.
	`Ret
();

203 
cbfo
->
	`back_
(*cbinfo);

204 
de
 
cbfo
;

205 
	}
}

207 
	gme
<
tyme
 
	gT
>

208 
	gme
<
tyme
 
	gS
>

209 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwp
(

210 
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
) {

211 *
m
 = 
da
.
	`GPam
();

212 
WkClbackInfo
<
T
> *
cbfo
 =

213 
ic_
<
WkClbackInfo
<
T
>*>(
m
);

214 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

215  
cbfo
;

216 
	}
}

218 #unde
NAN_WEAK_CALLBACK_SIG_


219 #unde
NAN_WEAK_CALLBACK_DATA_TYPE_


222 
	gme
<
tyme
 
	gT
>

223 
	gWkClbackInfo
<
	gT
>::
	$voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
) {

224 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwp
(
da
);

225 
cbfo
->
rsit_
.
	`Dio
();

226 
cbfo
->
rsit_
.
	`Cˬ
();

227 
cbfo
->
	`back_
(*cbinfo);

228 
de
 
cbfo
;

229 
	}
}

231 
	gme
<
tyme
 
	gT
>

232 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwp
(

233 
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
) {

234 
WkClbackInfo
<
T
> *
cbfo
 =

235 
ic_
<
WkClbackInfo
<
T
>*>(
da
);

236 
cbfo
->
isީe_
 = 
v8
::
Isީe
::
	`GCut
();

237  
cbfo
;

238 
	}
}

240 #unde
NAN_WEAK_CALLBACK_SIG_


241 #unde
NAN_WEAK_CALLBACK_DATA_TYPE_


244 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

245 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

246 
me
<
tyme
 
T
,ym
	gM
>

247 
	gme
<
tyme
 
	gP
>

248 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

249 
P
 *
m


250 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


251 , 
WkClbackTy
 
ty
) {

252 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

253 i(
	gty
 =
WkClbackTy
::
kPam
) {

254 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

255 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

256 , 
	gback


257 , 
	gm
);

258 
	gv8
::
PsitBa
<
T
>::
SWk
(

259 
wcbd


260 , 
WkClbackInfo
<
P
>::
vokam


261 , 
ty
);

263 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

264 
as
((*
lf
)->
IsObje
());

265 
	gcou
 = (*
lf
)->
IlFldCou
();

266 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

267 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

268 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

270 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

271 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

272 , 
	gback


274 , 
	g_flds
[0]

275 , 
	g_flds
[1]);

276 (*
	glf
)->
SAligdPorInIlFld
(0, 
wcbd
);

277 
	gv8
::
PsitBa
<
T
>::
SWk
(

278 
ic_
<
WkClbackInfo
<
P
>*>(0)

279 , 
WkClbackInfo
<
P
>::
vokwofld


280 , 
ty
);

283 #i
NODE_MODULE_VERSION
 > 
IOJS_1_1_MODULE_VERSION


284 
	gme
<
tyme
 
	gT
,ym
	gM
>

285 
	gme
<
tyme
 
	gP
>

286 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

287 
P
 *
m


288 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


289 , 
WkClbackTy
 
ty
) {

290 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

291 i(
	gty
 =
WkClbackTy
::
kPam
) {

292 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

293 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

294 , 
	gback


295 , 
	gm
);

296 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

297 
wcbd


298 , 
WkClbackInfo
<
P
>::
vokam
);

300 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

301 
as
((*
lf
)->
IsObje
());

302 
	gcou
 = (*
lf
)->
IlFldCou
();

303 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

304 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

305 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

307 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

308 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

309 , 
	gback


311 , 
	g_flds
[0]

312 , 
	g_flds
[1]);

313 (*
	glf
)->
SAligdPorInIlFld
(0, 
wcbd
);

314 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

315 
ic_
<
WkClbackInfo
<
P
>*>(0)

316 , 
WkClbackInfo
<
P
>::
vokwofld


318 , 
cou
 > 1 ? 1 : 
kNoIlFldIndex
);

321 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


322 
	gme
<
tyme
 
	gT
,ym
	gM
>

323 
	gme
<
tyme
 
	gP
>

324 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

325 
P
 *
m


326 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


327 , 
WkClbackTy
 
ty
) {

328 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

329 i(
	gty
 =
WkClbackTy
::
kPam
) {

330 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

331 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

332 , 
	gback


333 , 
	gm
);

334 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

335 
wcbd


336 , 
WkClbackInfo
<
P
>::
vokam
);

338 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

339 
as
((*
lf
)->
IsObje
());

340 
	gcou
 = (*
lf
)->
IlFldCou
();

341 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

342 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

343 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

345 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

346 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

347 , 
	gback


349 , 
	g_flds
[0]

350 , 
	g_flds
[1]);

351 (*
	glf
)->
SAligdPorInIlFld
(0, 
wcbd
);

352 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

353 
WkClbackInfo
<
P
>::
vokwofld


355 , 
cou
 > 1 ? 1 : 
kNoIlFldIndex
);

358 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


359 
	gme
<
tyme
 
	gT
,ym
	gM
>

360 
	gme
<
tyme
 
	gP
>

361 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

362 
P
 *
m


363 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


364 , 
WkClbackTy
 
ty
) {

365 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

366 i(
	gty
 =
WkClbackTy
::
kPam
) {

367 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

368 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

369 , 
	gback


370 , 
	gm
);

371 
	gv8
::
PsitBa
<
T
>::
SWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

373 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

374 
as
((*
lf
)->
IsObje
());

375 
	gcou
 = (*
lf
)->
IlFldCou
();

376 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

377 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

378 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

380 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

381 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

382 , 
	gback


384 , 
	g_flds
[0]

385 , 
	g_flds
[1]);

386 
	gv8
::
PsitBa
<
T
>::
SWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

390 
	gme
<
tyme
 
	gT
>

391 
	gme
<
tyme
 
	gP
>

392 
NAN_INLINE
 
	gPsitBa
<
	gT
>::
SWk
(

393 
P
 *
m


394 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


395 , 
WkClbackTy
 
ty
) {

396 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

397 i(
	gty
 =
WkClbackTy
::
kPam
) {

398 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

399 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

400 , 
	gback


401 , 
	gm
);

402 
	grsit
.
MakeWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

404 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

405 
as
((*
lf
)->
IsObje
());

406 
	gcou
 = (*
lf
)->
IlFldCou
();

407 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

408 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

409 
	g_flds
[
i
] = (*
lf
)->
GPorFromIlFld
(i);

411 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

412 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

413 , 
	gback


415 , 
	g_flds
[0]

416 , 
	g_flds
[1]);

417 
	grsit
.
MakeWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark-native.c

7 
	~<dio.h
>

8 
	~<unid.h
>

9 
	~<sys/time.h
>

10 
	~<uuid/uuid.h
>

12 
	$ma
() {

13 
uuid_t
 
myid
;

14 
buf
[36+1];

15 
i
;

16 
timev
 
t
;

17 
t
, 
fish
;

19 
	`gtimeofday
(&
t
, 
NULL
);

20 
t
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

22 
n
 = 2e5;

23 
i
 = 0; i < 
n
; i++) {

24 
	`uuid_ge
(
myid
);

25 
	`uuid_uŬ
(
myid
, 
buf
);

28 
	`gtimeofday
(&
t
, 
NULL
);

29 
fish
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

30 
dur
 = 
fish
 - 
t
;

32 
	`tf
("%d uuids/c", ()(
n
/
dur
));

34 
	}
}

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/async.cc

7 
	$async_age
(
uv_async_t
 *
async
) {

8 i(!
async
->
da
) ;

9 
FSEvts
 *
f
 = (FSEvt*)
async
->
da
;

10 
CFIndex
 
idx
, 
t
;

11 
f_evt
 *
evt
;

12 
thbuf
[1024];

13 cڡ *
thr
 = 
NULL
;

14 
f
->
	`lock
();

15 
t
 = 
f
->
evts
.
	`size
();

16 
idx
=0; idx<
t
; idx++) {

17 
evt
 = 
f
->
evts
.
	`
(
idx
);

18 i(
evt
 =
NULL
) ;

19 
thr
 = 
	`CFSgGCSgP
(
evt
->
th
, 
kCFSgEncodgUTF8
);

20 i(!
thr

	`CFSgGCSg
(
evt
->
th
, 
thbuf
, 1024, 
kCFSgEncodgUTF8
);

21 
f
->
	`emEvt
(
thr
 ?h: 
thbuf
, 
evt
->
ags
,vt->
id
);

22 
de
 
evt
;

24 i(
t
>0
f
->
evts
.
	`r
();

25 
f
->
	`uock
();

26 
	}
}

28 
	gFSEvts
::
	$asyncS
() {

29 i(
async
.
da
 =
this
) ;

30 
async
.
da
 = 
this
;

31 
	`uv_async_
(
	`uv_deu_lo
(), &
async
, (
uv_async_cb

async_age
);

32 
	}
}

34 
	gFSEvts
::
	$asyncTrigg
() {

35 i(
async
.
da
 !
this
) ;

36 
	`uv_async_nd
(&
async
);

37 
	}
}

39 
	gFSEvts
::
	$asyncSt
() {

40 i(
async
.
da
 !
this
) ;

41 
async
.
da
 = 
NULL
;

42 
	`uv_o
((
uv_hd_t
 *&
async
, 
NULL
);

43 
	}
}

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/constants.cc

7 #ide
kFSEvtSmEvtFgNe


8 
	#kFSEvtSmEvtFgNe
 0x00000000

	)

11 #ide
kFSEvtSmEvtFgMuSnSubDs


12 
	#kFSEvtSmEvtFgMuSnSubDs
 0x00000001

	)

15 #ide
kFSEvtSmEvtFgUrDrݳd


16 
	#kFSEvtSmEvtFgUrDrݳd
 0x00000002

	)

19 #ide
kFSEvtSmEvtFgKlDrݳd


20 
	#kFSEvtSmEvtFgKlDrݳd
 0x00000004

	)

23 #ide
kFSEvtSmEvtFgEvtIdsWed


24 
	#kFSEvtSmEvtFgEvtIdsWed
 0x00000008

	)

27 #ide
kFSEvtSmEvtFgHiyDe


28 
	#kFSEvtSmEvtFgHiyDe
 0x00000010

	)

31 #ide
kFSEvtSmEvtFgRoChged


32 
	#kFSEvtSmEvtFgRoChged
 0x00000020

	)

35 #ide
kFSEvtSmEvtFgMou


36 
	#kFSEvtSmEvtFgMou
 0x00000040

	)

39 #ide
kFSEvtSmEvtFgUnmou


40 
	#kFSEvtSmEvtFgUnmou
 0x00000080

	)

43 #ide
kFSEvtSmEvtFgImCed


44 
	#kFSEvtSmEvtFgImCed
 0x00000100

	)

47 #ide
kFSEvtSmEvtFgImRemoved


48 
	#kFSEvtSmEvtFgImRemoved
 0x00000200

	)

51 #ide
kFSEvtSmEvtFgImInodeMaMod


52 
	#kFSEvtSmEvtFgImInodeMaMod
 0x00000400

	)

55 #ide
kFSEvtSmEvtFgImRamed


56 
	#kFSEvtSmEvtFgImRamed
 0x00000800

	)

59 #ide
kFSEvtSmEvtFgImModifd


60 
	#kFSEvtSmEvtFgImModifd
 0x00001000

	)

63 #ide
kFSEvtSmEvtFgImFdInfoMod


64 
	#kFSEvtSmEvtFgImFdInfoMod
 0x00002000

	)

67 #ide
kFSEvtSmEvtFgImChgeOwr


68 
	#kFSEvtSmEvtFgImChgeOwr
 0x00004000

	)

71 #ide
kFSEvtSmEvtFgImXMod


72 
	#kFSEvtSmEvtFgImXMod
 0x00008000

	)

75 #ide
kFSEvtSmEvtFgImIsFe


76 
	#kFSEvtSmEvtFgImIsFe
 0x00010000

	)

79 #ide
kFSEvtSmEvtFgImIsD


80 
	#kFSEvtSmEvtFgImIsD
 0x00020000

	)

83 #ide
kFSEvtSmEvtFgImIsSymlk


84 
	#kFSEvtSmEvtFgImIsSymlk
 0x00040000

	)

87 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Cڡts
() {

88 
v8
::
Lol
<v8::
Obje
> 
obje
 = 
N
::
New
<v8::Object>();

89 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgNe").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgNe
));

90 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgMuSnSubDs").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgMuSnSubDs
));

91 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgUrDrݳd").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgUrDrݳd
));

92 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgKlDrݳd").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgKlDrݳd
));

93 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgEvtIdsWed").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgEvtIdsWed
));

94 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgHiyDe").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgHiyDe
));

95 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgRoChged").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgRoChged
));

96 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgMou").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgMou
));

97 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgUnmou").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgUnmou
));

98 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImCed").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImCed
));

99 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImRemoved").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImRemoved
));

100 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImInodeMaMod").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImInodeMaMod
));

101 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImRamed").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImRamed
));

102 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImModifd").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImModifd
));

103 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImFdInfoMod").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImFdInfoMod
));

104 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImChgeOwr").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImChgeOwr
));

105 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImXMod").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImXMod
));

106 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImIsFe").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImIsFe
));

107 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImIsD").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImIsD
));

108 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImIsSymlk").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImIsSymlk
));

109  
obje
;

110 
	}
}

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/locking.cc

6 
	gFSEvts
::
	$lockgS
() {

7 i(
lockSed
) ;

8 
lockSed
 = 
ue
;

9 
	`had_mux_
(&
lockmux
, 
NULL
);

10 
	}
}

12 
	gFSEvts
::
	$lock
() {

13 i(!
lockSed
) ;

14 
	`had_mux_lock
(&
lockmux
);

15 
	}
}

17 
	gFSEvts
::
	$uock
() {

18 i(!
lockSed
) ;

19 
	`had_mux_uock
(&
lockmux
);

20 
	}
}

22 
	gFSEvts
::
	$lockgSt
() {

23 i(!
lockSed
) ;

24 
lockSed
 = 
l
;

26 
	`had_mux_deroy
(&
lockmux
);

27 
	}
}

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/methods.cc

6 
	gFSEvts
::
	$emEvt
(cڡ *
th
, 
UI32
 
ags
, 
UI64
 
id
) {

7 i(!
hdr
) ;

8 
N
::
HdSce
 
hd_sce
;

9 
v8
::
Lol
<v8::
Vue
> 
gv
[] = {

10 
N
::
New
<
v8
::
Sg
>(
th
).
	`ToLolChecked
(),

11 
N
::
New
<
v8
::
Numb
>(
ags
),

12 
N
::
New
<
v8
::
Numb
>(
id
)

14 
hdr
->
	`Cl
(3, 
gv
);

15 
	}
}

17 
	$NAN_METHOD
(
FSEvts
::
New
) {

18 
N
::
Utf8Sg
 *
th
 = 
w
 N::
	`Utf8Sg
(
fo
[0]);

19 
N
::
Clback
 *
back
 = 
w
 N::
	`Clback
(
fo
[1].
As
<
v8
::
Funi
>());

21 
FSEvts
 *
f
 = 
w
 
	`FSEvts
(**
th
, 
back
);

22 
f
->
	`Wp
(
fo
.
	`This
());

24 
fo
.
	`GRuVue
().
	`S
(fo.
	`This
());

25 
	}
}

27 
	$NAN_METHOD
(
FSEvts
::
St
) {

28 
FSEvts
* 
f
 = 
node
::
ObjeWp
::
Unwp
<FSEvts>(
fo
.
	`This
());

30 
f
->
	`thadSt
();

31 
f
->
	`asyncSt
();

33 
fo
.
	`GRuVue
().
	`S
(fo.
	`This
());

34 
	}
}

36 
	$NAN_METHOD
(
FSEvts
::
S
) {

37 
FSEvts
* 
f
 = 
node
::
ObjeWp
::
Unwp
<FSEvts>(
fo
.
	`This
());

38 
f
->
	`asyncS
();

39 
f
->
	`thadS
();

41 
fo
.
	`GRuVue
().
	`S
(fo.
	`This
());

42 
	}
}

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/storage.cc

6 
	sf_evt
 {

7 
UI64
 
	mid
;

8 
UI32
 
	mags
;

9 
CFSgRef
 
	mth
;

11 
f_evt
(
CFSgRef
 
evtPh
, 
UI32
 
evtFg
, 
UI64
 
evtId
) {

12 
	mthis
->
	mth
 = 
evtPh
;

13 
	mthis
->
	mags
 = 
evtFg
;

14 
	mthis
->
	mid
 = 
evtId
;

15 i(
	mthis
->
	mth
 !
NULL
)

16 
CFRa
(
this
->
th
);

19 ~
f_evt
() {

20 i(
	mthis
->
	mth
 !
NULL
)

21 
CFR
(
this
->
th
);

24 
	mive
:

25 
f_evt
(const fse_event&);

26 
	mݔ
=(cڡ 
f_evt
&);

	@node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/thread.cc

7 #ide
kFSEvtSmCeFgNe


8 
	#kFSEvtSmCeFgNe
 0x00000000

	)

11 #ide
kFSEvtSmCeFgUCFTys


12 
	#kFSEvtSmCeFgUCFTys
 0x00000001

	)

15 #ide
kFSEvtSmCeFgNoDer


16 
	#kFSEvtSmCeFgNoDer
 0x00000002

	)

19 #ide
kFSEvtSmCeFgWchRo


20 
	#kFSEvtSmCeFgWchRo
 0x00000004

	)

23 #ide
kFSEvtSmCeFgIgneSf


24 
	#kFSEvtSmCeFgIgneSf
 0x00000008

	)

27 #ide
kFSEvtSmCeFgFeEvts


28 
	#kFSEvtSmCeFgFeEvts
 0x00000010

	)

31 
	gFSEvts
::
	$thadS
() {

32 i(
thadlo
) ;

33 
	`had_
(&
thad
, 
NULL
, &
FSEvts
::
thadRun
, 
this
);

34 
	}
}

36 
	$HdSmEvts
(
CڡFSEvtSmRef
 
am
, *
x
, 
size_t
 
numEvts
, *
evtPhs
, cڡ 
FSEvtSmEvtFgs
 
evtFgs
[], cڡ 
FSEvtSmEvtId
 
evtIds
[]) {

37 
FSEvts
 * 
f
 = (FSEvt*)
x
;

38 
size_t
 
idx
;

39 
f
->
	`lock
();

40 
idx
=0; idx < 
numEvts
; idx++) {

41 
f_evt
 *
evt
 = 
w
 
	`f_evt
(

42 (
CFSgRef
)
	`CFAayGVueAtIndex
((
CFAayRef
)
evtPhs
, 
idx
),

43 
evtFgs
[
idx
],

44 
evtIds
[
idx
]

46 
f
->
evts
.
	`push_back
(
evt
);

48 
f
->
	`asyncTrigg
();

49 
f
->
	`uock
();

50 
	}
}

52 *
	gFSEvts
::
	$thadRun
(*
x
) {

53 
FSEvts
 *
f
 = (FSEvts*)
x
;

54 
FSEvtSmCڋxt
 
cڋxt
 = { 0, 
x
, 
NULL
, NULL, NULL };

55 
f
->
thadlo
 = 
	`CFRunLoGCut
();

56 
FSEvtSmRef
 
am
 = 
	`FSEvtSmCe
(
NULL
, &
HdSmEvts
, &
cڋxt
, 
f
->
ths
, 
kFSEvtSmEvtIdSNow
, (
CFAbsuTime
0.1, 
kFSEvtSmCeFgNe
 | 
kFSEvtSmCeFgWchRo
 | 
kFSEvtSmCeFgFeEvts
 | 
kFSEvtSmCeFgUCFTys
);

57 
	`FSEvtSmScheduWhRunLo
(
am
, 
f
->
thadlo
, 
kCFRunLoDeuMode
);

58 
	`FSEvtSmS
(
am
);

59 
	`CFRunLoRun
();

60 
	`FSEvtSmSt
(
am
);

61 
	`FSEvtSmUnscheduFromRunLo
(
am
, 
f
->
thadlo
, 
kCFRunLoDeuMode
);

62 
	`FSEvtSmInvide
(
am
);

63 
	`FSEvtSmR
(
am
);

64 
f
->
thadlo
 = 
NULL
;

65  
NULL
;

66 
	}
}

68 
	gFSEvts
::
	$thadSt
() {

69 i(!
thadlo
) ;

70 
	`CFRunLoSt
(
thadlo
);

71 
	`had_jo
(
thad
, 
NULL
);

72 
	}
}

	@node_modules/browser-sync/node_modules/localtunnel/node_modules/request/node_modules/node-uuid/benchmark/benchmark-native.c

7 
	~<dio.h
>

8 
	~<unid.h
>

9 
	~<sys/time.h
>

10 
	~<uuid/uuid.h
>

12 
	$ma
() {

13 
uuid_t
 
myid
;

14 
buf
[36+1];

15 
i
;

16 
timev
 
t
;

17 
t
, 
fish
;

19 
	`gtimeofday
(&
t
, 
NULL
);

20 
t
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

22 
n
 = 2e5;

23 
i
 = 0; i < 
n
; i++) {

24 
	`uuid_ge
(
myid
);

25 
	`uuid_uŬ
(
myid
, 
buf
);

28 
	`gtimeofday
(&
t
, 
NULL
);

29 
fish
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

30 
dur
 = 
fish
 - 
t
;

32 
	`tf
("%d uuids/c", ()(
n
/
dur
));

34 
	}
}

	@node_modules/fsevents/fsevents.cc

6 
	~"n.h
"

7 
	~"uv.h
"

8 
	~"v8.h
"

9 
	~"had.h
"

10 
	~"CeFoundi/CeFoundi.h
"

11 
	~"CeSvis/CeSvis.h
"

12 
	~<ioam
>

13 
	~<ve
>

15 
	~"c/age.cc
"

16 
mea
 
	gf
 {

17 as
	cFSEvts
 : 
public
 
node
::
ObjeWp
 {

18 
public
:

19 
FSEvts
(cڡ *
th
, 
N
::
Clback
 *
hdr
);

20 ~
FSEvts
();

23 
bo
 
	glockSed
;

24 
had_mux_t
 
	glockmux
;

25 
lockgS
();

26 
lock
();

27 
uock
();

28 
lockgSt
();

31 
uv_async_t
 
	gasync
;

32 
asyncS
();

33 
asyncTrigg
();

34 
asyncSt
();

37 
had_t
 
	gthad
;

38 
CFRunLoRef
 
	gthadlo
;

39 
thadS
();

40 *
thadRun
(*
x
);

41 
thadSt
();

44 
	gN
::
Clback
 *
hdr
;

45 
emEvt
(cڡ *
th
, 
UI32
 
ags
, 
UI64
 
id
);

48 
CFAayRef
 
	gths
;

49 
	gd
::
ve
<
f_evt
*> 
evts
;

50 
Inlize
(
v8
::
Hd
<v8::
Obje
> 
expts
);

53 
NAN_METHOD
(
New
);

54 
NAN_METHOD
(
St
);

55 
NAN_METHOD
(
S
);

60 
usg
 
mea
 
	gf
;

62 
	gFSEvts
::
	$FSEvts
(cڡ *
th
, 
N
::
Clback
 *
hdr
): 
	$hdr
(
hdr
) {

63 
CFSgRef
 
ds
[] = { 
	`CFSgCeWhCSg
(
NULL
, 
th
, 
kCFSgEncodgUTF8
) };

64 
ths
 = 
	`CFAayCe
(
NULL
, (cڡ **)&
ds
, 1, NULL);

65 
thadlo
 = 
NULL
;

66 
	`lockgS
();

67 
	}
}

68 
	gFSEvts
::~
	$FSEvts
() {

69 
d
::
cout
 << "YIKES" << std::
dl
;

70 
	`lockgSt
();

71 
de
 
hdr
;

72 
hdr
 = 
NULL
;

74 
	`CFR
(
ths
);

75 
	}
}

77 #ide
kFSEvtSmEvtFgImCed


78 
	#kFSEvtSmEvtFgImCed
 0x00000010

	)

81 
	~"c/lockg.cc
"

82 
	~"c/async.cc
"

83 
	~"c/thad.cc
"

84 
	~"c/cڡts.cc
"

85 
	~"c/mhods.cc
"

87 
	gFSEvts
::
Inlize
(
v8
::
Hd
<v8::
Obje
> 
expts
) {

88 
v8
::
Lol
<v8::
FuniTeme
> 
l
 = 
N
::
New
<v8::FuniTeme>(
FSEvts
::New);

89 
	gl
->
SCssName
(
N
::
New
<
v8
::
Sg
>("FSEvts").
ToLolChecked
());

90 
	gl
->
InTeme
()->
SIlFldCou
(1);

91 
	gl
->
PryTeme
()->
S
(

92 
N
::
New
<
v8
::
Sg
>("t").
ToLolChecked
(),

93 
N
::
New
<
v8
::
FuniTeme
>(
FSEvts
::
S
));

94 
	gl
->
PryTeme
()->
S
(

95 
N
::
New
<
v8
::
Sg
>("").
ToLolChecked
(),

96 
N
::
New
<
v8
::
FuniTeme
>(
FSEvts
::
St
));

97 
	gexpts
->
S
(
N
::
New
<
v8
::
Sg
>("Cڡts").
ToLolChecked
(), 
Cڡts
());

98 
	gexpts
->
S
(
N
::
New
<
v8
::
Sg
>("FSEvts").
ToLolChecked
(),

99 
l
->
GFuni
());

102 
NODE_MODULE
(
f
, 
FSEvts
::
Inlize
)

	@node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark-native.c

7 
	~<dio.h
>

8 
	~<unid.h
>

9 
	~<sys/time.h
>

10 
	~<uuid/uuid.h
>

12 
	$ma
() {

13 
uuid_t
 
myid
;

14 
buf
[36+1];

15 
i
;

16 
timev
 
t
;

17 
t
, 
fish
;

19 
	`gtimeofday
(&
t
, 
NULL
);

20 
t
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

22 
n
 = 2e5;

23 
i
 = 0; i < 
n
; i++) {

24 
	`uuid_ge
(
myid
);

25 
	`uuid_uŬ
(
myid
, 
buf
);

28 
	`gtimeofday
(&
t
, 
NULL
);

29 
fish
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

30 
dur
 = 
fish
 - 
t
;

32 
	`tf
("%d uuids/c", ()(
n
/
dur
));

34 
	}
}

	@node_modules/fsevents/src/async.cc

7 
	$async_age
(
uv_async_t
 *
async
) {

8 i(!
async
->
da
) ;

9 
FSEvts
 *
f
 = (FSEvt*)
async
->
da
;

10 
CFIndex
 
idx
, 
t
;

11 
f_evt
 *
evt
;

12 
thbuf
[1024];

13 cڡ *
thr
 = 
NULL
;

14 
f
->
	`lock
();

15 
t
 = 
f
->
evts
.
	`size
();

16 
idx
=0; idx<
t
; idx++) {

17 
evt
 = 
f
->
evts
.
	`
(
idx
);

18 i(
evt
 =
NULL
) ;

19 
thr
 = 
	`CFSgGCSgP
(
evt
->
th
, 
kCFSgEncodgUTF8
);

20 i(!
thr

	`CFSgGCSg
(
evt
->
th
, 
thbuf
, 1024, 
kCFSgEncodgUTF8
);

21 
f
->
	`emEvt
(
thr
 ?h: 
thbuf
, 
evt
->
ags
,vt->
id
);

22 
de
 
evt
;

24 i(
t
>0
f
->
evts
.
	`r
();

25 
f
->
	`uock
();

26 
	}
}

28 
	gFSEvts
::
	$asyncS
() {

29 i(
async
.
da
 =
this
) ;

30 
async
.
da
 = 
this
;

31 
	`uv_async_
(
	`uv_deu_lo
(), &
async
, (
uv_async_cb

async_age
);

32 
	}
}

34 
	gFSEvts
::
	$asyncTrigg
() {

35 i(
async
.
da
 !
this
) ;

36 
	`uv_async_nd
(&
async
);

37 
	}
}

39 
	gFSEvts
::
	$asyncSt
() {

40 i(
async
.
da
 !
this
) ;

41 
async
.
da
 = 
NULL
;

42 
	`uv_o
((
uv_hd_t
 *&
async
, 
NULL
);

43 
	}
}

	@node_modules/fsevents/src/constants.cc

7 #ide
kFSEvtSmEvtFgNe


8 
	#kFSEvtSmEvtFgNe
 0x00000000

	)

11 #ide
kFSEvtSmEvtFgMuSnSubDs


12 
	#kFSEvtSmEvtFgMuSnSubDs
 0x00000001

	)

15 #ide
kFSEvtSmEvtFgUrDrݳd


16 
	#kFSEvtSmEvtFgUrDrݳd
 0x00000002

	)

19 #ide
kFSEvtSmEvtFgKlDrݳd


20 
	#kFSEvtSmEvtFgKlDrݳd
 0x00000004

	)

23 #ide
kFSEvtSmEvtFgEvtIdsWed


24 
	#kFSEvtSmEvtFgEvtIdsWed
 0x00000008

	)

27 #ide
kFSEvtSmEvtFgHiyDe


28 
	#kFSEvtSmEvtFgHiyDe
 0x00000010

	)

31 #ide
kFSEvtSmEvtFgRoChged


32 
	#kFSEvtSmEvtFgRoChged
 0x00000020

	)

35 #ide
kFSEvtSmEvtFgMou


36 
	#kFSEvtSmEvtFgMou
 0x00000040

	)

39 #ide
kFSEvtSmEvtFgUnmou


40 
	#kFSEvtSmEvtFgUnmou
 0x00000080

	)

43 #ide
kFSEvtSmEvtFgImCed


44 
	#kFSEvtSmEvtFgImCed
 0x00000100

	)

47 #ide
kFSEvtSmEvtFgImRemoved


48 
	#kFSEvtSmEvtFgImRemoved
 0x00000200

	)

51 #ide
kFSEvtSmEvtFgImInodeMaMod


52 
	#kFSEvtSmEvtFgImInodeMaMod
 0x00000400

	)

55 #ide
kFSEvtSmEvtFgImRamed


56 
	#kFSEvtSmEvtFgImRamed
 0x00000800

	)

59 #ide
kFSEvtSmEvtFgImModifd


60 
	#kFSEvtSmEvtFgImModifd
 0x00001000

	)

63 #ide
kFSEvtSmEvtFgImFdInfoMod


64 
	#kFSEvtSmEvtFgImFdInfoMod
 0x00002000

	)

67 #ide
kFSEvtSmEvtFgImChgeOwr


68 
	#kFSEvtSmEvtFgImChgeOwr
 0x00004000

	)

71 #ide
kFSEvtSmEvtFgImXMod


72 
	#kFSEvtSmEvtFgImXMod
 0x00008000

	)

75 #ide
kFSEvtSmEvtFgImIsFe


76 
	#kFSEvtSmEvtFgImIsFe
 0x00010000

	)

79 #ide
kFSEvtSmEvtFgImIsD


80 
	#kFSEvtSmEvtFgImIsD
 0x00020000

	)

83 #ide
kFSEvtSmEvtFgImIsSymlk


84 
	#kFSEvtSmEvtFgImIsSymlk
 0x00040000

	)

87 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Cڡts
() {

88 
v8
::
Lol
<v8::
Obje
> 
obje
 = 
N
::
New
<v8::Object>();

89 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgNe").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgNe
));

90 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgMuSnSubDs").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgMuSnSubDs
));

91 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgUrDrݳd").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgUrDrݳd
));

92 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgKlDrݳd").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgKlDrݳd
));

93 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgEvtIdsWed").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgEvtIdsWed
));

94 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgHiyDe").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgHiyDe
));

95 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgRoChged").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgRoChged
));

96 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgMou").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgMou
));

97 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgUnmou").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgUnmou
));

98 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImCed").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImCed
));

99 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImRemoved").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImRemoved
));

100 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImInodeMaMod").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImInodeMaMod
));

101 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImRamed").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImRamed
));

102 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImModifd").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImModifd
));

103 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImFdInfoMod").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImFdInfoMod
));

104 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImChgeOwr").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImChgeOwr
));

105 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImXMod").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImXMod
));

106 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImIsFe").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImIsFe
));

107 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImIsD").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImIsD
));

108 
obje
->
	`S
(
N
::
New
<
v8
::
Sg
>("kFSEvtSmEvtFgImIsSymlk").
	`ToLolChecked
(), N::New<v8::
Ieg
>(
kFSEvtSmEvtFgImIsSymlk
));

109  
obje
;

110 
	}
}

	@node_modules/fsevents/src/locking.cc

6 
	gFSEvts
::
	$lockgS
() {

7 i(
lockSed
) ;

8 
lockSed
 = 
ue
;

9 
	`had_mux_
(&
lockmux
, 
NULL
);

10 
	}
}

12 
	gFSEvts
::
	$lock
() {

13 i(!
lockSed
) ;

14 
	`had_mux_lock
(&
lockmux
);

15 
	}
}

17 
	gFSEvts
::
	$uock
() {

18 i(!
lockSed
) ;

19 
	`had_mux_uock
(&
lockmux
);

20 
	}
}

22 
	gFSEvts
::
	$lockgSt
() {

23 i(!
lockSed
) ;

24 
lockSed
 = 
l
;

26 
	`had_mux_deroy
(&
lockmux
);

27 
	}
}

	@node_modules/fsevents/src/methods.cc

6 
	gFSEvts
::
	$emEvt
(cڡ *
th
, 
UI32
 
ags
, 
UI64
 
id
) {

7 i(!
hdr
) ;

8 
N
::
HdSce
 
hd_sce
;

9 
v8
::
Lol
<v8::
Vue
> 
gv
[] = {

10 
N
::
New
<
v8
::
Sg
>(
th
).
	`ToLolChecked
(),

11 
N
::
New
<
v8
::
Numb
>(
ags
),

12 
N
::
New
<
v8
::
Numb
>(
id
)

14 
hdr
->
	`Cl
(3, 
gv
);

15 
	}
}

17 
	$NAN_METHOD
(
FSEvts
::
New
) {

18 
N
::
Utf8Sg
 *
th
 = 
w
 N::
	`Utf8Sg
(
fo
[0]);

19 
N
::
Clback
 *
back
 = 
w
 N::
	`Clback
(
fo
[1].
As
<
v8
::
Funi
>());

21 
FSEvts
 *
f
 = 
w
 
	`FSEvts
(**
th
, 
back
);

22 
f
->
	`Wp
(
fo
.
	`This
());

24 
fo
.
	`GRuVue
().
	`S
(fo.
	`This
());

25 
	}
}

27 
	$NAN_METHOD
(
FSEvts
::
St
) {

28 
FSEvts
* 
f
 = 
node
::
ObjeWp
::
Unwp
<FSEvts>(
fo
.
	`This
());

30 
f
->
	`thadSt
();

31 
f
->
	`asyncSt
();

33 
fo
.
	`GRuVue
().
	`S
(fo.
	`This
());

34 
	}
}

36 
	$NAN_METHOD
(
FSEvts
::
S
) {

37 
FSEvts
* 
f
 = 
node
::
ObjeWp
::
Unwp
<FSEvts>(
fo
.
	`This
());

38 
f
->
	`asyncS
();

39 
f
->
	`thadS
();

41 
fo
.
	`GRuVue
().
	`S
(fo.
	`This
());

42 
	}
}

	@node_modules/fsevents/src/storage.cc

6 
	sf_evt
 {

7 
UI64
 
	mid
;

8 
UI32
 
	mags
;

9 
CFSgRef
 
	mth
;

11 
f_evt
(
CFSgRef
 
evtPh
, 
UI32
 
evtFg
, 
UI64
 
evtId
) {

12 
	mthis
->
	mth
 = 
evtPh
;

13 
	mthis
->
	mags
 = 
evtFg
;

14 
	mthis
->
	mid
 = 
evtId
;

15 i(
	mthis
->
	mth
 !
NULL
)

16 
CFRa
(
this
->
th
);

19 ~
f_evt
() {

20 i(
	mthis
->
	mth
 !
NULL
)

21 
CFR
(
this
->
th
);

24 
	mive
:

25 
f_evt
(const fse_event&);

26 
	mݔ
=(cڡ 
f_evt
&);

	@node_modules/fsevents/src/thread.cc

7 #ide
kFSEvtSmCeFgNe


8 
	#kFSEvtSmCeFgNe
 0x00000000

	)

11 #ide
kFSEvtSmCeFgUCFTys


12 
	#kFSEvtSmCeFgUCFTys
 0x00000001

	)

15 #ide
kFSEvtSmCeFgNoDer


16 
	#kFSEvtSmCeFgNoDer
 0x00000002

	)

19 #ide
kFSEvtSmCeFgWchRo


20 
	#kFSEvtSmCeFgWchRo
 0x00000004

	)

23 #ide
kFSEvtSmCeFgIgneSf


24 
	#kFSEvtSmCeFgIgneSf
 0x00000008

	)

27 #ide
kFSEvtSmCeFgFeEvts


28 
	#kFSEvtSmCeFgFeEvts
 0x00000010

	)

31 
	gFSEvts
::
	$thadS
() {

32 i(
thadlo
) ;

33 
	`had_
(&
thad
, 
NULL
, &
FSEvts
::
thadRun
, 
this
);

34 
	}
}

36 
	$HdSmEvts
(
CڡFSEvtSmRef
 
am
, *
x
, 
size_t
 
numEvts
, *
evtPhs
, cڡ 
FSEvtSmEvtFgs
 
evtFgs
[], cڡ 
FSEvtSmEvtId
 
evtIds
[]) {

37 
FSEvts
 * 
f
 = (FSEvt*)
x
;

38 
size_t
 
idx
;

39 
f
->
	`lock
();

40 
idx
=0; idx < 
numEvts
; idx++) {

41 
f_evt
 *
evt
 = 
w
 
	`f_evt
(

42 (
CFSgRef
)
	`CFAayGVueAtIndex
((
CFAayRef
)
evtPhs
, 
idx
),

43 
evtFgs
[
idx
],

44 
evtIds
[
idx
]

46 
f
->
evts
.
	`push_back
(
evt
);

48 
f
->
	`asyncTrigg
();

49 
f
->
	`uock
();

50 
	}
}

52 *
	gFSEvts
::
	$thadRun
(*
x
) {

53 
FSEvts
 *
f
 = (FSEvts*)
x
;

54 
FSEvtSmCڋxt
 
cڋxt
 = { 0, 
x
, 
NULL
, NULL, NULL };

55 
f
->
thadlo
 = 
	`CFRunLoGCut
();

56 
FSEvtSmRef
 
am
 = 
	`FSEvtSmCe
(
NULL
, &
HdSmEvts
, &
cڋxt
, 
f
->
ths
, 
kFSEvtSmEvtIdSNow
, (
CFAbsuTime
0.1, 
kFSEvtSmCeFgNe
 | 
kFSEvtSmCeFgWchRo
 | 
kFSEvtSmCeFgFeEvts
 | 
kFSEvtSmCeFgUCFTys
);

57 
	`FSEvtSmScheduWhRunLo
(
am
, 
f
->
thadlo
, 
kCFRunLoDeuMode
);

58 
	`FSEvtSmS
(
am
);

59 
	`CFRunLoRun
();

60 
	`FSEvtSmSt
(
am
);

61 
	`FSEvtSmUnscheduFromRunLo
(
am
, 
f
->
thadlo
, 
kCFRunLoDeuMode
);

62 
	`FSEvtSmInvide
(
am
);

63 
	`FSEvtSmR
(
am
);

64 
f
->
thadlo
 = 
NULL
;

65  
NULL
;

66 
	}
}

68 
	gFSEvts
::
	$thadSt
() {

69 i(!
thadlo
) ;

70 
	`CFRunLoSt
(
thadlo
);

71 
	`had_jo
(
thad
, 
NULL
);

72 
	}
}

	@node_modules/less/node_modules/request/node_modules/node-uuid/benchmark/benchmark-native.c

7 
	~<dio.h
>

8 
	~<unid.h
>

9 
	~<sys/time.h
>

10 
	~<uuid/uuid.h
>

12 
	$ma
() {

13 
uuid_t
 
myid
;

14 
buf
[36+1];

15 
i
;

16 
timev
 
t
;

17 
t
, 
fish
;

19 
	`gtimeofday
(&
t
, 
NULL
);

20 
t
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

22 
n
 = 2e5;

23 
i
 = 0; i < 
n
; i++) {

24 
	`uuid_ge
(
myid
);

25 
	`uuid_uŬ
(
myid
, 
buf
);

28 
	`gtimeofday
(&
t
, 
NULL
);

29 
fish
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

30 
dur
 = 
fish
 - 
t
;

32 
	`tf
("%d uuids/c", ()(
n
/
dur
));

34 
	}
}

	@node_modules/nan/nan.h

20 #ide
NAN_H_


21 
	#NAN_H_


	)

23 
	~<node_vsi.h
>

25 
	#NODE_0_10_MODULE_VERSION
 11

	)

26 
	#NODE_0_12_MODULE_VERSION
 14

	)

27 
	#ATOM_0_21_MODULE_VERSION
 41

	)

28 
	#IOJS_1_0_MODULE_VERSION
 42

	)

29 
	#IOJS_1_1_MODULE_VERSION
 43

	)

30 
	#IOJS_2_0_MODULE_VERSION
 44

	)

31 
	#IOJS_3_0_MODULE_VERSION
 45

	)

32 
	#NODE_4_0_MODULE_VERSION
 46

	)

33 
	#NODE_5_0_MODULE_VERSION
 47

	)

34 
	#NODE_6_0_MODULE_VERSION
 48

	)

36 #ifde
_MSC_VER


37 
	#NAN_HAS_CPLUSPLUS_11
 (
_MSC_VER
 >1800)

	)

39 
	#NAN_HAS_CPLUSPLUS_11
 (
__lulus
 >201103L)

	)

42 #i
NODE_MODULE_VERSION
 >
IOJS_3_0_MODULE_VERSION
 && !
NAN_HAS_CPLUSPLUS_11


43 #r 
This
 
vsi
 
of
 
node
/
NAN
/
v8
 
ques
 
a
 
C
++11 
comp


46 
	~<uv.h
>

47 
	~<node.h
>

48 
	~<node_bufr.h
>

49 
	~<node_obje_wp.h
>

50 
	~<gܙhm
>

51 
	~<crg
>

52 
	~<ims
>

53 
	~<cdlib
>

54 #i
defed
(
_MSC_VER
)

55 #agm
wng

push
 )

56 #agm
wng

dib
 : 4530 )

57 
	~<rg
>

58 
	~<ve
>

59 #agm
wng

p
 )

61 
	~<rg
>

62 
	~<ve
>

66 #ifde
UV_VERSION_MAJOR


67 #ide
UV_VERSION_PATCH


68 
	#UV_VERSION_PATCH
 0

	)

70 
	#NAUV_UVVERSION
 ((
UV_VERSION_MAJOR
 << 16) | \

71 (
UV_VERSION_MINOR
 << 8) | \

72 (
UV_VERSION_PATCH
))

	)

74 
	#NAUV_UVVERSION
 0x000b00

	)

77 #i
NAUV_UVVERSION
 < 0x000b0b

78 #ifde
WIN32


79 
	~<wdows.h
>

81 
	~<had.h
>

85 
mea
 
	gN
 {

87 #i
defed
(
__GNUC__
&& !(defed(
DEBUG
) && DEBUG)

88 
	#NAN_INLINE
 
le
 
	`__ibu__
((
ways_le
))

	)

89 #i
defed
(
_MSC_VER
&& !(defed(
DEBUG
) && DEBUG)

90 
	#NAN_INLINE
 
__fle


	)

92 
	#NAN_INLINE
 
le


	)

95 #i
defed
(
__GNUC__
) && \

96 !(
defed
(
V8_DISABLE_DEPRECATIONS
&& 
	gV8_DISABLE_DEPRECATIONS
)

97 
	#NAN_DEPRECATED
 
	`__ibu__
((
dd
))

	)

98 #i
defed
(
_MSC_VER
) && \

99 !(
defed
(
V8_DISABLE_DEPRECATIONS
&& 
	gV8_DISABLE_DEPRECATIONS
)

100 
	#NAN_DEPRECATED
 
	`__deec
(
dd
)

	)

102 
	#NAN_DEPRECATED


	)

105 #i
NAN_HAS_CPLUSPLUS_11


106 
	#NAN_DISALLOW_ASSIGN
(
CLASS

ݔ
=(cڡ CLASS&
de
;

	)

107 
	#NAN_DISALLOW_COPY
(
CLASS

	`CLASS
(cڡ CLASS&
de
;

	)

108 
	#NAN_DISALLOW_MOVE
(
CLASS
) \

109 
	`CLASS
(
CLASS
&&
de
; \

110 
ݔ
=(
CLASS
&&
de
;

	)

112 
	#NAN_DISALLOW_ASSIGN
(
CLASS

ݔ
=(cڡ CLASS&);

	)

113 
	#NAN_DISALLOW_COPY
(
CLASS

	`CLASS
(cڡ CLASS&);

	)

114 
	#NAN_DISALLOW_MOVE
(
CLASS
)

	)

117 
	#NAN_DISALLOW_ASSIGN_COPY
(
CLASS
) \

118 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

119 
	`NAN_DISALLOW_COPY
(
CLASS
)

	)

121 
	#NAN_DISALLOW_ASSIGN_MOVE
(
CLASS
) \

122 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

123 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

125 
	#NAN_DISALLOW_COPY_MOVE
(
CLASS
) \

126 
	`NAN_DISALLOW_COPY
(
CLASS
) \

127 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

129 
	#NAN_DISALLOW_ASSIGN_COPY_MOVE
(
CLASS
) \

130 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

131 
	`NAN_DISALLOW_COPY
(
CLASS
) \

132 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

134 
	#TYPE_CHECK
(
T
, 
S
) \

135 
l
) { \

136 *(
ic_
<
T
 *vީ*>(0)ic_<
S
*>(0); \

137 }

	)

141 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


142 
	gv8
::
	tHd
<
	tv8
::
	tObje
> 
	tADDON_REGISTER_FUNCTION_ARGS_TYPE
;

144 
	gv8
::
	tLol
<
	tv8
::
	tObje
> 
	tADDON_REGISTER_FUNCTION_ARGS_TYPE
;

147 
	#NAN_MODULE_INIT
(
me
) \

148 
	`me
(
N
::
ADDON_REGISTER_FUNCTION_ARGS_TYPE
 
rg
)

	)

152 
	~"n_backs.h
"

156 #i(
NODE_MODULE_VERSION
 < 
NODE_0_12_MODULE_VERSION
)

157 
	gv8
::
	tSt
 
	tUnboundSt
;

158 
	gv8
::
	tSt
 
	tBoundSt
;

160 
	gv8
::
	tUnboundSt
 UnboundScript;

161 
	gv8
::
	tSt
 
	tBoundSt
;

164 #i(
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION
)

165 
	gv8
::
	tSg
::
	tExAsciiSgResour


166 
	tExOBySgResour
;

168 
	gv8
::
	tSg
::
	tExOBySgResour


169 
	tExOBySgResour
;

172 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

173 
	gme
<
tyme
 
	gT
>

174 
ass
 
	gNCyabPsitTs
 :

175 
public
 
v8
::
NCyabPsitTs
<
T
> {};

176 
	gme
<
tyme
 
	gT
>

177 
ass
 
	gCyabPsitTs
 :

178 
public
 
v8
::
CyabPsitTs
<
T
> {};

180 
	gme
<
tyme
 
	gT
>

181 
ass
 
	gPsitBa
 :

182 
public
 
v8
::
PsitBa
<
T
> {};

184 
	gme
<
tyme
 
	gT
,ym
	gM
 = 
v8
::
NCyabPsitTs
<
T
> >

185 
ass
 
Psit
;

187 
	gme
<
tyme
 
	gT
> 
ass
 
	gNCyabPsitTs
;

188 
	gme
<
tyme
 
	gT
> 
ass
 
	gPsitBa
;

189 
	gme
<
tyme
 
	gT
,ym
	gP
> 
ass
 
	gWkClbackDa
;

190 
	gme
<
tyme
 
	gT
,ym
	gM
 = 
NCyabPsitTs
<
T
> >

191 
ass
 
Psit
;

194 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

195 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

196 
	~"n_maybe_43_l.h
"

198 
	~"n_maybe_e_43_l.h
"

201 
	~"n_cvrs.h
"

202 
	~"n_w.h
"

204 #i
NAUV_UVVERSION
 < 0x000b17

205 
	#NAUV_WORK_CB
(
func
) \

206 
	`func
(
uv_async_t
 *
async
, )

	)

208 
	#NAUV_WORK_CB
(
func
) \

209 
	`func
(
uv_async_t
 *
async
)

	)

212 #i
NAUV_UVVERSION
 >= 0x000b0b

214 
uv_key_t
 
	tuv_key_t
;

216 
le
 
uv_key_
(
uv_key_t
 *
key
) {

217  
uv_key_
(
key
);

220 
le
 
uv_key_de
(
uv_key_t
 *
key
) {

221 
uv_key_de
(
key
);

224 
le
 * 
uv_key_g
(
uv_key_t
 *
key
) {

225  
uv_key_g
(
key
);

228 
le
 
uv_key_t
(
uv_key_t
 *
key
, *
vue
) {

229 
uv_key_t
(
key
, 
vue
);

239 #ide
WIN32


241 
had_key_t
 
	tuv_key_t
;

243 
le
 
uv_key_
(
uv_key_t
* 
key
) {

244  -
had_key_
(
key
, 
NULL
);

247 
le
 
uv_key_de
(
uv_key_t
* 
key
) {

248 i(
had_key_de
(*
key
))

249 
abt
();

252 
le
 * 
uv_key_g
(
uv_key_t
* 
key
) {

253  
had_gecific
(*
key
);

256 
le
 
uv_key_t
(
uv_key_t
* 
key
, * 
vue
) {

257 i(
had_tecific
(*
key
, 
vue
))

258 
abt
();

264 
DWORD
 
	gs_dex
;

265 } 
	tuv_key_t
;

267 
le
 
uv_key_
(
uv_key_t
* 
key
) {

268 
	gkey
->
	gs_dex
 = 
TlsAoc
();

269 i(
	gkey
->
	gs_dex
 =
TLS_OUT_OF_INDEXES
)

270  
UV_ENOMEM
;

274 
le
 
uv_key_de
(
uv_key_t
* 
key
) {

275 i(
TlsFe
(
key
->
s_dex
=
FALSE
)

276 
abt
();

277 
	gkey
->
	gs_dex
 = 
TLS_OUT_OF_INDEXES
;

280 
le
 * 
uv_key_g
(
uv_key_t
* 
key
) {

281 * 
	gvue
 = 
TlsGVue
(
key
->
s_dex
);

282 i(
	gvue
 =
NULL
)

283 i(
GLaE
(!
ERROR_SUCCESS
)

284 
abt
();

285  
	gvue
;

288 
le
 
uv_key_t
(
uv_key_t
* 
key
, * 
vue
) {

289 i(
TlsSVue
(
key
->
s_dex
, 
vue
=
FALSE
)

290 
abt
();

296 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


297 
	gme
<
tyme
 
	gT
>

298 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T>);

301 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

302 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

303 
v8
::
	tWkClbackTy
 WeakCallbackType;

305 
	sWkClbackTy
 {

306 
	eE
 {
	gkPam
, 
	gkIlFlds
};

307 
E
 
	gty
;

308 
WkClbackTy
(
E
 
h
: 
ty
(other) {}

309 
le
 
bo
 
ݔ
==(
E
 
h
{  oth =
this
->
ty
; }

310 
le
 
bo
 
	gݔ
!=(
E
 
h
{  !
ݔ
==(other); }

314 
	gme
<
tyme
 
	gP
> 
ass
 
	gWkClbackInfo
;

316 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


317 
	~"n_rsit_12_l.h
"

319 
	~"n_rsit_e_12_l.h
"

322 
mea
 
	gimp
 {

323 cڡ 
size_t
 
	gkMaxLgth
 = 0x3fffffff;

326 #i
NODE_MAJOR_VERSION
 > 0 || \

327 
	gNODE_MINOR_VERSION
 > 10 || \

328 
	gNODE_MINOR_VERSION
 =10 && 
NODE_PATCH_VERSION
 >= 29 || \

329 
NODE_MINOR_VERSION
 =8 && 
NODE_PATCH_VERSION
 >= 27

330 cڡ 
kRInvidUtf8
 = 
v8
::
Sg
::
REPLACE_INVALID_UTF8
;

332 cڡ 
	gkRInvidUtf8
 = 0;

338 as
	cHdSce
 {

339 
	gv8
::
HdSce
 
sce
;

341 
	gpublic
:

342 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


343 
le
 
HdSce
(: 
sce
(
v8
::
Isީe
::
GCut
()) {}

344 
le
 
NumbOfHds
() {

345  
v8
::
HdSce
::
NumbOfHds
(v8::
Isީe
::
GCut
());

348 
le
 
HdSce
(: 
sce
() {}

349 
le
 
NumbOfHds
() {

350  
v8
::
HdSce
::
NumbOfHds
();

354 
	give
:

357 
HdSce
(const HandleScope &);

358 
	gݔ
=(cڡ 
HdSce
 &);

359 *
ݔ
 
w
(
size_t
 
size
);

360 
ݔ
 
de
(*, 
size_t
);

363 as
	cEsbHdSce
 {

364 
	gpublic
:

365 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


366 
le
 
EsbHdSce
(: 
sce
(
v8
::
Isީe
::
GCut
()) {}

368 
le
 
NumbOfHds
() {

369  
v8
::
EsbHdSce
::
NumbOfHds
(v8::
Isީe
::
GCut
());

372 
	gme
<
tyme
 
	gT
>

373 
le
 
	gv8
::
Lol
<
T
> 
Es
(
v8
::Lol<T> 
vue
) {

374  
sce
.
Es
(
vue
);

377 
	give
:

378 
v8
::
EsbHdSce
 
sce
;

380 
le
 
EsbHdSce
(: 
sce
() {}

382 
le
 
NumbOfHds
() {

383  
v8
::
HdSce
::
NumbOfHds
();

386 
	gme
<
tyme
 
	gT
>

387 
le
 
	gv8
::
Lol
<
T
> 
Es
(
v8
::Lol<T> 
vue
) {

388  
sce
.
Clo
(
vue
);

391 
	give
:

392 
v8
::
HdSce
 
sce
;

395 
	give
:

398 
EsbHdSce
(const EscapableHandleScope &);

399 
	gݔ
=(cڡ 
EsbHdSce
 &);

400 *
ݔ
 
w
(
size_t
 
size
);

401 
ݔ
 
de
(*, 
size_t
);

406 as
	cTryCch
 {

407 
	gv8
::
TryCch
 
y_tch_
;

408 
nd
 
FExi
(cڡ 
TryCch
&);

410 
	gpublic
:

411 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


412 
TryCch
(: 
y_tch_
(
v8
::
Isީe
::
GCut
()) {}

415 
NAN_INLINE
 
bo
 
HasCaught
(cڡ {  
y_tch_
.HasCaught(); }

417 
NAN_INLINE
 
bo
 
CCtue
(cڡ {  
	gy_tch_
.CanContinue(); }

419 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
ReThrow
() {

420 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


421  
New
(
y_tch_
.
ReThrow
());

423  
	gy_tch_
.
ReThrow
();

427 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
Exi
() const {

428  
y_tch_
.
Exi
();

431 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

432 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

433 
NAN_INLINE
 
v8
::
MaybeLol
<v8::
Vue
> 
SckT
() const {

434  
y_tch_
.
SckT
(
GCutCڋxt
());

437 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
SckT
() const {

438  
MaybeLol
<
v8
::
Vue
>(
y_tch_
.
SckT
());

442 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Mesge
> Message() const {

443  
y_tch_
.
Mesge
();

446 
NAN_INLINE
 
Ret
({ 
	gy_tch_
.Reset(); }

448 
NAN_INLINE
 
SVbo
(
bo
 
vue
{ 
	gy_tch_
.SetVerbose(value); }

450 
NAN_INLINE
 
SCtuMesge
(
bo
 
vue
) {

451 
	gy_tch_
.
SCtuMesge
(
vue
);

458 #i
NODE_MODULE_VERSION
 >
NODE_0_12_MODULE_VERSION


459 
NAN_INLINE


460 
	$SCouFuni
(
v8
::
CouLookupClback
 
cb
) {

461 
v8
::
Isީe
::
	`GCut
()->
	`SCouFuni
(
cb
);

462 
	}
}

464 
NAN_INLINE


465 
	$SCeHiogmFuni
(
v8
::
CeHiogmClback
 
cb
) {

466 
v8
::
Isީe
::
	`GCut
()->
	`SCeHiogmFuni
(
cb
);

467 
	}
}

469 
NAN_INLINE


470 
	$SAddHiogmSameFuni
(
v8
::
AddHiogmSameClback
 
cb
) {

471 
v8
::
Isީe
::
	`GCut
()->
	`SAddHiogmSameFuni
(
cb
);

472 
	}
}

474 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

475 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

476 
NAN_INLINE
 
bo
 
	$IdNifiti
(
id_time__ms
) {

477  
v8
::
Isީe
::
	`GCut
()->
	`IdNifitiDdle
(

478 
id_time__ms
 * 0.001);

479 
	}
}

481 
NAN_INLINE
 
bo
 
	$IdNifiti
(
id_time__ms
) {

482  
v8
::
Isީe
::
	`GCut
()->
	`IdNifiti
(
id_time__ms
);

483 
	}
}

486 
NAN_INLINE
 
	$LowMemyNifiti
() {

487 
v8
::
Isީe
::
	`GCut
()->
	`LowMemyNifiti
();

488 
	}
}

490 
NAN_INLINE
 
	$CڋxtDiodNifiti
() {

491 
v8
::
Isީe
::
	`GCut
()->
	`CڋxtDiodNifiti
();

492 
	}
}

494 
NAN_INLINE


495 
	$SCouFuni
(
v8
::
CouLookupClback
 
cb
) {

496 
v8
::
V8
::
	`SCouFuni
(
cb
);

497 
	}
}

499 
NAN_INLINE


500 
	$SCeHiogmFuni
(
v8
::
CeHiogmClback
 
cb
) {

501 
v8
::
V8
::
	`SCeHiogmFuni
(
cb
);

502 
	}
}

504 
NAN_INLINE


505 
	$SAddHiogmSameFuni
(
v8
::
AddHiogmSameClback
 
cb
) {

506 
v8
::
V8
::
	`SAddHiogmSameFuni
(
cb
);

507 
	}
}

509 
NAN_INLINE
 
bo
 
	$IdNifiti
(
id_time__ms
) {

510  
v8
::
V8
::
	`IdNifiti
(
id_time__ms
);

511 
	}
}

513 
NAN_INLINE
 
	$LowMemyNifiti
() {

514 
v8
::
V8
::
	`LowMemyNifiti
();

515 
	}
}

517 
NAN_INLINE
 
	$CڋxtDiodNifiti
() {

518 
v8
::
V8
::
	`CڋxtDiodNifiti
();

519 
	}
}

522 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

523 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Undefed
() {

524 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


525 
EsbHdSce
 
sce
;

526  
sce
.
	`Es
(
	`New
(
v8
::
	`Undefed
(v8::
Isީe
::
	`GCut
())));

528  
v8
::
	`Undefed
(v8::
Isީe
::
	`GCut
());

530 
	}
}

532 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Nu
() {

533 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


534 
EsbHdSce
 
sce
;

535  
sce
.
	`Es
(
	`New
(
v8
::
	`Nu
(v8::
Isީe
::
	`GCut
())));

537  
v8
::
	`Nu
(v8::
Isީe
::
	`GCut
());

539 
	}
}

541 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$True
() {

542 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


543 
EsbHdSce
 
sce
;

544  
sce
.
	`Es
(
	`New
(
v8
::
	`True
(v8::
Isީe
::
	`GCut
())));

546  
v8
::
	`True
(v8::
Isީe
::
	`GCut
());

548 
	}
}

550 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$F
() {

551 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


552 
EsbHdSce
 
sce
;

553  
sce
.
	`Es
(
	`New
(
v8
::
	`F
(v8::
Isީe
::
	`GCut
())));

555  
v8
::
	`F
(v8::
Isީe
::
	`GCut
());

557 
	}
}

559 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Sg
> 
	$EmySg
() {

560  
v8
::
Sg
::
	`Emy
(v8::
Isީe
::
	`GCut
());

561 
	}
}

563 
NAN_INLINE
 
	$AdjuExMemy
(
bc
) {

564  
ic_
<>(

565 
v8
::
Isީe
::
	`GCut
()->
	`AdjuAmouOfExAodMemy
(
bc
));

566 
	}
}

568 
NAN_INLINE
 
STeme
(

569 
v8
::
Lol
<v8::
Teme
> 
m


570 , cڡ *
me


571 , 
v8
::
Lol
<v8::
Da
> 
vue
) {

572 
m
->
S
(
v8
::
Isީe
::
GCut
(), 
me
, 
vue
);

575 
NAN_INLINE
 
STeme
(

576 
v8
::
Lol
<v8::
Teme
> 
m


577 , 
v8
::
Lol
<v8::
Sg
> 
me


578 , 
v8
::
Lol
<v8::
Da
> 
vue


579 , 
v8
::
PrݔtyAribu
 
ibus
) {

580 
m
->
S
(
me
, 
vue
, 
ibus
);

583 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
	$GCutCڋxt
() {

584  
v8
::
Isީe
::
	`GCut
()->
	`GCutCڋxt
();

585 
	}
}

587 
NAN_INLINE
 * 
GIlFldPor
(

588 
v8
::
Lol
<v8::
Obje
> 
obje


589 , 
dex
) {

590  
	gobje
->
GAligdPorFromIlFld
(
dex
);

593 
NAN_INLINE
 
SIlFldPor
(

594 
v8
::
Lol
<v8::
Obje
> 
obje


595 , 
dex


596 , * 
vue
) {

597 
	gobje
->
SAligdPorInIlFld
(
dex
, 
vue
);

600 
	#NAN_GC_CALLBACK
(
me
) \

601 
	$me
(
v8
::
Isީe
 *
isީe
, v8::
GCTy
 
ty
, v8::
GCClbackFgs
 
ags
)

	)

603 #i
NODE_MODULE_VERSION
 <
NODE_4_0_MODULE_VERSION


604 
v8
::
	tIsީe
::
	tGCEpogueClback
 GCEpilogueCallback;

605 
v8
::
	tIsީe
::
	tGCProgueClback
 GCPrologueCallback;

607 
v8
::
	tIsީe
::
	tGCClback
 
	tGCEpogueClback
;

608 
v8
::
	tIsީe
::
	tGCClback
 
	tGCProgueClback
;

611 
NAN_INLINE
 
	$AddGCEpogueClback
(

612 
GCEpogueClback
 
back


613 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

614 
v8
::
Isީe
::
	`GCut
()->
	`AddGCEpogueClback
(
back
, 
gc_ty_fr
);

615 
	}
}

617 
NAN_INLINE
 
	$RemoveGCEpogueClback
(

618 
GCEpogueClback
 
back
) {

619 
v8
::
Isީe
::
	`GCut
()->
	`RemoveGCEpogueClback
(
back
);

620 
	}
}

622 
NAN_INLINE
 
	$AddGCProgueClback
(

623 
GCProgueClback
 
back


624 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

625 
v8
::
Isީe
::
	`GCut
()->
	`AddGCProgueClback
(
back
, 
gc_ty_fr
);

626 
	}
}

628 
NAN_INLINE
 
	$RemoveGCProgueClback
(

629 
GCProgueClback
 
back
) {

630 
v8
::
Isީe
::
	`GCut
()->
	`RemoveGCProgueClback
(
back
);

631 
	}
}

633 
NAN_INLINE
 
	$GHpStiics
(

634 
v8
::
HpStiics
 *
hp_iics
) {

635 
v8
::
Isީe
::
	`GCut
()->
	`GHpStiics
(
hp_iics
);

636 
	}
}

638 
	#X
(
NAME
) \

639 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	$NAME
(cڡ *
msg
) { \

640 
EsbHdSce
 
sce
; \

641  
sce
.
	`Es
(
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

642 
	}
} \

644 
NAN_INLINE
 \

645 
v8
::
Lol
<v8::
Vue
> 
	`NAME
(v8::Lol<v8::
Sg
> 
msg
) { \

646  
v8
::
Exi
::
	`NAME
(
msg
); \

649 
NAN_INLINE
 
Throw
 ## 
	$NAME
(cڡ *
msg
) { \

650 
HdSce
 
sce
; \

651 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
( \

652 
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

653 
	}
} \

655 
NAN_INLINE
 
Throw
 ## 
	`NAME
(
v8
::
Lol
<v8::
Sg
> 
msg
) { \

656 
HdSce
 
sce
; \

657 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
( \

658 
v8
::
Exi
::
	`NAME
(
msg
)); \

659 }

	)

661 
	$X
(
E
)

662 
	$X
(
RgeE
)

663 
	$X
(
RenE
)

664 
	$X
(
SyaxE
)

665 
	$X
(
TyE
)

667 #unde
X


669 
NAN_INLINE
 
	`ThrowE
(
v8
::
Lol
<v8::
Vue
> 
r
) {

670 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
(
r
);

671 
	}
}

673 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
NewBufr
(

674 *
da


675 , 
size_t
 
ngth


676 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


677 , 
node
::
Bufr
::
FeClback
 
back


679 , 
node
::
smloc
::
FeClback
 
back


681 , *
ht


685 
as
(
ngth
 <
imp
::
kMaxLgth
 && "tooarge buffer");

686 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


687  
	gnode
::
Bufr
::
New
(

688 
v8
::
Isީe
::
GCut
(), 
da
, 
ngth
, 
back
, 
ht
);

690  
	gMaybeLol
<
	gv8
::
Obje
>(
node
::
Bufr
::
New
(

691 
v8
::
Isީe
::
GCut
(), 
da
, 
ngth
, 
back
, 
ht
));

695 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$CyBufr
(

696 cڡ *
da


697 , 
ut32_t
 
size


701 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

702 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


703  
node
::
Bufr
::
	`Cy
(

704 
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

706  
MaybeLol
<
v8
::
Obje
>(
node
::
Bufr
::
	`New
(

707 
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
));

709 
	}
}

711 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(
ut32_t
 
size
) {

714 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

715 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


716  
node
::
Bufr
::
	`New
(

717 
v8
::
Isީe
::
	`GCut
(), 
size
);

719  
MaybeLol
<
v8
::
Obje
>(
node
::
Bufr
::
	`New
(

720 
v8
::
Isީe
::
	`GCut
(), 
size
));

722 
	}
}

724 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

725 * 
da


726 , 
ut32_t
 
size


730 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

731 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


732  
node
::
Bufr
::
	`New
(
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

734  
MaybeLol
<
v8
::
Obje
>(

735 
node
::
Bufr
::
	`U
(
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
));

737 
	}
}

739 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

740 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

741 
NAN_INLINE
 
MaybeLol
<
v8
::
Sg
>

742 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

743  
v8
::
Sg
::
NewFromOBy
(v8::
Isީe
::
GCut
(), 
vue
,

744 
v8
::
NewSgTy
::
kNm
, 
ngth
);

747 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

748 
v8
::
Lol
<v8::
Sg
> 
s


749 , cڡ 
v8
::
StOrig
& 
ig


751 
v8
::
StComp
::
Sour
 
sour
(
s
, 
ig
);

752  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
sour
);

755 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

756 
v8
::
Lol
<v8::
Sg
> 
s


758 
v8
::
StComp
::
Sour
 
sour
(
s
);

759  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
sour
);

762 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

763 
v8
::
Lol
<
UnboundSt
> 
st


765  
st
->
BdToCutCڋxt
()->
Run
(
GCutCڋxt
());

768 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

769 
v8
::
Lol
<
BoundSt
> 
st


771  
st
->
Run
(
GCutCڋxt
());

774 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
>

775 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

776  
MaybeLol
<
v8
::
Sg
>(

777 
v8
::
Sg
::
NewFromOBy
(

778 
v8
::
Isީe
::
GCut
()

779 , 
vue


780 , 
v8
::
Sg
::
kNmSg
, 
ngth
));

783 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

784 
v8
::
Lol
<v8::
Sg
> 
s


785 , cڡ 
v8
::
StOrig
& 
ig


787 
v8
::
StComp
::
Sour
 
sour
(
s
, 
ig
);

788  
	gMaybeLol
<
	gBoundSt
>(

789 
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
sour
));

792 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

793 
v8
::
Lol
<v8::
Sg
> 
s


795 
v8
::
StComp
::
Sour
 
sour
(
s
);

796  
	gMaybeLol
<
	gBoundSt
>(

797 
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
sour
));

800 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

801 
v8
::
Lol
<
UnboundSt
> 
st


803  
MaybeLol
<
v8
::
Vue
>(
st
->
BdToCutCڋxt
()->
Run
());

806 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

807 
v8
::
Lol
<
BoundSt
> 
st


809  
MaybeLol
<
v8
::
Vue
>(
st
->
Run
());

813 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

814 
v8
::
Lol
<v8::
Obje
> 
rg


815 , 
v8
::
Lol
<v8::
Funi
> 
func


816 , 
gc


817 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

818 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


819  
New
(
node
::
MakeClback
(

820 
v8
::
Isީe
::
GCut
(), 
rg
, 
func
, 
gc
, 
gv
));

822  
	gnode
::
MakeClback
(

823 
v8
::
Isީe
::
GCut
(), 
rg
, 
func
, 
gc
, 
gv
);

827 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

828 
v8
::
Lol
<v8::
Obje
> 
rg


829 , 
v8
::
Lol
<v8::
Sg
> 
symb


830 , 
gc


831 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

832 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


833  
New
(
node
::
MakeClback
(

834 
v8
::
Isީe
::
GCut
(), 
rg
, 
symb
, 
gc
, 
gv
));

836  
	gnode
::
MakeClback
(

837 
v8
::
Isީe
::
GCut
(), 
rg
, 
symb
, 
gc
, 
gv
);

841 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

842 
v8
::
Lol
<v8::
Obje
> 
rg


843 , cڡ * 
mhod


844 , 
gc


845 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

846 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


847  
New
(
node
::
MakeClback
(

848 
v8
::
Isީe
::
GCut
(), 
rg
, 
mhod
, 
gc
, 
gv
));

850  
	gnode
::
MakeClback
(

851 
v8
::
Isީe
::
GCut
(), 
rg
, 
mhod
, 
gc
, 
gv
);

855 
NAN_INLINE
 
	$FExi
(cڡ 
TryCch
& 
y_tch
) {

856 
node
::
	`FExi
(
v8
::
Isީe
::
	`GCut
(), 
y_tch
.
y_tch_
);

857 
	}
}

859 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$EnoExi
(

860 
rno


861 , cڡ * 
sys
 = 
NULL


862 , cڡ * 
mesge
 = 
NULL


863 , cڡ * 
th
 = 
NULL
) {

864  
node
::
	`EnoExi
(
v8
::
Isީe
::
	`GCut
(), 
rno
, 
sys
,

865 
mesge
, 
th
);

866 
	}
}

868 
NAN_DEPRECATED
 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$NEnoExi
(

869 
rno


870 , cڡ * 
sys
 = 
NULL


871 , cڡ * 
mesge
 = 
NULL


872 , cڡ * 
th
 = 
NULL
) {

873  
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

874 
	}
}

876 
	gme
<
tyme
 
	gT
>

877 
NAN_INLINE
 
	$SIsީeDa
(

878 
v8
::
Isީe
 *
isީe


879 , 
T
 *
da


881 
isީe
->
	`SDa
(0, 
da
);

882 
	}
}

884 
	gme
<
tyme
 
	gT
>

885 
NAN_INLINE
 
T
 *
	$GIsީeDa
(

886 
v8
::
Isީe
 *
isީe


888  
ic_
<
T
*>(
isީe
->
	`GDa
(0));

889 
	}
}

891 as
	cUtf8Sg
 {

892 
	gpublic
:

893 
NAN_INLINE
 
exic
 
Utf8Sg
(
v8
::
Lol
<v8::
Vue
> 
om
) :

894 
ngth_
(0), 
r_
(
r__
) {

895 i(!
	gom
.
IsEmy
()) {

896 
	gv8
::
Lol
<
v8
::
Sg
> 
rg
 = 
om
->
ToSg
();

897 i(!
	grg
.
IsEmy
()) {

898 
size_t
 
	gn
 = 3 * 
rg
->
Lgth
() + 1;

899 
as
(
n
 <
INT_MAX
);

900 i(
	gn
 >  (
	gr__
)) {

901 
	gr_
 = 
ic_
<*>(
mloc
(
n
));

902 
as
(
r_
 != 0);

904 cڡ 
	gags
 =

905 
v8
::
Sg
::
NO_NULL_TERMINATION
 | 
imp
::
kRInvidUtf8
;

906 
	gngth_
 = 
rg
->
WreUtf8
(
r_
, 
ic_
<>(
n
), 0, 
ags
);

907 
	gr_
[
ngth_
] = '\0';

912 
NAN_INLINE
 
ngth
() const {

913  
	gngth_
;

916 
NAN_INLINE
 * 
	gݔ
*({  
	gr_
; }

917 
NAN_INLINE
 cڡ * 
	gݔ
*(cڡ {  
	gr_
; }

919 
	gNAN_INLINE
 ~
Utf8Sg
() {

920 i(
	gr_
 !
r__
) {

921 

(
r_
);

925 
	give
:

926 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Utf8Sg
)

928 
ngth_
;

929 *
	gr_
;

930 
	gr__
[1024];

934 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Undefed
() {

935 
EsbHdSce
 
sce
;

936  
sce
.
	`Es
(
	`New
(
v8
::
	`Undefed
()));

937 
	}
}

939 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Nu
() {

940 
EsbHdSce
 
sce
;

941  
sce
.
	`Es
(
	`New
(
v8
::
	`Nu
()));

942 
	}
}

944 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$True
() {

945 
EsbHdSce
 
sce
;

946  
sce
.
	`Es
(
	`New
(
v8
::
	`True
()));

947 
	}
}

949 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$F
() {

950 
EsbHdSce
 
sce
;

951  
sce
.
	`Es
(
	`New
(
v8
::
	`F
()));

952 
	}
}

954 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Sg
> 
	$EmySg
() {

955  
v8
::
Sg
::
	`Emy
();

956 
	}
}

958 
NAN_INLINE
 
	$AdjuExMemy
(
bc
) {

959  
ic_
<>(
v8
::
V8
::
	`AdjuAmouOfExAodMemy
(
bc
));

960 
	}
}

962 
NAN_INLINE
 
STeme
(

963 
v8
::
Lol
<v8::
Teme
> 
m


964 , cڡ *
me


965 , 
v8
::
Lol
<v8::
Da
> 
vue
) {

966 
m
->
S
(
me
, 
vue
);

969 
NAN_INLINE
 
STeme
(

970 
v8
::
Lol
<v8::
Teme
> 
m


971 , 
v8
::
Lol
<v8::
Sg
> 
me


972 , 
v8
::
Lol
<v8::
Da
> 
vue


973 , 
v8
::
PrݔtyAribu
 
ibus
) {

974 
m
->
S
(
me
, 
vue
, 
ibus
);

977 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
	$GCutCڋxt
() {

978  
v8
::
Cڋxt
::
	`GCut
();

979 
	}
}

981 
NAN_INLINE
 * 
GIlFldPor
(

982 
v8
::
Lol
<v8::
Obje
> 
obje


983 , 
dex
) {

984  
	gobje
->
GPorFromIlFld
(
dex
);

987 
NAN_INLINE
 
SIlFldPor
(

988 
v8
::
Lol
<v8::
Obje
> 
obje


989 , 
dex


990 , * 
vue
) {

991 
	gobje
->
SPorInIlFld
(
dex
, 
vue
);

994 
	#NAN_GC_CALLBACK
(
me
) \

995 
	$me
(
v8
::
GCTy
 
ty
, v8::
GCClbackFgs
 
ags
)

	)

997 
NAN_INLINE
 
	$AddGCEpogueClback
(

998 
v8
::
GCEpogueClback
 
back


999 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

1000 
v8
::
V8
::
	`AddGCEpogueClback
(
back
, 
gc_ty_fr
);

1001 
	}
}

1002 
NAN_INLINE
 
	$RemoveGCEpogueClback
(

1003 
v8
::
GCEpogueClback
 
back
) {

1004 
v8
::
V8
::
	`RemoveGCEpogueClback
(
back
);

1005 
	}
}

1006 
NAN_INLINE
 
	$AddGCProgueClback
(

1007 
v8
::
GCProgueClback
 
back


1008 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

1009 
v8
::
V8
::
	`AddGCProgueClback
(
back
, 
gc_ty_fr
);

1010 
	}
}

1011 
NAN_INLINE
 
	$RemoveGCProgueClback
(

1012 
v8
::
GCProgueClback
 
back
) {

1013 
v8
::
V8
::
	`RemoveGCProgueClback
(
back
);

1014 
	}
}

1015 
NAN_INLINE
 
	$GHpStiics
(

1016 
v8
::
HpStiics
 *
hp_iics
) {

1017 
v8
::
V8
::
	`GHpStiics
(
hp_iics
);

1018 
	}
}

1020 
	#X
(
NAME
) \

1021 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	$NAME
(cڡ *
msg
) { \

1022 
EsbHdSce
 
sce
; \

1023  
sce
.
	`Es
(
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

1024 
	}
} \

1026 
NAN_INLINE
 \

1027 
v8
::
Lol
<v8::
Vue
> 
	`NAME
(v8::Lol<v8::
Sg
> 
msg
) { \

1028  
v8
::
Exi
::
	`NAME
(
msg
); \

1031 
NAN_INLINE
 
Throw
 ## 
	$NAME
(cڡ *
msg
) { \

1032 
HdSce
 
sce
; \

1033 
v8
::
	`ThrowExi
(v8::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

1034 
	}
} \

1036 
NAN_INLINE
 \

1037 
Throw
 ## 
	`NAME
(
v8
::
Lol
<v8::
Sg
> 
rmsg
) { \

1038 
v8
::
	`ThrowExi
(v8::
Exi
::
	`NAME
(
rmsg
)); \

1039 }

	)

1041 
	$X
(
E
)

1042 
	$X
(
RgeE
)

1043 
	$X
(
RenE
)

1044 
	$X
(
SyaxE
)

1045 
	$X
(
TyE
)

1047 #unde
X


1049 
NAN_INLINE
 
	`ThrowE
(
v8
::
Lol
<v8::
Vue
> 
r
) {

1050 
v8
::
	`ThrowExi
(
r
);

1051 
	}
}

1053 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

1054 *
da


1055 , 
size_t
 
ngth


1056 , 
node
::
Bufr
::
_back
 
back


1057 , *
ht


1059 
EsbHdSce
 
sce
;

1062 
	`as
(
ngth
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1063  
MaybeLol
<
v8
::
Obje
>(
sce
.
	`Es
(

1064 
	`New
(
node
::
Bufr
::New(
da
, 
ngth
, 
back
, 
ht
)->
hd_
)));

1065 
	}
}

1067 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$CyBufr
(

1068 cڡ *
da


1069 , 
ut32_t
 
size


1071 
EsbHdSce
 
sce
;

1074 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1075 #i
NODE_MODULE_VERSION
 >
NODE_0_10_MODULE_VERSION


1076  
MaybeLol
<
v8
::
Obje
>(

1077 
sce
.
	`Es
(
	`New
(
node
::
Bufr
::New(
da
, 
size
)->
hd_
)));

1079  
MaybeLol
<
v8
::
Obje
>(
sce
.
	`Es
(

1080 
	`New
(
node
::
Bufr
::New(
cڡ_
<*>(
da
), 
size
)->
hd_
)));

1082 
	}
}

1084 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(
ut32_t
 
size
) {

1087 
EsbHdSce
 
sce
;

1088 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1089  
MaybeLol
<
v8
::
Obje
>(

1090 
sce
.
	`Es
(
	`New
(
node
::
Bufr
::New(
size
)->
hd_
)));

1091 
	}
}

1093 
NAN_INLINE
 
	$FeDa
(*
da
, *
ht
) {

1094 (
ht
;

1095 
de
[] 
da
;

1096 
	}
}

1098 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

1099 * 
da


1100 , 
ut32_t
 
size


1102 
EsbHdSce
 
sce
;

1105 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1106  
MaybeLol
<
v8
::
Obje
>(
sce
.
	`Es
(
	`New
(

1107 
node
::
Bufr
::
	`New
(
da
, 
size
, 
FeDa
, 
NULL
)->
hd_
)));

1108 
	}
}

1110 
mea
 
	gimp
 {

1111 
NAN_INLINE
 

1112 
widSg
(
d
::
ve
<
ut16_t
> *
ws
, cڡ 
ut8_t
 *
s
, 
l
) {

1113 
size_t
 
	gn
 = 
ic_
<size_t>(
l
);

1114 i(
	gl
 < 0) {

1115 
	gn
 = 

(
t_
<cڡ *>(
s
));

1117 
as
(
n
 <
INT_MAX
 && "stringooong");

1118 
	gws
->
size
(
n
);

1119 
	gd
::
cy
(
s
, s + 
n
, 
ws
->
beg
());

1123 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
>

1124 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

1125 
d
::
ve
<
ut16_t
> 
wideSg
;

1126 
	gimp
::
widSg
(&
wideSg
, 
vue
, 
ngth
);

1127  
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
New
(

1128 &
wideSg
.
t
(), 
ic_
<>(wideSg.
size
())));

1131 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

1132 
v8
::
Lol
<v8::
Sg
> 
s


1133 , cڡ 
v8
::
StOrig
& 
ig


1135  
MaybeLol
<
BoundSt
>(

1136 
v8
::
St
::
Compe
(
s
, 
cڡ_
<v8::
StOrig
 *>(&
ig
)));

1139 
NAN_INLINE
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

1140 
v8
::
Lol
<v8::
Sg
> 
s


1142  
MaybeLol
<
BoundSt
>(
v8
::
St
::
Compe
(
s
));

1145 
NAN_INLINE


1146 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(
v8
::
Lol
<v8::
St
> 
st
) {

1147  
MaybeLol
<
v8
::
Vue
>(
st
->
Run
());

1150 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1151 
v8
::
Lol
<v8::
Obje
> 
rg


1152 , 
v8
::
Lol
<v8::
Funi
> 
func


1153 , 
gc


1154 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1155  
New
(
node
::
MakeClback
(
rg
, 
func
, 
gc
, 
gv
));

1158 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1159 
v8
::
Lol
<v8::
Obje
> 
rg


1160 , 
v8
::
Lol
<v8::
Sg
> 
symb


1161 , 
gc


1162 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1163  
New
(
node
::
MakeClback
(
rg
, 
symb
, 
gc
, 
gv
));

1166 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1167 
v8
::
Lol
<v8::
Obje
> 
rg


1168 , cڡ * 
mhod


1169 , 
gc


1170 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1171  
New
(
node
::
MakeClback
(
rg
, 
mhod
, 
gc
, 
gv
));

1174 
NAN_INLINE
 
	$FExi
(cڡ 
TryCch
& 
y_tch
) {

1175 
node
::
	`FExi
(
cڡ_
<
v8
::
TryCch
 &>(
y_tch
.
y_tch_
));

1176 
	}
}

1178 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$EnoExi
(

1179 
rno


1180 , cڡ * 
sys
 = 
NULL


1181 , cڡ * 
mesge
 = 
NULL


1182 , cڡ * 
th
 = 
NULL
) {

1183  
node
::
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

1184 
	}
}

1186 
NAN_DEPRECATED
 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$NEnoExi
(

1187 
rno


1188 , cڡ * 
sys
 = 
NULL


1189 , cڡ * 
mesge
 = 
NULL


1190 , cڡ * 
th
 = 
NULL
) {

1191  
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

1192 
	}
}

1195 
	gme
<
tyme
 
	gT
>

1196 
NAN_INLINE
 
	$SIsީeDa
(

1197 
v8
::
Isީe
 *
isީe


1198 , 
T
 *
da


1200 
isީe
->
	`SDa
(
da
);

1201 
	}
}

1203 
	gme
<
tyme
 
	gT
>

1204 
NAN_INLINE
 
T
 *
	$GIsީeDa
(

1205 
v8
::
Isީe
 *
isީe


1207  
ic_
<
T
*>(
isީe
->
	`GDa
());

1208 
	}
}

1210 as
	cUtf8Sg
 {

1211 
	gpublic
:

1212 
NAN_INLINE
 
exic
 
Utf8Sg
(
v8
::
Lol
<v8::
Vue
> 
om
) :

1213 
ngth_
(0), 
r_
(
r__
) {

1214 i(!
	gom
.
IsEmy
()) {

1215 
	gv8
::
Lol
<
v8
::
Sg
> 
rg
 = 
om
->
ToSg
();

1216 i(!
	grg
.
IsEmy
()) {

1217 
size_t
 
	gn
 = 3 * 
rg
->
Lgth
() + 1;

1218 
as
(
n
 <
INT_MAX
);

1219 i(
	gn
 >  (
	gr__
)) {

1220 
	gr_
 = 
ic_
<*>(
mloc
(
n
));

1221 
as
(
r_
 != 0);

1223 cڡ 
	gags
 =

1224 
v8
::
Sg
::
NO_NULL_TERMINATION
 | 
imp
::
kRInvidUtf8
;

1225 
	gngth_
 = 
rg
->
WreUtf8
(
r_
, 
ic_
<>(
n
), 0, 
ags
);

1226 
	gr_
[
ngth_
] = '\0';

1231 
NAN_INLINE
 
ngth
() const {

1232  
	gngth_
;

1235 
NAN_INLINE
 * 
	gݔ
*({  
	gr_
; }

1236 
NAN_INLINE
 cڡ * 
	gݔ
*(cڡ {  
	gr_
; }

1238 
	gNAN_INLINE
 ~
Utf8Sg
() {

1239 i(
	gr_
 !
r__
) {

1240 

(
r_
);

1244 
	give
:

1245 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Utf8Sg
)

1247 
ngth_
;

1248 *
	gr_
;

1249 
	gr__
[1024];

1254 (*
	tFeClback
)(*
	tda
, *
	tht
);

1256 cڡ 
	tFuniClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_METHOD_ARGS_TYPE
;

1257 
	tNAN_METHOD_RETURN_TYPE
;

1259 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_GETTER_ARGS_TYPE
;

1260 
	tNAN_GETTER_RETURN_TYPE
;

1262 cڡ 
	tPrݔtyClbackInfo
<>& 
	tNAN_SETTER_ARGS_TYPE
;

1263 
	tNAN_SETTER_RETURN_TYPE
;

1265 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&

1266 
	tNAN_PROPERTY_GETTER_ARGS_TYPE
;

1267 
	tNAN_PROPERTY_GETTER_RETURN_TYPE
;

1269 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&

1270 
	tNAN_PROPERTY_SETTER_ARGS_TYPE
;

1271 
	tNAN_PROPERTY_SETTER_RETURN_TYPE
;

1273 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&

1274 
	tNAN_PROPERTY_ENUMERATOR_ARGS_TYPE
;

1275 
	tNAN_PROPERTY_ENUMERATOR_RETURN_TYPE
;

1277 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&

1278 
	tNAN_PROPERTY_DELETER_ARGS_TYPE
;

1279 
	tNAN_PROPERTY_DELETER_RETURN_TYPE
;

1281 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&

1282 
	tNAN_PROPERTY_QUERY_ARGS_TYPE
;

1283 
	tNAN_PROPERTY_QUERY_RETURN_TYPE
;

1285 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_INDEX_GETTER_ARGS_TYPE
;

1286 
	tNAN_INDEX_GETTER_RETURN_TYPE
;

1288 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_INDEX_SETTER_ARGS_TYPE
;

1289 
	tNAN_INDEX_SETTER_RETURN_TYPE
;

1291 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&

1292 
	tNAN_INDEX_ENUMERATOR_ARGS_TYPE
;

1293 
	tNAN_INDEX_ENUMERATOR_RETURN_TYPE
;

1295 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&

1296 
	tNAN_INDEX_DELETER_ARGS_TYPE
;

1297 
	tNAN_INDEX_DELETER_RETURN_TYPE
;

1299 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&

1300 
	tNAN_INDEX_QUERY_ARGS_TYPE
;

1301 
	tNAN_INDEX_QUERY_RETURN_TYPE
;

1303 
	#NAN_METHOD
(
me
) \

1304 
N
::
NAN_METHOD_RETURN_TYPE
 
	$me
(
N
::
NAN_METHOD_ARGS_TYPE
 
fo
)

	)

1305 
	#NAN_GETTER
(
me
) \

1306 
N
::
NAN_GETTER_RETURN_TYPE
 
	`me
( \

1307 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1308 , 
N
::
NAN_GETTER_ARGS_TYPE
 
fo
)

	)

1309 
	#NAN_SETTER
(
me
) \

1310 
N
::
NAN_SETTER_RETURN_TYPE
 
	`me
( \

1311 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1312 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1313 , 
N
::
NAN_SETTER_ARGS_TYPE
 
fo
)

	)

1314 
	#NAN_PROPERTY_GETTER
(
me
) \

1315 
N
::
NAN_PROPERTY_GETTER_RETURN_TYPE
 
	`me
( \

1316 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1317 , 
N
::
NAN_PROPERTY_GETTER_ARGS_TYPE
 
fo
)

	)

1318 
	#NAN_PROPERTY_SETTER
(
me
) \

1319 
N
::
NAN_PROPERTY_SETTER_RETURN_TYPE
 
	`me
( \

1320 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1321 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1322 , 
N
::
NAN_PROPERTY_SETTER_ARGS_TYPE
 
fo
)

	)

1323 
	#NAN_PROPERTY_ENUMERATOR
(
me
) \

1324 
N
::
NAN_PROPERTY_ENUMERATOR_RETURN_TYPE
 
	`me
( \

1325 
N
::
NAN_PROPERTY_ENUMERATOR_ARGS_TYPE
 
fo
)

	)

1326 
	#NAN_PROPERTY_DELETER
(
me
) \

1327 
N
::
NAN_PROPERTY_DELETER_RETURN_TYPE
 
	`me
( \

1328 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1329 , 
N
::
NAN_PROPERTY_DELETER_ARGS_TYPE
 
fo
)

	)

1330 
	#NAN_PROPERTY_QUERY
(
me
) \

1331 
N
::
NAN_PROPERTY_QUERY_RETURN_TYPE
 
	`me
( \

1332 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1333 , 
N
::
NAN_PROPERTY_QUERY_ARGS_TYPE
 
fo
)

	)

1334 
	#NAN_INDEX_GETTER
(
me
) \

1335 
N
::
NAN_INDEX_GETTER_RETURN_TYPE
 
	`me
( \

1336 
ut32_t
 
dex
 \

1337 , 
N
::
NAN_INDEX_GETTER_ARGS_TYPE
 
fo
)

	)

1338 
	#NAN_INDEX_SETTER
(
me
) \

1339 
N
::
NAN_INDEX_SETTER_RETURN_TYPE
 
	`me
( \

1340 
ut32_t
 
dex
 \

1341 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1342 , 
N
::
NAN_INDEX_SETTER_ARGS_TYPE
 
fo
)

	)

1343 
	#NAN_INDEX_ENUMERATOR
(
me
) \

1344 
N
::
NAN_INDEX_ENUMERATOR_RETURN_TYPE
 \

1345 
	$me
(
N
::
NAN_INDEX_ENUMERATOR_ARGS_TYPE
 
fo
)

	)

1346 
	#NAN_INDEX_DELETER
(
me
) \

1347 
N
::
NAN_INDEX_DELETER_RETURN_TYPE
 
	`me
( \

1348 
ut32_t
 
dex
 \

1349 , 
N
::
NAN_INDEX_DELETER_ARGS_TYPE
 
fo
)

	)

1350 
	#NAN_INDEX_QUERY
(
me
) \

1351 
N
::
NAN_INDEX_QUERY_RETURN_TYPE
 
	`me
( \

1352 
ut32_t
 
dex
 \

1353 , 
N
::
NAN_INDEX_QUERY_ARGS_TYPE
 
fo
)

	)

1355 as
	cClback
 {

1356 
public
:

1357 
	`Clback
() {

1358 
HdSce
 
sce
;

1359 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
New
<v8::Object>();

1360 
hd
.
	`Ret
(
obj
);

1363 
exic
 
	`Clback
(cڡ 
v8
::
Lol
<v8::
Funi
> &

) {

1364 
HdSce
 
sce
;

1365 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
New
<v8::Object>();

1366 
hd
.
	`Ret
(
obj
);

1367 
	`SFuni
(

);

1370 ~
	`Clback
() {

1371 i(
hd
.
	`IsEmy
()) ;

1372 
hd
.
	`Ret
();

1375 
bo
 
ݔ
==(cڡ 
Clback
 &
h
) const {

1376 
HdSce
 
sce
;

1377 
v8
::
Lol
<v8::
Vue
> 
a
 = 
	`New
(
hd
)->
	`G
(
kClbackIndex
);

1378 
v8
::
Lol
<v8::
Vue
> 
b
 = 
	`New
(
h
.
hd
)->
	`G
(
kClbackIndex
);

1379  
a
->
	`SiEqus
(
b
);

1382 
bo
 
ݔ
!=(cڡ 
Clback
 &
h
) const {

1383  !
this
->
ݔ
==(
h
);

1386 
NAN_INLINE


1387 
v8
::
Lol
<v8::
Funi
> 
ݔ
*(cڡ {  
this
->
	`GFuni
(); }

1389 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	`ݔ
()(

1390 
v8
::
Lol
<v8::
Obje
> 
rg


1391 , 
gc
 = 0

1392 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1393  
this
->
	`Cl
(
rg
, 
gc
, 
gv
);

1396 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
> 
	`ݔ
()(

1397 
gc
 = 0

1398 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1399  
this
->
	`Cl
(
gc
, 
gv
);

1402 
NAN_INLINE
 
	`SFuni
(cڡ 
v8
::
Lol
<v8::
Funi
> &

) {

1403 
HdSce
 
sce
;

1404 
	`S
(
	`New
(
hd
), 
kClbackIndex
, 

);

1407 
NAN_INLINE
 
v8
::
Lol
<v8::
Funi
> 
	`GFuni
() const {

1408 
EsbHdSce
 
sce
;

1409  
sce
.
	`Es
(
	`New
(
hd
)->
	`G
(
kClbackIndex
)

1410 .
As
<
v8
::
Funi
>());

1413 
NAN_INLINE
 
bo
 
	`IsEmy
() const {

1414 
HdSce
 
sce
;

1415  
	`New
(
hd
)->
	`G
(
kClbackIndex
)->
	`IsUndefed
();

1418 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
>

1419 
	`Cl
(
v8
::
Lol
<v8::
Obje
> 
rg


1420 , 
gc


1421 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1422 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1423 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1424  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
);

1426  
	`Cl_
(
rg
, 
gc
, 
gv
);

1430 
NAN_INLINE
 
v8
::
Lol
<v8::
Vue
>

1431 
	`Cl
(
gc
, 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1432 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1433 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1434  
	`Cl_
(
isީe
, isީe->
	`GCutCڋxt
()->
	`Glob
(), 
gc
, 
gv
);

1436  
	`Cl_
(
v8
::
Cڋxt
::
	`GCut
()->
	`Glob
(), 
gc
, 
gv
);

1440 
ive
:

1441 
	`NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Clback
)

1442 
Psit
<
v8
::
Obje
> 
hd
;

1443 cڡ 
ut32_t
 
kClbackIndex
 = 0;

1445 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1446 
v8
::
Lol
<v8::
Vue
> 
	`Cl_
(v8::
Isީe
 *
isީe


1447 , 
v8
::
Lol
<v8::
Obje
> 
rg


1448 , 
gc


1449 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1450 
EsbHdSce
 
sce
;

1452 
v8
::
Lol
<v8::
Funi
> 
back
 = 
	`New
(
hd
)->

1453 
	`G
(
kClbackIndex
).
As
<
v8
::
Funi
>();

1454 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


1455  
sce
.
	`Es
(
	`New
(
node
::
	`MakeClback
(

1456 
isީe


1457 , 
rg


1458 , 
back


1459 , 
gc


1460 , 
gv


1463  
sce
.
	`Es
(
node
::
	`MakeClback
(

1464 
isީe


1465 , 
rg


1466 , 
back


1467 , 
gc


1468 , 
gv


1473 
v8
::
Lol
<v8::
Vue
> 
	`Cl_
(v8::Lol<v8::
Obje
> 
rg


1474 , 
gc


1475 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1476 
EsbHdSce
 
sce
;

1478 
v8
::
Lol
<v8::
Funi
> 
back
 = 
	`New
(
hd
)->

1479 
	`G
(
kClbackIndex
).
As
<
v8
::
Funi
>();

1480  
sce
.
	`Es
(
	`New
(
node
::
	`MakeClback
(

1481 
rg


1482 , 
back


1483 , 
gc


1484 , 
gv


1488 
	}
};

1490  cs
	cAsyncWk
 {

1491 
	gpublic
:

1492 
exic
 
AsyncWk
(
Clback
 *
back_
)

1493 : 
back
(
back_
), 
rmsg_
(
NULL
) {

1494 
	gque
.
	gda
 = 
this
;

1496 
HdSce
 
	gsce
;

1497 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
New
<v8::Object>();

1498 
	grsitHd
.
Ret
(
obj
);

1501 
	gvtu
 ~
AsyncWk
() {

1502 
HdSce
 
	gsce
;

1504 i(!
	grsitHd
.
IsEmy
())

1505 
	grsitHd
.
Ret
();

1506 
de
 
	gback
;

1507 
	gde
[] 
	grmsg_
;

1510 
vtu
 
WkCome
() {

1511 
HdSce
 
	gsce
;

1513 i(
	grmsg_
 =
NULL
)

1514 
HdOKClback
();

1516 
HdEClback
();

1517 
de
 
	gback
;

1518 
	gback
 = 
NULL
;

1521 
NAN_INLINE
 
SaveToPsit
(

1522 cڡ *
key
, cڡ 
v8
::
Lol
<v8::
Vue
> &
vue
) {

1523 
HdSce
 
sce
;

1524 
New
(
rsitHd
)->
S
(New(
key
).
ToLolChecked
(), 
vue
);

1527 
NAN_INLINE
 
SaveToPsit
(

1528 cڡ 
v8
::
Lol
<v8::
Sg
> &
key
, cڡ v8::Lol<v8::
Vue
> &
vue
) {

1529 
HdSce
 
sce
;

1530 
New
(
rsitHd
)->
S
(
key
, 
vue
);

1533 
NAN_INLINE
 
SaveToPsit
(

1534 
ut32_t
 
dex
, cڡ 
v8
::
Lol
<v8::
Vue
> &
vue
) {

1535 
HdSce
 
sce
;

1536 
New
(
rsitHd
)->
S
(
dex
, 
vue
);

1539 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
GFromPsit
(cڡ *
key
) const {

1540 
EsbHdSce
 
sce
;

1541  
	gsce
.
Es
(

1542 
New
(
rsitHd
)->
G
(New(
key
).
ToLolChecked
()));

1545 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
>

1546 
GFromPsit
(cڡ 
v8
::
Lol
<v8::
Sg
> &
key
) const {

1547 
EsbHdSce
 
sce
;

1548  
	gsce
.
Es
(
New
(
rsitHd
)->
G
(
key
));

1551 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
GFromPsit
(
ut32_t
 
dex
) const {

1552 
EsbHdSce
 
sce
;

1553  
	gsce
.
Es
(
New
(
rsitHd
)->
G
(
dex
));

1556 
vtu
 
Execu
() = 0;

1558 
uv_wk_t
 
	gque
;

1560 
vtu
 
Deroy
() {

1561 
de
 
	gthis
;

1564 
	geed
:

1565 
Psit
<
v8
::
Obje
> 
rsitHd
;

1566 
Clback
 *
	gback
;

1568 
vtu
 
HdOKClback
() {

1569 
	gback
->
Cl
(0, 
NULL
);

1572 
vtu
 
HdEClback
() {

1573 
HdSce
 
	gsce
;

1575 
	gv8
::
Lol
<
v8
::
Vue
> 
gv
[] = {

1576 
v8
::
Exi
::
E
(
New
<v8::
Sg
>(
EMesge
()).
ToLolChecked
())

1578 
	gback
->
Cl
(1, 
gv
);

1581 
SEMesge
(cڡ *
msg
) {

1582 
	gde
[] 
	grmsg_
;

1584 
size_t
 
	gsize
 = 

(
msg
) + 1;

1585 
	grmsg_
 = 
w
 [
size
];

1586 
memy
(
rmsg_
, 
msg
, 
size
);

1589 cڡ * 
EMesge
() const {

1590  
	grmsg_
;

1593 
	give
:

1594 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
AsyncWk
)

1595 *
rmsg_
;

1598  cs
	cAsyncProgssWk
 : 
public
 
AsyncWk
 {

1599 
public
:

1600 
exic
 
AsyncProgssWk
(
Clback
 *
back_
)

1601 : 
AsyncWk
(
back_
), 
asyncda_
(
NULL
), 
asyncsize_
(0) {

1602 
	gasync
 = 
w
 
uv_async_t
;

1603 
uv_async_
(

1604 
uv_deu_lo
()

1605 , 
async


1606 , 
AsyncProgss_


1608 
	gasync
->
	gda
 = 
this
;

1610 
uv_mux_
(&
async_lock
);

1613 
	gvtu
 ~
AsyncProgssWk
() {

1614 
uv_mux_deroy
(&
async_lock
);

1616 
	gde
[] 
	gasyncda_
;

1619 
WkProgss
() {

1620 
uv_mux_lock
(&
async_lock
);

1621 *
	gda
 = 
asyncda_
;

1622 
size_t
 
	gsize
 = 
asyncsize_
;

1623 
	gasyncda_
 = 
NULL
;

1624 
uv_mux_uock
(&
async_lock
);

1627 i(
	gback
) {

1628 
HdProgssClback
(
da
, 
size
);

1630 
	gde
[] 
	gda
;

1633 as
	cExecutiProgss
 {

1634 
nd
 
ass
 
	gAsyncProgssWk
;

1635 
	gpublic
:

1636 
Sigl
() const {

1637 
uv_async_nd
(
th_
->
async
);

1640 
Sd
(cڡ * 
da
, 
size_t
 
size
) const {

1641 
	gth_
->
SdProgss_
(
da
, 
size
);

1644 
	give
:

1645 
exic
 
ExecutiProgss
(
AsyncProgssWk
* 
th
: 
th_
(that) {}

1646 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
ExecutiProgss
)

1647 
AsyncProgssWk
* cڡ 
th_
;

1650 
vtu
 
Execu
(cڡ 
ExecutiProgss
& 
ogss
) = 0;

1651 
vtu
 
HdProgssClback
(cڡ *
da
, 
size_t
 
size
) = 0;

1653 
vtu
 
Deroy
() {

1654 
uv_o
(
t_
<
uv_hd_t
*>(
async
), 
AsyncClo_
);

1657 
	give
:

1658 
Execu
() {

1659 
ExecutiProgss
 
ogss
(
this
);

1660 
Execu
(
ogss
);

1663 
SdProgss_
(cڡ *
da
, 
size_t
 
size
) {

1664 *
	gw_da
 = 
w
 [
size
];

1665 
memy
(
w_da
, 
da
, 
size
);

1667 
uv_mux_lock
(&
async_lock
);

1668 *
	gd_da
 = 
asyncda_
;

1669 
	gasyncda_
 = 
w_da
;

1670 
	gasyncsize_
 = 
size
;

1671 
uv_mux_uock
(&
async_lock
);

1673 
	gde
[] 
	gd_da
;

1674 
uv_async_nd
(
async
);

1677 
NAN_INLINE
 
NAUV_WORK_CB
(
AsyncProgss_
) {

1678 
AsyncProgssWk
 *
	gwk
 =

1679 
ic_
<
AsyncProgssWk
*>(
async
->
da
);

1680 
	gwk
->
WkProgss
();

1683 
NAN_INLINE
 
AsyncClo_
(
uv_hd_t
* 
hd
) {

1684 
AsyncProgssWk
 *
	gwk
 =

1685 
ic_
<
AsyncProgssWk
*>(
hd
->
da
);

1686 
de
 
	gt_
<
	guv_async_t
*>(
	ghd
);

1687 
de
 
	gwk
;

1690 
uv_async_t
 *
	gasync
;

1691 
uv_mux_t
 
	gasync_lock
;

1692 *
	gasyncda_
;

1693 
size_t
 
	gasyncsize_
;

1696 
NAN_INLINE
 
	$AsyncExecu
 (
uv_wk_t
* 
q
) {

1697 
AsyncWk
 *
wk
 = 
ic_
<AsyncWk*>(
q
->
da
);

1698 
wk
->
	`Execu
();

1699 
	}
}

1701 
NAN_INLINE
 
	$AsyncExecuCome
 (
uv_wk_t
* 
q
) {

1702 
AsyncWk
* 
wk
 = 
ic_
<AsyncWk*>(
q
->
da
);

1703 
wk
->
	`WkCome
();

1704 
wk
->
	`Deroy
();

1705 
	}
}

1707 
NAN_INLINE
 
	$AsyncQueueWk
 (
AsyncWk
* 
wk
) {

1708 
	`uv_queue_wk
(

1709 
	`uv_deu_lo
()

1710 , &
wk
->
que


1711 , 
AsyncExecu


1712 , 
t_
<
uv_a_wk_cb
>(
AsyncExecuCome
)

1714 
	}
}

1716 
mea
 
	gimp
 {

1718 
le


1719 
ExOBySgResour
 const*

1720 
GExResour
(
v8
::
Lol
<v8::
Sg
> 
r
) {

1721 #i
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION


1722  
r
->
GExAsciiSgResour
();

1724  
	gr
->
GExOBySgResour
();

1728 
le


1729 
bo


1730 
IsEx
(
v8
::
Lol
<v8::
Sg
> 
r
) {

1731 #i
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION


1732  
r
->
IsExAscii
();

1734  
	gr
->
IsExOBy
();

1740 
	eEncodg
 {
	gASCII
, 
	gUTF8
, 
	gBASE64
, 
	gUCS2
, 
	gBINARY
, 
	gHEX
, 
	gBUFFER
};

1742 #i
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION


1743 
	~"n_rg_bys.h
"

1746 
NAN_INLINE
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Encode
(

1747 cڡ *
buf
, 
size_t
 
n
, 
Encodg
 
codg
 = 
BINARY
) {

1748 #i(
NODE_MODULE_VERSION
 >
ATOM_0_21_MODULE_VERSION
)

1749 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
	`GCut
();

1750 
node
::
codg
 
node_c
 = 
ic_
<node::encoding>(encoding);

1752 i(
codg
 =
UCS2
) {

1753  
node
::
	`Encode
(

1754 
isީe


1755 , 
t_
<cڡ 
ut16_t
 *>(
buf
)

1756 , 
n
 / 2);

1758  
node
::
	`Encode
(

1759 
isީe


1760 , 
t_
<cڡ *>(
buf
)

1761 , 
n


1762 , 
node_c
);

1764 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1765  
node
::
	`Encode
(

1766 
v8
::
Isީe
::
	`GCut
()

1767 , 
buf
, 
n


1768 , 
ic_
<
node
::
codg
>(encoding));

1770 #i
NODE_MODULE_VERSION
 >
NODE_0_10_MODULE_VERSION


1771  
node
::
	`Encode
(
buf
, 
n
, 
ic_
<node::
codg
>(encoding));

1773  
imp
::
	`Encode
(
t_
<cڡ *>(
buf
), 
n
, 
codg
);

1776 
	}
}

1778 
NAN_INLINE
 
ssize_t
 
DecodeBys
(

1779 
v8
::
Lol
<v8::
Vue
> 
v
, 
Encodg
 
codg
 = 
BINARY
) {

1780 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1781  
node
::
DecodeBys
(

1782 
v8
::
Isީe
::
GCut
()

1783 , 
v


1784 , 
ic_
<
node
::
codg
>(encoding));

1786 #i(
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION
)

1787 i(
	gcodg
 =
BUFFER
) {

1788  
node
::
DecodeBys
(
v
,ode::
BINARY
);

1791  
	gnode
::
DecodeBys
(
v
, 
ic_
<
node
::
codg
>(encoding));

1795 
NAN_INLINE
 
ssize_t
 
DecodeWre
(

1796 *
buf


1797 , 
size_t
 
n


1798 , 
v8
::
Lol
<v8::
Vue
> 
v


1799 , 
Encodg
 
codg
 = 
BINARY
) {

1800 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

1801  
node
::
DecodeWre
(

1802 
v8
::
Isީe
::
GCut
()

1803 , 
buf


1804 , 
n


1805 , 
v


1806 , 
ic_
<
node
::
codg
>(encoding));

1808 #i(
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION
)

1809 i(
	gcodg
 =
BUFFER
) {

1810  
node
::
DecodeWre
(
buf
, 
n
, 
v
,ode::
BINARY
);

1813  
	gnode
::
DecodeWre
(

1814 
buf


1815 , 
n


1816 , 
v


1817 , 
ic_
<
node
::
codg
>(encoding));

1821 
NAN_INLINE
 
SPryTeme
(

1822 
v8
::
Lol
<v8::
FuniTeme
> 
m


1823 , cڡ *
me


1824 , 
v8
::
Lol
<v8::
Da
> 
vue


1826 
STeme
(
m
->
PryTeme
(), 
me
, 
vue
);

1829 
NAN_INLINE
 
SPryTeme
(

1830 
v8
::
Lol
<v8::
FuniTeme
> 
m


1831 , 
v8
::
Lol
<v8::
Sg
> 
me


1832 , 
v8
::
Lol
<v8::
Da
> 
vue


1833 , 
v8
::
PrݔtyAribu
 
ibus


1835 
STeme
(
m
->
PryTeme
(), 
me
, 
vue
, 
ibus
);

1838 
NAN_INLINE
 
SInTeme
(

1839 
v8
::
Lol
<v8::
FuniTeme
> 
m


1840 , cڡ *
me


1841 , 
v8
::
Lol
<v8::
Da
> 
vue


1843 
STeme
(
m
->
InTeme
(), 
me
, 
vue
);

1846 
NAN_INLINE
 
SInTeme
(

1847 
v8
::
Lol
<v8::
FuniTeme
> 
m


1848 , 
v8
::
Lol
<v8::
Sg
> 
me


1849 , 
v8
::
Lol
<v8::
Da
> 
vue


1850 , 
v8
::
PrݔtyAribu
 
ibus


1852 
STeme
(
m
->
InTeme
(), 
me
, 
vue
, 
ibus
);

1855 
mea
 
	gimp
 {

1861 
	gme
 <
tyme
 
	gT
>

1862 
NAN_INLINE


1864 
SMhodAux
(
T
 
cv
,

1865 
v8
::
Lol
<v8::
Sg
> 
me
,

1866 
v8
::
Lol
<v8::
FuniTeme
> 
l
,

1867 
v8
::
Teme
 *) {

1868 
cv
->
S
(
me
, 
l
);

1871 
	gme
 <
tyme
 
	gT
>

1872 
NAN_INLINE


1874 
SMhodAux
(
T
 
cv
,

1875 
v8
::
Lol
<v8::
Sg
> 
me
,

1876 
v8
::
Lol
<v8::
FuniTeme
> 
l
,

1878 
	gcv
->
S
(
me
, 
GFuni
(
l
).
ToLolChecked
());

1883 
	gme
 <
tyme
 
	gT
,em<
	gtyme
> 
ass
 
	gHdTy
>

1884 
NAN_INLINE
 
SMhod
(

1885 
HdTy
<
T
> 
cv


1886 , cڡ *
me


1887 , 
FuniClback
 
back
) {

1888 
HdSce
 
	gsce
;

1889 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
t
 = 
New
<v8::FuniTeme>(
back
);

1890 
	gv8
::
Lol
<
v8
::
Sg
> 
_me
 = 
New
(
me
).
ToLolChecked
();

1891 
	gt
->
SCssName
(
_me
);

1894 
	gimp
::
SMhodAux
(
cv
, 
_me
, 
t
, 
ic_
<
T
*>(0));

1897 
NAN_INLINE
 
SPryMhod
(

1898 
v8
::
Lol
<v8::
FuniTeme
> 
cv


1899 , cڡ * 
me
, 
FuniClback
 
back
) {

1900 
HdSce
 
	gsce
;

1901 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
t
 = 
New
<v8::FunctionTemplate>(

1902 
back


1903 , 
	gv8
::
Lol
<
v8
::
Vue
>()

1904 , 
	gNew
<
	gv8
::
Sigtu
>(
cv
));

1905 
	gv8
::
Lol
<
v8
::
Sg
> 
_me
 = 
New
(
me
).
ToLolChecked
();

1906 
	gcv
->
PryTeme
()->
S
(
_me
, 
t
);

1907 
	gt
->
SCssName
(
_me
);

1912 
le
 
SAcss
(

1913 
v8
::
Lol
<v8::
ObjeTeme
> 
l


1914 , 
v8
::
Lol
<v8::
Sg
> 
me


1915 , 
GrClback
 
gr


1916 , 
SrClback
 

 = 0

1917 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

1918 , 
v8
::
AcssCڌ
 
gs
 = v8::
DEFAULT


1919 , 
v8
::
PrݔtyAribu
 
ibu
 = v8::
Ne


1920 , 
imp
::
Sig
 
sigtu
 = imp::
	$Sig
()) {

1921 
HdSce
 
sce
;

1923 
imp
::
NiveGr
 
gr_
 =

1924 
imp
::
GrClbackW
;

1925 
imp
::
NiveSr
 
_
 =

1926 

 ? 
imp
::
SrClbackW
 : 0;

1928 
v8
::
Lol
<v8::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

1929 
ٶ
->
	`SIlFldCou
(
imp
::
kAcssFldCou
);

1930 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
	`NewIn
(
ٶ
).
	`ToLolChecked
();

1932 
obj
->
	`SIlFld
(

1933 
imp
::
kGrIndex


1934 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

1936 i(

 != 0) {

1937 
obj
->
	`SIlFld
(

1938 
imp
::
kSrIndex


1939 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

1942 i(!
da
.
	`IsEmy
()) {

1943 
obj
->
	`SIlFld
(
imp
::
kDaIndex
, 
da
);

1946 
l
->
	`SAcss
(

1947 
me


1948 , 
gr_


1949 , 
_


1950 , 
obj


1951 , 
gs


1952 , 
ibu


1953 , 
sigtu
);

1954 
	}
}

1956 
le
 
bo
 
SAcss
(

1957 
v8
::
Lol
<v8::
Obje
> 
obj


1958 , 
v8
::
Lol
<v8::
Sg
> 
me


1959 , 
GrClback
 
gr


1960 , 
SrClback
 

 = 0

1961 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

1962 , 
v8
::
AcssCڌ
 
gs
 = v8::
DEFAULT


1963 , 
v8
::
PrݔtyAribu
 
ibu
 = v8::
Ne
) {

1964 
EsbHdSce
 
sce
;

1966 
	gimp
::
NiveGr
 
gr_
 =

1967 
imp
::
GrClbackW
;

1968 
	gimp
::
NiveSr
 
_
 =

1969 

 ? 
imp
::
SrClbackW
 : 0;

1971 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

1972 
	gٶ
->
SIlFldCou
(
imp
::
kAcssFldCou
);

1973 
	gv8
::
Lol
<
v8
::
Obje
> 
daobj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

1975 
	gdaobj
->
SIlFld
(

1976 
imp
::
kGrIndex


1977 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

1979 i(!
	gda
.
IsEmy
()) {

1980 
	gdaobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

1983 i(
	g
) {

1984 
	gdaobj
->
SIlFld
(

1985 
imp
::
kSrIndex


1986 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

1989  
	gobj
->
SAcss
(

1990 
me


1991 , 
gr_


1992 , 
_


1993 , 
daobj


1994 , 
gs


1995 , 
ibu
);

1998 
le
 
SNamedPrݔtyHdr
(

1999 
v8
::
Lol
<v8::
ObjeTeme
> 
l


2000 , 
PrݔtyGrClback
 
gr


2001 , 
PrݔtySrClback
 

 = 0

2002 , 
PrݔtyQuyClback
 
quy
 = 0

2003 , 
PrݔtyDClback
 
d
 = 0

2004 , 
PrݔtyEnumClback
 
um
 = 0

2005 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2006 
HdSce
 
sce
;

2008 
	gimp
::
NivePrݔtyGr
 
gr_
 =

2009 
imp
::
PrݔtyGrClbackW
;

2010 
	gimp
::
NivePrݔtySr
 
_
 =

2011 

 ? 
imp
::
PrݔtySrClbackW
 : 0;

2012 
	gimp
::
NivePrݔtyQuy
 
quy_
 =

2013 
quy
 ? 
imp
::
PrݔtyQuyClbackW
 : 0;

2014 
	gimp
::
NivePrݔtyD
 *
d_
 =

2015 
d
 ? 
imp
::
PrݔtyDClbackW
 : 0;

2016 
	gimp
::
NivePrݔtyEnum
 
um_
 =

2017 
um
 ? 
imp
::
PrݔtyEnumClbackW
 : 0;

2019 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2020 
	gٶ
->
SIlFldCou
(
imp
::
kPrݔtyFldCou
);

2021 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2022 
	gobj
->
SIlFld
(

2023 
imp
::
kPrݔtyGrIndex


2024 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2026 i(
	g
) {

2027 
	gobj
->
SIlFld
(

2028 
imp
::
kPrݔtySrIndex


2029 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2032 i(
	gquy
) {

2033 
	gobj
->
SIlFld
(

2034 
imp
::
kPrݔtyQuyIndex


2035 , 
New
<
v8
::
Ex
>(
t_
<*>(
quy
)));

2038 i(
	gd
) {

2039 
	gobj
->
SIlFld
(

2040 
imp
::
kPrݔtyDIndex


2041 , 
New
<
v8
::
Ex
>(
t_
<*>(
d
)));

2044 i(
	gum
) {

2045 
	gobj
->
SIlFld
(

2046 
imp
::
kPrݔtyEnumIndex


2047 , 
New
<
v8
::
Ex
>(
t_
<*>(
um
)));

2050 i(!
	gda
.
IsEmy
()) {

2051 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2054 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


2055 
	gl
->
SHdr
(
v8
::
NamedPrݔtyHdrCfiguti
(

2056 
gr_
, 
_
, 
quy_
, 
d_
, 
um_
, 
obj
));

2058 
	gl
->
SNamedPrݔtyHdr
(

2059 
gr_


2060 , 
_


2061 , 
quy_


2062 , 
d_


2063 , 
um_


2064 , 
obj
);

2068 
le
 
SIndexedPrݔtyHdr
(

2069 
v8
::
Lol
<v8::
ObjeTeme
> 
l


2070 , 
IndexGrClback
 
gr


2071 , 
IndexSrClback
 

 = 0

2072 , 
IndexQuyClback
 
quy
 = 0

2073 , 
IndexDClback
 
d
 = 0

2074 , 
IndexEnumClback
 
um
 = 0

2075 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2076 
HdSce
 
sce
;

2078 
	gimp
::
NiveIndexGr
 
gr_
 =

2079 
imp
::
IndexGrClbackW
;

2080 
	gimp
::
NiveIndexSr
 
_
 =

2081 

 ? 
imp
::
IndexSrClbackW
 : 0;

2082 
	gimp
::
NiveIndexQuy
 
quy_
 =

2083 
quy
 ? 
imp
::
IndexQuyClbackW
 : 0;

2084 
	gimp
::
NiveIndexD
 
d_
 =

2085 
d
 ? 
imp
::
IndexDClbackW
 : 0;

2086 
	gimp
::
NiveIndexEnum
 
um_
 =

2087 
um
 ? 
imp
::
IndexEnumClbackW
 : 0;

2089 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2090 
	gٶ
->
SIlFldCou
(
imp
::
kIndexPrݔtyFldCou
);

2091 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2092 
	gobj
->
SIlFld
(

2093 
imp
::
kIndexPrݔtyGrIndex


2094 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2096 i(
	g
) {

2097 
	gobj
->
SIlFld
(

2098 
imp
::
kIndexPrݔtySrIndex


2099 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2102 i(
	gquy
) {

2103 
	gobj
->
SIlFld
(

2104 
imp
::
kIndexPrݔtyQuyIndex


2105 , 
New
<
v8
::
Ex
>(
t_
<*>(
quy
)));

2108 i(
	gd
) {

2109 
	gobj
->
SIlFld
(

2110 
imp
::
kIndexPrݔtyDIndex


2111 , 
New
<
v8
::
Ex
>(
t_
<*>(
d
)));

2114 i(
	gum
) {

2115 
	gobj
->
SIlFld
(

2116 
imp
::
kIndexPrݔtyEnumIndex


2117 , 
New
<
v8
::
Ex
>(
t_
<*>(
um
)));

2120 i(!
	gda
.
IsEmy
()) {

2121 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2124 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


2125 
	gl
->
SHdr
(
v8
::
IndexedPrݔtyHdrCfiguti
(

2126 
gr_
, 
_
, 
quy_
, 
d_
, 
um_
, 
obj
));

2128 
	gl
->
SIndexedPrݔtyHdr
(

2129 
gr_


2130 , 
_


2131 , 
quy_


2132 , 
d_


2133 , 
um_


2134 , 
obj
);

2138 
le
 
SClHdr
(

2139 
v8
::
Lol
<v8::
FuniTeme
> 
l


2140 , 
FuniClback
 
back


2141 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2142 
HdSce
 
sce
;

2144 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2145 
	gٶ
->
SIlFldCou
(
imp
::
kFuniFldCou
);

2146 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2148 
	gobj
->
SIlFld
(

2149 
imp
::
kFuniIndex


2150 , 
New
<
v8
::
Ex
>(
t_
<*>(
back
)));

2152 i(!
	gda
.
IsEmy
()) {

2153 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2156 
	gl
->
SClHdr
(
imp
::
FuniClbackW
, 
obj
);

2160 
le
 
SClAsFuniHdr
(

2161 
v8
::
Lol
<v8::
ObjeTeme
> 
l
,

2162 
FuniClback
 
back
,

2163 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2164 
HdSce
 
sce
;

2166 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2167 
	gٶ
->
SIlFldCou
(
imp
::
kFuniFldCou
);

2168 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2170 
	gobj
->
SIlFld
(

2171 
imp
::
kFuniIndex


2172 , 
New
<
v8
::
Ex
>(
t_
<*>(
back
)));

2174 i(!
	gda
.
IsEmy
()) {

2175 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2178 
	gl
->
SClAsFuniHdr
(
imp
::
FuniClbackW
, 
obj
);

2183 
	~"n_wk.h
"

2187 
	~"n_obje_wp.h
"

2191 
le


2193 
	$Expt
(
ADDON_REGISTER_FUNCTION_ARGS_TYPE
 
rg
, cڡ *
me
,

2194 
FuniClback
 
f
) {

2195 
	`S
(
rg
, 
New
<
v8
::
Sg
>(
me
).
	`ToLolChecked
(),

2196 
	`GFuni
(
New
<
v8
::
FuniTeme
>(
f
)).
	`ToLolChecked
());

2197 
	}
}

2201 
	sT
 {

2202 
exic
 
T
(
v8
::
Lol
<v8::
Vue
> 
t
: 
t_
() {

2203 
t_
.
Ret
(
To
<
v8
::
Obje
>(
t
).
ToLolChecked
());

2206 ~
T
({ 
	gt_
.
Ret
(); }

2208 
le
 

(
i
) {

2209 
	gv8
::
Lol
<
v8
::
Vue
> 
g
 = 
New
(
i
);

2210 
MakeClback
(
New
(
t_
), "", 1, &
g
);

2213 
le
 
ok
(
bo
 
isOk
, cڡ *
msg
 = 
NULL
) {

2214 
v8
::
Lol
<v8::
Vue
> 
gs
[2];

2215 
	ggs
[0] = 
New
(
isOk
);

2216 i(
	gmsg

	ggs
[1] = 
New
(
msg
).
ToLolChecked
();

2217 
MakeClback
(
New
(
t_
), "ok", 
msg
 ? 2 : 1, 
gs
);

2220 
le
 
ss
(cڡ * 
msg
 = 
NULL
) {

2221 
v8
::
Lol
<v8::
Vue
> 
hmsg
;

2222 i(
	gmsg

	ghmsg
 = 
New
(
msg
).
ToLolChecked
();

2223 
MakeClback
(
New
(
t_
), "ss", 
msg
 ? 1 : 0, &
hmsg
);

2226 
	give
:

2227 
Psit
<
v8
::
Obje
> 
t_
;

2230 
	#NAN_STRINGIZE2
(
x
#x

	)

2231 
	#NAN_STRINGIZE
(
x

	$NAN_STRINGIZE2
(
x
)

	)

2232 
	#NAN_TEST_EXPRESSION
(
exessi
) \

2233 
exessi
 ), 
__FILE__
 ":" 
	`NAN_STRINGIZE
(
__LINE__
": " #exessi

	)

2235 
	#NAN_EXPORT
(
rg
, 
funi

	`Expt
Ѭg, #funi, funi)

	)

2237 #unde
TYPE_CHECK


2241 
mea
 
imp
 {

2243 
me
 <
tyme
 
T
> 
Maybefr
;

2245 
me
 <
tyme
 
T
> 
Maybefr
<
v8
::
Lol
<T> > {

2246 
MaybeLol
<
T
> 
	`cvt
(
v8
::
Lol
<T> 
v
) {

2247  
MaybeLol
<
T
>(
v
);

2251 
me
 <
tyme
 
T
> 
Maybefr
<
MaybeLol
<T> > {

2252 
MaybeLol
<
T
> 
	`cvt
(MaybeLol<T> 
v
) {

2253  
v
;

2257 
	}
}

2259 
	gme
 <
tyme
 
	gT
,em<
	gtyme
> 
ass
 
	gMaybeMaybe
>

2260 
	gMaybeLol
<
	gT
>

2261 
MakeMaybe
(
MaybeMaybe
<
T
> 
v
) {

2262  
	gimp
::
Maybefr
<
MaybeMaybe
<
T
> >::
cvt
(
v
);

2267 
	~"n_tydy_cڋs.h
"

	@node_modules/nan/nan_callbacks.h

9 #ide
NAN_CALLBACKS_H_


10 
	#NAN_CALLBACKS_H_


	)

12 
	gme
<
tyme
 
	gT
> 
ass
 
	gFuniClbackInfo
;

13 
	gme
<
tyme
 
	gT
> 
ass
 
	gPrݔtyClbackInfo
;

14 
	gme
<
tyme
 
	gT
> 
ass
 
	gGlob
;

16 (*
	tFuniClback
)(cڡ 
	tFuniClbackInfo
<
	tv8
::
	tVue
>&);

17 (*
	tGrClback
)

18 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ 
	tPrݔtyClbackInfo
<v8::
	tVue
>&);

19 (*
	tSrClback
)(

20 
	tv8
::
	tLol
<v8::
	tSg
>,

21 
	tv8
::
	tLol
<v8::
	tVue
>,

22 cڡ 
	tPrݔtyClbackInfo
<>&);

23 (*
	tPrݔtyGrClback
)(

24 
	tv8
::
	tLol
<v8::
	tSg
>,

25 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

26 (*
	tPrݔtySrClback
)(

27 
	tv8
::
	tLol
<v8::
	tSg
>,

28 
	tv8
::
	tLol
<v8::
	tVue
>,

29 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

30 (*
	tPrݔtyEnumClback
)

31 (cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&);

32 (*
	tPrݔtyDClback
)(

33 
	tv8
::
	tLol
<v8::
	tSg
>,

34 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&);

35 (*
	tPrݔtyQuyClback
)(

36 
	tv8
::
	tLol
<v8::
	tSg
>,

37 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&);

38 (*
	tIndexGrClback
)(

39 
	tut32_t
,

40 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

41 (*
	tIndexSrClback
)(

42 
	tut32_t
,

43 
	tv8
::
	tLol
<v8::
	tVue
>,

44 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

45 (*
	tIndexEnumClback
)

46 (cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&);

47 (*
	tIndexDClback
)(

48 
	tut32_t
,

49 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&);

50 (*
	tIndexQuyClback
)(

51 
	tut32_t
,

52 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&);

54 
mea
 
imp
 {

55 
v8
::
	tLol
<
	tv8
::
	tAcssSigtu
> 
	tSig
;

57 cڡ 
kDaIndex
 = 0;

59 cڡ 
kFuniIndex
 = 1;

60 cڡ 
kFuniFldCou
 = 2;

62 cڡ 
kGrIndex
 = 1;

63 cڡ 
kSrIndex
 = 2;

64 cڡ 
kAcssFldCou
 = 3;

66 cڡ 
kPrݔtyGrIndex
 = 1;

67 cڡ 
kPrݔtySrIndex
 = 2;

68 cڡ 
kPrݔtyEnumIndex
 = 3;

69 cڡ 
kPrݔtyDIndex
 = 4;

70 cڡ 
kPrݔtyQuyIndex
 = 5;

71 cڡ 
kPrݔtyFldCou
 = 6;

73 cڡ 
kIndexPrݔtyGrIndex
 = 1;

74 cڡ 
kIndexPrݔtySrIndex
 = 2;

75 cڡ 
kIndexPrݔtyEnumIndex
 = 3;

76 cڡ 
kIndexPrݔtyDIndex
 = 4;

77 cڡ 
kIndexPrݔtyQuyIndex
 = 5;

78 cڡ 
kIndexPrݔtyFldCou
 = 6;

80 
	}
}

82 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


83 
	~"n_backs_12_l.h
"

85 
	~"n_backs_e_12_l.h
"

	@node_modules/nan/nan_callbacks_12_inl.h

9 #ide
NAN_CALLBACKS_12_INL_H_


10 
	#NAN_CALLBACKS_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cRuVue
 {

14 
	mv8
::
RuVue
<
T
> 
vue_
;

16 
	mpublic
:

17 
me
 <
ass
 
S
>

18 
exic
 
le
 
RuVue
(cڡ 
v8
::RuVue<
S
> &
vue
) :

19 
	$vue_
(
vue
) {}

20 
me
 <
ass
 
S
>

21 
exic
 
le
 
	`RuVue
(cڡ 
RuVue
<
S
>& 
th
)

22 : 
	$vue_
(
th
.
vue_
) {

23 
	`TYPE_CHECK
(
T
, 
S
);

24 
	}
}

27 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
v8
::
Lol
<
S
> &
hd
) {

28 
TYPE_CHECK
(
T
, 
S
);

29 
	gvue_
.
S
(
hd
);

32 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
Glob
<
S
> &
hd
) {

33 
TYPE_CHECK
(
T
, 
S
);

34 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

35 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && \

36 (
V8_MINOR_VERSION
 > 5 || (V8_MINOR_VERSION == 5 && \

37 
defed
(
V8_BUILD_NUMBER
) && V8_BUILD_NUMBER >= 8))))

38 
vue_
.
S
(
hd
);

40 
	gvue_
.
S
(*
t_
<cڡ 
v8
::
Psit
<
S
>*>(&
hd
));

41 
	gcڡ_
<
	gGlob
<
	gS
> &>(
	ghd
).
Ret
();

46 
le
 
	$S
(
bo
 
vue
) {

47 
	`TYPE_CHECK
(
T
, 
v8
::
Boޗn
);

48 
vue_
.
	`S
(
vue
);

49 
	}
}

51 
le
 
	$S
(
i
) {

52 
	`TYPE_CHECK
(
T
, 
v8
::
Numb
);

53 
vue_
.
	`S
(
i
);

54 
	}
}

56 
le
 
	$S
(
t32_t
 
i
) {

57 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

58 
vue_
.
	`S
(
i
);

59 
	}
}

61 
le
 
	$S
(
ut32_t
 
i
) {

62 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

63 
vue_
.
	`S
(
i
);

64 
	}
}

67 
le
 
	$SNu
() {

68 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

69 
vue_
.
	`SNu
();

70 
	}
}

72 
le
 
	$SUndefed
() {

73 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

74 
vue_
.
	`SUndefed
();

75 
	}
}

77 
le
 
	$SEmySg
() {

78 
	`TYPE_CHECK
(
T
, 
v8
::
Sg
);

79 
vue_
.
	`SEmySg
();

80 
	}
}

83 
le
 
	gv8
::
Isީe
 *
	$GIsީe
() const {

84  
vue_
.
	`GIsީe
();

85 
	}
}

88 
	gme
<
tyme
 
	gS
>

89 
le
 
	$S
(
S
 *
whev
{ 
	`TYPE_CHECK
(S*, 
v8
::
Primive
); 
	}
}

92 
	gme
<
tyme
 
	gT
>

93 as
	cFuniClbackInfo
 {

94 cڡ 
	mv8
::
FuniClbackInfo
<
T
> &
fo_
;

95 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

97 
	mpublic
:

98 
exic
 
le
 
FuniClbackInfo
(

99 cڡ 
v8
::
FuniClbackInfo
<
T
> &
fo


100 , 
v8
::
Lol
<v8::
Vue
> 
da
) :

101 
fo_
(
fo
)

102 , 
	$da_
(
da
) {}

104 
le
 
RuVue
<
T
> 
	$GRuVue
() const {

105  
RuVue
<
T
>(
fo_
.
	`GRuVue
());

106 
	}
}

108 
le
 
	gv8
::
Lol
<
v8
::
Funi
> 
	$Ce
(cڡ {  
fo_
.
	`Ce
(); 
	}
}

109 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

110 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

111 
le
 
bo
 
	$IsCڡruCl
(cڡ {  
fo_
.
	`IsCڡruCl
(); 
	}
}

112 
le
 
	$Lgth
(cڡ {  
fo_
.
	`Lgth
(); 
	}
}

113 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
ݔ
[](
i
cڡ {  
fo_
[i]; }

114 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

115 
le
 
	gv8
::
Isީe
 *
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

118 
	geed
:

119 cڡ 
kHdIndex
 = 0;

120 cڡ 
	gkIsީeIndex
 = 1;

121 cڡ 
	gkRuVueDeuVueIndex
 = 2;

122 cڡ 
	gkRuVueIndex
 = 3;

123 cڡ 
	gkDaIndex
 = 4;

124 cڡ 
	gkCeIndex
 = 5;

125 cڡ 
	gkCڋxtSaveIndex
 = 6;

126 cڡ 
	gkArgsLgth
 = 7;

128 
	give
:

129 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
FuniClbackInfo
)

132 
	gme
<
tyme
 
	gT
>

133 as
	cPrݔtyClbackInfo
 {

134 cڡ 
	mv8
::
PrݔtyClbackInfo
<
T
> &
fo_
;

135 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

137 
	mpublic
:

138 
exic
 
le
 
PrݔtyClbackInfo
(

139 cڡ 
v8
::
PrݔtyClbackInfo
<
T
> &
fo


140 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

141 
fo_
(
fo
)

142 , 
	$da_
(
da
) {}

144 
le
 
v8
::
Isީe
* 
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

145 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

146 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

147 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

148 
le
 
	gRuVue
<
	gT
> 
	$GRuVue
() const {

149  
RuVue
<
T
>(
fo_
.
	`GRuVue
());

150 
	}
}

152 
	geed
:

153 cڡ 
kHdIndex
 = 0;

154 cڡ 
	gkIsީeIndex
 = 1;

155 cڡ 
	gkRuVueDeuVueIndex
 = 2;

156 cڡ 
	gkRuVueIndex
 = 3;

157 cڡ 
	gkDaIndex
 = 4;

158 cڡ 
	gkThisIndex
 = 5;

159 cڡ 
	gkArgsLgth
 = 6;

161 
	give
:

162 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
PrݔtyClbackInfo
)

165 
mea
 
	gimp
 {

167 
FuniClbackW
(cڡ 
v8
::
FuniClbackInfo
<v8::
Vue
> &
fo
) {

168 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

169 
FuniClback
 
	gback
 = 
t_
<FunctionCallback>(

170 
t_
<
_t
>(

171 
obj
->
GIlFld
(
kFuniIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

172 
	gFuniClbackInfo
<
	gv8
::
Vue
>

173 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

174 
back
(
cbfo
);

177 (*
	gNiveFuni
)(cڡ 
	tv8
::
	tFuniClbackInfo
<v8::
	tVue
> &);

179 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


181 
GrClbackW
(

182 
v8
::
Lol
<v8::
Name
> 
ݔty


183 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

184 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

185 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

186 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

187 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

188 
t_
<
_t
>(

189 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

190 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

193 (*
	gNiveGr
)

194 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

197 
SrClbackW
(

198 
v8
::
Lol
<v8::
Name
> 
ݔty


199 , 
v8
::
Lol
<v8::
Vue
> 
vue


200 , cڡ 
v8
::
PrݔtyClbackInfo
<> &
fo
) {

201 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

202 
	gPrݔtyClbackInfo
<>

203 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

204 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

205 
t_
<
_t
>(

206 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

207 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
vue
, 
cbfo
);

210 (*
	gNiveSr
)(

211 
	tv8
::
	tLol
<v8::
	tName
>

212 , 
	tv8
::
	tLol
<v8::
	tVue
>

213 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<> &);

216 
GrClbackW
(

217 
v8
::
Lol
<v8::
Sg
> 
ݔty


218 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

219 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

220 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

221 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

222 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

223 
t_
<
_t
>(

224 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

225 
back
(
ݔty
, 
cbfo
);

228 (*
	gNiveGr
)

229 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

232 
SrClbackW
(

233 
v8
::
Lol
<v8::
Sg
> 
ݔty


234 , 
v8
::
Lol
<v8::
Vue
> 
vue


235 , cڡ 
v8
::
PrݔtyClbackInfo
<> &
fo
) {

236 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

237 
	gPrݔtyClbackInfo
<>

238 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

239 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

240 
t_
<
_t
>(

241 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

242 
back
(
ݔty
, 
vue
, 
cbfo
);

245 (*
	gNiveSr
)(

246 
	tv8
::
	tLol
<v8::
	tSg
>

247 , 
	tv8
::
	tLol
<v8::
	tVue
>

248 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<> &);

251 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


253 
PrݔtyGrClbackW
(

254 
v8
::
Lol
<v8::
Name
> 
ݔty


255 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

256 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

257 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

258 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

259 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

260 
t_
<
_t
>(

261 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

262 .
As
<
v8
::
Ex
>()->
Vue
()));

263 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

266 (*
	gNivePrݔtyGr
)

267 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

270 
PrݔtySrClbackW
(

271 
v8
::
Lol
<v8::
Name
> 
ݔty


272 , 
v8
::
Lol
<v8::
Vue
> 
vue


273 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

274 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

275 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

276 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

277 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

278 
t_
<
_t
>(

279 
obj
->
GIlFld
(
kPrݔtySrIndex
)

280 .
As
<
v8
::
Ex
>()->
Vue
()));

281 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
vue
, 
cbfo
);

284 (*
	gNivePrݔtySr
)(

285 
	tv8
::
	tLol
<v8::
	tName
>

286 , 
	tv8
::
	tLol
<v8::
	tVue
>

287 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

290 
PrݔtyEnumClbackW
(

291 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

292 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

293 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

294 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

295 
PrݔtyEnumClback
 
	gback
 =

296 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

297 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

298 .
As
<
v8
::
Ex
>()->
Vue
()));

299 
back
(
cbfo
);

302 (*
	gNivePrݔtyEnum
)

303 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

306 
PrݔtyDClbackW
(

307 
v8
::
Lol
<v8::
Name
> 
ݔty


308 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

309 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

310 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

311 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

312 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

313 
t_
<
_t
>(

314 
obj
->
GIlFld
(
kPrݔtyDIndex
)

315 .
As
<
v8
::
Ex
>()->
Vue
()));

316 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

319 (
	gNivePrݔtyD
)

320 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

323 
PrݔtyQuyClbackW
(

324 
v8
::
Lol
<v8::
Name
> 
ݔty


325 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

326 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

327 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

328 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

329 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

330 
t_
<
_t
>(

331 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

332 .
As
<
v8
::
Ex
>()->
Vue
()));

333 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

336 (*
	gNivePrݔtyQuy
)

337 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

340 
PrݔtyGrClbackW
(

341 
v8
::
Lol
<v8::
Sg
> 
ݔty


342 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

343 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

344 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

345 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

346 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

347 
t_
<
_t
>(

348 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

349 .
As
<
v8
::
Ex
>()->
Vue
()));

350 
back
(
ݔty
, 
cbfo
);

353 (*
	gNivePrݔtyGr
)

354 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

357 
PrݔtySrClbackW
(

358 
v8
::
Lol
<v8::
Sg
> 
ݔty


359 , 
v8
::
Lol
<v8::
Vue
> 
vue


360 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

361 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

362 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

363 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

364 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

365 
t_
<
_t
>(

366 
obj
->
GIlFld
(
kPrݔtySrIndex
)

367 .
As
<
v8
::
Ex
>()->
Vue
()));

368 
back
(
ݔty
, 
vue
, 
cbfo
);

371 (*
	gNivePrݔtySr
)(

372 
	tv8
::
	tLol
<v8::
	tSg
>

373 , 
	tv8
::
	tLol
<v8::
	tVue
>

374 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

377 
PrݔtyEnumClbackW
(

378 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

379 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

380 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

381 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

382 
PrݔtyEnumClback
 
	gback
 =

383 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

384 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

385 .
As
<
v8
::
Ex
>()->
Vue
()));

386 
back
(
cbfo
);

389 (*
	gNivePrݔtyEnum
)

390 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

393 
PrݔtyDClbackW
(

394 
v8
::
Lol
<v8::
Sg
> 
ݔty


395 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

396 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

397 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

398 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

399 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

400 
t_
<
_t
>(

401 
obj
->
GIlFld
(
kPrݔtyDIndex
)

402 .
As
<
v8
::
Ex
>()->
Vue
()));

403 
back
(
ݔty
, 
cbfo
);

406 (
	gNivePrݔtyD
)

407 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

410 
PrݔtyQuyClbackW
(

411 
v8
::
Lol
<v8::
Sg
> 
ݔty


412 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

413 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

414 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

415 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

416 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

417 
t_
<
_t
>(

418 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

419 .
As
<
v8
::
Ex
>()->
Vue
()));

420 
back
(
ݔty
, 
cbfo
);

423 (*
	gNivePrݔtyQuy
)

424 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

428 
IndexGrClbackW
(

429 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

430 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

431 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

432 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

433 
IndexGrClback
 
	gback
 = 
t_
<IndexGetterCallback>(

434 
t_
<
_t
>(

435 
obj
->
GIlFld
(
kIndexPrݔtyGrIndex
)

436 .
As
<
v8
::
Ex
>()->
Vue
()));

437 
back
(
dex
, 
cbfo
);

440 (*
	gNiveIndexGr
)

441 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

444 
IndexSrClbackW
(

445 
ut32_t
 
dex


446 , 
v8
::
Lol
<v8::
Vue
> 
vue


447 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

448 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

449 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

450 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

451 
IndexSrClback
 
	gback
 = 
t_
<IndexSetterCallback>(

452 
t_
<
_t
>(

453 
obj
->
GIlFld
(
kIndexPrݔtySrIndex
)

454 .
As
<
v8
::
Ex
>()->
Vue
()));

455 
back
(
dex
, 
vue
, 
cbfo
);

458 (*
	gNiveIndexSr
)(

459 
	tut32_t


460 , 
	tv8
::
	tLol
<v8::
	tVue
>

461 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

464 
IndexEnumClbackW
(

465 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

466 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

467 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

468 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

469 
IndexEnumClback
 
	gback
 = 
t_
<IndexEnumeratorCallback>(

470 
t_
<
_t
>(

471 
obj
->
GIlFld
(

472 
kIndexPrݔtyEnumIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

473 
back
(
cbfo
);

476 (*
	gNiveIndexEnum
)

477 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

480 
IndexDClbackW
(

481 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

482 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

483 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

484 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

485 
IndexDClback
 
	gback
 = 
t_
<IndexDeleterCallback>(

486 
t_
<
_t
>(

487 
obj
->
GIlFld
(
kIndexPrݔtyDIndex
)

488 .
As
<
v8
::
Ex
>()->
Vue
()));

489 
back
(
dex
, 
cbfo
);

492 (*
	gNiveIndexD
)

493 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

496 
IndexQuyClbackW
(

497 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

498 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

499 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

500 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

501 
IndexQuyClback
 
	gback
 = 
t_
<IndexQueryCallback>(

502 
t_
<
_t
>(

503 
obj
->
GIlFld
(
kIndexPrݔtyQuyIndex
)

504 .
As
<
v8
::
Ex
>()->
Vue
()));

505 
back
(
dex
, 
cbfo
);

508 (*
	gNiveIndexQuy
)

509 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

	@node_modules/nan/nan_callbacks_pre_12_inl.h

9 #ide
NAN_CALLBACKS_PRE_12_INL_H_


10 
	#NAN_CALLBACKS_PRE_12_INL_H_


	)

12 
mea
 
	gimp
 {

13 
	gme
<
tyme
 
	gT
> 
ass
 
	gRuVueImp
;

16 
	gme
<
tyme
 
	gT
>

17 as
	cRuVue
 {

18 
	mv8
::
Isީe
 *
isީe_
;

19 
	mv8
::
Psit
<
T
> *
vue_
;

20 
nd
 
ass
 
	mimp
::
RuVueImp
<
T
>;

22 
	mpublic
:

23 
me
 <
ass
 
S
>

24 
exic
 
le
 
RuVue
(
v8
::
Isީe
 *
isީe
, v8::
Psit
<
S
> *
p
) :

25 
isީe_
(
isީe
), 
	$vue_
(
p
) {}

26 
me
 <
ass
 
S
>

27 
exic
 
le
 
	`RuVue
(cڡ 
RuVue
<
S
>& 
th
)

28 : 
	`isީe_
(
th
.
isީe_
), 
	$vue_
(
th
.
vue_
) {

29 
	`TYPE_CHECK
(
T
, 
S
);

30 
	}
}

33 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
v8
::
Lol
<
S
> &
hd
) {

34 
TYPE_CHECK
(
T
, 
S
);

35 
	gvue_
->
Dio
();

36 *
	gvue_
 = 
v8
::
Psit
<
T
>::
New
(
hd
);

39 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
Glob
<
S
> &
hd
) {

40 
TYPE_CHECK
(
T
, 
S
);

41 
	gvue_
->
Dio
();

42 *
	gvue_
 = 
v8
::
Psit
<
T
>::
New
(
hd
.
rsit
);

43 
	gcڡ_
<
	gGlob
<
	gS
> &>(
	ghd
).
Ret
();

47 
le
 
	$S
(
bo
 
vue
) {

48 
	`TYPE_CHECK
(
T
, 
v8
::
Boޗn
);

49 
vue_
->
	`Dio
();

50 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Boޗn
::New(
vue
));

51 
	}
}

53 
le
 
	$S
(
i
) {

54 
	`TYPE_CHECK
(
T
, 
v8
::
Numb
);

55 
vue_
->
	`Dio
();

56 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Numb
::New(
i
));

57 
	}
}

59 
le
 
	$S
(
t32_t
 
i
) {

60 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

61 
vue_
->
	`Dio
();

62 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
I32
::New(
i
));

63 
	}
}

65 
le
 
	$S
(
ut32_t
 
i
) {

66 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

67 
vue_
->
	`Dio
();

68 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Ut32
::
	`NewFromUnsigd
(
i
));

69 
	}
}

72 
le
 
	$SNu
() {

73 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

74 
vue_
->
	`Dio
();

75 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
	`Nu
());

76 
	}
}

78 
le
 
	$SUndefed
() {

79 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

80 
vue_
->
	`Dio
();

81 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
	`Undefed
());

82 
	}
}

84 
le
 
	$SEmySg
() {

85 
	`TYPE_CHECK
(
T
, 
v8
::
Sg
);

86 
vue_
->
	`Dio
();

87 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Sg
::
	`Emy
());

88 
	}
}

91 
le
 
	gv8
::
Isީe
 *
	$GIsީe
() const {

92  
isީe_
;

93 
	}
}

96 
	gme
<
tyme
 
	gS
>

97 
le
 
	$S
(
S
 *
whev
{ 
	`TYPE_CHECK
(S*, 
v8
::
Primive
); 
	}
}

100 
	gme
<
tyme
 
	gT
>

101 as
	cFuniClbackInfo
 {

102 cڡ 
	mv8
::
Argumts
 &
gs_
;

103 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

104 
	mRuVue
<
	mT
> 
	mtu_vue_
;

105 
	mv8
::
Psit
<
T
> 
tv_
;

107 
	mpublic
:

108 
exic
 
le
 
FuniClbackInfo
(

109 cڡ 
v8
::
Argumts
 &
gs


110 , 
v8
::
Lol
<v8::
Vue
> 
da
) :

111 
gs_
(
gs
)

112 , 
da_
(
da
)

113 , 
tu_vue_
(
gs
.
GIsީe
(), &
tv_
)

114 , 
tv_
(
v8
::
Psit
<
T
>::
New
(v8::
	$Undefed
())) {}

116 
le
 ~
	$FuniClbackInfo
() {

117 
tv_
.
	`Dio
();

118 
tv_
.
	`Cˬ
();

119 
	}
}

121 
le
 
	gRuVue
<
	gT
> 
	$GRuVue
() const {

122  
RuVue
<
T
>(
tu_vue_
);

123 
	}
}

125 
le
 
	gv8
::
Lol
<
v8
::
Funi
> 
	$Ce
(cڡ {  
gs_
.
	`Ce
(); 
	}
}

126 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

127 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
gs_
.
	`Hd
(); 
	}
}

128 
le
 
bo
 
	$IsCڡruCl
(cڡ {  
gs_
.
	`IsCڡruCl
(); 
	}
}

129 
le
 
	$Lgth
(cڡ {  
gs_
.
	`Lgth
(); 
	}
}

130 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
ݔ
[](
i
cڡ {  
gs_
[i]; }

131 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
gs_
.
	`This
(); 
	}
}

132 
le
 
	gv8
::
Isީe
 *
	$GIsީe
(cڡ {  
gs_
.
	`GIsީe
(); 
	}
}

135 
	geed
:

136 cڡ 
kHdIndex
 = 0;

137 cڡ 
	gkIsީeIndex
 = 1;

138 cڡ 
	gkRuVueDeuVueIndex
 = 2;

139 cڡ 
	gkRuVueIndex
 = 3;

140 cڡ 
	gkDaIndex
 = 4;

141 cڡ 
	gkCeIndex
 = 5;

142 cڡ 
	gkCڋxtSaveIndex
 = 6;

143 cڡ 
	gkArgsLgth
 = 7;

145 
	give
:

146 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
FuniClbackInfo
)

149 
	gme
<
tyme
 
	gT
>

150 as
	cPrݔtyClbackInfoBa
 {

151 cڡ 
	mv8
::
AcssInfo
 &
fo_
;

152 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

154 
	mpublic
:

155 
exic
 
le
 
PrݔtyClbackInfoBa
(

156 cڡ 
v8
::
AcssInfo
 &
fo


157 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

158 
fo_
(
fo
)

159 , 
	$da_
(
da
) {}

161 
le
 
v8
::
Isީe
* 
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

162 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

163 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

164 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

166 
	geed
:

167 cڡ 
kHdIndex
 = 0;

168 cڡ 
	gkIsީeIndex
 = 1;

169 cڡ 
	gkRuVueDeuVueIndex
 = 2;

170 cڡ 
	gkRuVueIndex
 = 3;

171 cڡ 
	gkDaIndex
 = 4;

172 cڡ 
	gkThisIndex
 = 5;

173 cڡ 
	gkArgsLgth
 = 6;

175 
	give
:

176 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
PrݔtyClbackInfoBa
)

179 
	gme
<
tyme
 
	gT
>

180 
ass
 
	gPrݔtyClbackInfo
 : 
public
 
PrݔtyClbackInfoBa
<
T
> {

181 
RuVue
<
T
> 
tu_vue_
;

182 
	gv8
::
Psit
<
T
> 
tv_
;

184 
	gpublic
:

185 
exic
 
le
 
PrݔtyClbackInfo
(

186 cڡ 
v8
::
AcssInfo
 &
fo


187 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

188 
PrݔtyClbackInfoBa
<
T
>(
fo
, 
	gda
)

189 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

190 , 
tv_
(
v8
::
Psit
<
T
>::
New
(v8::
Undefed
())) {}

192 
le
 ~
PrݔtyClbackInfo
() {

193 
tv_
.
Dio
();

194 
	gtv_
.
Cˬ
();

197 
le
 
	gRuVue
<
	gT
> 
GRuVue
(cڡ {  
	gtu_vue_
; }

200 
	gme
<>

201 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
> :

202 
public
 
PrݔtyClbackInfoBa
<
v8
::
Aay
> {

203 
RuVue
<
v8
::
Aay
> 
tu_vue_
;

204 
	gv8
::
Psit
<
v8
::
Aay
> 
tv_
;

206 
	gpublic
:

207 
exic
 
le
 
PrݔtyClbackInfo
(

208 cڡ 
v8
::
AcssInfo
 &
fo


209 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

210 
PrݔtyClbackInfoBa
<
v8
::
Aay
>(
fo
, 
	gda
)

211 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

212 , 
tv_
(
v8
::
Psit
<v8::
Aay
>::
New
(v8::
Lol
<v8::Array>())) {}

214 
le
 ~
PrݔtyClbackInfo
() {

215 
tv_
.
Dio
();

216 
	gtv_
.
Cˬ
();

219 
le
 
	gRuVue
<
	gv8
::
Aay
> 
GRuVue
() const {

220  
tu_vue_
;

224 
	gme
<>

225 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
> :

226 
public
 
PrݔtyClbackInfoBa
<
v8
::
Boޗn
> {

227 
RuVue
<
v8
::
Boޗn
> 
tu_vue_
;

228 
	gv8
::
Psit
<
v8
::
Boޗn
> 
tv_
;

230 
	gpublic
:

231 
exic
 
le
 
PrݔtyClbackInfo
(

232 cڡ 
v8
::
AcssInfo
 &
fo


233 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

234 
PrݔtyClbackInfoBa
<
v8
::
Boޗn
>(
fo
, 
	gda
)

235 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

236 , 
tv_
(
v8
::
Psit
<v8::
Boޗn
>::
New
(v8::
Lol
<v8::Boolean>())) {}

238 
le
 ~
PrݔtyClbackInfo
() {

239 
tv_
.
Dio
();

240 
	gtv_
.
Cˬ
();

243 
le
 
	gRuVue
<
	gv8
::
Boޗn
> 
GRuVue
() const {

244  
tu_vue_
;

248 
	gme
<>

249 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
> :

250 
public
 
PrݔtyClbackInfoBa
<
v8
::
Ieg
> {

251 
RuVue
<
v8
::
Ieg
> 
tu_vue_
;

252 
	gv8
::
Psit
<
v8
::
Ieg
> 
tv_
;

254 
	gpublic
:

255 
exic
 
le
 
PrݔtyClbackInfo
(

256 cڡ 
v8
::
AcssInfo
 &
fo


257 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

258 
PrݔtyClbackInfoBa
<
v8
::
Ieg
>(
fo
, 
	gda
)

259 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

260 , 
tv_
(
v8
::
Psit
<v8::
Ieg
>::
New
(v8::
Lol
<v8::Integer>())) {}

262 
le
 ~
PrݔtyClbackInfo
() {

263 
tv_
.
Dio
();

264 
	gtv_
.
Cˬ
();

267 
le
 
	gRuVue
<
	gv8
::
Ieg
> 
GRuVue
() const {

268  
tu_vue_
;

272 
mea
 
	gimp
 {

273 
	gme
<
tyme
 
	gT
>

274 
ass
 
	gRuVueImp
 : 
public
 
RuVue
<
T
> {

275 
public
:

276 
exic
 
RuVueImp
(
RuVue
<
T
> 
th
) :

277 
RuVue
<
T
>(
th
) {}

278 
NAN_INLINE
 
v8
::
Hd
<
T
> 
Vue
() {

279  *
RuVue
<
T
>::
vue_
;

284 
	gv8
::
Hd
<
v8
::
Vue
> 
FuniClbackW
(cڡ v8::
Argumts
 &
gs
) {

285 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
gs
.
Da
().
As
<v8::Object>();

286 
FuniClback
 
	gback
 = 
t_
<FunctionCallback>(

287 
t_
<
_t
>(

288 
obj
->
GIlFld
(
kFuniIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

289 
	gFuniClbackInfo
<
	gv8
::
Vue
>

290 
cbfo
(
gs
, 
obj
->
GIlFld
(
kDaIndex
));

291 
back
(
cbfo
);

292  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

295 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveFuni
)(cڡ v8::
	tArgumts
 &);

298 
	gv8
::
Hd
<
v8
::
Vue
> 
GrClbackW
(

299 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

300 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

301 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

302 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

303 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

304 
t_
<
_t
>(

305 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

306 
back
(
ݔty
, 
cbfo
);

307  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

310 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveGr
)

311 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

314 
SrClbackW
(

315 
v8
::
Lol
<v8::
Sg
> 
ݔty


316 , 
v8
::
Lol
<v8::
Vue
> 
vue


317 , cڡ 
v8
::
AcssInfo
 &
fo
) {

318 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

319 
	gPrݔtyClbackInfo
<>

320 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

321 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

322 
t_
<
_t
>(

323 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

324 
back
(
ݔty
, 
vue
, 
cbfo
);

327 (*
	gNiveSr
)

328 (
	tv8
::
	tLol
<v8::
	tSg
>, v8::Lol<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

331 
	gv8
::
Hd
<
v8
::
Vue
> 
PrݔtyGrClbackW
(

332 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

333 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

334 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

335 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

336 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

337 
t_
<
_t
>(

338 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

339 .
As
<
v8
::
Ex
>()->
Vue
()));

340 
back
(
ݔty
, 
cbfo
);

341  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

344 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNivePrݔtyGr
)

345 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

348 
	gv8
::
Hd
<
v8
::
Vue
> 
PrݔtySrClbackW
(

349 
v8
::
Lol
<v8::
Sg
> 
ݔty


350 , 
v8
::
Lol
<v8::
Vue
> 
vue


351 , cڡ 
v8
::
AcssInfo
 &
fo
) {

352 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

353 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

354 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

355 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

356 
t_
<
_t
>(

357 
obj
->
GIlFld
(
kPrݔtySrIndex
)

358 .
As
<
v8
::
Ex
>()->
Vue
()));

359 
back
(
ݔty
, 
vue
, 
cbfo
);

360  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

363 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNivePrݔtySr
)

364 (
	tv8
::
	tLol
<v8::
	tSg
>, v8::Lol<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

367 
	gv8
::
Hd
<
v8
::
Aay
> 
PrݔtyEnumClbackW
(

368 cڡ 
v8
::
AcssInfo
 &
fo
) {

369 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

370 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

371 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

372 
PrݔtyEnumClback
 
	gback
 =

373 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

374 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

375 .
As
<
v8
::
Ex
>()->
Vue
()));

376 
back
(
cbfo
);

377  
	gRuVueImp
<
	gv8
::
Aay
>(
cbfo
.
GRuVue
()).
Vue
();

380 
	gv8
::
	tHd
<
	tv8
::
	tAay
> (*
	tNivePrݔtyEnum
)

381 (cڡ 
	tv8
::
	tAcssInfo
 &);

384 
	gv8
::
Hd
<
v8
::
Boޗn
> 
PrݔtyDClbackW
(

385 
v8
::
Lol
<v8::
Sg
> 
ݔty


386 , cڡ 
v8
::
AcssInfo
 &
fo
) {

387 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

388 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

389 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

390 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

391 
t_
<
_t
>(

392 
obj
->
GIlFld
(
kPrݔtyDIndex
)

393 .
As
<
v8
::
Ex
>()->
Vue
()));

394 
back
(
ݔty
, 
cbfo
);

395  
	gRuVueImp
<
	gv8
::
Boޗn
>(
cbfo
.
GRuVue
()).
Vue
();

398 
	gv8
::
	tHd
<
	tv8
::
	tBoޗn
> (
	tNivePrݔtyD
)

399 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

402 
	gv8
::
Hd
<
v8
::
Ieg
> 
PrݔtyQuyClbackW
(

403 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

404 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

405 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

406 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

407 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

408 
t_
<
_t
>(

409 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

410 .
As
<
v8
::
Ex
>()->
Vue
()));

411 
back
(
ݔty
, 
cbfo
);

412  
	gRuVueImp
<
	gv8
::
Ieg
>(
cbfo
.
GRuVue
()).
Vue
();

415 
	gv8
::
	tHd
<
	tv8
::
	tIeg
> (*
	tNivePrݔtyQuy
)

416 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

419 
	gv8
::
Hd
<
v8
::
Vue
> 
IndexGrClbackW
(

420 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

421 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

422 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

423 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

424 
IndexGrClback
 
	gback
 = 
t_
<IndexGetterCallback>(

425 
t_
<
_t
>(

426 
obj
->
GIlFld
(
kIndexPrݔtyGrIndex
)

427 .
As
<
v8
::
Ex
>()->
Vue
()));

428 
back
(
dex
, 
cbfo
);

429  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

432 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveIndexGr
)

433 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

436 
	gv8
::
Hd
<
v8
::
Vue
> 
IndexSrClbackW
(

437 
ut32_t
 
dex


438 , 
v8
::
Lol
<v8::
Vue
> 
vue


439 , cڡ 
v8
::
AcssInfo
 &
fo
) {

440 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

441 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

442 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

443 
IndexSrClback
 
	gback
 = 
t_
<IndexSetterCallback>(

444 
t_
<
_t
>(

445 
obj
->
GIlFld
(
kIndexPrݔtySrIndex
)

446 .
As
<
v8
::
Ex
>()->
Vue
()));

447 
back
(
dex
, 
vue
, 
cbfo
);

448  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

451 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveIndexSr
)

452 (
	tut32_t
, 
	tv8
::
	tLol
<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

455 
	gv8
::
Hd
<
v8
::
Aay
> 
IndexEnumClbackW
(

456 cڡ 
v8
::
AcssInfo
 &
fo
) {

457 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

458 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

459 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

460 
IndexEnumClback
 
	gback
 = 
t_
<IndexEnumeratorCallback>(

461 
t_
<
_t
>(

462 
obj
->
GIlFld
(
kIndexPrݔtyEnumIndex
)

463 .
As
<
v8
::
Ex
>()->
Vue
()));

464 
back
(
cbfo
);

465  
	gRuVueImp
<
	gv8
::
Aay
>(
cbfo
.
GRuVue
()).
Vue
();

468 
	gv8
::
	tHd
<
	tv8
::
	tAay
> (*
	tNiveIndexEnum
)

469 (cڡ 
	tv8
::
	tAcssInfo
 &);

472 
	gv8
::
Hd
<
v8
::
Boޗn
> 
IndexDClbackW
(

473 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

474 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

475 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

476 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

477 
IndexDClback
 
	gback
 = 
t_
<IndexDeleterCallback>(

478 
t_
<
_t
>(

479 
obj
->
GIlFld
(
kIndexPrݔtyDIndex
)

480 .
As
<
v8
::
Ex
>()->
Vue
()));

481 
back
(
dex
, 
cbfo
);

482  
	gRuVueImp
<
	gv8
::
Boޗn
>(
cbfo
.
GRuVue
()).
Vue
();

485 
	gv8
::
	tHd
<
	tv8
::
	tBoޗn
> (*
	tNiveIndexD
)

486 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

489 
	gv8
::
Hd
<
v8
::
Ieg
> 
IndexQuyClbackW
(

490 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

491 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

492 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

493 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

494 
IndexQuyClback
 
	gback
 = 
t_
<IndexQueryCallback>(

495 
t_
<
_t
>(

496 
obj
->
GIlFld
(
kIndexPrݔtyQuyIndex
)

497 .
As
<
v8
::
Ex
>()->
Vue
()));

498 
back
(
dex
, 
cbfo
);

499  
	gRuVueImp
<
	gv8
::
Ieg
>(
cbfo
.
GRuVue
()).
Vue
();

502 
	gv8
::
	tHd
<
	tv8
::
	tIeg
> (*
	tNiveIndexQuy
)

503 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

	@node_modules/nan/nan_converters.h

9 #ide
NAN_CONVERTERS_H_


10 
	#NAN_CONVERTERS_H_


	)

12 
mea
 
	gimp
 {

13 
	gme
<
tyme
 
	gT
> 
	sToFayBa
 {

14 
	gMaybeLol
<
	tT
> 
	ttu_t
;

16 
	gme
<
tyme
 
	gT
> 
	sVueFayBa
 { 
	gMaybe
<
	tT
> 
	ttu_t
; };

18 
	gme
<
tyme
 
	gT
> 
	gToFay
;

20 
	#X
(
TYPE
) \

21 
me
<> \

22 
ToFay
<
v8
::
TYPE
> : 
ToFayBa
<v8::TYPE> { \

23 
le
 
tu_t
 
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
); \

24 };

	)

26 
X
(
Boޗn
)

27 
X
(
Numb
)

28 
X
(
Sg
)

29 
X
(
Obje
)

30 
X
(
Ieg
)

31 
X
(
Ut32
)

32 
X
(
I32
)

34 #unde
X


36 
	#X
(
TYPE
) \

37 
me
<> \

38 
ToFay
<
TYPE
> : 
VueFayBa
<TYPE> { \

39 
le
 
tu_t
 
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
); \

40 };

	)

42 
X
(
bo
)

43 
X
()

44 
X
(
t64_t
)

45 
X
(
ut32_t
)

46 
X
(
t32_t
)

48 #unde
X


51 
	gme
<
tyme
 
	gT
>

52 
NAN_INLINE


53 
tyme
 
	gimp
::
ToFay
<
T
>::
tu_t
 
To
(
v8
::
Lol
<v8::
Vue
> 
v
) {

54  
imp
::
ToFay
<
T
>::
cvt
(
v
);

57 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

58 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

59 
	~"n_cvrs_43_l.h
"

61 
	~"n_cvrs_e_43_l.h
"

	@node_modules/nan/nan_converters_43_inl.h

9 #ide
NAN_CONVERTERS_43_INL_H_


10 
	#NAN_CONVERTERS_43_INL_H_


	)

12 
	#X
(
TYPE
) \

13 
imp
::
ToFay
<
v8
::
TYPE
>::
tu_t
 \

14 
imp
::
ToFay
<
v8
::
TYPE
>::
	`cvt
(v8::
Lol
<v8::
Vue
> 
v
) { \

15  
v
->
To
 ## 
	`TYPE
(
	`GCutCڋxt
()); \

16 }

	)

18 
	$X
(
Boޗn
)

19 
	$X
(
Numb
)

20 
	$X
(
Sg
)

21 
	$X
(
Obje
)

22 
	$X
(
Ieg
)

23 
	$X
(
Ut32
)

24 
	$X
(
I32
)

26 #unde
X


28 
	#X
(
TYPE
, 
NAME
) \

29 
imp
::
ToFay
<
TYPE
>::
tu_t
 \

30 
imp
::
ToFay
<
TYPE
>::
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) { \

31  
v
->
NAME
 ## 
	`Vue
(
	`GCutCڋxt
()); \

32 
	}

	)
}

34 
	$X
(
bo
, 
Boޗn
)

35 
	$X
(, 
Numb
)

36 
	$X
(
t64_t
, 
Ieg
)

37 
	$X
(
ut32_t
, 
Ut32
)

38 
	$X
(
t32_t
, 
I32
)

40 #unde
X


	@node_modules/nan/nan_converters_pre_43_inl.h

9 #ide
NAN_CONVERTERS_PRE_43_INL_H_


10 
	#NAN_CONVERTERS_PRE_43_INL_H_


	)

12 
	#X
(
TYPE
) \

13 
imp
::
ToFay
<
v8
::
TYPE
>::
tu_t
 \

14 
imp
::
ToFay
<
v8
::
TYPE
>::
	`cvt
(v8::
Lol
<v8::
Vue
> 
v
) { \

15  
MaybeLol
<
v8
::
TYPE
>(
v
->
To
 ## 
	`TYPE
()); \

16 }

	)

18 
	$X
(
Boޗn
)

19 
	$X
(
Numb
)

20 
	$X
(
Sg
)

21 
	$X
(
Obje
)

22 
	$X
(
Ieg
)

23 
	$X
(
Ut32
)

24 
	$X
(
I32
)

26 #unde
X


28 
	#X
(
TYPE
, 
NAME
) \

29 
imp
::
ToFay
<
TYPE
>::
tu_t
 \

30 
imp
::
ToFay
<
TYPE
>::
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) { \

31  
Ju
<
TYPE
>(
v
->
NAME
 ##
	`Vue
()); \

32 
	}

	)
}

34 
	$X
(
bo
, 
Boޗn
)

35 
	$X
(, 
Numb
)

36 
	$X
(
t64_t
, 
Ieg
)

37 
	$X
(
ut32_t
, 
Ut32
)

38 
	$X
(
t32_t
, 
I32
)

40 #unde
X


	@node_modules/nan/nan_implementation_12_inl.h

9 #ide
NAN_IMPLEMENTATION_12_INL_H_


10 
	#NAN_IMPLEMENTATION_12_INL_H_


	)

15 
mea
 
	gimp
 {

19 
	gFay
<
	gv8
::
Aay
>::
tu_t


20 
Fay
<
v8
::
Aay
>::
New
() {

21  
v8
::
Aay
::
New
(v8::
Isީe
::
GCut
());

24 
	gFay
<
	gv8
::
Aay
>::
tu_t


25 
Fay
<
v8
::
Aay
>::
New
(
ngth
) {

26  
v8
::
Aay
::
New
(v8::
Isީe
::
GCut
(), 
ngth
);

31 
	gFay
<
	gv8
::
Boޗn
>::
tu_t


32 
Fay
<
v8
::
Boޗn
>::
New
(
bo
 
vue
) {

33  
v8
::
Boޗn
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

38 
	gFay
<
	gv8
::
BoޗnObje
>::
tu_t


39 
Fay
<
v8
::
BoޗnObje
>::
New
(
bo
 
vue
) {

40  
v8
::
BoޗnObje
::
New
(
vue
).
As
<v8::BooleanObject>();

45 
	gFay
<
	gv8
::
Cڋxt
>::
tu_t


46 
Fay
<
v8
::
Cڋxt
>::
New
v8::
ExnsiCfiguti
* 
exnsis


47 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm


48 , 
v8
::
Lol
<v8::
Vue
> 
obj
) {

49  
v8
::
Cڋxt
::
New
(v8::
Isީe
::
GCut
(), 
exnsis
, 
tm
, 
obj
);

54 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

55 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

56 
Fay
<
v8
::
De
>::
tu_t


57 
Fay
<
v8
::
De
>::
New
(
vue
) {

58 
v8
::
Lol
<v8::
De
> 
t
;

59 i(
	gv8
::
De
::
New
(
GCutCڋxt
(), 
vue
).

60 
ToLol
(
t_
<
v8
::
Lol
<v8::
Vue
>*>(&
t
))) {

61  
v8
::
MaybeLol
<v8::
De
>(
t
);

63  
	gv8
::
MaybeLol
<
v8
::
De
>(
t
);

67 
	gFay
<
	gv8
::
De
>::
tu_t


68 
Fay
<
v8
::
De
>::
New
(
vue
) {

69  
Fay
<
v8
::
De
>::
tu_t
(

70 
v8
::
De
::
New
(v8::
Isީe
::
GCut
(), 
vue
).
As
<v8::Date>());

76 
	gFay
<
	gv8
::
Ex
>::
tu_t


77 
Fay
<
v8
::
Ex
>::
New
(* 
vue
) {

78  
v8
::
Ex
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

83 
	gFay
<
	gv8
::
Funi
>::
tu_t


84 
Fay
<
v8
::
Funi
>::
New

FuniClback
 
back


85 , 
v8
::
Lol
<v8::
Vue
> 
da
) {

86 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

87 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

88 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
(
isީe
);

89 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

90 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
l
).
ToLolChecked
();

92 
	gobj
->
SIlFld
(

93 
imp
::
kFuniIndex


94 , 
v8
::
Ex
::
New
(
isީe
, 
t_
<*>(
back
)));

96 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
isީe
, 
da
);

98 i(!
	gv
.
IsEmy
()) {

99 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

102  
	gsce
.
Es
(
v8
::
Funi
::
New

isީe


103 , 
imp
::
FuniClbackW


104 , 
obj
));

109 
	gFay
<
	gv8
::
FuniTeme
>::
tu_t


110 
Fay
<
v8
::
FuniTeme
>::
New

FuniClback
 
back


111 , 
v8
::
Lol
<v8::
Vue
> 
da


112 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
) {

113 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

114 i(
	gback
) {

115 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

116 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
(
isީe
);

117 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

118 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
l
).
ToLolChecked
();

120 
	gobj
->
SIlFld
(

121 
imp
::
kFuniIndex


122 , 
v8
::
Ex
::
New
(
isީe
, 
t_
<*>(
back
)));

123 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
isީe
, 
da
);

125 i(!
	gv
.
IsEmy
()) {

126 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

129  
	gsce
.
Es
(
v8
::
FuniTeme
::
New

isީe


130 , 
imp
::
FuniClbackW


131 , 
obj


132 , 
sigtu
));

134  
	gv8
::
FuniTeme
::
New
(
isީe
, 0, 
da
, 
sigtu
);

140 
	gFay
<
	gv8
::
Numb
>::
tu_t


141 
Fay
<
v8
::
Numb
>::
New
(
vue
) {

142  
v8
::
Numb
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

147 
	gFay
<
	gv8
::
NumbObje
>::
tu_t


148 
Fay
<
v8
::
NumbObje
>::
New
(
vue
) {

149  
v8
::
NumbObje
::
New
v8::
Isީe
::
GCut
()

150 , 
vue
).
	gAs
<
	gv8
::
NumbObje
>();

155 
	gme
 <
tyme
 
	gT
>

156 
tyme
 
	gIegFay
<
	gT
>::
tu_t


157 
IegFay
<
T
>::
New
(
t32_t
 
vue
) {

158  
To
<
T
>(T::
New
(
v8
::
Isީe
::
GCut
(), 
vue
));

161 
	gme
 <
tyme
 
	gT
>

162 
tyme
 
	gIegFay
<
	gT
>::
tu_t


163 
IegFay
<
T
>::
New
(
ut32_t
 
vue
) {

164  
To
<
T
>(T::
NewFromUnsigd
(
v8
::
Isީe
::
GCut
(), 
vue
));

167 
	gFay
<
	gv8
::
Ut32
>::
tu_t


168 
Fay
<
v8
::
Ut32
>::
New
(
t32_t
 
vue
) {

169  
To
<
v8
::
Ut32
>(

170 
v8
::
Ut32
::
NewFromUnsigd
(v8::
Isީe
::
GCut
(), 
vue
));

173 
	gFay
<
	gv8
::
Ut32
>::
tu_t


174 
Fay
<
v8
::
Ut32
>::
New
(
ut32_t
 
vue
) {

175  
To
<
v8
::
Ut32
>(

176 
v8
::
Ut32
::
NewFromUnsigd
(v8::
Isީe
::
GCut
(), 
vue
));

181 
	gFay
<
	gv8
::
Obje
>::
tu_t


182 
Fay
<
v8
::
Obje
>::
New
() {

183  
v8
::
Obje
::
New
(v8::
Isީe
::
GCut
());

188 
	gFay
<
	gv8
::
ObjeTeme
>::
tu_t


189 
Fay
<
v8
::
ObjeTeme
>::
New
() {

190  
v8
::
ObjeTeme
::
New
(v8::
Isީe
::
GCut
());

195 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

196 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

197 
Fay
<
v8
::
RegExp
>::
tu_t


198 
Fay
<
v8
::
RegExp
>::
New
(

199 
v8
::
Lol
<v8::
Sg
> 
n


200 , 
v8
::
RegExp
::
Fgs
 
ags
) {

201  
v8
::
RegExp
::
New
(
GCutCڋxt
(), 
n
, 
ags
);

204 
	gFay
<
	gv8
::
RegExp
>::
tu_t


205 
Fay
<
v8
::
RegExp
>::
New
(

206 
v8
::
Lol
<v8::
Sg
> 
n


207 , 
v8
::
RegExp
::
Fgs
 
ags
) {

208  
Fay
<
v8
::
RegExp
>::
tu_t
(v8::RegExp::
New
(
n
, 
ags
));

214 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

215 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

216 
Fay
<
v8
::
St
>::
tu_t


217 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

218 
v8
::
StComp
::
Sour
 
c
(
sour
);

219  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
c
);

222 
	gFay
<
	gv8
::
St
>::
tu_t


223 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


224 , 
v8
::
StOrig
 cڡ& 
ig
) {

225 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

226  
	gv8
::
StComp
::
Compe
(
GCutCڋxt
(), &
c
);

229 
	gFay
<
	gv8
::
St
>::
tu_t


230 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

231 
v8
::
StComp
::
Sour
 
c
(
sour
);

232  
	gFay
<
	gv8
::
St
>::
tu_t
(

233 
v8
::
StComp
::
Compe
(v8::
Isީe
::
GCut
(), &
c
));

236 
	gFay
<
	gv8
::
St
>::
tu_t


237 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


238 , 
v8
::
StOrig
 cڡ& 
ig
) {

239 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

240  
	gFay
<
	gv8
::
St
>::
tu_t
(

241 
v8
::
StComp
::
Compe
(v8::
Isީe
::
GCut
(), &
c
));

247 
	gFay
<
	gv8
::
Sigtu
>::
tu_t


248 
Fay
<
v8
::
Sigtu
>::
New
(Fay<v8::Sigtu>::
FTH
 
iv
) {

249  
v8
::
Sigtu
::
New
(v8::
Isީe
::
GCut
(), 
iv
);

254 
	gFay
<
	gv8
::
Sg
>::
tu_t


255 
Fay
<
v8
::
Sg
>::
New
() {

256  
Fay
<
v8
::
Sg
>::
tu_t
(

257 
v8
::
Sg
::
Emy
(v8::
Isީe
::
GCut
()));

260 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

261 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

262 
Fay
<
v8
::
Sg
>::
tu_t


263 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

264  
	gv8
::
Sg
::
NewFromUtf8
(

265 
v8
::
Isީe
::
GCut
(), 
vue
, v8::
NewSgTy
::
kNm
, 
ngth
);

268 
	gFay
<
	gv8
::
Sg
>::
tu_t


269 
Fay
<
v8
::
Sg
>::
New
(
d
::
rg
 cڡ& 
vue
) {

270 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

271  
	gv8
::
Sg
::
NewFromUtf8
(
v8
::
Isީe
::
GCut
(),

272 
vue
.
da
(), 
v8
::
NewSgTy
::
kNm
, 
ic_
<>(vue.
size
()));

275 
	gFay
<
	gv8
::
Sg
>::
tu_t


276 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

277  
	gv8
::
Sg
::
NewFromTwoBy
(
v8
::
Isީe
::
GCut
(), 
vue
,

278 
v8
::
NewSgTy
::
kNm
, 
ngth
);

281 
	gFay
<
	gv8
::
Sg
>::
tu_t


282 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

283  
v8
::
Sg
::
NewExTwoBy
(v8::
Isީe
::
GCut
(), 
vue
);

286 
	gFay
<
	gv8
::
Sg
>::
tu_t


287 
Fay
<
v8
::
Sg
>::
New
(
ExOBySgResour
 * 
vue
) {

288  
v8
::
Sg
::
NewExOBy
(v8::
Isީe
::
GCut
(), 
vue
);

291 
	gFay
<
	gv8
::
Sg
>::
tu_t


292 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

293  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

294 
v8
::
Sg
::
NewFromUtf8
(

295 
v8
::
Isީe
::
GCut
()

296 , 
vue


297 , 
v8
::
Sg
::
kNmSg


298 , 
ngth
));

301 
	gFay
<
	gv8
::
Sg
>::
tu_t


302 
Fay
<
v8
::
Sg
>::
New
(

303 
d
::
rg
 cڡ& 
vue
) {

304 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

305  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

306 
v8
::
Sg
::
NewFromUtf8
(

307 
v8
::
Isީe
::
GCut
()

308 , 
vue
.
da
()

309 , 
v8
::
Sg
::
kNmSg


310 , 
ic_
<>(
vue
.
size
())));

313 
	gFay
<
	gv8
::
Sg
>::
tu_t


314 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

315  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

316 
v8
::
Sg
::
NewFromTwoBy
(

317 
v8
::
Isީe
::
GCut
()

318 , 
vue


319 , 
v8
::
Sg
::
kNmSg


320 , 
ngth
));

323 
	gFay
<
	gv8
::
Sg
>::
tu_t


324 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

325  
Fay
<
v8
::
Sg
>::
tu_t
(

326 
v8
::
Sg
::
NewEx
(v8::
Isީe
::
GCut
(), 
vue
));

329 
	gFay
<
	gv8
::
Sg
>::
tu_t


330 
Fay
<
v8
::
Sg
>::
New
(
ExOBySgResour
 * 
vue
) {

331  
Fay
<
v8
::
Sg
>::
tu_t
(

332 
v8
::
Sg
::
NewEx
(v8::
Isީe
::
GCut
(), 
vue
));

338 
	gFay
<
	gv8
::
SgObje
>::
tu_t


339 
Fay
<
v8
::
SgObje
>::
New
(v8::
Lol
<v8::
Sg
> 
vue
) {

340  
v8
::
SgObje
::
New
(
vue
).
As
<v8::StringObject>();

345 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

346 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

347 
Fay
<
v8
::
UnboundSt
>::
tu_t


348 
Fay
<
v8
::
UnboundSt
>::
New
(v8::
Lol
<v8::
Sg
> 
sour
) {

349 
v8
::
StComp
::
Sour
 
c
(
sour
);

350  
	gv8
::
StComp
::
CompeUnboundSt
(

351 
v8
::
Isީe
::
GCut
(), &
c
);

354 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


355 
Fay
<
v8
::
UnboundSt
>::
New
v8::
Lol
<v8::
Sg
> 
sour


356 , 
v8
::
StOrig
 cڡ& 
ig
) {

357 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

358  
	gv8
::
StComp
::
CompeUnboundSt
(

359 
v8
::
Isީe
::
GCut
(), &
c
);

362 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


363 
Fay
<
v8
::
UnboundSt
>::
New
(v8::
Lol
<v8::
Sg
> 
sour
) {

364 
v8
::
StComp
::
Sour
 
c
(
sour
);

365  
	gFay
<
	gv8
::
UnboundSt
>::
tu_t
(

366 
v8
::
StComp
::
CompeUnbound
(v8::
Isީe
::
GCut
(), &
c
));

369 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


370 
Fay
<
v8
::
UnboundSt
>::
New
v8::
Lol
<v8::
Sg
> 
sour


371 , 
v8
::
StOrig
 cڡ& 
ig
) {

372 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

373  
	gFay
<
	gv8
::
UnboundSt
>::
tu_t
(

374 
v8
::
StComp
::
CompeUnbound
(v8::
Isީe
::
GCut
(), &
c
));

382 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


383 
	gme
 <
tyme
 
	gT
>

384 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
) {

385  
v8
::
Lol
<
T
>::
New
(v8::
Isީe
::
GCut
(), 
h
);

389 
	gme
 <
tyme
 
	gT
,ym
	gM
>

390 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T, 
M
> cڡ& 
p
) {

391  
	gv8
::
Lol
<
T
>::
New
(
v8
::
Isީe
::
GCut
(), 
p
);

394 
	gme
 <
tyme
 
	gT
,ym
	gM
>

395 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
) {

396  
	gv8
::
Lol
<
T
>::
New
(
v8
::
Isީe
::
GCut
(), 
p
);

399 
	gme
 <
tyme
 
	gT
>

400 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
) {

401  
v8
::
Lol
<
T
>::
New
(v8::
Isީe
::
GCut
(), 
p
);

	@node_modules/nan/nan_implementation_pre_12_inl.h

9 #ide
NAN_IMPLEMENTATION_PRE_12_INL_H_


10 
	#NAN_IMPLEMENTATION_PRE_12_INL_H_


	)

16 
mea
 
	gimp
 {

20 
	gFay
<
	gv8
::
Aay
>::
tu_t


21 
Fay
<
v8
::
Aay
>::
New
() {

22  
v8
::
Aay
::
New
();

25 
	gFay
<
	gv8
::
Aay
>::
tu_t


26 
Fay
<
v8
::
Aay
>::
New
(
ngth
) {

27  
v8
::
Aay
::
New
(
ngth
);

32 
	gFay
<
	gv8
::
Boޗn
>::
tu_t


33 
Fay
<
v8
::
Boޗn
>::
New
(
bo
 
vue
) {

34  
v8
::
Boޗn
::
New
(
vue
)->
ToBoޗn
();

39 
	gFay
<
	gv8
::
BoޗnObje
>::
tu_t


40 
Fay
<
v8
::
BoޗnObje
>::
New
(
bo
 
vue
) {

41  
v8
::
BoޗnObje
::
New
(
vue
).
As
<v8::BooleanObject>();

46 
	gFay
<
	gv8
::
Cڋxt
>::
tu_t


47 
Fay
<
v8
::
Cڋxt
>::
New
v8::
ExnsiCfiguti
* 
exnsis


48 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm


49 , 
v8
::
Lol
<v8::
Vue
> 
obj
) {

50 
v8
::
Psit
<v8::
Cڋxt
> 
x
 = v8::Cڋxt::
New
(
exnsis
, 
tm
, 
obj
);

51 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
lx
 = v8::Lol<v8::Cڋxt>::
New
(
x
);

52 
	gx
.
Dio
();

53  
	glx
;

58 
	gFay
<
	gv8
::
De
>::
tu_t


59 
Fay
<
v8
::
De
>::
New
(
vue
) {

60  
Fay
<
v8
::
De
>::
tu_t
(v8::De::
New
(
vue
).
As
<v8::Date>());

65 
	gFay
<
	gv8
::
Ex
>::
tu_t


66 
Fay
<
v8
::
Ex
>::
New
(* 
vue
) {

67  
v8
::
Ex
::
New
(
vue
);

72 
	gFay
<
	gv8
::
Funi
>::
tu_t


73 
Fay
<
v8
::
Funi
>::
New

FuniClback
 
back


74 , 
v8
::
Lol
<v8::
Vue
> 
da
) {

75  
Fay
<
v8
::
FuniTeme
>::
New

back


76 , 
da


77 , 
v8
::
Lol
<v8::
Sigtu
>()

78 )->
GFuni
();

84 
	gFay
<
	gv8
::
FuniTeme
>::
tu_t


85 
Fay
<
v8
::
FuniTeme
>::
New

FuniClback
 
back


86 , 
v8
::
Lol
<v8::
Vue
> 
da


87 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
) {

88 i(
back
) {

89 
v8
::
HdSce
 
sce
;

91 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
();

92 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

93 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
l
->
NewIn
();

95 
	gobj
->
SIlFld
(

96 
imp
::
kFuniIndex


97 , 
v8
::
Ex
::
New
(
t_
<*>(
back
)));

99 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
da
);

101 i(!
	gv
.
IsEmy
()) {

102 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

107  
	gsce
.
Clo
(

108 
v8
::
FuniTeme
::
New
(
imp
::
FuniClbackW


109 , 
obj


110 , 
sigtu
));

112  
	gv8
::
FuniTeme
::
New
(0, 
da
, 
sigtu
);

118 
	gFay
<
	gv8
::
Numb
>::
tu_t


119 
Fay
<
v8
::
Numb
>::
New
(
vue
) {

120  
v8
::
Numb
::
New
(
vue
);

125 
	gFay
<
	gv8
::
NumbObje
>::
tu_t


126 
Fay
<
v8
::
NumbObje
>::
New
(
vue
) {

127  
v8
::
NumbObje
::
New
(
vue
).
As
<v8::NumberObject>();

132 
	gme
 <
tyme
 
	gT
>

133 
tyme
 
	gIegFay
<
	gT
>::
tu_t


134 
IegFay
<
T
>::
New
(
t32_t
 
vue
) {

135  
To
<
T
>(T::
New
(
vue
));

138 
	gme
 <
tyme
 
	gT
>

139 
tyme
 
	gIegFay
<
	gT
>::
tu_t


140 
IegFay
<
T
>::
New
(
ut32_t
 
vue
) {

141  
To
<
T
>(T::
NewFromUnsigd
(
vue
));

144 
	gFay
<
	gv8
::
Ut32
>::
tu_t


145 
Fay
<
v8
::
Ut32
>::
New
(
t32_t
 
vue
) {

146  
To
<
v8
::
Ut32
>(v8::Ut32::
NewFromUnsigd
(
vue
));

149 
	gFay
<
	gv8
::
Ut32
>::
tu_t


150 
Fay
<
v8
::
Ut32
>::
New
(
ut32_t
 
vue
) {

151  
To
<
v8
::
Ut32
>(v8::Ut32::
NewFromUnsigd
(
vue
));

157 
	gFay
<
	gv8
::
Obje
>::
tu_t


158 
Fay
<
v8
::
Obje
>::
New
() {

159  
v8
::
Obje
::
New
();

164 
	gFay
<
	gv8
::
ObjeTeme
>::
tu_t


165 
Fay
<
v8
::
ObjeTeme
>::
New
() {

166  
v8
::
ObjeTeme
::
New
();

171 
	gFay
<
	gv8
::
RegExp
>::
tu_t


172 
Fay
<
v8
::
RegExp
>::
New
(

173 
v8
::
Lol
<v8::
Sg
> 
n


174 , 
v8
::
RegExp
::
Fgs
 
ags
) {

175  
Fay
<
v8
::
RegExp
>::
tu_t
(v8::RegExp::
New
(
n
, 
ags
));

180 
	gFay
<
	gv8
::
St
>::
tu_t


181 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

182  
Fay
<
v8
::
St
>::
tu_t
(v8::St::
New
(
sour
));

184 
	gFay
<
	gv8
::
St
>::
tu_t


185 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


186 , 
v8
::
StOrig
 cڡ& 
ig
) {

187  
Fay
<
v8
::
St
>::
tu_t
(

188 
v8
::
St
::
New
(
sour
, 
cڡ_
<v8::
StOrig
*>(&
ig
)));

193 
	gFay
<
	gv8
::
Sigtu
>::
tu_t


194 
Fay
<
v8
::
Sigtu
>::
New
(Fay<v8::Sigtu>::
FTH
 
iv
) {

195  
v8
::
Sigtu
::
New
(
iv
);

200 
	gFay
<
	gv8
::
Sg
>::
tu_t


201 
Fay
<
v8
::
Sg
>::
New
() {

202  
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
Emy
());

205 
	gFay
<
	gv8
::
Sg
>::
tu_t


206 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

207  
	gFay
<
	gv8
::
Sg
>::
tu_t
(
v8
::Sg::
New
(
vue
, 
ngth
));

210 
	gFay
<
	gv8
::
Sg
>::
tu_t


211 
Fay
<
v8
::
Sg
>::
New
(

212 
d
::
rg
 cڡ& 
vue
) {

213 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

214  
	gFay
<
	gv8
::
Sg
>::
tu_t
(

215 
v8
::
Sg
::
New

vue
.
da
(), 
ic_
<>(vue.
size
())));

218 
	gFay
<
	gv8
::
Sg
>::
tu_t


219 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

220  
	gFay
<
	gv8
::
Sg
>::
tu_t
(
v8
::Sg::
New
(
vue
, 
ngth
));

223 
	gFay
<
	gv8
::
Sg
>::
tu_t


224 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

225  
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
NewEx
(
vue
));

228 
	gFay
<
	gv8
::
Sg
>::
tu_t


229 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExAsciiSgResour
 * 
vue
) {

230  
Fay
<
v8
::
Sg
>::
tu_t
(v8::Sg::
NewEx
(
vue
));

235 
	gFay
<
	gv8
::
SgObje
>::
tu_t


236 
Fay
<
v8
::
SgObje
>::
New
(v8::
Lol
<v8::
Sg
> 
vue
) {

237  
v8
::
SgObje
::
New
(
vue
).
As
<v8::StringObject>();

244 
	gme
 <
tyme
 
	gT
>

245 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
) {

246  
v8
::
Lol
<
T
>::
New
(
h
);

249 
	gme
 <
tyme
 
	gT
>

250 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T> cڡ& 
p
) {

251  
v8
::
Lol
<
T
>::
New
(
p
);

254 
	gme
 <
tyme
 
	gT
,ym
	gM
>

255 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
) {

256  
	gv8
::
Lol
<
T
>::
New
(
p
.
rsit
);

259 
	gme
 <
tyme
 
	gT
>

260 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
) {

261  
v8
::
Lol
<
T
>::
New
(
p
.
rsit
);

	@node_modules/nan/nan_maybe_43_inl.h

9 #ide
NAN_MAYBE_43_INL_H_


10 
	#NAN_MAYBE_43_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 
usg
 
	gMaybeLol
 = 
v8
::
MaybeLol
<
T
>;

15 
	gme
<
tyme
 
	gT
>

16 
usg
 
	gMaybe
 = 
v8
::
Maybe
<
T
>;

18 
	gme
<
tyme
 
	gT
>

19 
NAN_INLINE
 
	gMaybe
<
	gT
> 
	$Nhg
() {

20  
v8
::
Nhg
<
T
>();

21 
	}
}

23 
	gme
<
tyme
 
	gT
>

24 
NAN_INLINE
 
	gMaybe
<
	gT
> 
	$Ju
(cڡ 
T
& 
t
) {

25  
v8
::
Ju
<
T
>(
t
);

26 
	}
}

28 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
GCutCڋxt
();

30 
NAN_INLINE


31 
	gMaybeLol
<
	gv8
::
Sg
> 
ToDaSg
(
v8
::
Lol
<v8::
Vue
> 
v
) {

32  
v
->
ToDaSg
(
GCutCڋxt
());

35 
NAN_INLINE


36 
	gMaybeLol
<
	gv8
::
Ut32
> 
ToAayIndex
(
v8
::
Lol
<v8::
Vue
> 
v
) {

37  
v
->
ToAayIndex
(
GCutCڋxt
());

40 
NAN_INLINE


41 
	gMaybe
<
	gbo
> 
Equs
(
v8
::
Lol
<v8::
Vue
> 
a
, v8::Lol<v8::Vue>(
b
)) {

42  
a
->
Equs
(
GCutCڋxt
(), 
b
);

45 
NAN_INLINE


46 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Lol
<v8::
Funi
> 
h
) {

47  
h
->
NewIn
(
GCutCڋxt
());

50 
NAN_INLINE


51 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(

52 
v8
::
Lol
<v8::
Funi
> 
h


53 , 
gc


54 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

55  
h
->
NewIn
(
GCutCڋxt
(), 
gc
, 
gv
);

58 
NAN_INLINE


59 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Lol
<v8::
ObjeTeme
> 
h
) {

60  
h
->
NewIn
(
GCutCڋxt
());

64 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Funi
> 
GFuni
(

65 
v8
::
Lol
<v8::
FuniTeme
> 
t
) {

66  
t
->
GFuni
(
GCutCڋxt
());

69 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

70 
v8
::
Lol
<v8::
Obje
> 
obj


71 , 
v8
::
Lol
<v8::
Vue
> 
key


72 , 
v8
::
Lol
<v8::
Vue
> 
vue
) {

73  
obj
->
S
(
GCutCڋxt
(), 
key
, 
vue
);

76 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

77 
v8
::
Lol
<v8::
Obje
> 
obj


78 , 
ut32_t
 
dex


79 , 
v8
::
Lol
<v8::
Vue
> 
vue
) {

80  
obj
->
S
(
GCutCڋxt
(), 
dex
, 
vue
);

83 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
FS
(

84 
v8
::
Lol
<v8::
Obje
> 
obj


85 , 
v8
::
Lol
<v8::
Vue
> 
key


86 , 
v8
::
Lol
<v8::
Vue
> 
vue


87 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

88  
obj
->
FS
(
GCutCڋxt
(), 
key
, 
vue
, 
ibs
);

91 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

92 
v8
::
Lol
<v8::
Obje
> 
obj


93 , 
v8
::
Lol
<v8::
Vue
> 
key
) {

94  
obj
->
G
(
GCutCڋxt
(), 
key
);

97 
NAN_INLINE


98 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

99  
	gobj
->
G
(
GCutCڋxt
(), 
dex
);

102 
NAN_INLINE
 
	gv8
::
PrݔtyAribu
 
GPrݔtyAribus
(

103 
v8
::
Lol
<v8::
Obje
> 
obj


104 , 
v8
::
Lol
<v8::
Vue
> 
key
) {

105  
obj
->
GPrݔtyAribus
(
GCutCڋxt
(), 
key
).
FromJu
();

108 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(

109 
v8
::
Lol
<v8::
Obje
> 
obj


110 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

111  
obj
->
Has
(
GCutCڋxt
(), 
key
);

114 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

115  
	gobj
->
Has
(
GCutCڋxt
(), 
dex
);

118 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
De
(

119 
v8
::
Lol
<v8::
Obje
> 
obj


120 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

121  
obj
->
De
(
GCutCڋxt
(), 
key
);

124 
NAN_INLINE


125 
	gMaybe
<
	gbo
> 
De
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

126  
	gobj
->
De
(
GCutCڋxt
(), 
dex
);

129 
NAN_INLINE


130 
	gMaybeLol
<
	gv8
::
Aay
> 
GPrݔtyNames
(
v8
::
Lol
<v8::
Obje
> 
obj
) {

131  
obj
->
GPrݔtyNames
(
GCutCڋxt
());

134 
NAN_INLINE


135 
	gMaybeLol
<
	gv8
::
Aay
> 
GOwnPrݔtyNames
(
v8
::
Lol
<v8::
Obje
> 
obj
) {

136  
obj
->
GOwnPrݔtyNames
(
GCutCڋxt
());

139 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
SPry
(

140 
v8
::
Lol
<v8::
Obje
> 
obj


141 , 
v8
::
Lol
<v8::
Vue
> 
y
) {

142  
obj
->
SPry
(
GCutCڋxt
(), 
y
);

145 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
> 
ObjeProToSg
(

146 
v8
::
Lol
<v8::
Obje
> 
obj
) {

147  
obj
->
ObjeProToSg
(
GCutCڋxt
());

150 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasOwnPrݔty
(

151 
v8
::
Lol
<v8::
Obje
> 
obj


152 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

153  
obj
->
HasOwnPrݔty
(
GCutCڋxt
(), 
key
);

156 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedPrݔty
(

157 
v8
::
Lol
<v8::
Obje
> 
obj


158 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

159  
obj
->
HasRlNamedPrݔty
(
GCutCڋxt
(), 
key
);

162 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlIndexedPrݔty
(

163 
v8
::
Lol
<v8::
Obje
> 
obj


164 , 
ut32_t
 
dex
) {

165  
	gobj
->
HasRlIndexedPrݔty
(
GCutCڋxt
(), 
dex
);

168 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedClbackPrݔty
(

169 
v8
::
Lol
<v8::
Obje
> 
obj


170 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

171  
obj
->
HasRlNamedClbackPrݔty
(
GCutCڋxt
(), 
key
);

174 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔtyInPryCha
(

175 
v8
::
Lol
<v8::
Obje
> 
obj


176 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

177  
obj
->
GRlNamedPrݔtyInPryCha
(
GCutCڋxt
(), 
key
);

180 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔty
(

181 
v8
::
Lol
<v8::
Obje
> 
obj


182 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

183  
obj
->
GRlNamedPrݔty
(
GCutCڋxt
(), 
key
);

186 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsFuni
(

187 
v8
::
Lol
<v8::
Obje
> 
obj


188 , 
v8
::
Lol
<v8::
Obje
> 
cv


189 , 
gc


190 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

191  
obj
->
ClAsFuni
(
GCutCڋxt
(), 
cv
, 
gc
, 
gv
);

194 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsCڡru
(

195 
v8
::
Lol
<v8::
Obje
> 
obj


196 , 
gc
, 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

197  
obj
->
ClAsCڡru
(
GCutCڋxt
(), 
gc
, 
gv
);

200 
NAN_INLINE


201 
	gMaybeLol
<
	gv8
::
Sg
> 
GSourLe
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

202  
msg
->
GSourLe
(
GCutCڋxt
());

205 
NAN_INLINE
 
	gMaybe
<> 
GLeNumb
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

206  
msg
->
GLeNumb
(
GCutCڋxt
());

209 
NAN_INLINE
 
	gMaybe
<> 
GSCumn
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

210  
msg
->
GSCumn
(
GCutCڋxt
());

213 
NAN_INLINE
 
	gMaybe
<> 
GEndCumn
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

214  
msg
->
GEndCumn
(
GCutCڋxt
());

217 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
CleEmtAt
(

218 
v8
::
Lol
<v8::
Aay
> 
y


219 , 
ut32_t
 
dex
) {

220  
	gy
->
CleEmtAt
(
GCutCڋxt
(), 
dex
);

223 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

224 
v8
::
Lol
<v8::
Funi
> 
fun


225 , 
v8
::
Lol
<v8::
Obje
> 
cv


226 , 
gc


227 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

228  
fun
->
Cl
(
GCutCڋxt
(), 
cv
, 
gc
, 
gv
);

	@node_modules/nan/nan_maybe_pre_43_inl.h

9 #ide
NAN_MAYBE_PRE_43_INL_H_


10 
	#NAN_MAYBE_PRE_43_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cMaybeLol
 {

14 
	mpublic
:

15 
NAN_INLINE
 
	$MaybeLol
(: 
	`v_
(
v8
::
Lol
<
T
>()) {}

17 
me
<
tyme
 
S
>

18 #i
NODE_MODULE_VERSION
 >
NODE_0_12_MODULE_VERSION


19 
NAN_INLINE
 
	`MaybeLol
(
v8
::
Lol
<
S
> 
th
: 
	$v_
(
th
{
	}
}

21 
NAN_INLINE
 
MaybeLol
(
v8
::
Lol
<
S
> 
th
) :

22 
v_
(*
t_
<
v8
::
Lol
<
T
>*>(&
th
)) {}

25 
NAN_INLINE
 
bo
 
	$IsEmy
(cڡ {  
v_
.
	`IsEmy
(); 
	}
}

27 
	gme
<
tyme
 
	gS
>

28 
NAN_INLINE
 
bo
 
ToLol
(
v8
::
Lol
<
S
> *
out
) const {

29 *
out
 = 
v_
;

30  !
IsEmy
();

33 
NAN_INLINE
 
	gv8
::
Lol
<
T
> 
	$ToLolChecked
() const {

34 #i
	`defed
(
V8_ENABLE_CHECKS
)

35 
	`as
(!
	`IsEmy
() && "ToLocalChecked is Empty");

37  
v_
;

38 
	}
}

40 
	gme
<
tyme
 
	gS
>

41 
NAN_INLINE
 
	gv8
::
Lol
<
S
> 
FromMaybe
(
v8
::Lol<S> 
deu_vue
) const {

42  
IsEmy
(? 
deu_vue
 : 
v_
;

45 
	give
:

46 
v8
::
Lol
<
T
> 
v_
;

49 
	gme
<
tyme
 
	gT
>

50 as
	cMaybe
 {

51 
	mpublic
:

52 
NAN_INLINE
 
bo
 
	$IsNhg
(cڡ {  !
has_vue_
; }

53 
NAN_INLINE
 
bo
 
	$IsJu
(cڡ {  
has_vue_
; 
	}
}

55 
NAN_INLINE
 
T
 
	$FromJu
() const {

56 #i
	`defed
(
V8_ENABLE_CHECKS
)

57 
	`as
(
	`IsJu
() && "FromJust is Nothing");

59  
vue_
;

60 
	}
}

62 
NAN_INLINE
 
T
 
	$FromMaybe
(cڡ 
T
& 
deu_vue
) const {

63  
has_vue_
 ? 
vue_
 : 
deu_vue
;

64 
	}
}

66 
NAN_INLINE
 
bo
 
	gݔ
==(cڡ 
Maybe
 &
h
) const {

67  (
IsJu
(=
h
.IsJust()) &&

68 (!
IsJu
(|| 
FromJu
(=
h
.FromJust());

71 
NAN_INLINE
 
bo
 
	gݔ
!=(cڡ 
Maybe
 &
h
) const {

72  !
ݔ
==(
h
);

75 
	give
:

76 
	$Maybe
(: 
	$has_vue_
(
l
{
	}
}

77 
exic
 
	$Maybe
(cڡ 
T
& 
t
: 
	`has_vue_
(
ue
), 
	$vue_
(
t
{
	}
}

78 
bo
 
	ghas_vue_
;

79 
T
 
	gvue_
;

81 
	gme
<
tyme
 
	gU
>

82 
nd
 
	gMaybe
<
	gU
> 
Nhg
();

83 
	gme
<
tyme
 
	gU
>

84 
nd
 
	gMaybe
<
	gU
> 
Ju
(cڡ 
U
& 
u
);

87 
	gme
<
tyme
 
	gT
>

88 
le
 
	gMaybe
<
	gT
> 
	$Nhg
() {

89  
Maybe
<
T
>();

90 
	}
}

92 
	gme
<
tyme
 
	gT
>

93 
le
 
	gMaybe
<
	gT
> 
	$Ju
(cڡ 
T
& 
t
) {

94  
Maybe
<
T
>(
t
);

95 
	}
}

97 
NAN_INLINE


98 
	gMaybeLol
<
	gv8
::
Sg
> 
ToDaSg
(
v8
::
Hd
<v8::
Vue
> 
v
) {

99  
MaybeLol
<
v8
::
Sg
>(
v
->
ToDaSg
());

102 
NAN_INLINE


103 
	gMaybeLol
<
	gv8
::
Ut32
> 
ToAayIndex
(
v8
::
Hd
<v8::
Vue
> 
v
) {

104  
MaybeLol
<
v8
::
Ut32
>(
v
->
ToAayIndex
());

107 
NAN_INLINE


108 
	gMaybe
<
	gbo
> 
Equs
(
v8
::
Hd
<v8::
Vue
> 
a
, v8::Hd<v8::Vue>(
b
)) {

109  
Ju
<
bo
>(
a
->
Equs
(
b
));

112 
NAN_INLINE


113 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Hd
<v8::
Funi
> 
h
) {

114  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
());

117 
NAN_INLINE


118 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(

119 
v8
::
Lol
<v8::
Funi
> 
h


120 , 
gc


121 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

122  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
(
gc
, 
gv
));

125 
NAN_INLINE


126 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Hd
<v8::
ObjeTeme
> 
h
) {

127  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
());

130 
NAN_INLINE


131 
	gMaybeLol
<
	gv8
::
Funi
> 
GFuni
(
v8
::
Hd
<v8::
FuniTeme
> 
t
) {

132  
MaybeLol
<
v8
::
Funi
>(
t
->
GFuni
());

135 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

136 
v8
::
Hd
<v8::
Obje
> 
obj


137 , 
v8
::
Hd
<v8::
Vue
> 
key


138 , 
v8
::
Hd
<v8::
Vue
> 
vue
) {

139  
Ju
<
bo
>(
obj
->
S
(
key
, 
vue
));

142 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
S
(

143 
v8
::
Hd
<v8::
Obje
> 
obj


144 , 
ut32_t
 
dex


145 , 
v8
::
Hd
<v8::
Vue
> 
vue
) {

146  
Ju
<
bo
>(
obj
->
S
(
dex
, 
vue
));

149 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
FS
(

150 
v8
::
Hd
<v8::
Obje
> 
obj


151 , 
v8
::
Hd
<v8::
Vue
> 
key


152 , 
v8
::
Hd
<v8::
Vue
> 
vue


153 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

154  
Ju
<
bo
>(
obj
->
FS
(
key
, 
vue
, 
ibs
));

157 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

158 
v8
::
Hd
<v8::
Obje
> 
obj


159 , 
v8
::
Hd
<v8::
Vue
> 
key
) {

160  
MaybeLol
<
v8
::
Vue
>(
obj
->
G
(
key
));

163 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

164 
v8
::
Hd
<v8::
Obje
> 
obj


165 , 
ut32_t
 
dex
) {

166  
	gMaybeLol
<
	gv8
::
Vue
>(
obj
->
G
(
dex
));

169 
NAN_INLINE
 
	gMaybe
<
	gv8
::
PrݔtyAribu
> 
GPrݔtyAribus
(

170 
v8
::
Hd
<v8::
Obje
> 
obj


171 , 
v8
::
Hd
<v8::
Vue
> 
key
) {

172  
Ju
<
v8
::
PrݔtyAribu
>(
obj
->
GPrݔtyAribus
(
key
));

175 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(

176 
v8
::
Hd
<v8::
Obje
> 
obj


177 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

178  
Ju
<
bo
>(
obj
->
Has
(
key
));

181 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
Has
(

182 
v8
::
Hd
<v8::
Obje
> 
obj


183 , 
ut32_t
 
dex
) {

184  
	gJu
<
	gbo
>(
	gobj
->
Has
(
dex
));

187 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
De
(

188 
v8
::
Hd
<v8::
Obje
> 
obj


189 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

190  
Ju
<
bo
>(
obj
->
De
(
key
));

193 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
De
(

194 
v8
::
Hd
<v8::
Obje
> 
obj


195 , 
ut32_t
 
dex
) {

196  
	gJu
<
	gbo
>(
	gobj
->
De
(
dex
));

199 
NAN_INLINE


200 
	gMaybeLol
<
	gv8
::
Aay
> 
GPrݔtyNames
(
v8
::
Hd
<v8::
Obje
> 
obj
) {

201  
MaybeLol
<
v8
::
Aay
>(
obj
->
GPrݔtyNames
());

204 
NAN_INLINE


205 
	gMaybeLol
<
	gv8
::
Aay
> 
GOwnPrݔtyNames
(
v8
::
Hd
<v8::
Obje
> 
obj
) {

206  
MaybeLol
<
v8
::
Aay
>(
obj
->
GOwnPrݔtyNames
());

209 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
SPry
(

210 
v8
::
Hd
<v8::
Obje
> 
obj


211 , 
v8
::
Hd
<v8::
Vue
> 
y
) {

212  
Ju
<
bo
>(
obj
->
SPry
(
y
));

215 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Sg
> 
ObjeProToSg
(

216 
v8
::
Hd
<v8::
Obje
> 
obj
) {

217  
MaybeLol
<
v8
::
Sg
>(
obj
->
ObjeProToSg
());

220 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasOwnPrݔty
(

221 
v8
::
Hd
<v8::
Obje
> 
obj


222 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

223  
Ju
<
bo
>(
obj
->
HasOwnPrݔty
(
key
));

226 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedPrݔty
(

227 
v8
::
Hd
<v8::
Obje
> 
obj


228 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

229  
Ju
<
bo
>(
obj
->
HasRlNamedPrݔty
(
key
));

232 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlIndexedPrݔty
(

233 
v8
::
Hd
<v8::
Obje
> 
obj


234 , 
ut32_t
 
dex
) {

235  
	gJu
<
	gbo
>(
	gobj
->
HasRlIndexedPrݔty
(
dex
));

238 
NAN_INLINE
 
	gMaybe
<
	gbo
> 
HasRlNamedClbackPrݔty
(

239 
v8
::
Hd
<v8::
Obje
> 
obj


240 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

241  
Ju
<
bo
>(
obj
->
HasRlNamedClbackPrݔty
(
key
));

244 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔtyInPryCha
(

245 
v8
::
Hd
<v8::
Obje
> 
obj


246 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

247  
MaybeLol
<
v8
::
Vue
>(

248 
obj
->
GRlNamedPrݔtyInPryCha
(
key
));

251 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔty
(

252 
v8
::
Hd
<v8::
Obje
> 
obj


253 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

254  
MaybeLol
<
v8
::
Vue
>(
obj
->
GRlNamedPrݔty
(
key
));

257 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsFuni
(

258 
v8
::
Hd
<v8::
Obje
> 
obj


259 , 
v8
::
Hd
<v8::
Obje
> 
cv


260 , 
gc


261 , 
v8
::
Hd
<v8::
Vue
> 
gv
[]) {

262  
MaybeLol
<
v8
::
Vue
>(
obj
->
ClAsFuni
(
cv
, 
gc
, 
gv
));

265 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsCڡru
(

266 
v8
::
Hd
<v8::
Obje
> 
obj


267 , 
gc


268 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

269  
MaybeLol
<
v8
::
Vue
>(
obj
->
ClAsCڡru
(
gc
, 
gv
));

272 
NAN_INLINE


273 
	gMaybeLol
<
	gv8
::
Sg
> 
GSourLe
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

274  
MaybeLol
<
v8
::
Sg
>(
msg
->
GSourLe
());

277 
NAN_INLINE
 
	gMaybe
<> 
GLeNumb
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

278  
Ju
<>(
msg
->
GLeNumb
());

281 
NAN_INLINE
 
	gMaybe
<> 
GSCumn
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

282  
Ju
<>(
msg
->
GSCumn
());

285 
NAN_INLINE
 
	gMaybe
<> 
GEndCumn
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

286  
Ju
<>(
msg
->
GEndCumn
());

289 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Obje
> 
CleEmtAt
(

290 
v8
::
Hd
<v8::
Aay
> 
y


291 , 
ut32_t
 
dex
) {

292  
	gMaybeLol
<
	gv8
::
Obje
>(
y
->
CleEmtAt
(
dex
));

295 
NAN_INLINE
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

296 
v8
::
Lol
<v8::
Funi
> 
fun


297 , 
v8
::
Lol
<v8::
Obje
> 
cv


298 , 
gc


299 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

300  
MaybeLol
<
v8
::
Vue
>(
fun
->
Cl
(
cv
, 
gc
, 
gv
));

	@node_modules/nan/nan_new.h

9 #ide
NAN_NEW_H_


10 
	#NAN_NEW_H_


	)

12 
mea
 
	gimp
 {

15 
	gme
 <
tyme
 
	gT
> 
	gv8
::
Lol
<
T
> 
To
(
v8
::Lol<v8::
Ieg
> 
i
);

17 
	gme
 <>

18 
le


19 
	gv8
::
Lol
<
v8
::
Ieg
>

20 
To
<
v8
::
Ieg
>(v8::
Lol
<v8::Ieg> 
i
) {

21  
N
::
To
<
v8
::
Ieg
>(
i
).
ToLolChecked
();

24 
	gme
 <>

25 
le


26 
	gv8
::
Lol
<
v8
::
I32
>

27 
To
<
v8
::
I32
>(v8::
Lol
<v8::
Ieg
> 
i
) {

28  
N
::
To
<
v8
::
I32
>(
i
).
ToLolChecked
();

31 
	gme
 <>

32 
le


33 
	gv8
::
Lol
<
v8
::
Ut32
>

34 
To
<
v8
::
Ut32
>(v8::
Lol
<v8::
Ieg
> 
i
) {

35  
N
::
To
<
v8
::
Ut32
>(
i
).
ToLolChecked
();

38 
	gme
 <
tyme
 
	gT
> 
	sFayBa
 {

39 
	gv8
::
	tLol
<
	tT
> 
	ttu_t
;

42 
	gme
 <
tyme
 
	gT
> 
	sMaybeFayBa
 {

43 
	gMaybeLol
<
	tT
> 
	ttu_t
;

46 
	gme
 <
tyme
 
	gT
> 
	gFay
;

48 
	gme
 <>

49 
	gFay
<
	gv8
::
Aay
> : 
FayBa
<
v8
::Array> {

50 
le
 
tu_t
 
New
();

51 
le
 
tu_t
 
New
(
ngth
);

54 
	gme
 <>

55 
	gFay
<
	gv8
::
Boޗn
> : 
FayBa
<
v8
::Boolean> {

56 
le
 
tu_t
 
New
(
bo
 
vue
);

59 
	gme
 <>

60 
	gFay
<
	gv8
::
BoޗnObje
> : 
FayBa
<
v8
::BooleanObject> {

61 
le
 
tu_t
 
New
(
bo
 
vue
);

64 
	gme
 <>

65 
	gFay
<
	gv8
::
Cڋxt
> : 
FayBa
<
v8
::Context> {

66 
le


67 
tu_t


68 
New

v8
::
ExnsiCfiguti
* 
exnsis
 = 
NULL


69 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm
 = v8::Local<v8::ObjectTemplate>()

70 , 
v8
::
Lol
<v8::
Vue
> 
obj
 = v8::Local<v8::Value>());

73 
	gme
 <>

74 
	gFay
<
	gv8
::
De
> : 
MaybeFayBa
<
v8
::Date> {

75 
le
 
tu_t
 
New
(
vue
);

78 
	gme
 <>

79 
	gFay
<
	gv8
::
Ex
> : 
FayBa
<
v8
::External> {

80 
le
 
tu_t
 
New
(*
vue
);

83 
	gme
 <>

84 
	gFay
<
	gv8
::
Funi
> : 
FayBa
<
v8
::Function> {

85 
le


86 
tu_t


87 
New

FuniClback
 
back


88 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>());

91 
	gme
 <>

92 
	gFay
<
	gv8
::
FuniTeme
> : 
FayBa
<
v8
::FunctionTemplate> {

93 
le


94 
tu_t


95 
New

FuniClback
 
back
 = 
NULL


96 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

97 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
 = v8::Local<v8::Signature>());

100 
	gme
 <>

101 
	gFay
<
	gv8
::
Numb
> : 
FayBa
<
v8
::Number> {

102 
le
 
tu_t
 
New
(
vue
);

105 
	gme
 <>

106 
	gFay
<
	gv8
::
NumbObje
> : 
FayBa
<
v8
::NumberObject> {

107 
le
 
tu_t
 
New
(
vue
);

110 
	gme
 <
tyme
 
	gT
>

111 
	gIegFay
 : 
FayBa
<
T
> {

112 
tyme
 
	tFayBa
<
	tT
>::
	ttu_t
eturn_t;

113 
le
 
tu_t
 
New
(
t32_t
 
vue
);

114 
le
 
tu_t
 
New
(
ut32_t
 
vue
);

117 
	gme
 <>

118 
	gFay
<
	gv8
::
Ieg
> : 
IegFay
<
v8
::Integer> {};

120 
	gme
 <>

121 
	gFay
<
	gv8
::
I32
> : 
IegFay
<
v8
::Int32> {};

123 
	gme
 <>

124 
	gFay
<
	gv8
::
Ut32
> : 
FayBa
<
v8
::Uint32> {

125 
le
 
tu_t
 
New
(
t32_t
 
vue
);

126 
le
 
tu_t
 
New
(
ut32_t
 
vue
);

129 
	gme
 <>

130 
	gFay
<
	gv8
::
Obje
> : 
FayBa
<
v8
::Object> {

131 
le
 
tu_t
 
New
();

134 
	gme
 <>

135 
	gFay
<
	gv8
::
ObjeTeme
> : 
FayBa
<
v8
::ObjectTemplate> {

136 
le
 
tu_t
 
New
();

139 
	gme
 <>

140 
	gFay
<
	gv8
::
RegExp
> : 
MaybeFayBa
<
v8
::RegExp> {

141 
le
 
tu_t
 
New
(

142 
v8
::
Lol
<v8::
Sg
> 
n
, v8::
RegExp
::
Fgs
 
ags
);

145 
	gme
 <>

146 
	gFay
<
	gv8
::
St
> : 
MaybeFayBa
<
v8
::Script> {

147 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour
);

148 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour


149 , 
v8
::
StOrig
 cڡ& 
ig
);

152 
	gme
 <>

153 
	gFay
<
	gv8
::
Sigtu
> : 
FayBa
<
v8
::Signature> {

154 
v8
::
	tLol
<
	tv8
::
	tFuniTeme
> 
	tFTH
;

155 
le
 
tu_t
 
New
(
FTH
 
iv
 = FTH());

158 
	gme
 <>

159 
	gFay
<
	gv8
::
Sg
> : 
MaybeFayBa
<
v8
::String> {

160 
le
 
tu_t
 
New
();

161 
le
 
tu_t
 
New
(cڡ *
vue
, 
ngth
 = -1);

162 
le
 
tu_t
 
New
(cڡ 
ut16_t
 *
vue
, 
ngth
 = -1);

163 
le
 
tu_t
 
New
(
d
::
rg
 cڡ& 
vue
);

165 
le
 
tu_t
 
New
(
v8
::
Sg
::
ExSgResour
 * 
vue
);

166 
le
 
tu_t
 
New
(
ExOBySgResour
 * 
vue
);

169 
	gme
 <>

170 
	gFay
<
	gv8
::
SgObje
> : 
FayBa
<
v8
::StringObject> {

171 
le
 
tu_t
 
New
(
v8
::
Lol
<v8::
Sg
> 
vue
);

176 #i(
NODE_MODULE_VERSION
 >= 12)

178 
mea
 
	gimp
 {

180 
	gme
 <>

181 
	gFay
<
	gv8
::
UnboundSt
> : 
MaybeFayBa
<
v8
::UnboundScript> {

182 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour
);

183 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour


184 , 
v8
::
StOrig
 cڡ& 
ig
);

189 
	~"n_imemti_12_l.h
"

193 
	~"n_imemti_e_12_l.h
"

199 
	gme
 <
tyme
 
	gT
>

200 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


201 
	$New
() {

202  
imp
::
Fay
<
T
>::
	`New
();

203 
	}
}

205 
	gme
 <
tyme
 
	gT
,ym
	gA0
>

206 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


207 
	$New
(
A0
 
g0
) {

208  
imp
::
Fay
<
T
>::
	`New
(
g0
);

209 
	}
}

211 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
>

212 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


213 
	$New
(
A0
 
g0
, 
A1
 
g1
) {

214  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
);

215 
	}
}

217 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
,ym
	gA2
>

218 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


219 
	$New
(
A0
 
g0
, 
A1
 
g1
, 
A2
 
g2
) {

220  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
, 
g2
);

221 
	}
}

223 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
,ym
	gA2
,ym
	gA3
>

224 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


225 
	$New
(
A0
 
g0
, 
A1
 
g1
, 
A2
 
g2
, 
A3
 
g3
) {

226  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
, 
g2
, 
g3
);

227 
	}
}

235 
	gme
 <
tyme
 
	gT
>

236 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


237 
New

FuniClback
 
back


238 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

239  
imp
::
Fay
<
T
>::
New
(
back
, 
da
);

243 
	gme
 <
tyme
 
	gT
,ym
	gA2
>

244 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


245 
New

FuniClback
 
back


246 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

247 , 
A2
 
a2
 = 
	$A2
()) {

248  
imp
::
Fay
<
T
>::
	`New
(
back
, 
da
, 
a2
);

249 
	}
}

253 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


254 
	gme
 <
tyme
 
	gT
> 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
);

257 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


258 
	gme
 <
tyme
 
	gT
,ym
	gM
>

259 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T, 
M
> cڡ& 
p
);

261 
	gme
 <
tyme
 
	gT
> 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T> cڡ& 
p
);

263 
	gme
 <
tyme
 
	gT
,ym
	gM
>

264 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
);

265 
	gme
 <
tyme
 
	gT
>

266 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
);

268 
le


269 
	gimp
::
Fay
<
v8
::
Boޗn
>::
tu_t


270 
	$New
(
bo
 
vue
) {

271  
New
<
v8
::
Boޗn
>(
vue
);

272 
	}
}

274 
le


275 
	gimp
::
Fay
<
v8
::
I32
>::
tu_t


276 
	$New
(
t32_t
 
vue
) {

277  
New
<
v8
::
I32
>(
vue
);

278 
	}
}

280 
le


281 
	gimp
::
Fay
<
v8
::
Ut32
>::
tu_t


282 
	$New
(
ut32_t
 
vue
) {

283  
New
<
v8
::
Ut32
>(
vue
);

284 
	}
}

286 
le


287 
	gimp
::
Fay
<
v8
::
Numb
>::
tu_t


288 
	$New
(
vue
) {

289  
New
<
v8
::
Numb
>(
vue
);

290 
	}
}

292 
le


293 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


294 
	$New
(
d
::
rg
 cڡ& 
vue
) {

295  
New
<
v8
::
Sg
>(
vue
);

296 
	}
}

298 
le


299 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


300 
	$New
(cڡ * 
vue
, 
ngth
) {

301  
New
<
v8
::
Sg
>(
vue
, 
ngth
);

302 
	}
}

304 
le


305 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


306 
	$New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

307  
New
<
v8
::
Sg
>(
vue
, 
ngth
);

308 
	}
}

310 
le


311 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


312 
	$New
(cڡ * 
vue
) {

313  
New
<
v8
::
Sg
>(
vue
);

314 
	}
}

316 
le


317 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


318 
	$New
(cڡ 
ut16_t
 * 
vue
) {

319  
New
<
v8
::
Sg
>(
vue
);

320 
	}
}

322 
le


323 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


324 
	$New
(
v8
::
Sg
::
ExSgResour
 * 
vue
) {

325  
New
<
v8
::
Sg
>(
vue
);

326 
	}
}

328 
le


329 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


330 
	$New
(
ExOBySgResour
 * 
vue
) {

331  
New
<
v8
::
Sg
>(
vue
);

332 
	}
}

334 
le


335 
	gimp
::
Fay
<
v8
::
RegExp
>::
tu_t


336 
New
(
v8
::
Lol
<v8::
Sg
> 
n
, v8::
RegExp
::
Fgs
 
ags
) {

337  
New
<
v8
::
RegExp
>(
n
, 
	gags
);

	@node_modules/nan/nan_object_wrap.h

9 #ide
NAN_OBJECT_WRAP_H_


10 
	#NAN_OBJECT_WRAP_H_


	)

12 as
	cObjeWp
 {

13 
	mpublic
:

14 
	$ObjeWp
() {

15 
fs_
 = 0;

19 
vtu
 ~
	$ObjeWp
() {

20 i(
	`rsit
().
	`IsEmy
()) {

24 
	`as
(
	`rsit
().
	`IsNrDth
());

25 
	`rsit
().
	`CˬWk
();

26 
	`rsit
().
	`Ret
();

27 
	}
}

30 
	gme
 <
ass
 
	gT
>

31 
le
 
T
* 
Unwp
(
v8
::
Lol
<v8::
Obje
> 
obje
) {

32 
as
(!
obje
.
IsEmy
());

33 
as
(
obje
->
IlFldCou
() > 0);

36 * 
	gr
 = 
GIlFldPor
(
obje
, 0);

37 
ObjeWp
* 
	gwp
 = 
ic_
<ObjeWp*>(
r
);

38  
	gic_
<
	gT
*>(
	gwp
);

42 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$hd
() {

43  
	`New
(
	`rsit
());

44 
	}
}

47 
le
 
	gPsit
<
	gv8
::
Obje
>& 
	$rsit
() {

48  
hd_
;

49 
	}
}

52 
	geed
:

53 
le
 
Wp
(
v8
::
Lol
<v8::
Obje
> 
obje
) {

54 
as
(
rsit
().
IsEmy
());

55 
as
(
obje
->
IlFldCou
() > 0);

56 
SIlFldPor
(
obje
, 0, 
this
);

57 
rsit
().
Ret
(
obje
);

58 
MakeWk
();

61 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

62 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

64 
le
 
	$MakeWk
() {

65 
	`rsit
().
v8
::
PsitBa
<v8::
Obje
>::
	`SWk
(

66 
this
, 
WkClback
, 
v8
::
WkClbackTy
::
kPam
);

67 
	`rsit
().
	`MkInddt
();

68 
	}
}

70 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


72 
le
 
	$MakeWk
() {

73 
	`rsit
().
v8
::
PsitBa
<v8::
Obje
>::
	`SWk
(
this
, 
WkClback
);

74 
	`rsit
().
	`MkInddt
();

75 
	}
}

79 
le
 
	$MakeWk
() {

80 
	`rsit
().
rsit
.
	`MakeWk
(
this
, 
WkClback
);

81 
	`rsit
().
	`MkInddt
();

82 
	}
}

90 
vtu
 
	$Ref
() {

91 
	`as
(!
	`rsit
().
	`IsEmy
());

92 
	`rsit
().
	`CˬWk
();

93 
fs_
++;

94 
	}
}

105 
vtu
 
	$Uef
() {

106 
	`as
(!
	`rsit
().
	`IsEmy
());

107 
	`as
(!
	`rsit
().
	`IsWk
());

108 
	`as
(
fs_
 > 0);

109 i(--
fs_
 == 0)

110 
	`MakeWk
();

111 
	}
}

113 
	gfs_
;

115 
	give
:

116 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
ObjeWp
)

117 #i
	`defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

118 (
V8_MAJOR_VERSION
 =4 && 
	`defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

121 
	`WkClback
(
v8
::
WkClbackInfo
<
ObjeWp
> cڡ& 
fo
) {

122 
ObjeWp
* 
wp
 = 
fo
.
	`GPam
();

123 
	`as
(
wp
->
fs_
 == 0);

124 
	`as
(
wp
->
hd_
.
	`IsNrDth
());

125 
wp
->
hd_
.
	`Ret
();

126 
de
 
wp
;

127 
	}
}

129 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


132 
WkClback
(
v8
::
WkClbackDa
<v8::
Obje
, 
ObjeWp
> cڡ& 
da
) {

133 
ObjeWp
* 
	gwp
 = 
da
.
GPam
();

134 
as
(
wp
->
fs_
 == 0);

135 
as
(
wp
->
hd_
.
IsNrDth
());

136 
	gwp
->
	ghd_
.
Ret
();

137 
de
 
	gwp
;

142 
WkClback
(
v8
::
Psit
<v8::
Vue
> 
vue
, *
da
) {

143 
ObjeWp
 *
	gwp
 = 
ic_
<ObjeWp*>(
da
);

144 
as
(
wp
->
fs_
 == 0);

145 
as
(
wp
->
hd_
.
IsNrDth
());

146 
	gwp
->
	ghd_
.
Ret
();

147 
de
 
	gwp
;

151 
	gPsit
<
	gv8
::
Obje
> 
hd_
;

	@node_modules/nan/nan_persistent_12_inl.h

9 #ide
NAN_PERSISTENT_12_INL_H_


10 
	#NAN_PERSISTENT_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
,ym
	gM
> 
ass
 
	gPsit
 :

13 
public
 
v8
::
Psit
<
T
, 
	gM
> {

14 
	gpublic
:

15 
NAN_INLINE
 
Psit
(: 
v8
::Psit<
T
, 
	gM
>() {}

17 
	gme
<
tyme
 
	gS
> 
NAN_INLINE
 
Psit
(
v8
::
Lol
<
S
> 
th
) :

18 
v8
::
Psit
<
T
, 
	gM
>(
	gv8
::
Isީe
::
GCut
(), 
	gth
) {}

20 
	gme
<
tyme
 
	gS
,ym
	gM2
>

21 
NAN_INLINE
 
Psit
(cڡ 
v8
::Psit<
S
, 
M2
> &
th
) :

22 
v8
::
Psit
<
T
, 
	gM2
>(
	gv8
::
Isީe
::
GCut
(), 
	gth
) {}

24 
NAN_INLINE
 
Ret
({ 
	gv8
::
PsitBa
<
T
>::Reset(); }

26 
	gme
 <
tyme
 
	gS
>

27 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

28 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

31 
	gme
 <
tyme
 
	gS
>

32 
NAN_INLINE
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

33 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

36 
	gme
<
tyme
 
	gP
>

37 
NAN_INLINE
 
SWk
(

38 
P
 *
m


39 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


40 , 
WkClbackTy
 
ty
);

42 
	give
:

43 
NAN_INLINE
 
T
 *
ݔ
*(cڡ {  *
PsitBa
<T>::
rsit
; }

45 
	gme
<
tyme
 
	gS
,ym
	gM2
>

46 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M2
> &
th
) {

47 
TYPE_CHECK
(
T
, 
S
);

49 
	gthis
->
Ret
();

51 i(!
	gth
.
IsEmy
()) {

52 
	gthis
->
Ret
(
th
);

53 
	gM
::
Cy
(
th
, 
this
);

58 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

59 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

60 
me
<
tyme
 
T
>

61 
ass
 
Glob
 : 
public
 
v8
::Glob<
T
> {

62 
public
:

63 
NAN_INLINE
 
Glob
(: 
v8
::Glob<
T
>() {}

65 
me
<
tyme
 
S
> 
NAN_INLINE
 
Glob
(
v8
::
Lol
<S> 
th
) :

66 
v8
::
Glob
<
T
>(v8::
Isީe
::
GCut
(), 
th
) {}

68 
me
<
tyme
 
S
>

69 
NAN_INLINE
 
Glob
(cڡ 
v8
::
PsitBa
<
S
> &
th
) :

70 
v8
::
Glob
<
S
>(v8::
Isީe
::
GCut
(), 
th
) {}

72 
NAN_INLINE
 
Ret
({ 
v8
::
PsitBa
<
T
>::Reset(); }

74 
	gme
 <
tyme
 
	gS
>

75 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

76 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

79 
	gme
 <
tyme
 
	gS
>

80 
NAN_INLINE
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

81 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

84 
	gme
<
tyme
 
	gP
>

85 
NAN_INLINE
 
SWk
(

86 
P
 *
m


87 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


88 , 
WkClbackTy
 
ty
) {

89 
	gt_
<
	gPsit
<
	gT
>*>(
	gthis
)->
SWk
(

90 
m
, 
back
, 
ty
);

94 
	gme
<
tyme
 
	gT
>

95 
ass
 
	gGlob
 : 
public
 
v8
::
UniquePsit
<
T
> {

96 
public
:

97 
NAN_INLINE
 
Glob
(: 
v8
::
UniquePsit
<
T
>() {}

99 
me
<
tyme
 
S
> 
NAN_INLINE
 
Glob
(
v8
::
Lol
<S> 
th
) :

100 
v8
::
UniquePsit
<
T
>(v8::
Isީe
::
GCut
(), 
	gth
) {}

102 
	gme
<
tyme
 
	gS
>

103 
NAN_INLINE
 
Glob
(cڡ 
v8
::
PsitBa
<
S
> &
th
) :

104 
v8
::
UniquePsit
<
S
>(v8::
Isީe
::
GCut
(), 
	gth
) {}

106 
NAN_INLINE
 
Ret
({ 
	gv8
::
PsitBa
<
T
>::Reset(); }

108 
	gme
 <
tyme
 
	gS
>

109 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

110 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

113 
	gme
 <
tyme
 
	gS
>

114 
NAN_INLINE
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

115 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

118 
	gme
<
tyme
 
	gP
>

119 
NAN_INLINE
 
SWk
(

120 
P
 *
m


121 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


122 , 
WkClbackTy
 
ty
) {

123 
	gt_
<
	gPsit
<
	gT
>*>(
	gthis
)->
SWk
(

124 
m
, 
back
, 
ty
);

	@node_modules/nan/nan_persistent_pre_12_inl.h

9 #ide
NAN_PERSISTENT_PRE_12_INL_H_


10 
	#NAN_PERSISTENT_PRE_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cPsitBa
 {

14 
	mv8
::
Psit
<
T
> 
rsit
;

15 
	mme
<
tyme
 
	mU
>

16 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
PsitBa
<U> &
p
);

17 
	mme
<
tyme
 
	mU
,ym
	mM
>

18 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
Psit
<U, 
M
> &
p
);

19 
	mme
<
tyme
 
	mU
>

20 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
Glob
<U> &
p
);

21 
	mme
<
tyme
 
	mS
> 
nd
 
ass
 
	mRuVue
;

23 
	mpublic
:

24 
NAN_INLINE
 
	$PsitBa
() :

25 
	$rsit
() {}

27 
NAN_INLINE
 
	$Ret
() {

28 
rsit
.
	`Dio
();

29 
rsit
.
	`Cˬ
();

30 
	}
}

32 
	gme
<
tyme
 
	gS
>

33 
NAN_INLINE
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

34 
TYPE_CHECK
(
T
, 
S
);

36 i(!
	grsit
.
IsEmy
()) {

37 
	grsit
.
Dio
();

40 i(
	gh
.
IsEmy
()) {

41 
	grsit
.
Cˬ
();

43 
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
h
);

47 
	gme
<
tyme
 
	gS
>

48 
NAN_INLINE
 
Ret
(cڡ 
PsitBa
<
S
> &
h
) {

49 
TYPE_CHECK
(
T
, 
S
);

51 i(!
	grsit
.
IsEmy
()) {

52 
	grsit
.
Dio
();

55 i(
	gh
.
IsEmy
()) {

56 
	grsit
.
Cˬ
();

58 
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
h
.
rsit
);

62 
NAN_INLINE
 
bo
 
	$IsEmy
(cڡ {  
rsit
.
	`IsEmy
(); 
	}
}

64 
NAN_INLINE
 
	$Emy
({ 
rsit
.
	`Cˬ
(); 
	}
}

66 
	gme
<
tyme
 
	gS
>

67 
NAN_INLINE
 
bo
 
	gݔ
==(cڡ 
PsitBa
<
S
> &
th
) {

68  
this
->
rsit
 =
th
.persistent;

71 
	gme
<
tyme
 
	gS
>

72 
NAN_INLINE
 
bo
 
	gݔ
==(cڡ 
v8
::
Lol
<
S
> &
th
) {

73  
this
->
rsit
 =
th
;

76 
	gme
<
tyme
 
	gS
>

77 
NAN_INLINE
 
bo
 
	gݔ
!=(cڡ 
PsitBa
<
S
> &
th
) {

78  !
ݔ
==(
th
);

81 
	gme
<
tyme
 
	gS
>

82 
NAN_INLINE
 
bo
 
	gݔ
!=(cڡ 
v8
::
Lol
<
S
> &
th
) {

83  !
ݔ
==(
th
);

86 
	gme
<
tyme
 
	gP
>

87 
NAN_INLINE
 
SWk
(

88 
P
 *
m


89 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


90 , 
WkClbackTy
 
ty
);

92 
NAN_INLINE
 
	$CˬWk
({ 
rsit
.
	`CˬWk
(); 
	}
}

94 
NAN_INLINE
 
	$MkInddt
({ 
rsit
.
	`MkInddt
(); 
	}
}

96 
NAN_INLINE
 
bo
 
	$IsInddt
(cڡ {  
rsit
.
	`IsInddt
(); 
	}
}

98 
NAN_INLINE
 
bo
 
	$IsNrDth
(cڡ {  
rsit
.
	`IsNrDth
(); 
	}
}

100 
NAN_INLINE
 
bo
 
	$IsWk
(cڡ {  
rsit
.
	`IsWk
(); 
	}
}

102 
	give
:

103 
NAN_INLINE
 
exic
 
PsitBa
(
v8
::
Psit
<
T
> 
th
) :

104 
	$rsit
(
th
{ 
	}
}

105 
NAN_INLINE
 
exic
 
	$PsitBa
(
T
 *
v
: 
	$rsit
(
v
{
	}
}

106 
me
<
tyme
 
S
,ym
	gM
> 
nd
 
ass
 
	gPsit
;

107 
	gme
<
tyme
 
	gS
> 
nd
 
ass
 
	gGlob
;

108 
nd
 
ass
 
	gObjeWp
;

111 
	gme
<
tyme
 
	gT
>

112 as
	cNCyabPsitTs
 {

113 
	mpublic
:

114 
Psit
<
	tT
, 
	tNCyabPsitTs
<T> >

115 
	tNCyabPsit
;

116 cڡ 
bo
 
	mkRetInDeru
 = 
l
;

117 
	mme
<
tyme
 
	mS
,ym
	mM
>

118 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M
> &
sour
,

119 
NCyabPsit
 *
de
) {

120 
	mUncompab
<
	mv8
::
Obje
>();

123 
	gme
<
tyme
 
	gO
> 
NAN_INLINE
 
	$Uncompab
() {

124 
	`TYPE_CHECK
(
O
, 
v8
::
Primive
);

125 
	}
}

128 
	gme
<
tyme
 
	gT
>

129 
	sCyabPsitTs
 {

130 
	mPsit
<
	tT
, 
	tCyabPsitTs
<T> > 
	tCyabPsit
;

131 cڡ 
bo
 
	mkRetInDeru
 = 
ue
;

132 
	mme
<
tyme
 
	mS
,ym
	mM
>

133 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M
> &
sour
,

134 
CyabPsit
 *
de
) {}

137 
	gme
<
tyme
 
	gT
,ym
	gM
> 
ass
 
	gPsit
 :

138 
public
 
PsitBa
<
T
> {

139 
public
:

140 
NAN_INLINE
 
Psit
() {}

142 
me
<
tyme
 
S
> 
NAN_INLINE
 
Psit
(
v8
::
Hd
<S> 
th
)

143 : 
PsitBa
<
T
>(
v8
::
Psit
<T>::
New
(
th
)) {

144 
TYPE_CHECK
(
T
, 
S
);

147 
NAN_INLINE
 
Psit
(cڡ Psi&
th
: 
PsitBa
<
T
>() {

148 
Cy
(
th
);

151 
	gme
<
tyme
 
	gS
,ym
	gM2
>

152 
NAN_INLINE
 
Psit
(cڡ Psit<
S
, 
M2
> &
th
) :

153 
PsitBa
<
T
>() {

154 
Cy
(
th
);

157 
NAN_INLINE
 
	gPsit
 &
	gݔ
=(cڡ 
Psit
 &
th
) {

158 
Cy
(
th
);

159  *
	gthis
;

162 
	gme
 <
ass
 
	gS
, cs
	gM2
>

163 
NAN_INLINE
 
	gPsit
 &
	gݔ
=(cڡ 
Psit
<
S
, 
	gM2
> &
	gth
) {

164 
Cy
(
th
);

165  *
	gthis
;

168 
	gNAN_INLINE
 ~
Psit
() {

169 i(
	gM
::
kRetInDeru

this
->
Ret
();

172 
	give
:

173 
NAN_INLINE
 
T
 *
ݔ
*(cڡ {  *
PsitBa
<T>::
rsit
; }

175 
	gme
<
tyme
 
	gS
,ym
	gM2
>

176 
NAN_INLINE
 
Cy
(cڡ 
Psit
<
S
, 
M2
> &
th
) {

177 
TYPE_CHECK
(
T
, 
S
);

179 
	gthis
->
Ret
();

181 i(!
	gth
.
IsEmy
()) {

182 
	gthis
->
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
th
.
rsit
);

183 
	gM
::
Cy
(
th
, 
this
);

188 
	gme
<
tyme
 
	gT
>

189 
ass
 
	gGlob
 : 
public
 
PsitBa
<
T
> {

190 
	sRVue
 {

191 
NAN_INLINE
 
exic
 
RVue
(
Glob
* 
obj
: 
obje
(obj) {}

192 
Glob
* 
obje
;

195 
	gpublic
:

196 
NAN_INLINE
 
Glob
(: 
PsitBa
<
T
>(0) { }

198 
me
 <
tyme
 
S
>

199 
NAN_INLINE
 
Glob
(
v8
::
Lol
<
S
> 
th
)

200 : 
PsitBa
<
T
>(
v8
::
Psit
<T>::
New
(
th
)) {

201 
TYPE_CHECK
(
T
, 
S
);

204 
	gme
 <
tyme
 
	gS
>

205 
NAN_INLINE
 
Glob
(cڡ 
PsitBa
<
S
> &
th
)

206 : 
PsitBa
<
T
>(
th
) {

207 
TYPE_CHECK
(
T
, 
S
);

212 
NAN_INLINE
 
Glob
(
RVue
 
rvue
)

213 : 
PsitBa
<
T
>(
rvue
.
obje
->
rsit
) {

214 
rvue
.
obje
->
Ret
();

216 
	gNAN_INLINE
 ~
Glob
({ 
	gthis
->
Ret
(); }

220 
	gme
<
tyme
 
	gS
>

221 
NAN_INLINE
 
	gGlob
 &
	gݔ
=(
Glob
<
S
> 
rhs
) {

222 
TYPE_CHECK
(
T
, 
S
);

223 
	gthis
->
Ret
(
rhs
.
rsit
);

224 
	grhs
.
Ret
();

225  *
	gthis
;

230 
NAN_INLINE
 
ݔ
 
RVue
({  RVue(
this
); }

234 
Glob
 
Pass
({  Glob(
RVue
(
this
)); }

236 
	give
:

237 
Glob
(Global &);

238 
	gݔ
=(
Glob
 &);

239 
	gme
<
tyme
 
	gS
> 
nd
 
ass
 
	gRuVue
;

	@node_modules/nan/nan_string_bytes.h

22 #ide
NAN_STRING_BYTES_H_


23 
	#NAN_STRING_BYTES_H_


	)

27 
mea
 
	gimp
 {

29 
usg
 
	gv8
::
Lol
;

30 
usg
 
	gv8
::
Obje
;

31 
usg
 
	gv8
::
Sg
;

32 
usg
 
	gv8
::
Vue
;

37 
	#ba64_coded_size
(
size
((siz+ 2 - ((siz+ 2% 3)/ 3 * 4)

	)

43 
bo
 
cڏs_n_ascii_ow
(cڡ * 
buf
, 
size_t
 
n
) {

44 
size_t
 
	gi
 = 0; i < 
	gn
; ++i) {

45 i(
	gbuf
[
i
] & 0x80 
	gue
;

47  
	gl
;

51 
bo
 
cڏs_n_ascii
(cڡ * 
c
, 
size_t
 
n
) {

52 i(
	gn
 < 16) {

53  
cڏs_n_ascii_ow
(
c
, 
n
);

56 cڡ 
	gbys_r_wd
 = (*);

57 cڡ 
	gign_mask
 = 
bys_r_wd
 - 1;

58 cڡ 
	guligd
 = 
t_
<
u_t
>(
c
& 
ign_mask
;

60 i(
	guligd
 > 0) {

61 cڡ 
	gn
 = 
bys_r_wd
 - 
uligd
;

62 i(
cڏs_n_ascii_ow
(
c
, 
n
) 
	gue
;

63 
	gc
 +
n
;

64 
	gn
 -
n
;

68 #i
defed
(
__x86_64__
|| defed(
_WIN64
)

69 cڡ 
u_t
 
	gmask
 = 0x8080808080808080ll;

71 cڡ 
u_t
 
	gmask
 = 0x80808080l;

74 cڡ 
u_t
* 
	gcw
 = 
t_
<cڡ u_t*>(
c
);

76 
size_t
 
	gi
 = 0, 
	gn
 = 
n
 / 
bys_r_wd
; i <; ++i) {

77 i(
	gcw
[
i
] & 
	gmask
 
	gue
;

80 cڡ 
	gmad
 = 
n
 & 
ign_mask
;

81 i(
	gmad
 > 0) {

82 cڡ 
size_t
 
	gofft
 = 
n
 - 
mad
;

83 i(
cڏs_n_ascii_ow
(
c
 + 
offt
, 
mad
) 
	gue
;

86  
	gl
;

90 
f_ascii_ow
(cڡ * 
c
, * 
d
, 
size_t
 
n
) {

91 
size_t
 
	gi
 = 0; i < 
	gn
; ++i) {

92 
	gd
[
i
] = 
c
[i] & 0x7f;

97 
f_ascii
(cڡ * 
c
, * 
d
, 
size_t
 
n
) {

98 i(
	gn
 < 16) {

99 
f_ascii_ow
(
c
, 
d
, 
n
);

103 cڡ 
	gbys_r_wd
 = (*);

104 cڡ 
	gign_mask
 = 
bys_r_wd
 - 1;

105 cڡ 
	gc_ulign
 = 
t_
<
u_t
>(
c
& 
ign_mask
;

106 cڡ 
	gd_ulign
 = 
t_
<
u_t
>(
d
& 
ign_mask
;

108 i(
	gc_ulign
 > 0) {

109 i(
	gc_ulign
 =
d_ulign
) {

110 cڡ 
ulign
 = 
bys_r_wd
 - 
c_ulign
;

111 
f_ascii_ow
(
c
, 
d
, 
ulign
);

112 
	gc
 +
ulign
;

113 
	gd
 +
ulign
;

114 
	gn
 -
c_ulign
;

116 
f_ascii_ow
(
c
, 
d
, 
n
);

121 #i
defed
(
__x86_64__
|| defed(
_WIN64
)

122 cڡ 
u_t
 
	gmask
 = ~0x8080808080808080ll;

124 cڡ 
u_t
 
	gmask
 = ~0x80808080l;

127 cڡ 
u_t
* 
	gcw
 = 
t_
<cڡ u_t*>(
c
);

128 
u_t
* 
	gdw
 = 
t_
<u_t*>(
d
);

130 
size_t
 
	gi
 = 0, 
	gn
 = 
n
 / 
bys_r_wd
; i <; ++i) {

131 
	gdw
[
i
] = 
cw
[i] & 
mask
;

134 cڡ 
	gmad
 = 
n
 & 
ign_mask
;

135 i(
	gmad
 > 0) {

136 cڡ 
size_t
 
	gofft
 = 
n
 - 
mad
;

137 
f_ascii_ow
(
c
 + 
offt
, 
d
 + offt, 
mad
);

142 
size_t
 
ba64_code
(cڡ * 
c
,

143 
size_t
 

,

144 * 
d
,

145 
size_t
 
dn
) {

147 
as
(
dn
 >
ba64_coded_size
(

) &&

150 
	gdn
 = 
ba64_coded_size
(

);

152 
	ga
;

153 
	gb
;

154 
	gc
;

155 
	gi
;

156 
	gk
;

157 
	gn
;

159 cڡ 
	gb
[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

163 
	gi
 = 0;

164 
	gk
 = 0;

165 
	gn
 = 

 / 3 * 3;

167 
	gi
 < 
	gn
) {

168 
	ga
 = 
c
[
i
 + 0] & 0xff;

169 
	gb
 = 
c
[
i
 + 1] & 0xff;

170 
	gc
 = 
c
[
i
 + 2] & 0xff;

172 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

173 
	gd
[
k
 + 1] = 
b
[((
a
 & 3<< 4| (
b
 >> 4)];

174 
	gd
[
k
 + 2] = 
b
[((
b
 & 0x0f<< 2| (
c
 >> 6)];

175 
	gd
[
k
 + 3] = 
b
[
c
 & 0x3f];

177 
	gi
 += 3;

178 
	gk
 += 4;

181 i(
	gn
 !

) {

182 

 - 
n
) {

184 
a
 = 
c
[
i
 + 0] & 0xff;

185 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

186 
	gd
[
k
 + 1] = 
b
[(
a
 & 3) << 4];

187 
	gd
[
k
 + 2] = '=';

188 
	gd
[
k
 + 3] = '=';

192 
a
 = 
c
[
i
 + 0] & 0xff;

193 
	gb
 = 
c
[
i
 + 1] & 0xff;

194 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

195 
	gd
[
k
 + 1] = 
b
[((
a
 & 3<< 4| (
b
 >> 4)];

196 
	gd
[
k
 + 2] = 
b
[(
b
 & 0x0f) << 2];

197 
	gd
[
k
 + 3] = '=';

202  
	gdn
;

206 
size_t
 
hex_code
(cڡ * 
c
, size_

, * 
d
, size_
dn
) {

208 
as
(
dn
 >

 * 2 &&

211 
	gdn
 = 

 * 2;

212 
ut32_t
 
	gi
 = 0, 
	gk
 = 0; k < 
	gdn
; i += 1, k += 2) {

213 cڡ 
hex
[] = "0123456789abcdef";

214 
ut8_t
 
	gv
 = 
ic_
<ut8_t>(
c
[
i
]);

215 
	gd
[
k
 + 0] = 
hex
[
v
 >> 4];

216 
	gd
[
k
 + 1] = 
hex
[
v
 & 15];

219  
	gdn
;

224 
	gLol
<
	gVue
> 
Encode
(cڡ * 
buf
,

225 
size_t
 
bu
,

226 
Encodg
 
codg
) {

227 
as
(
bu
 <
node
::
Bufr
::
kMaxLgth
);

228 i(!
	gbu
 && 
	gcodg
 !
BUFFER
)

229  
New
("").
ToLolChecked
();

231 
	gLol
<
	gSg
> 
	gv
;

232 
	gcodg
) {

233 
	gBUFFER
:

234  
CyBufr
(
buf
, 
bu
).
ToLolChecked
();

236 
	gASCII
:

237 i(
cڏs_n_ascii
(
buf
, 
bu
)) {

238 * 
	gout
 = 
w
 [
bu
];

239 
f_ascii
(
buf
, 
out
, 
bu
);

240 
	gv
 = 
New
<
Sg
>(
out
, 
	gbu
).
ToLolChecked
();

241 
	gde
[] 
	gout
;

243 
	gv
 = 
New
<
Sg
>(
buf
, 
	gbu
).
ToLolChecked
();

247 
	gUTF8
:

248 
v
 = 
New
<
Sg
>(
buf
, 
	gbu
).
ToLolChecked
();

251 
	gBINARY
: {

253 cڡ *
cbuf
 = 
t_
<cڡ *>(
buf
);

254 
ut16_t
 * 
	gtwobybuf
 = 
w
 ut16_t[
bu
];

255 
size_t
 
	gi
 = 0; i < 
	gbu
; i++) {

257 
	gtwobybuf
[
i
] = 
cbuf
[i];

259 
	gv
 = 
New
<
Sg
>(
twobybuf
, 
	gbu
).
ToLolChecked
();

260 
	gde
[] 
	gtwobybuf
;

264 
	gBASE64
: {

265 
size_t
 
dn
 = 
ba64_coded_size
(
bu
);

266 * 
	gd
 = 
w
 [
dn
];

268 
size_t
 
	gwrn
 = 
ba64_code
(
buf
, 
bu
, 
d
, 
dn
);

269 
as
(
wrn
 =
dn
);

271 
	gv
 = 
New
<
Sg
>(
d
, 
	gdn
).
ToLolChecked
();

272 
	gde
[] 
	gd
;

276 
	gUCS2
: {

277 cڡ 
ut16_t
* 
da
 = 
t_
<cڡ ut16_t*>(
buf
);

278 
	gv
 = 
New
<
Sg
>(
da
, 
	gbu
 / 2).
ToLolChecked
();

282 
	gHEX
: {

283 
size_t
 
dn
 = 
bu
 * 2;

284 * 
	gd
 = 
w
 [
dn
];

285 
size_t
 
	gwrn
 = 
hex_code
(
buf
, 
bu
, 
d
, 
dn
);

286 
as
(
wrn
 =
dn
);

288 
	gv
 = 
New
<
Sg
>(
d
, 
	gdn
).
ToLolChecked
();

289 
	gde
[] 
	gd
;

294 
as
(0 && "unknownncoding");

298  
	gv
;

301 #unde
ba64_coded_size


	@node_modules/nan/nan_typedarray_contents.h

9 #ide
NAN_TYPEDARRAY_CONTENTS_H_


10 
	#NAN_TYPEDARRAY_CONTENTS_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cTydAayCڋs
 {

14 
	mpublic
:

15 
NAN_INLINE
 
exic
 
TydAayCڋs
(
v8
::
Lol
<v8::
Vue
> 
om
) :

16 
ngth_
(0), 
	$da_
(
NULL
) {

18 
size_t
 
ngth
 = 0;

19 * 
da
 = 
NULL
;

21 #i
	`defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

22 (
V8_MAJOR_VERSION
 =4 && 
	`defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

24 i(
om
->
	`IsAayBufrVw
()) {

25 
v8
::
Lol
<v8::
AayBufrVw
> 
y
 =

26 
v8
::
Lol
<v8::
AayBufrVw
>::
	`Ca
(
om
);

28 cڡ 
size_t
 
by_ngth
 = 
y
->
	`ByLgth
();

29 cڡ 
rdiff_t
 
by_offt
 = 
y
->
	`ByOfft
();

30 
v8
::
Lol
<v8::
AayBufr
> 
bufr
 = 
y
->
	`Bufr
();

32 
ngth
 = 
by_ngth
 / (
T
);

33 
da
 = 
ic_
<*>(
bufr
->
	`GCڋs
().
	`Da
()+ 
by_offt
;

38 i(
om
->
	`IsObje
(&& !om->
	`IsNu
()) {

39 
v8
::
Lol
<v8::
Obje
> 
y
 = v8::Lol<v8::Obje>::
	`Ca
(
om
);

41 
MaybeLol
<
v8
::
Vue
> 
bufr
 = 
	`G
(
y
,

42 
New
<
v8
::
Sg
>("bufr").
	`ToLolChecked
());

43 
MaybeLol
<
v8
::
Vue
> 
by_ngth
 = 
	`G
(
y
,

44 
New
<
v8
::
Sg
>("byLgth").
	`ToLolChecked
());

45 
MaybeLol
<
v8
::
Vue
> 
by_offt
 = 
	`G
(
y
,

46 
New
<
v8
::
Sg
>("byOfft").
	`ToLolChecked
());

48 i(!
bufr
.
	`IsEmy
() &&

49 !
by_ngth
.
	`IsEmy
(&& by_ngth.
	`ToLolChecked
()->
	`IsUt32
() &&

50 !
by_offt
.
	`IsEmy
(&& by_offt.
	`ToLolChecked
()->
	`IsUt32
()) {

51 
da
 = 
y
->
	`GIndexedPrݔtsExAayDa
();

52 if(
da
) {

53 
ngth
 = 
by_ngth
.
	`ToLolChecked
()->
	`Ut32Vue
(/ (
T
);

60 #i
	`defed
(
_MSC_VER
&& _MSC_VER >1900 || 
__lulus
 >= 201103L

61 
	`as
(
t_
<
u_t
>(
da
% 
	`ignof
 (
T
) == 0);

62 #i
	`defed
(
_MSC_VER
&& _MSC_VER >1600 || defed(
__GNUC__
)

63 
	`as
(
t_
<
u_t
>(
da
% 
	`__ignof
(
T
) == 0);

65 
	`as
(
t_
<
u_t
>(
da
%  (
T
) == 0);

68 
ngth_
 = 
ngth
;

69 
da_
 = 
ic_
<
T
*>(
da
);

72 
NAN_INLINE
 
size_t
 
	$ngth
(cڡ {  
ngth_
; 
	}
}

73 
NAN_INLINE
 
T
* 
	gݔ
*({  
	gda_
; }

74 
NAN_INLINE
 cڡ 
T
* 
	gݔ
*(cڡ {  
	gda_
; }

76 
	give
:

77 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
TydAayCڋs
)

80 *
ݔ
 
	`w
(
size_t
 
size
);

81 
ݔ
 
	`de
(*, 
size_t
);

83 
size_t
 
ngth_
;

84 
T
* 
da_
;

85 
	}
};

	@node_modules/nan/nan_weak.h

9 #ide
NAN_WEAK_H_


10 
	#NAN_WEAK_H_


	)

12 cڡ 
	gkIlFldsInWkClback
 = 2;

13 cڡ 
	gkNoIlFldIndex
 = -1;

15 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

16 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

17 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

18 
v8
::
WkClbackInfo
<WkClbackInfo<
T
> > cڡ&

	)

19 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

20 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

21 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

22 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

23 #i
NODE_MODULE_VERSION
 > 
IOJS_1_1_MODULE_VERSION


24 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

25 
v8
::
PhtomClbackDa
<
WkClbackInfo
<
T
> > cڡ&

	)

26 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

27 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

28 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

29 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

30 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


31 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

32 
v8
::
PhtomClbackDa
<
WkClbackInfo
<
T
> > cڡ&

	)

33 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

34 
v8
::
IlFldsClbackDa
<
WkClbackInfo
<
T
>, > cڡ&

	)

35 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

36 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

37 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


38 
	#NAN_WEAK_CALLBACK_DATA_TYPE_
 \

39 
v8
::
WkClbackDa
<
S
, 
WkClbackInfo
<
T
> > cڡ&

	)

40 
	#NAN_WEAK_CALLBACK_SIG_
 
NAN_WEAK_CALLBACK_DATA_TYPE_


	)

42 
	#NAN_WEAK_CALLBACK_DATA_TYPE_
 *

	)

43 
	#NAN_WEAK_CALLBACK_SIG_
 \

44 
v8
::
Psit
<v8::
Vue
>, 
NAN_WEAK_CALLBACK_DATA_TYPE_


	)

47 
	gme
<
tyme
 
	gT
>

48 as
	cWkClbackInfo
 {

49 
	mpublic
:

50 (*
	tClback
)(cڡ 
	tWkClbackInfo
<
	tT
>& 
	tda
);

51 
	`WkClbackInfo
(

52 
Psit
<
v8
::
Vue
> *
rsit


53 , 
Clback
 
back


54 , *
m


55 , *
fld1
 = 0

56 , *
fld2
 = 0) :

57 
	`back_
(
back
), 
	`isީe_
(0), 
	$m_
(
m
) {

58 
d
::
	`memy
(&
rsit_
, 
rsit
,  (
v8
::
Psit
<v8::
Vue
>));

59 
_flds_
[0] = 
fld1
;

60 
_flds_
[1] = 
fld2
;

62 
NAN_INLINE
 
v8
::
Isީe
 *
	$GIsީe
(cڡ {  
isީe_
; 
	}
}

63 
NAN_INLINE
 
T
 *
	$GPam
(cڡ {  
ic_
<
T
*>(
m_
); 
	}
}

64 
NAN_INLINE
 *
	$GIlFld
(
dex
) const {

65 
	`as
((
dex
 == 0 || index == 1) && "internal field index out of bounds");

66 i(
dex
 == 0) {

67  
_flds_
[0];

69  
_flds_
[1];

71 
	}
}

73 
	give
:

74 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
WkClbackInfo
)

75 
Clback
 
back_
;

76 
v8
::
Isީe
 *
isީe_
;

77 *
m_
;

78 *
_flds_
[
kIlFldsInWkClback
];

79 
v8
::
Psit
<v8::
Vue
> 
rsit_
;

80 
me
<
tyme
 
S
,ym
M
> 
nd
 
ass
 
Psit
;

81 
me
<
tyme
 
S
> 
nd
 
ass
 
PsitBa
;

82 #i
NODE_MODULE_VERSION
 <
NODE_0_12_MODULE_VERSION


83 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


84 
me
<
tyme
 
S
>

85 
	`voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
);

86 
me
<
tyme
 
S
>

87 
WkClbackInfo
 *
	`unwp
(
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
);

89 
	`voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
);

90 
WkClbackInfo
 *
	`unwp
(
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
);

93 
	`vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
);

94 
	`vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
);

95 
WkClbackInfo
 *
	`unwam
(

96 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
);

97 
WkClbackInfo
 *
	`unwwofld
(

98 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
);

100 
	}
};

103 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

104 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

106 
me
<
tyme
 
T
>

108 
WkClbackInfo
<
T
>::
	$vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
) {

109 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwam
(
da
);

110 i(
da
.
	`IsFPass
()) {

111 
cbfo
->
rsit_
.
	`Ret
();

112 
da
.
	`SSecdPassClback
(
vokam
);

114 
cbfo
->
	`back_
(*cbinfo);

115 
de
 
cbfo
;

117 
	}
}

119 
	gme
<
tyme
 
	gT
>

121 
	gWkClbackInfo
<
	gT
>::
	$vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
) {

122 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwwofld
(
da
);

123 i(
da
.
	`IsFPass
()) {

124 
cbfo
->
rsit_
.
	`Ret
();

125 
da
.
	`SSecdPassClback
(
vokwofld
);

127 
cbfo
->
	`back_
(*cbinfo);

128 
de
 
cbfo
;

130 
	}
}

132 
	gme
<
tyme
 
	gT
>

133 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwam
(

134 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
) {

135 
WkClbackInfo
<
T
> *
cbfo
 =

136 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GPam
());

137 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

138  
cbfo
;

139 
	}
}

141 
	gme
<
tyme
 
	gT
>

142 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwwofld
(

143 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
) {

144 
WkClbackInfo
<
T
> *
cbfo
 =

145 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GIlFld
(0));

146 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

147  
cbfo
;

148 
	}
}

150 #unde
NAN_WEAK_PARAMETER_CALLBACK_SIG_


151 #unde
NAN_WEAK_TWOFIELD_CALLBACK_SIG_


152 #unde
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


153 #unde
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


154 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


156 
	gme
<
tyme
 
	gT
>

158 
	gWkClbackInfo
<
	gT
>::
	$vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
) {

159 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwam
(
da
);

160 
cbfo
->
rsit_
.
	`Ret
();

161 
cbfo
->
	`back_
(*cbinfo);

162 
de
 
cbfo
;

163 
	}
}

165 
	gme
<
tyme
 
	gT
>

167 
	gWkClbackInfo
<
	gT
>::
	$vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
) {

168 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwwofld
(
da
);

169 
cbfo
->
rsit_
.
	`Ret
();

170 
cbfo
->
	`back_
(*cbinfo);

171 
de
 
cbfo
;

172 
	}
}

174 
	gme
<
tyme
 
	gT
>

175 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwam
(

176 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
) {

177 
WkClbackInfo
<
T
> *
cbfo
 =

178 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GPam
());

179 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

180  
cbfo
;

181 
	}
}

183 
	gme
<
tyme
 
	gT
>

184 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwwofld
(

185 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
) {

186 
WkClbackInfo
<
T
> *
cbfo
 =

187 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GIlFld1
());

188 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

189  
cbfo
;

190 
	}
}

192 #unde
NAN_WEAK_PARAMETER_CALLBACK_SIG_


193 #unde
NAN_WEAK_TWOFIELD_CALLBACK_SIG_


194 #unde
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


195 #unde
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


196 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


198 
	gme
<
tyme
 
	gT
>

199 
	gme
<
tyme
 
	gS
>

200 
	gWkClbackInfo
<
	gT
>::
	$voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
) {

201 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwp
(
da
);

202 
cbfo
->
rsit_
.
	`Ret
();

203 
cbfo
->
	`back_
(*cbinfo);

204 
de
 
cbfo
;

205 
	}
}

207 
	gme
<
tyme
 
	gT
>

208 
	gme
<
tyme
 
	gS
>

209 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwp
(

210 
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
) {

211 *
m
 = 
da
.
	`GPam
();

212 
WkClbackInfo
<
T
> *
cbfo
 =

213 
ic_
<
WkClbackInfo
<
T
>*>(
m
);

214 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

215  
cbfo
;

216 
	}
}

218 #unde
NAN_WEAK_CALLBACK_SIG_


219 #unde
NAN_WEAK_CALLBACK_DATA_TYPE_


222 
	gme
<
tyme
 
	gT
>

223 
	gWkClbackInfo
<
	gT
>::
	$voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
) {

224 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwp
(
da
);

225 
cbfo
->
rsit_
.
	`Dio
();

226 
cbfo
->
rsit_
.
	`Cˬ
();

227 
cbfo
->
	`back_
(*cbinfo);

228 
de
 
cbfo
;

229 
	}
}

231 
	gme
<
tyme
 
	gT
>

232 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwp
(

233 
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
) {

234 
WkClbackInfo
<
T
> *
cbfo
 =

235 
ic_
<
WkClbackInfo
<
T
>*>(
da
);

236 
cbfo
->
isީe_
 = 
v8
::
Isީe
::
	`GCut
();

237  
cbfo
;

238 
	}
}

240 #unde
NAN_WEAK_CALLBACK_SIG_


241 #unde
NAN_WEAK_CALLBACK_DATA_TYPE_


244 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

245 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

246 
me
<
tyme
 
T
,ym
	gM
>

247 
	gme
<
tyme
 
	gP
>

248 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

249 
P
 *
m


250 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


251 , 
WkClbackTy
 
ty
) {

252 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

253 i(
	gty
 =
WkClbackTy
::
kPam
) {

254 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

255 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

256 , 
	gback


257 , 
	gm
);

258 
	gv8
::
PsitBa
<
T
>::
SWk
(

259 
wcbd


260 , 
WkClbackInfo
<
P
>::
vokam


261 , 
ty
);

263 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

264 
as
((*
lf
)->
IsObje
());

265 
	gcou
 = (*
lf
)->
IlFldCou
();

266 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

267 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

268 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

270 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

271 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

272 , 
	gback


274 , 
	g_flds
[0]

275 , 
	g_flds
[1]);

276 (*
	glf
)->
SAligdPorInIlFld
(0, 
wcbd
);

277 
	gv8
::
PsitBa
<
T
>::
SWk
(

278 
ic_
<
WkClbackInfo
<
P
>*>(0)

279 , 
WkClbackInfo
<
P
>::
vokwofld


280 , 
ty
);

283 #i
NODE_MODULE_VERSION
 > 
IOJS_1_1_MODULE_VERSION


284 
	gme
<
tyme
 
	gT
,ym
	gM
>

285 
	gme
<
tyme
 
	gP
>

286 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

287 
P
 *
m


288 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


289 , 
WkClbackTy
 
ty
) {

290 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

291 i(
	gty
 =
WkClbackTy
::
kPam
) {

292 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

293 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

294 , 
	gback


295 , 
	gm
);

296 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

297 
wcbd


298 , 
WkClbackInfo
<
P
>::
vokam
);

300 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

301 
as
((*
lf
)->
IsObje
());

302 
	gcou
 = (*
lf
)->
IlFldCou
();

303 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

304 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

305 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

307 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

308 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

309 , 
	gback


311 , 
	g_flds
[0]

312 , 
	g_flds
[1]);

313 (*
	glf
)->
SAligdPorInIlFld
(0, 
wcbd
);

314 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

315 
ic_
<
WkClbackInfo
<
P
>*>(0)

316 , 
WkClbackInfo
<
P
>::
vokwofld


318 , 
cou
 > 1 ? 1 : 
kNoIlFldIndex
);

321 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


322 
	gme
<
tyme
 
	gT
,ym
	gM
>

323 
	gme
<
tyme
 
	gP
>

324 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

325 
P
 *
m


326 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


327 , 
WkClbackTy
 
ty
) {

328 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

329 i(
	gty
 =
WkClbackTy
::
kPam
) {

330 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

331 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

332 , 
	gback


333 , 
	gm
);

334 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

335 
wcbd


336 , 
WkClbackInfo
<
P
>::
vokam
);

338 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

339 
as
((*
lf
)->
IsObje
());

340 
	gcou
 = (*
lf
)->
IlFldCou
();

341 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

342 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

343 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

345 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

346 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

347 , 
	gback


349 , 
	g_flds
[0]

350 , 
	g_flds
[1]);

351 (*
	glf
)->
SAligdPorInIlFld
(0, 
wcbd
);

352 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

353 
WkClbackInfo
<
P
>::
vokwofld


355 , 
cou
 > 1 ? 1 : 
kNoIlFldIndex
);

358 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


359 
	gme
<
tyme
 
	gT
,ym
	gM
>

360 
	gme
<
tyme
 
	gP
>

361 
NAN_INLINE
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

362 
P
 *
m


363 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


364 , 
WkClbackTy
 
ty
) {

365 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

366 i(
	gty
 =
WkClbackTy
::
kPam
) {

367 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

368 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

369 , 
	gback


370 , 
	gm
);

371 
	gv8
::
PsitBa
<
T
>::
SWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

373 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

374 
as
((*
lf
)->
IsObje
());

375 
	gcou
 = (*
lf
)->
IlFldCou
();

376 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

377 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

378 
	g_flds
[
i
] = (*
lf
)->
GAligdPorFromIlFld
(i);

380 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

381 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

382 , 
	gback


384 , 
	g_flds
[0]

385 , 
	g_flds
[1]);

386 
	gv8
::
PsitBa
<
T
>::
SWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

390 
	gme
<
tyme
 
	gT
>

391 
	gme
<
tyme
 
	gP
>

392 
NAN_INLINE
 
	gPsitBa
<
	gT
>::
SWk
(

393 
P
 *
m


394 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


395 , 
WkClbackTy
 
ty
) {

396 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

397 i(
	gty
 =
WkClbackTy
::
kPam
) {

398 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

399 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

400 , 
	gback


401 , 
	gm
);

402 
	grsit
.
MakeWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

404 
	gv8
::
Lol
<
T
>* 
lf
 = 
t_
<
v8
::Lol<T>*>(
this
);

405 
as
((*
lf
)->
IsObje
());

406 
	gcou
 = (*
lf
)->
IlFldCou
();

407 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

408 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

409 
	g_flds
[
i
] = (*
lf
)->
GPorFromIlFld
(i);

411 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

412 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

413 , 
	gback


415 , 
	g_flds
[0]

416 , 
	g_flds
[1]);

417 
	grsit
.
MakeWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

	@node_modules/node-gyp/gyp/data/win/large-pdb-shim.cc

	@node_modules/node-gyp/src/win_delay_load_hook.c

10 #ifde
_MSC_VER


12 #ide
WIN32_LEAN_AND_MEAN


13 
	#WIN32_LEAN_AND_MEAN


	)

16 
	~<wdows.h
>

18 
	~<dayimp.h
>

19 
	~<rg.h
>

21 
FARPROC
 
WINAPI
 
	$ld_exe_hook
(
evt
, 
DayLdInfo
* 
fo
) {

22 
HMODULE
 
m
;

23 i(
evt
 !
dliNePLdLibry
)

24  
NULL
;

26 i(
	`_ricmp
(
fo
->
szD
, "iojs.exe") != 0 &&

27 
	`_ricmp
(
fo
->
szD
, "node.exe") != 0)

28  
NULL
;

30 
m
 = 
	`GModuHd
(
NULL
);

31  (
FARPROC

m
;

32 
	}
}

34 
PDliHook
 
	g__pDliNifyHook2
 = 
ld_exe_hook
;

	@node_modules/node-sass/src/binding.cpp

1 
	~<n.h
>

2 
	~<ve
>

3 
	~"ss_cڋxt_w.h
"

4 
	~"cuom_funi_bridge.h
"

5 
	~"_rg.h
"

6 
	~"ss_tys/y.h
"

8 
Sass_Impt_Li
 
	$ss_imp܋r
(cڡ * 
cur_th
, 
Sass_Imp܋r_Ery
 
cb
, 
Sass_Comp
* 
comp
)

10 * 
cook
 = 
	`ss_imp܋r_g_cook
(
cb
);

11 
Sass_Impt
* 
evious
 = 
	`ss_comp_g_ϡ_impt
(
comp
);

12 cڡ * 
ev_th
 = 
	`ss_impt_g_abs_th
(
evious
);

13 
CuomImp܋rBridge
& 
bridge
 = *(
ic_
<CuomImp܋rBridge*>(
cook
));

15 
d
::
ve
<*> 
gv
;

16 
gv
.
	`push_back
((*)
cur_th
);

17 
gv
.
	`push_back
((*)
ev_th
);

19  
	`bridge
(
gv
);

20 
	}
}

22 
Sass_Vue
* 
	$ss_cuom_funi
(cڡ 
Sass_Vue
* 
s_gs
, 
Sass_Funi_Ery
 
cb
, 
Sass_Comp
* 
comp
)

24 * 
cook
 = 
	`ss_funi_g_cook
(
cb
);

25 
CuomFuniBridge
& 
bridge
 = *(
ic_
<CuomFuniBridge*>(
cook
));

27 
d
::
ve
<*> 
gv
;

28 
l
 = 
	`ss_li_g_ngth
(
s_gs
), 
i
 = 0; i <; i++) {

29 
gv
.
	`push_back
((*)
	`ss_li_g_vue
(
s_gs
, 
i
));

32  
	`bridge
(
gv
);

33 
	}
}

35 
ExaOis
(
v8
::
Lol
<v8::
Obje
> 
tis
, * 

, 
ss_cڋxt_w
* 
x_w
, 
bo
 
is_fe
, bo 
is_sync
) {

36 
	gN
::
HdSce
 
sce
;

38 
Sass_Cڋxt
* 
	gx
;

40 
	gv8
::
Lol
<
v8
::
Vue
> 
su_
 = 
N
::
G
(

41 
tis
,

42 
N
::
New
("su").
ToLolChecked
()

43 ).
ToLolChecked
();

44 i(!
	gsu_
->
IsObje
()) {

45 
	gN
::
ThrowTyE
("\"result\"lement isotn object");

49 
	gx_w
->
	gsu
.
Ret
(
su_
.
As
<
v8
::
Obje
>());

51 i(
	gis_fe
) {

52 
	gx_w
->
	gfx
 = (
Sass_Fe_Cڋxt
*

;

53 
	gx
 = 
ss_fe_cڋxt_g_cڋxt
(
x_w
->
fx
);

56 
	gx_w
->
	gdx
 = (
Sass_Da_Cڋxt
*

;

57 
	gx
 = 
ss_da_cڋxt_g_cڋxt
(
x_w
->
dx
);

60 
Sass_Ois
* 
	gss_tis
 = 
ss_cڋxt_g_tis
(
x
);

62 
	gx_w
->
	gis_sync
 = 
is_sync
;

64 i(!
	gis_sync
) {

65 
	gx_w
->
	gque
.
	gda
 = 
x_w
;

68 
	gv8
::
Lol
<
v8
::
Funi
> 
sucss_back
 = v8::Lol<v8::Funi>::
Ca
(
N
::
G
(
tis
, N::
New
("sucss").
ToLolChecked
()).ToLocalChecked());

69 
	gv8
::
Lol
<
v8
::
Funi
> 
r_back
 = v8::Lol<v8::Funi>::
Ca
(
N
::
G
(
tis
, N::
New
("r").
ToLolChecked
()).ToLocalChecked());

71 
	gx_w
->
	gsucss_back
 = 
w
 
N
::
Clback
(
sucss_back
);

72 
	gx_w
->
	gr_back
 = 
w
 
N
::
Clback
(
r_back
);

75 i(!
	gis_fe
) {

76 
	gx_w
->
	gfe
 = 
_rg
(
N
::
G
(
tis
, N::
New
("fe").
ToLolChecked
()));

77 
ss_ti_t_put_th
(
ss_tis
, 
x_w
->
fe
);

80 
	gdt_n
 = 
N
::
To
<
t32_t
>(

81 
N
::
G
(

82 
tis
,

83 
N
::
New
("dtWidth").
ToLolChecked
()

84 ).
ToLolChecked
()).
FromJu
();

86 
	gx_w
->
	gdt
 = (*)
mloc
(
dt_n
 + 1);

88 
ry
(
x_w
->
dt
, 
d
::
rg
(

89 
dt_n
,

90 
N
::
To
<
t32_t
>(

91 
N
::
G
(

92 
tis
,

93 
N
::
New
("dtTy").
ToLolChecked
()

94 ).
ToLolChecked
()).
FromJu
() == 1 ? '\t' : ' '

95 ).
c_r
());

97 
	gx_w
->
	gleed
 = 
_rg
(
N
::
G
(
tis
, N::
New
("leed").
ToLolChecked
()));

98 
	gx_w
->
	gude_th
 = 
_rg
(
N
::
G
(
tis
, N::
New
("udePhs").
ToLolChecked
()));

99 
	gx_w
->
	gout_fe
 = 
_rg
(
N
::
G
(
tis
, N::
New
("outFe").
ToLolChecked
()));

100 
	gx_w
->
	gsour_m
 = 
_rg
(
N
::
G
(
tis
, N::
New
("sourM").
ToLolChecked
()));

101 
	gx_w
->
	gsour_m_ro
 = 
_rg
(
N
::
G
(
tis
, N::
New
("sourMRo").
ToLolChecked
()));

103 
ss_ti_t_ouut_th
(
ss_tis
, 
x_w
->
out_fe
);

104 
ss_ti_t_ouut_y
(
ss_tis
, (
Sass_Ouut_Sty
)
N
::
To
<
t32_t
>(N::
G
(
tis
, N::
New
("y").
ToLolChecked
()).ToLolChecked()).
FromJu
());

105 
ss_ti_t_is_dd_syax_c
(
ss_tis
, 
N
::
To
<
bo
>(N::
G
(
tis
, N::
New
("ddSyax").
ToLolChecked
()).ToLolChecked()).
FromJu
());

106 
ss_ti_t_sour_commts
(
ss_tis
, 
N
::
To
<
bo
>(N::
G
(
tis
, N::
New
("sourCommts").
ToLolChecked
()).ToLolChecked()).
FromJu
());

107 
ss_ti_t_om_sour_m_u
(
ss_tis
, 
N
::
To
<
bo
>(N::
G
(
tis
, N::
New
("omSourMU").
ToLolChecked
()).ToLolChecked()).
FromJu
());

108 
ss_ti_t_sour_m_embed
(
ss_tis
, 
N
::
To
<
bo
>(N::
G
(
tis
, N::
New
("sourMEmbed").
ToLolChecked
()).ToLolChecked()).
FromJu
());

109 
ss_ti_t_sour_m_cڋs
(
ss_tis
, 
N
::
To
<
bo
>(N::
G
(
tis
, N::
New
("sourMCڋs").
ToLolChecked
()).ToLolChecked()).
FromJu
());

110 
ss_ti_t_sour_m_fe
(
ss_tis
, 
x_w
->
sour_m
);

111 
ss_ti_t_sour_m_ro
(
ss_tis
, 
x_w
->
sour_m_ro
);

112 
ss_ti_t_ude_th
(
ss_tis
, 
x_w
->
ude_th
);

113 
ss_ti_t_ecisi
(
ss_tis
, 
N
::
To
<
t32_t
>(N::
G
(
tis
, N::
New
("ecisi").
ToLolChecked
()).ToLolChecked()).
FromJu
());

114 
ss_ti_t_dt
(
ss_tis
, 
x_w
->
dt
);

115 
ss_ti_t_leed
(
ss_tis
, 
x_w
->
leed
);

117 
	gv8
::
Lol
<
v8
::
Vue
> 
imp܋r_back
 = 
N
::
G
(
tis
, N::
New
("imp܋r").
ToLolChecked
()).ToLocalChecked();

119 i(
	gimp܋r_back
->
IsFuni
()) {

120 
	gv8
::
Lol
<
v8
::
Funi
> 
imp܋r
 = 
imp܋r_back
.
As
<v8::Function>();

122 
CuomImp܋rBridge
 *
	gbridge
 = 
w
 CuomImp܋rBridge(
imp܋r
, 
x_w
->
is_sync
);

123 
	gx_w
->
	gimp܋r_bridges
.
push_back
(
bridge
);

125 
Sass_Imp܋r_Li
 
	gc_imp܋rs
 = 
ss_make_imp܋r_li
(1);

126 
	gc_imp܋rs
[0] = 
ss_make_imp܋r
(
ss_imp܋r
, 0, 
bridge
);

128 
ss_ti_t_c_imp܋rs
(
ss_tis
, 
c_imp܋rs
);

130 i(
	gimp܋r_back
->
IsAay
()) {

131 
	gv8
::
Lol
<
v8
::
Aay
> 
imp܋rs
 = 
imp܋r_back
.
As
<v8::Array>();

132 
Sass_Imp܋r_Li
 
	gc_imp܋rs
 = 
ss_make_imp܋r_li
(
imp܋rs
->
Lgth
());

134 
size_t
 
	gi
 = 0; i < 
	gimp܋rs
->
Lgth
(); ++i) {

135 
	gv8
::
Lol
<
v8
::
Funi
> 
back
 = v8::Lol<v8::Funi>::
Ca
(
N
::
G
(
imp܋rs
, 
ic_
<
ut32_t
>(
i
)).
ToLolChecked
());

137 
CuomImp܋rBridge
 *
	gbridge
 = 
w
 CuomImp܋rBridge(
back
, 
x_w
->
is_sync
);

138 
	gx_w
->
	gimp܋r_bridges
.
push_back
(
bridge
);

140 
	gc_imp܋rs
[
i
] = 
ss_make_imp܋r
(
ss_imp܋r
, 
imp܋rs
->
Lgth
(- i - 1, 
bridge
);

143 
ss_ti_t_c_imp܋rs
(
ss_tis
, 
c_imp܋rs
);

146 
	gv8
::
Lol
<
v8
::
Vue
> 
cuom_funis
 = 
N
::
G
(
tis
, N::
New
("funis").
ToLolChecked
()).ToLocalChecked();

148 i(
	gcuom_funis
->
IsObje
()) {

149 
	gv8
::
Lol
<
v8
::
Obje
> 
funis
 = 
cuom_funis
.
As
<v8::Object>();

150 
	gv8
::
Lol
<
v8
::
Aay
> 
sigtus
 = 
N
::
GOwnPrݔtyNames
(
funis
).
ToLolChecked
();

151 
	gnum_sigtus
 = 
sigtus
->
Lgth
();

152 
Sass_Funi_Li
 
	g_li
 = 
ss_make_funi_li
(
num_sigtus
);

154 
	gi
 = 0; i < 
	gnum_sigtus
; i++) {

155 
	gv8
::
Lol
<
v8
::
Sg
> 
sigtu
 = v8::Lol<v8::Sg>::
Ca
(
N
::
G
(
sigtus
, N::
New
(
i
)).
ToLolChecked
());

156 
	gv8
::
Lol
<
v8
::
Funi
> 
back
 = v8::Lol<v8::Funi>::
Ca
(
N
::
G
(
funis
, 
sigtu
).
ToLolChecked
());

158 
CuomFuniBridge
 *
	gbridge
 = 
w
 CuomFuniBridge(
back
, 
x_w
->
is_sync
);

159 
	gx_w
->
	gfuni_bridges
.
push_back
(
bridge
);

161 
Sass_Funi_Ery
 
	g
 = 
ss_make_funi
(
_rg
(
sigtu
), 
ss_cuom_funi
, 
bridge
);

162 
ss_funi_t_li_y
(
_li
, 
i
, 

);

165 
ss_ti_t_c_funis
(
ss_tis
, 
_li
);

170 
	$GSts
(
ss_cڋxt_w
* 
x_w
, 
Sass_Cڋxt
* 
x
) {

171 
N
::
HdSce
 
sce
;

173 ** 
uded_fes
 = 
	`ss_cڋxt_g_uded_fes
(
x
);

174 
v8
::
Lol
<v8::
Aay
> 
r
 = 
N
::
New
<v8::Array>();

176 i(
uded_fes
) {

177 
i
 = 0; 
uded_fes
[i] !
nuαr
; ++i) {

178 
N
::
	`S
(
r
, 
i
, N::
New
<
v8
::
Sg
>(
uded_fes
[i]).
	`ToLolChecked
());

182 
v8
::
Lol
<v8::
Obje
> 
su
 = 
N
::
	`New
(
x_w
->result);

183 
	`as
(
su
->
	`IsObje
());

185 
v8
::
Lol
<v8::
Vue
> 
s
 = 
N
::
	`G
(

186 
su
,

187 
N
::
	`New
("s").
	`ToLolChecked
()

188 ).
	`ToLolChecked
();

189 i(
s
->
	`IsObje
()) {

190 
N
::
	`S
(

191 
s
.
As
<
v8
::
Obje
>(),

192 
N
::
	`New
("udedFes").
	`ToLolChecked
(),

193 
r


196 
N
::
	`ThrowTyE
("\"result.stats\"lement isotn object");

198 
	}
}

200 
	$GResu
(
ss_cڋxt_w
* 
x_w
, 
Sass_Cڋxt
* 
x
, 
bo
 
is_sync
 = 
l
) {

201 
N
::
HdSce
 
sce
;

202 
v8
::
Lol
<v8::
Obje
> 
su
;

204 
us
 = 
	`ss_cڋxt_g_r_us
(
x
);

206 
su
 = 
N
::
	`New
(
x_w
->result);

207 
	`as
(
su
->
	`IsObje
());

209 i(
us
 == 0) {

210 cڡ * 
css
 = 
	`ss_cڋxt_g_ouut_rg
(
x
);

211 cڡ * 
m
 = 
	`ss_cڋxt_g_sour_m_rg
(
x
);

213 
N
::
	`S
(
su
, N::
	`New
("css").
	`ToLolChecked
(), N::
	`CyBufr
(
css
, 
ic_
<
ut32_t
>(
	`
(css))).ToLocalChecked());

215 
	`GSts
(
x_w
, 
x
);

217 i(
m
) {

218 
N
::
	`S
(
su
, N::
	`New
("m").
	`ToLolChecked
(), N::
	`CyBufr
(
m
, 
ic_
<
ut32_t
>(
	`
(map))).ToLocalChecked());

221 i(
is_sync
) {

222 
N
::
	`S
(
su
, N::
	`New
("r").
	`ToLolChecked
(), N::
New
<
v8
::
Sg
>(
	`ss_cڋxt_g_r_js
(
x
)).ToLocalChecked());

225  
us
;

226 
	}
}

228 
	$MakeClback
(
uv_wk_t
* 
q
) {

229 
N
::
HdSce
 
sce
;

231 
N
::
TryCch
 
y_tch
;

232 
ss_cڋxt_w
* 
x_w
 = 
ic_
<ss_cڋxt_w*>(
q
->
da
);

233 
Sass_Cڋxt
* 
x
;

235 i(
x_w
->
dx
) {

236 
x
 = 
	`ss_da_cڋxt_g_cڋxt
(
x_w
->
dx
);

239 
x
 = 
	`ss_fe_cڋxt_g_cڋxt
(
x_w
->
fx
);

242 
us
 = 
	`GResu
(
x_w
, 
x
);

244 i(
us
 =0 && 
x_w
->
sucss_back
) {

246 
x_w
->
sucss_back
->
	`Cl
(0, 0);

248 i(
x_w
->
r_back
) {

250 cڡ * 
r
 = 
	`ss_cڋxt_g_r_js
(
x
);

251 
v8
::
Lol
<v8::
Vue
> 
gv
[] = {

252 
N
::
New
<
v8
::
Sg
>(
r
).
	`ToLolChecked
()

254 
x_w
->
r_back
->
	`Cl
(1, 
gv
);

256 i(
y_tch
.
	`HasCaught
()) {

257 
N
::
	`FExi
(
y_tch
);

260 
	`ss__cڋxt_w
(
x_w
);

261 
	}
}

263 
	$NAN_METHOD
(
nd
) {

265 
v8
::
Lol
<v8::
Obje
> 
tis
 = 
N
::
To
<v8::Obje>(
fo
[0]).
	`ToLolChecked
();

266 * 
sour_rg
 = 
	`_rg
(
N
::
	`G
(
tis
, N::
	`New
("da").
	`ToLolChecked
()));

267 
Sass_Da_Cڋxt
* 
dx
 = 
	`ss_make_da_cڋxt
(
sour_rg
);

268 
ss_cڋxt_w
* 
x_w
 = 
	`ss_make_cڋxt_w
();

270 i(
	`ExaOis
(
tis
, 
dx
, 
x_w
, 
l
, false) >= 0) {

272 
us
 = 
	`uv_queue_wk
(
	`uv_deu_lo
(), &
x_w
->
que
, 
compe_
, (
uv_a_wk_cb
)
MakeClback
);

274 
	`as
(
us
 == 0);

276 
	}
}

278 
	$NAN_METHOD
(
nd_sync
) {

280 
v8
::
Lol
<v8::
Obje
> 
tis
 = 
N
::
To
<v8::Obje>(
fo
[0]).
	`ToLolChecked
();

281 * 
sour_rg
 = 
	`_rg
(
N
::
	`G
(
tis
, N::
	`New
("da").
	`ToLolChecked
()));

282 
Sass_Da_Cڋxt
* 
dx
 = 
	`ss_make_da_cڋxt
(
sour_rg
);

283 
Sass_Cڋxt
* 
x
 = 
	`ss_da_cڋxt_g_cڋxt
(
dx
);

284 
ss_cڋxt_w
* 
x_w
 = 
	`ss_make_cڋxt_w
();

285 
su
 = -1;

287 i((
su
 = 
	`ExaOis
(
tis
, 
dx
, 
x_w
, 
l
, 
ue
)) >= 0) {

288 
	`compe_da
(
dx
);

289 
su
 = 
	`GResu
(
x_w
, 
x
, 
ue
);

292 
	`ss__cڋxt_w
(
x_w
);

293 
fo
.
	`GRuVue
().
	`S
(
su
 == 0);

294 
	}
}

296 
	$NAN_METHOD
(
nd_fe
) {

298 
v8
::
Lol
<v8::
Obje
> 
tis
 = 
N
::
To
<v8::Obje>(
fo
[0]).
	`ToLolChecked
();

299 * 
put_th
 = 
	`_rg
(
N
::
	`G
(
tis
, N::
	`New
("fe").
	`ToLolChecked
()));

300 
Sass_Fe_Cڋxt
* 
fx
 = 
	`ss_make_fe_cڋxt
(
put_th
);

301 
ss_cڋxt_w
* 
x_w
 = 
	`ss_make_cڋxt_w
();

303 i(
	`ExaOis
(
tis
, 
fx
, 
x_w
, 
ue
, 
l
) >= 0) {

305 
us
 = 
	`uv_queue_wk
(
	`uv_deu_lo
(), &
x_w
->
que
, 
compe_
, (
uv_a_wk_cb
)
MakeClback
);

306 
	`as
(
us
 == 0);

308 
	}
}

310 
	$NAN_METHOD
(
nd_fe_sync
) {

312 
v8
::
Lol
<v8::
Obje
> 
tis
 = 
N
::
To
<v8::Obje>(
fo
[0]).
	`ToLolChecked
();

313 * 
put_th
 = 
	`_rg
(
N
::
	`G
(
tis
, N::
	`New
("fe").
	`ToLolChecked
()));

314 
Sass_Fe_Cڋxt
* 
fx
 = 
	`ss_make_fe_cڋxt
(
put_th
);

315 
Sass_Cڋxt
* 
x
 = 
	`ss_fe_cڋxt_g_cڋxt
(
fx
);

316 
ss_cڋxt_w
* 
x_w
 = 
	`ss_make_cڋxt_w
();

317 
su
 = -1;

319 i((
su
 = 
	`ExaOis
(
tis
, 
fx
, 
x_w
, 
ue
,rue)) >= 0) {

320 
	`compe_fe
(
fx
);

321 
su
 = 
	`GResu
(
x_w
, 
x
, 
ue
);

324 
	`
(
put_th
);

325 
	`ss__cڋxt_w
(
x_w
);

327 
fo
.
	`GRuVue
().
	`S
(
su
 == 0);

328 
	}
}

330 
	$NAN_METHOD
(
libss_vsi
) {

331 
fo
.
	`GRuVue
().
	`S
(
N
::
New
<
v8
::
Sg
>(
	`libss_vsi
()).
	`ToLolChecked
());

332 
	}
}

334 
	$NAN_MODULE_INIT
(
RegiModu
) {

335 
N
::
	`SMhod
(
rg
, "nd", 
nd
);

336 
N
::
	`SMhod
(
rg
, "ndSync", 
nd_sync
);

337 
N
::
	`SMhod
(
rg
, "ndFe", 
nd_fe
);

338 
N
::
	`SMhod
(
rg
, "ndFeSync", 
nd_fe_sync
);

339 
N
::
	`SMhod
(
rg
, "libssVsi", 
libss_vsi
);

340 
SassTys
::
Fay
::
	`Expts
(
rg
);

341 
	}
}

343 
NODE_MODULE
(
bdg
, 
RegiModu
);

	@node_modules/node-sass/src/callback_bridge.h

1 #ide
CALLBACK_BRIDGE_H


2 
	#CALLBACK_BRIDGE_H


	)

4 
	~<ve
>

5 
	~<n.h
>

6 
	~<gܙhm
>

7 
	~<uv.h
>

9 
	#COMMA
 ,

	)

11 
	gme
 <
tyme
 
	gT
,ym
	gL
 = *>

12 as
	cClbackBridge
 {

13 
public
:

14 
ClbackBridge
(
v8
::
Lol
<v8::
Funi
>, 
bo
);

15 
	mvtu
 ~
ClbackBridge
();

18 
T
 
	$ݔ
()(
d
::
ve
<*>);

20 
eed
:

23 
N
::
MaybeLol
<
v8
::
Funi
> 
	`g_w_cڡru
();

24 
	`async_ge
(
uv_hd_t
 *
hd
);

25 
	`NAN_METHOD
(
New
);

26 
	`NAN_METHOD
(
RuClback
);

27 
N
::
Psit
<
v8
::
Funi
> 
w_cڡru
;

28 
N
::
Psit
<
v8
::
Obje
> 
w
;

32 
	`diched_async_uv_back
(
uv_async_t
*);

37 
vtu
 
T
 
	`po_oss_tu_vue
(
v8
::
Lol
<v8::
Vue
>) const =0;

40 
vtu
 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
	`e_oss_gs
(d::ve<
L
>) const =0;

42 
N
::
Clback
* 
back
;

43 
bo
 
is_sync
;

45 
uv_mux_t
 
cv_mux
;

46 
uv_cd_t
 
cdi_vb
;

47 
uv_async_t
 *
async
;

48 
d
::
ve
<
L
> 
gv
;

49 
bo
 
has_tued
;

50 
T
 
tu_vue
;

53 
me
 <
tyme
 
T
,ym
L
>

54 
N
::
Psit
<
v8
::
Funi
> 
ClbackBridge
<
T
, 
L
>::
w_cڡru
;

56 
me
 <
tyme
 
T
,ym
L
>

57 
ClbackBridge
<
T
, 
L
>::
	`ClbackBridge
(
v8
::
Lol
<v8::
Funi
> 
back
, 
bo
 
is_sync
: 
	`back
(
w
 
N
::
	`Clback
(back)), 
	$is_sync
(
is_sync
) {

62 
N
::
HdSce
 
sce
;

63 
	`uv_mux_
(&
this
->
cv_mux
);

64 
	`uv_cd_
(&
this
->
cdi_vb
);

65 i(!
is_sync
) {

66 
this
->
async
 = 
w
 
uv_async_t
;

67 
this
->
async
->
da
 = (*)his;

68 
	`uv_async_
(
	`uv_deu_lo
(), 
this
->
async
, (
uv_async_cb

diched_async_uv_back
);

71 
v8
::
Lol
<v8::
Funi
> 
func
 = 
ClbackBridge
<
T
, 
L
>::
	`g_w_cڡru
().
	`ToLolChecked
();

72 
w
.
	`Ret
(
N
::
	`NewIn
(
func
).
	`ToLolChecked
());

73 
N
::
	`SIlFldPor
(N::
	`New
(
w
), 0, 
this
);

74 
	}
}

76 
	gme
 <
tyme
 
	gT
,ym
	gL
>

77 
	gClbackBridge
<
	gT
, 
	gL
>::~
	$ClbackBridge
() {

78 
de
 
this
->
back
;

79 
this
->
w
.
	`Ret
();

80 
	`uv_cd_deroy
(&
this
->
cdi_vb
);

81 
	`uv_mux_deroy
(&
this
->
cv_mux
);

83 i(!
is_sync
) {

84 
	`uv_o
((
uv_hd_t
*)
this
->
async
, &
async_ge
);

86 
	}
}

88 
	gme
 <
tyme
 
	gT
,ym
	gL
>

89 
T
 
	gClbackBridge
<
	gT
, 
	gL
>::
	$ݔ
()(
d
::
ve
<*> 
gv
) {

91 i(
this
->
is_sync
) {

100 
N
::
HdSce
 
sce
;

101 
N
::
TryCch
 
y_tch
;

102 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
gv_v8
 = 
	`e_oss_gs
(
gv
);

103 i(
y_tch
.
	`HasCaught
()) {

104 
N
::
	`FExi
(
y_tch
);

107 
gv_v8
.
	`push_back
(
N
::
	`New
(
w
));

109  
this
->
	`po_oss_tu_vue
(

110 
this
->
back
->
	`Cl
(
gv_v8
.
	`size
(), &argv_v8[0])

127 
this
->
gv
 =rgv;

129 
	`uv_mux_lock
(&
this
->
cv_mux
);

130 
this
->
has_tued
 = 
l
;

131 
	`uv_async_nd
(
this
->
async
);

132 !
this
->
has_tued
) {

133 
	`uv_cd_wa
(&
this
->
cdi_vb
, &this->
cv_mux
);

135 
	`uv_mux_uock
(&
this
->
cv_mux
);

136  
this
->
tu_vue
;

138 
	}
}

140 
	gme
 <
tyme
 
	gT
,ym
	gL
>

141 
	gClbackBridge
<
	gT
, 
	gL
>::
	$diched_async_uv_back
(
uv_async_t
 *
q
) {

142 
ClbackBridge
* 
bridge
 = 
ic_
<ClbackBridge*>(
q
->
da
);

153 
N
::
HdSce
 
sce
;

154 
N
::
TryCch
 
y_tch
;

156 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
gv_v8
 = 
bridge
->
	`e_oss_gs
(bridge->
gv
);

157 i(
y_tch
.
	`HasCaught
()) {

158 
N
::
	`FExi
(
y_tch
);

160 
gv_v8
.
	`push_back
(
N
::
	`New
(
bridge
->
w
));

162 
bridge
->
back
->
	`Cl
(
gv_v8
.
	`size
(), &argv_v8[0]);

164 i(
y_tch
.
	`HasCaught
()) {

165 
N
::
	`FExi
(
y_tch
);

167 
	}
}

169 
	gme
 <
tyme
 
	gT
,ym
	gL
>

170 
NAN_METHOD
(
ClbackBridge
<
T
 
COMMA
 
L
>::
RuClback
) {

179 
ClbackBridge
<
T
, 
	gL
>* 
	gbridge
 = 
ic_
<ClbackBridge<T, L>*>(
	gN
::
GIlFldPor
(
fo
.
This
(), 0));

180 
	gN
::
TryCch
 
y_tch
;

182 
	gbridge
->
	gtu_vue
 = 
bridge
->
po_oss_tu_vue
(
fo
[0]);

185 
uv_mux_lock
(&
bridge
->
cv_mux
);

186 
	gbridge
->
	ghas_tued
 = 
ue
;

187 
uv_mux_uock
(&
bridge
->
cv_mux
);

190 
uv_cd_brd
(&
bridge
->
cdi_vb
);

192 i(
	gy_tch
.
HasCaught
()) {

193 
	gN
::
FExi
(
y_tch
);

197 
	gme
 <
tyme
 
	gT
,ym
	gL
>

198 
	gN
::
MaybeLol
<
v8
::
Funi
> 
ClbackBridge
<
T
, 
	gL
>::
	$g_w_cڡru
() {

200 i(
w_cڡru
.
	`IsEmy
()) {

201 
v8
::
Lol
<v8::
FuniTeme
> 
l
 = 
N
::
New
<v8::FunctionTemplate>(New);

202 
l
->
	`SCssName
(
N
::
	`New
("ClbackBridge").
	`ToLolChecked
());

203 
l
->
	`InTeme
()->
	`SIlFldCou
(1);

205 
N
::
	`SPryTeme
(
l
, "success",

206 
N
::
New
<
v8
::
FuniTeme
>(
RuClback
)

209 
w_cڡru
.
	`Ret
(
N
::
	`GFuni
(
l
).
	`ToLolChecked
());

212  
N
::
	`New
(
w_cڡru
);

213 
	}
}

215 
	gme
 <
tyme
 
	gT
,ym
	gL
>

216 
NAN_METHOD
(
ClbackBridge
<
T
 
COMMA
 
L
>::
New
) {

217 
fo
.
GRuVue
().
S
(fo.
This
());

220 
	gme
 <
tyme
 
	gT
,ym
	gL
>

221 
	gClbackBridge
<
	gT
, 
	gL
>::
	$async_ge
(
uv_hd_t
 *
hd
) {

222 
	`de
 (
uv_async_t
 *)
hd
;

223 
	}
}

	@node_modules/node-sass/src/create_string.cpp

1 
	~<n.h
>

2 
	~<dlib.h
>

3 
	~<rg.h
>

4 
	~"_rg.h
"

6 * 
_rg
(
N
::
MaybeLol
<
v8
::
Vue
> 
maybevue
) {

7 
v8
::
Lol
<v8::
Vue
> 
vue
;

9 i(
	gmaybevue
.
ToLol
(&
vue
)) {

10 i(
	gvue
->
IsNu
(|| !vue->
IsSg
()) {

17 
	gv8
::
Sg
::
Utf8Vue
 
rg
(
vue
);

18 *
	gr
 = (*)
mloc
(
rg
.
ngth
() + 1);

19 
ry
(
r
, *
rg
);

20  
	gr
;

	@node_modules/node-sass/src/create_string.h

1 #ide
CREATE_STRING_H


2 
	#CREATE_STRING_H


	)

4 
	~<n.h
>

6 * 
_rg
(
N
::
MaybeLol
<
v8
::
Vue
>);

	@node_modules/node-sass/src/custom_function_bridge.cpp

1 
	~<n.h
>

2 
	~<dex
>

3 
	~"cuom_funi_bridge.h
"

4 
	~"ss_tys/y.h
"

5 
	~"ss_tys/vue.h
"

7 
Sass_Vue
* 
	gCuomFuniBridge
::
po_oss_tu_vue
(
v8
::
Lol
<v8::
Vue
> 
v
) const {

8 
SassTys
::
Vue
 *
v_
;

9 i((
	gv_
 = 
SassTys
::
Fay
::
unwp
(
v
))) {

10  
v_
->
g_ss_vue
();

12  
ss_make_r
("A SassValue object wasxpected.");

16 
	gd
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
CuomFuniBridge
::
e_oss_gs
(
d
::ve<*> 

) const {

17 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
gv
 = std::vector<v8::Local<v8::Value>>();

19 * 
	gvue
 : 

) {

20 
gv
.
push_back
(
SassTys
::
Fay
::

(
ic_
<
Sass_Vue
*>(
vue
))->
g_js_obje
());

23  
	ggv
;

	@node_modules/node-sass/src/custom_function_bridge.h

1 #ide
CUSTOM_FUNCTION_BRIDGE_H


2 
	#CUSTOM_FUNCTION_BRIDGE_H


	)

4 
	~<n.h
>

5 
	~<ss/vues.h
>

6 
	~<ss/funis.h
>

7 
	~"back_bridge.h
"

9 
ass
 
	gCuomFuniBridge
 : 
public
 
ClbackBridge
<
Sass_Vue
*> {

10 
public
:

11 
CuomFuniBridge
(
v8
::
Lol
<v8::
Funi
> 
cb
, 
bo
 
is_sync
: 
ClbackBridge
<
Sass_Vue
*>(cb, 
	gis_sync
) {}

13 
	give
:

14 
Sass_Vue
* 
po_oss_tu_vue
(
v8
::
Lol
<v8::
Vue
>) const;

15 
	gd
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
e_oss_gs
(
d
::vector<*>) const;

	@node_modules/node-sass/src/custom_importer_bridge.cpp

1 
	~<n.h
>

2 
	~<dex
>

3 
	~"cuom_imp܋r_bridge.h
"

4 
	~"_rg.h
"

6 
SassImptLi
 
	gCuomImp܋rBridge
::
po_oss_tu_vue
(
v8
::
Lol
<v8::
Vue
> 
tued_vue
) const {

7 
SassImptLi
 
impts
 = 0;

8 
	gN
::
HdSce
 
sce
;

10 i(
	gtued_vue
->
IsAay
()) {

11 
	gv8
::
Lol
<
v8
::
Aay
> 
y
 = 
tued_vue
.
As
<v8::Array>();

13 
	gimpts
 = 
ss_make_impt_li
(
y
->
Lgth
());

15 
size_t
 
	gi
 = 0; i < 
	gy
->
Lgth
(); ++i) {

16 
	gv8
::
Lol
<
v8
::
Vue
> 
vue
 = 
N
::
G
(
y
, 
ic_
<
ut32_t
>(
i
)).
ToLolChecked
();

18 i(!
	gvue
->
IsObje
()) {

19 aut
	gy
 = 
ss_make_impt_y
(0, 0, 0);

20 
ss_impt_t_r
(
y
, "returnedrray must only contain objectiterals", -1, -1);

24 
	gv8
::
Lol
<
v8
::
Obje
> 
obje
 = 
vue
.
As
<v8::Object>();

26 i(
	gvue
->
IsNiveE
()) {

27 * 
	gmesge
 = 
_rg
(
N
::
G
(
obje
, N::
New
<
v8
::
Sg
>("mesge").
ToLolChecked
()));

29 
	gimpts
[
i
] = 
ss_make_impt_y
(0, 0, 0);

31 
ss_impt_t_r
(
impts
[
i
], 
mesge
, -1, -1);

34 
	gimpts
[
i
] = 
g_imp܋r_y
(
obje
);

38 i(
	gtued_vue
->
IsNiveE
()) {

39 
	gimpts
 = 
ss_make_impt_li
(1);

40 
	gv8
::
Lol
<
v8
::
Obje
> 
obje
 = 
tued_vue
.
As
<v8::Object>();

41 * 
	gmesge
 = 
_rg
(
N
::
G
(
obje
, N::
New
<
v8
::
Sg
>("mesge").
ToLolChecked
()));

43 
	gimpts
[0] = 
ss_make_impt_y
(0, 0, 0);

45 
ss_impt_t_r
(
impts
[0], 
mesge
, -1, -1);

47 i(
	gtued_vue
->
IsObje
()) {

48 
	gimpts
 = 
ss_make_impt_li
(1);

49 
	gimpts
[0] = 
g_imp܋r_y
(
tued_vue
.
As
<
v8
::
Obje
>());

52  
	gimpts
;

55 
Sass_Impt
* 
	gCuomImp܋rBridge
::
check_tued_rg
(
N
::
MaybeLol
<
v8
::
Vue
> 
vue
, cڡ *
msg
) const

57 
	gv8
::
Lol
<
v8
::
Vue
> 
checked
;

58 i(
	gvue
.
ToLol
(&
checked
)) {

59 i(!
	gchecked
->
IsUndefed
(&& !checked->
IsSg
()) {

60 
	gr
;

62  
	gnuαr
;

65 
	gr
:

66 aut
y
 = 
ss_make_impt_y
(0, 0, 0);

67 
ss_impt_t_r
(
y
, 
msg
, -1, -1);

68  
	gy
;

71 
Sass_Impt
* 
	gCuomImp܋rBridge
::
g_imp܋r_y
(cڡ 
v8
::
Lol
<v8::
Obje
>& 
obje
) const {

72 aut
tued_fe
 = 
N
::
G
(
obje
, N::
New
<
v8
::
Sg
>("fe").
ToLolChecked
());

73 aut
	gtued_cڋs
 = 
N
::
G
(
obje
, N::
New
<
v8
::
Sg
>("cڋs").
ToLolChecked
()).ToLocalChecked();

74 aut
	gtued_m
 = 
N
::
G
(
obje
, N::
New
<
v8
::
Sg
>("m").
ToLolChecked
());

75 
Sass_Impt
 *
	gr
;

77 i((
	gr
 = 
check_tued_rg
(
tued_fe
, "returned value of `file` must be string")))

78  
	gr
;

80 i((
	gr
 = 
check_tued_rg
(
tued_cڋs
, "returned value of `contents` must be string")))

81  
	gr
;

83 i((
	gr
 = 
check_tued_rg
(
tued_m
, "returned value of `returned_map` must be string")))

84  
	gr
;

86 * 
	gth
 = 
_rg
(
tued_fe
);

87 * 
	gcڋs
 = 
_rg
(
tued_cڋs
);

88 * 
	gcm
 = 
_rg
(
tued_m
);

90  
ss_make_impt_y
(
th
, 
cڋs
, 
cm
);

93 
	gd
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
CuomImp܋rBridge
::
e_oss_gs
(
d
::ve<*> 

) const {

94 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
out
;

96 * 
	gr
 : 

) {

97 
out
.
push_back
(
N
::
New
<
v8
::
Sg
>((cڡ*)
r
).
ToLolChecked
());

100  
	gout
;

	@node_modules/node-sass/src/custom_importer_bridge.h

1 #ide
CUSTOM_IMPORTER_BRIDGE_H


2 
	#CUSTOM_IMPORTER_BRIDGE_H


	)

4 
	~<n.h
>

5 
	~<ss/funis.h
>

6 
	~<ss/vues.h
>

7 
	~"back_bridge.h
"

9 
Sass_Impt_Li
 
	tSassImptLi
;

11 
ass
 
	gCuomImp܋rBridge
 : 
public
 
ClbackBridge
<
SassImptLi
> {

12 
public
:

13 
CuomImp܋rBridge
(
v8
::
Lol
<v8::
Funi
> 
cb
, 
bo
 
is_sync
: 
ClbackBridge
<
SassImptLi
>(cb, 
	gis_sync
) {}

15 
	give
:

16 
SassImptLi
 
po_oss_tu_vue
(
v8
::
Lol
<v8::
Vue
>) const;

17 
Sass_Impt
* 
check_tued_rg
(
N
::
MaybeLol
<
v8
::
Vue
> 
vue
, cڡ *
msg
) const;

18 
Sass_Impt
* 
g_imp܋r_y
(cڡ 
v8
::
Lol
<v8::
Obje
>&) const;

19 
	gd
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
e_oss_gs
(
d
::vector<*>) const;

	@node_modules/node-sass/src/libsass/contrib/plugin.cpp

1 
	~<crg
>

2 
	~<ioam
>

3 
	~<dt.h
>

4 
	~<ss.h
>

9 "C" cڡ * 
ADDCALL
 
	$libss_g_vsi
() {

10  
	`libss_vsi
();

11 
	}
}

13 
Sass_Vue
* 
	$cuom_funi
(cڡ 
Sass_Vue
* 
s_gs
, 
Sass_Funi_Ery
 
cb
, 
Sass_Comp
* 
comp
)

16 
Sass_Cڋxt
* 
x
 = 
	`ss_comp_g_cڋxt
(
comp
);

17 
Sass_Ois
* 
ts
 = 
	`ss_comp_g_tis
(
comp
);

19 * 
cook
 = 
	`ss_funi_g_cook
(
cb
);

21  
	`ss_make_numb
((
_t
)
cook
, "px");

22 
	}
}

24 "C" 
Sass_Funi_Li
 
ADDCALL
 
	$libss_ld_funis
()

27 
Sass_Funi_Ery
 
c_func
 =

28 
	`ss_make_funi
("foo()", 
cuom_funi
, (*)42);

30 
Sass_Funi_Li
 
_li
 = 
	`ss_make_funi_li
(1);

32 
	`ss_funi_t_li_y
(
_li
, 0, 
c_func
);

34  
_li
;

35 
	}
}

37 
Sass_Impt_Li
 
	$cuom_imp܋r
(cڡ * 
cur_th
, 
Sass_Imp܋r_Ery
 
cb
, 
Sass_Comp
* 
comp
)

40 * 
cook
 = 
	`ss_imp܋r_g_cook
(
cb
);

42 
Sass_Impt_Li
 
cs
 = 
	`ss_make_impt_li
(1);

44 
cs
[0] = 
	`ss_make_impt_y
(
cur_th
, 0, 0);

46  
cs
;

47 
	}
}

49 "C" 
Sass_Imp܋r_Li
 
ADDCALL
 
	$libss_ld_imp܋rs
()

52 
Sass_Imp܋r_Ery
 
c_imp
 =

53 
	`ss_make_imp܋r
(
cuom_imp܋r
, - 99, (*)42);

55 
Sass_Imp܋r_Li
 
imp_li
 = 
	`ss_make_imp܋r_li
(1);

57 
	`ss_imp܋r_t_li_y
(
imp_li
, 0, 
c_imp
);

59  
imp_li
;

60 
	}
}

	@node_modules/node-sass/src/libsass/include/sass.h

1 #ide
SASS_H


2 
	#SASS_H


	)

7 
	~<ss/ba.h
>

8 
	~<ss/vsi.h
>

9 
	~<ss/vues.h
>

10 
	~<ss/funis.h
>

11 
	~<ss/cڋxt.h
>

12 
	~<ss2scss.h
>

	@node_modules/node-sass/src/libsass/include/sass/base.h

1 #ide
SASS_BASE_H


2 
	#SASS_BASE_H


	)

4 #ifde
_MSC_VER


5 #agm
wng
(
dib
 : 4503)

6 #ide
_SCL_SECURE_NO_WARNINGS


7 
	#_SCL_SECURE_NO_WARNINGS


	)

9 #ide
_CRT_SECURE_NO_WARNINGS


10 
	#_CRT_SECURE_NO_WARNINGS


	)

12 #ide
_CRT_NONSTDC_NO_DEPRECATE


13 
	#_CRT_NONSTDC_NO_DEPRECATE


	)

17 
	~<ddef.h
>

18 
	~<dbo.h
>

20 #ifde
__GNUC__


21 
	#DEPRECATED
(
func
fun
	`__ibu__
 ((
dd
))

	)

22 #i
defed
(
_MSC_VER
)

23 
	#DEPRECATED
(
func

	`__deec
(
dd

	)
func

25 #agm
mesge
("WARNING: Youeedo implement DEPRECATED forhis compiler")

26 
	#DEPRECATED
(
func

	)
func

29 #ifde
_WIN32


32 #ifde
ADD_EXPORTS


33 
	#ADDAPI
 
	`__deec
(
dexpt
)

	)

34 
	#ADDCALL
 
__cde


	)

36 
	#ADDAPI


	)

37 
	#ADDCALL


	)

43 
	#ADDAPI


	)

44 
	#ADDCALL


	)

49 #ifde
__lulus


55 
	eSass_Ouut_Sty
 {

56 
SASS_STYLE_NESTED
,

57 
SASS_STYLE_EXPANDED
,

58 
SASS_STYLE_COMPACT
,

59 
SASS_STYLE_COMPRESSED
,

61 
SASS_STYLE_INSPECT
,

62 
SASS_STYLE_TO_SASS


66 * 
ss_loc_memy
(
size_t
 
size
);

68 * 
ss_cy_c_rg
(cڡ * 
r
);

70 
ss__memy
(* 
r
);

73 
ADDAPI
 * 
ADDCALL
 
ss_rg_que
 (cڡ * 
r
, cڡ 
que_mk
);

74 
ADDAPI
 * 
ADDCALL
 
ss_rg_unque
 (cڡ * 
r
);

77 
ADDAPI
 * 
ADDCALL
 
ss_sve_fe
 (cڡ * 
th
, cڡ * 
cs
[]);

80 
ADDAPI
 cڡ * 
ADDCALL
 
libss_vsi
();

83 
ADDAPI
 cڡ * 
ADDCALL
 
libss_nguage_vsi
();

85 #ifde
__lulus


	@node_modules/node-sass/src/libsass/include/sass/context.h

1 #ide
SASS_C_CONTEXT_H


2 
	#SASS_C_CONTEXT_H


	)

4 
	~<ddef.h
>

5 
	~<dbo.h
>

6 
	~<ss/ba.h
>

7 
	~<ss/vues.h
>

8 
	~<ss/funis.h
>

10 #ifde
__lulus


16 
Sass_Comp
;

19 
Sass_Ois
;

20 
Sass_Cڋxt
;

21 
Sass_Fe_Cڋxt
;

22 
Sass_Da_Cڋxt
;

25 
	eSass_Comp_S
 {

26 
SASS_COMPILER_CREATED
,

27 
SASS_COMPILER_PARSED
,

28 
SASS_COMPILER_EXECUTED


32 
ADDAPI
 
Sass_Ois
* 
ADDCALL
 
ss_make_tis
 ();

34 
ADDAPI
 
Sass_Fe_Cڋxt
* 
ADDCALL
 
ss_make_fe_cڋxt
 (cڡ * 
put_th
);

35 
ADDAPI
 
Sass_Da_Cڋxt
* 
ADDCALL
 
ss_make_da_cڋxt
 (* 
sour_rg
);

38 
ADDAPI
 
ADDCALL
 
ss_compe_fe_cڋxt
 (
Sass_Fe_Cڋxt
* 
x
);

39 
ADDAPI
 
ADDCALL
 
ss_compe_da_cڋxt
 (
Sass_Da_Cڋxt
* 
x
);

42 
ADDAPI
 
Sass_Comp
* 
ADDCALL
 
ss_make_fe_comp
 (
Sass_Fe_Cڋxt
* 
fe_x
);

43 
ADDAPI
 
Sass_Comp
* 
ADDCALL
 
ss_make_da_comp
 (
Sass_Da_Cڋxt
* 
da_x
);

47 
ADDAPI
 
ADDCALL
 
ss_comp_r
(
Sass_Comp
* 
comp
);

48 
ADDAPI
 
ADDCALL
 
ss_comp_execu
(
Sass_Comp
* 
comp
);

52 
ADDAPI
 
ADDCALL
 
ss_de_comp
(
Sass_Comp
* 
comp
);

55 
ADDAPI
 
ADDCALL
 
ss_de_fe_cڋxt
 (
Sass_Fe_Cڋxt
* 
x
);

56 
ADDAPI
 
ADDCALL
 
ss_de_da_cڋxt
 (
Sass_Da_Cڋxt
* 
x
);

59 
ADDAPI
 
Sass_Cڋxt
* 
ADDCALL
 
ss_fe_cڋxt_g_cڋxt
 (
Sass_Fe_Cڋxt
* 
fe_x
);

60 
ADDAPI
 
Sass_Cڋxt
* 
ADDCALL
 
ss_da_cڋxt_g_cڋxt
 (
Sass_Da_Cڋxt
* 
da_x
);

63 
ADDAPI
 
Sass_Ois
* 
ADDCALL
 
ss_cڋxt_g_tis
 (
Sass_Cڋxt
* 
x
);

64 
ADDAPI
 
Sass_Ois
* 
ADDCALL
 
ss_fe_cڋxt_g_tis
 (
Sass_Fe_Cڋxt
* 
fe_x
);

65 
ADDAPI
 
Sass_Ois
* 
ADDCALL
 
ss_da_cڋxt_g_tis
 (
Sass_Da_Cڋxt
* 
da_x
);

66 
ADDAPI
 
ADDCALL
 
ss_fe_cڋxt_t_tis
 (
Sass_Fe_Cڋxt
* 
fe_x
, 
Sass_Ois
* 
t
);

67 
ADDAPI
 
ADDCALL
 
ss_da_cڋxt_t_tis
 (
Sass_Da_Cڋxt
* 
da_x
, 
Sass_Ois
* 
t
);

71 
ADDAPI
 
ADDCALL
 
ss_ti_g_ecisi
 (
Sass_Ois
* 
tis
);

72 
ADDAPI
 
Sass_Ouut_Sty
 
ADDCALL
 
ss_ti_g_ouut_y
 (
Sass_Ois
* 
tis
);

73 
ADDAPI
 
bo
 
ADDCALL
 
ss_ti_g_sour_commts
 (
Sass_Ois
* 
tis
);

74 
ADDAPI
 
bo
 
ADDCALL
 
ss_ti_g_sour_m_embed
 (
Sass_Ois
* 
tis
);

75 
ADDAPI
 
bo
 
ADDCALL
 
ss_ti_g_sour_m_cڋs
 (
Sass_Ois
* 
tis
);

76 
ADDAPI
 
bo
 
ADDCALL
 
ss_ti_g_om_sour_m_u
 (
Sass_Ois
* 
tis
);

77 
ADDAPI
 
bo
 
ADDCALL
 
ss_ti_g_is_dd_syax_c
 (
Sass_Ois
* 
tis
);

78 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_dt
 (
Sass_Ois
* 
tis
);

79 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_leed
 (
Sass_Ois
* 
tis
);

80 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_put_th
 (
Sass_Ois
* 
tis
);

81 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_ouut_th
 (
Sass_Ois
* 
tis
);

82 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_ug_th
 (
Sass_Ois
* 
tis
);

83 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_ude_th
 (
Sass_Ois
* 
tis
);

84 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_sour_m_fe
 (
Sass_Ois
* 
tis
);

85 
ADDAPI
 cڡ * 
ADDCALL
 
ss_ti_g_sour_m_ro
 (
Sass_Ois
* 
tis
);

86 
ADDAPI
 
Sass_Imp܋r_Li
 
ADDCALL
 
ss_ti_g_c_hds
 (
Sass_Ois
* 
tis
);

87 
ADDAPI
 
Sass_Imp܋r_Li
 
ADDCALL
 
ss_ti_g_c_imp܋rs
 (
Sass_Ois
* 
tis
);

88 
ADDAPI
 
Sass_Funi_Li
 
ADDCALL
 
ss_ti_g_c_funis
 (
Sass_Ois
* 
tis
);

91 
ADDAPI
 
ADDCALL
 
ss_ti_t_ecisi
 (
Sass_Ois
* 
tis
, 
ecisi
);

92 
ADDAPI
 
ADDCALL
 
ss_ti_t_ouut_y
 (
Sass_Ois
* 
tis
, 
Sass_Ouut_Sty
 
ouut_y
);

93 
ADDAPI
 
ADDCALL
 
ss_ti_t_sour_commts
 (
Sass_Ois
* 
tis
, 
bo
 
sour_commts
);

94 
ADDAPI
 
ADDCALL
 
ss_ti_t_sour_m_embed
 (
Sass_Ois
* 
tis
, 
bo
 
sour_m_embed
);

95 
ADDAPI
 
ADDCALL
 
ss_ti_t_sour_m_cڋs
 (
Sass_Ois
* 
tis
, 
bo
 
sour_m_cڋs
);

96 
ADDAPI
 
ADDCALL
 
ss_ti_t_om_sour_m_u
 (
Sass_Ois
* 
tis
, 
bo
 
om_sour_m_u
);

97 
ADDAPI
 
ADDCALL
 
ss_ti_t_is_dd_syax_c
 (
Sass_Ois
* 
tis
, 
bo
 
is_dd_syax_c
);

98 
ADDAPI
 
ADDCALL
 
ss_ti_t_dt
 (
Sass_Ois
* 
tis
, cڡ * 
dt
);

99 
ADDAPI
 
ADDCALL
 
ss_ti_t_leed
 (
Sass_Ois
* 
tis
, cڡ * 
leed
);

100 
ADDAPI
 
ADDCALL
 
ss_ti_t_put_th
 (
Sass_Ois
* 
tis
, cڡ * 
put_th
);

101 
ADDAPI
 
ADDCALL
 
ss_ti_t_ouut_th
 (
Sass_Ois
* 
tis
, cڡ * 
ouut_th
);

102 
ADDAPI
 
ADDCALL
 
ss_ti_t_ug_th
 (
Sass_Ois
* 
tis
, cڡ * 
ug_th
);

103 
ADDAPI
 
ADDCALL
 
ss_ti_t_ude_th
 (
Sass_Ois
* 
tis
, cڡ * 
ude_th
);

104 
ADDAPI
 
ADDCALL
 
ss_ti_t_sour_m_fe
 (
Sass_Ois
* 
tis
, cڡ * 
sour_m_fe
);

105 
ADDAPI
 
ADDCALL
 
ss_ti_t_sour_m_ro
 (
Sass_Ois
* 
tis
, cڡ * 
sour_m_ro
);

106 
ADDAPI
 
ADDCALL
 
ss_ti_t_c_hds
 (
Sass_Ois
* 
tis
, 
Sass_Imp܋r_Li
 
c_hds
);

107 
ADDAPI
 
ADDCALL
 
ss_ti_t_c_imp܋rs
 (
Sass_Ois
* 
tis
, 
Sass_Imp܋r_Li
 
c_imp܋rs
);

108 
ADDAPI
 
ADDCALL
 
ss_ti_t_c_funis
 (
Sass_Ois
* 
tis
, 
Sass_Funi_Li
 
c_funis
);

112 
ADDAPI
 cڡ * 
ADDCALL
 
ss_cڋxt_g_ouut_rg
 (
Sass_Cڋxt
* 
x
);

113 
ADDAPI
 
ADDCALL
 
ss_cڋxt_g_r_us
 (
Sass_Cڋxt
* 
x
);

114 
ADDAPI
 cڡ * 
ADDCALL
 
ss_cڋxt_g_r_js
 (
Sass_Cڋxt
* 
x
);

115 
ADDAPI
 cڡ * 
ADDCALL
 
ss_cڋxt_g_r_xt
 (
Sass_Cڋxt
* 
x
);

116 
ADDAPI
 cڡ * 
ADDCALL
 
ss_cڋxt_g_r_mesge
 (
Sass_Cڋxt
* 
x
);

117 
ADDAPI
 cڡ * 
ADDCALL
 
ss_cڋxt_g_r_fe
 (
Sass_Cڋxt
* 
x
);

118 
ADDAPI
 cڡ * 
ADDCALL
 
ss_cڋxt_g_r_c
 (
Sass_Cڋxt
* 
x
);

119 
ADDAPI
 
size_t
 
ADDCALL
 
ss_cڋxt_g_r_le
 (
Sass_Cڋxt
* 
x
);

120 
ADDAPI
 
size_t
 
ADDCALL
 
ss_cڋxt_g_r_cumn
 (
Sass_Cڋxt
* 
x
);

121 
ADDAPI
 cڡ * 
ADDCALL
 
ss_cڋxt_g_sour_m_rg
 (
Sass_Cڋxt
* 
x
);

122 
ADDAPI
 ** 
ADDCALL
 
ss_cڋxt_g_uded_fes
 (
Sass_Cڋxt
* 
x
);

125 
ADDAPI
 
size_t
 
ADDCALL
 
ss_cڋxt_g_uded_fes_size
 (
Sass_Cڋxt
* 
x
);

128 
ADDAPI
 * 
ADDCALL
 
ss_cڋxt_ke_r_js
 (
Sass_Cڋxt
* 
x
);

129 
ADDAPI
 * 
ADDCALL
 
ss_cڋxt_ke_r_xt
 (
Sass_Cڋxt
* 
x
);

130 
ADDAPI
 * 
ADDCALL
 
ss_cڋxt_ke_r_mesge
 (
Sass_Cڋxt
* 
x
);

131 
ADDAPI
 * 
ADDCALL
 
ss_cڋxt_ke_r_fe
 (
Sass_Cڋxt
* 
x
);

132 
ADDAPI
 * 
ADDCALL
 
ss_cڋxt_ke_ouut_rg
 (
Sass_Cڋxt
* 
x
);

133 
ADDAPI
 * 
ADDCALL
 
ss_cڋxt_ke_sour_m_rg
 (
Sass_Cڋxt
* 
x
);

134 
ADDAPI
 ** 
ADDCALL
 
ss_cڋxt_ke_uded_fes
 (
Sass_Cڋxt
* 
x
);

137 
ADDAPI
 
Sass_Comp_S
 
ADDCALL
 
ss_comp_g_e
(
Sass_Comp
* 
comp
);

138 
ADDAPI
 
Sass_Cڋxt
* 
ADDCALL
 
ss_comp_g_cڋxt
(
Sass_Comp
* 
comp
);

139 
ADDAPI
 
Sass_Ois
* 
ADDCALL
 
ss_comp_g_tis
(
Sass_Comp
* 
comp
);

140 
ADDAPI
 
size_t
 
ADDCALL
 
ss_comp_g_impt_ack_size
(
Sass_Comp
* 
comp
);

141 
ADDAPI
 
Sass_Impt_Ery
 
ADDCALL
 
ss_comp_g_ϡ_impt
(
Sass_Comp
* 
comp
);

142 
ADDAPI
 
Sass_Impt_Ery
 
ADDCALL
 
ss_comp_g_impt_y
(
Sass_Comp
* 
comp
, 
size_t
 
idx
);

145 
ADDAPI
 
ADDCALL
 
ss_ti_push_ug_th
 (
Sass_Ois
* 
tis
, cڡ * 
th
);

146 
ADDAPI
 
ADDCALL
 
ss_ti_push_ude_th
 (
Sass_Ois
* 
tis
, cڡ * 
th
);

148 #ifde
__lulus


	@node_modules/node-sass/src/libsass/include/sass/functions.h

1 #ide
SASS_C_FUNCTIONS_H


2 
	#SASS_C_FUNCTIONS_H


	)

4 
	~<ddef.h
>

5 
	~<dbo.h
>

6 
	~<ss/ba.h
>

8 #ifde
__lulus


14 
Sass_Impt
;

15 
Sass_Ois
;

16 
Sass_Comp
;

17 
Sass_Imp܋r
;

18 
Sass_Funi
;

21 
Sass_Impt
 (*
	tSass_Impt_Ery
);

22 
Sass_Impt
* (*
	tSass_Impt_Li
);

24 
Sass_Imp܋r
 (*
	tSass_Imp܋r_Ery
);

25 
Sass_Imp܋r
* (*
	tSass_Imp܋r_Li
);

27 
Sass_Impt_Li
 (*
	tSass_Imp܋r_Fn
)

28 (cڡ * 
	tu
, 
	tSass_Imp܋r_Ery
 
	tcb
, 
	tSass_Comp
* 
	tcomp
);

31 
Sass_Funi
 (*
	tSass_Funi_Ery
);

32 
Sass_Funi
* (*
	tSass_Funi_Li
);

34 
Sass_Vue
* (*
	tSass_Funi_Fn
)

35 (cڡ 
	tSass_Vue
*, 
	tSass_Funi_Ery
 
	tcb
, 
	tSass_Comp
* 
	tcomp
);

39 
ADDAPI
 
Sass_Imp܋r_Li
 
ADDCALL
 
ss_make_imp܋r_li
 (
size_t
 
ngth
);

40 
ADDAPI
 
Sass_Imp܋r_Ery
 
ADDCALL
 
ss_imp܋r_g_li_y
 (
Sass_Imp܋r_Li
 
li
, 
size_t
 
idx
);

41 
ADDAPI
 
ADDCALL
 
ss_imp܋r_t_li_y
 (
Sass_Imp܋r_Li
 
li
, 
size_t
 
idx
, 
Sass_Imp܋r_Ery
 
y
);

46 
ADDAPI
 
Sass_Imp܋r_Ery
 
ADDCALL
 
ss_make_imp܋r
 (
Sass_Imp܋r_Fn
 
imp܋r
, 
iܙy
, * 
cook
);

49 
ADDAPI
 
Sass_Imp܋r_Fn
 
ADDCALL
 
ss_imp܋r_g_funi
 (
Sass_Imp܋r_Ery
 
cb
);

50 
ADDAPI
 
ADDCALL
 
ss_imp܋r_g_iܙy
 (
Sass_Imp܋r_Ery
 
cb
);

51 
ADDAPI
 * 
ADDCALL
 
ss_imp܋r_g_cook
 (
Sass_Imp܋r_Ery
 
cb
);

54 
ADDAPI
 
ADDCALL
 
ss_de_imp܋r
 (
Sass_Imp܋r_Ery
 
cb
);

57 
ADDAPI
 
Sass_Impt_Li
 
ADDCALL
 
ss_make_impt_li
 (
size_t
 
ngth
);

59 
ADDAPI
 
Sass_Impt_Ery
 
ADDCALL
 
ss_make_impt_y
 (cڡ * 
th
, * 
sour
, * 
cm
);

60 
ADDAPI
 
Sass_Impt_Ery
 
ADDCALL
 
ss_make_impt
 (cڡ * 
imp_th
, cڡ * 
abs_ba
, * 
sour
, * 
cm
);

62 
ADDAPI
 
Sass_Impt_Ery
 
ADDCALL
 
ss_impt_t_r
(Sass_Impt_Ery 
impt
, cڡ * 
mesge
, 
size_t
 
le
, size_
c
);

66 
ADDAPI
 
ADDCALL
 
ss_impt_t_li_y
 (
Sass_Impt_Li
 
li
, 
size_t
 
idx
, 
Sass_Impt_Ery
 
y
);

67 
ADDAPI
 
Sass_Impt_Ery
 
ADDCALL
 
ss_impt_g_li_y
 (
Sass_Impt_Li
 
li
, 
size_t
 
idx
);

70 
ADDAPI
 cڡ * 
ADDCALL
 
ss_impt_g_imp_th
 (
Sass_Impt_Ery
);

71 
ADDAPI
 cڡ * 
ADDCALL
 
ss_impt_g_abs_th
 (
Sass_Impt_Ery
);

72 
ADDAPI
 cڡ * 
ADDCALL
 
ss_impt_g_sour
 (
Sass_Impt_Ery
);

73 
ADDAPI
 cڡ * 
ADDCALL
 
ss_impt_g_cm
 (
Sass_Impt_Ery
);

76 
ADDAPI
 * 
ADDCALL
 
ss_impt_ke_sour
 (
Sass_Impt_Ery
);

77 
ADDAPI
 * 
ADDCALL
 
ss_impt_ke_cm
 (
Sass_Impt_Ery
);

79 
ADDAPI
 
size_t
 
ADDCALL
 
ss_impt_g_r_le
 (
Sass_Impt_Ery
);

80 
ADDAPI
 
size_t
 
ADDCALL
 
ss_impt_g_r_cumn
 (
Sass_Impt_Ery
);

81 
ADDAPI
 cڡ * 
ADDCALL
 
ss_impt_g_r_mesge
 (
Sass_Impt_Ery
);

84 
ADDAPI
 
ADDCALL
 
ss_de_impt_li
 (
Sass_Impt_Li
);

86 
ADDAPI
 
ADDCALL
 
ss_de_impt
 (
Sass_Impt_Ery
);

91 
ADDAPI
 
Sass_Funi_Li
 
ADDCALL
 
ss_make_funi_li
 (
size_t
 
ngth
);

92 
ADDAPI
 
Sass_Funi_Ery
 
ADDCALL
 
ss_make_funi
 (cڡ * 
sigtu
, 
Sass_Funi_Fn
 
cb
, * 
cook
);

95 
ADDAPI
 
Sass_Funi_Ery
 
ADDCALL
 
ss_funi_g_li_y
(
Sass_Funi_Li
 
li
, 
size_t
 
pos
);

96 
ADDAPI
 
ADDCALL
 
ss_funi_t_li_y
(
Sass_Funi_Li
 
li
, 
size_t
 
pos
, 
Sass_Funi_Ery
 
cb
);

99 
ADDAPI
 cڡ * 
ADDCALL
 
ss_funi_g_sigtu
 (
Sass_Funi_Ery
 
cb
);

100 
ADDAPI
 
Sass_Funi_Fn
 
ADDCALL
 
ss_funi_g_funi
 (
Sass_Funi_Ery
 
cb
);

101 
ADDAPI
 * 
ADDCALL
 
ss_funi_g_cook
 (
Sass_Funi_Ery
 
cb
);

104 #ifde
__lulus


	@node_modules/node-sass/src/libsass/include/sass/values.h

1 #ide
SASS_C_VALUES_H


2 
	#SASS_C_VALUES_H


	)

4 
	~<ddef.h
>

5 
	~<dbo.h
>

6 
	~<ss/ba.h
>

8 #ifde
__lulus


14 
Sass_Vue
;

17 
	eSass_Tag
 {

18 
SASS_BOOLEAN
,

19 
SASS_NUMBER
,

20 
SASS_COLOR
,

21 
SASS_STRING
,

22 
SASS_LIST
,

23 
SASS_MAP
,

24 
SASS_NULL
,

25 
SASS_ERROR
,

26 
SASS_WARNING


30 
	eSass_S
 {

31 
SASS_COMMA
,

32 
SASS_SPACE
,

33 
SASS_HASH


37 
	eSass_OP
 {

38 
AND
, 
OR
,

39 
EQ
, 
NEQ
, 
GT
, 
GTE
, 
LT
, 
LTE
,

40 
ADD
, 
SUB
, 
MUL
, 
DIV
, 
MOD
,

41 
NUM_OPS


46 
ADDAPI
 
Sass_Tag
 
ADDCALL
 
ss_vue_g_g
 (cڡ 
Sass_Vue
* 
v
);

50 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_nu
 (cڡ 
Sass_Vue
* 
v
);

51 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_numb
 (cڡ 
Sass_Vue
* 
v
);

52 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_rg
 (cڡ 
Sass_Vue
* 
v
);

53 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_boޗn
 (cڡ 
Sass_Vue
* 
v
);

54 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_c
 (cڡ 
Sass_Vue
* 
v
);

55 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_li
 (cڡ 
Sass_Vue
* 
v
);

56 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_m
 (cڡ 
Sass_Vue
* 
v
);

57 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_r
 (cڡ 
Sass_Vue
* 
v
);

58 
ADDAPI
 
bo
 
ADDCALL
 
ss_vue_is_wng
 (cڡ 
Sass_Vue
* 
v
);

61 
ADDAPI
 
ADDCALL
 
ss_numb_g_vue
 (cڡ 
Sass_Vue
* 
v
);

62 
ADDAPI
 
ADDCALL
 
ss_numb_t_vue
 (
Sass_Vue
* 
v
, 
vue
);

63 
ADDAPI
 cڡ * 
ADDCALL
 
ss_numb_g_un
 (cڡ 
Sass_Vue
* 
v
);

64 
ADDAPI
 
ADDCALL
 
ss_numb_t_un
 (
Sass_Vue
* 
v
, * 
un
);

67 
ADDAPI
 cڡ * 
ADDCALL
 
ss_rg_g_vue
 (cڡ 
Sass_Vue
* 
v
);

68 
ADDAPI
 
ADDCALL
 
ss_rg_t_vue
 (
Sass_Vue
* 
v
, * 
vue
);

69 
ADDAPI
 
bo
 
ADDCALL
 
ss_rg_is_qued
(cڡ 
Sass_Vue
* 
v
);

70 
ADDAPI
 
ADDCALL
 
ss_rg_t_qued
(
Sass_Vue
* 
v
, 
bo
 
qued
);

73 
ADDAPI
 
bo
 
ADDCALL
 
ss_boޗn_g_vue
 (cڡ 
Sass_Vue
* 
v
);

74 
ADDAPI
 
ADDCALL
 
ss_boޗn_t_vue
 (
Sass_Vue
* 
v
, 
bo
 
vue
);

77 
ADDAPI
 
ADDCALL
 
ss_c_g_r
 (cڡ 
Sass_Vue
* 
v
);

78 
ADDAPI
 
ADDCALL
 
ss_c_t_r
 (
Sass_Vue
* 
v
, 
r
);

79 
ADDAPI
 
ADDCALL
 
ss_c_g_g
 (cڡ 
Sass_Vue
* 
v
);

80 
ADDAPI
 
ADDCALL
 
ss_c_t_g
 (
Sass_Vue
* 
v
, 
g
);

81 
ADDAPI
 
ADDCALL
 
ss_c_g_b
 (cڡ 
Sass_Vue
* 
v
);

82 
ADDAPI
 
ADDCALL
 
ss_c_t_b
 (
Sass_Vue
* 
v
, 
b
);

83 
ADDAPI
 
ADDCALL
 
ss_c_g_a
 (cڡ 
Sass_Vue
* 
v
);

84 
ADDAPI
 
ADDCALL
 
ss_c_t_a
 (
Sass_Vue
* 
v
, 
a
);

87 
ADDAPI
 
size_t
 
ADDCALL
 
ss_li_g_ngth
 (cڡ 
Sass_Vue
* 
v
);

89 
ADDAPI
 
Sass_S
 
ADDCALL
 
ss_li_g_t
 (cڡ 
Sass_Vue
* 
v
);

90 
ADDAPI
 
ADDCALL
 
ss_li_t_t
 (
Sass_Vue
* 
v
, 
Sass_S
 
vue
);

92 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_li_g_vue
 (cڡ Sass_Vue* 
v
, 
size_t
 
i
);

93 
ADDAPI
 
ADDCALL
 
ss_li_t_vue
 (
Sass_Vue
* 
v
, 
size_t
 
i
, Sass_Vue* 
vue
);

96 
ADDAPI
 
size_t
 
ADDCALL
 
ss_m_g_ngth
 (cڡ 
Sass_Vue
* 
v
);

98 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_m_g_key
 (cڡ Sass_Vue* 
v
, 
size_t
 
i
);

99 
ADDAPI
 
ADDCALL
 
ss_m_t_key
 (
Sass_Vue
* 
v
, 
size_t
 
i
, Sass_Value*);

100 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_m_g_vue
 (cڡ Sass_Vue* 
v
, 
size_t
 
i
);

101 
ADDAPI
 
ADDCALL
 
ss_m_t_vue
 (
Sass_Vue
* 
v
, 
size_t
 
i
, Sass_Value*);

104 
ADDAPI
 * 
ADDCALL
 
ss_r_g_mesge
 (cڡ 
Sass_Vue
* 
v
);

105 
ADDAPI
 
ADDCALL
 
ss_r_t_mesge
 (
Sass_Vue
* 
v
, * 
msg
);

108 
ADDAPI
 * 
ADDCALL
 
ss_wng_g_mesge
 (cڡ 
Sass_Vue
* 
v
);

109 
ADDAPI
 
ADDCALL
 
ss_wng_t_mesge
 (
Sass_Vue
* 
v
, * 
msg
);

112 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_nu
 ();

113 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_boޗn
 (
bo
 
v
);

114 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_rg
 (cڡ * 
v
);

115 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_qrg
 (cڡ * 
v
);

116 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_numb
 (
v
, cڡ * 
un
);

117 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_c
 (
r
, 
g
, 
b
, 
a
);

118 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_li
 (
size_t
 
n
, 
Sass_S
 
p
);

119 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_m
 (
size_t
 
n
);

120 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_r
 (cڡ * 
msg
);

121 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_make_wng
 (cڡ * 
msg
);

126 
ADDAPI
 
ADDCALL
 
ss_de_vue
 (
Sass_Vue
* 
v
);

129 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_e_vue
 (cڡ Sass_Vue* 
v
);

132 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_vue_rgify
 (cڡ Sass_Vue* 
a
, 
bo
 
comesd
, 
ecisi
);

135 
ADDAPI
 
Sass_Vue
* 
ADDCALL
 
ss_vue_
 (
Sass_OP
 

, cڡ Sass_Vue* 
a
, cڡ Sass_Vue* 
b
);

138 #ifde
__lulus


	@node_modules/node-sass/src/libsass/include/sass/version.h

1 #ide
SASS_VERSION_H


2 
	#SASS_VERSION_H


	)

4 #ide
LIBSASS_VERSION


5 
	#LIBSASS_VERSION
 "[NA]"

	)

8 #ide
LIBSASS_LANGUAGE_VERSION


9 
	#LIBSASS_LANGUAGE_VERSION
 "[NA]"

	)

	@node_modules/node-sass/src/libsass/include/sass2scss.h

7 #ide
SASS2SCSS_H


8 
	#SASS2SCSS_H


	)

10 #ifde
_WIN32


13 #ifde
ADD_EXPORTS


14 
	#ADDAPI
 
	`__deec
(
dexpt
)

	)

15 
	#ADDCALL
 
__cde


	)

17 
	#ADDAPI


	)

18 
	#ADDCALL


	)

24 
	#ADDAPI


	)

25 
	#ADDCALL


	)

29 #ifde
__lulus


31 
	~<ack
>

32 
	~<rg
>

33 
	~<crg
>

34 
	~<sam
>

35 
	~<ioam
>

37 #ide
SASS2SCSS_VERSION


40 
	#SASS2SCSS_VERSION
 "1.0.6"

	)

44 
mea
 
	gSass


48 cڡ 
	gSASS2SCSS_PRETTIFY_0
 = 0;

49 cڡ 
	gSASS2SCSS_PRETTIFY_1
 = 1;

50 cڡ 
	gSASS2SCSS_PRETTIFY_2
 = 2;

51 cڡ 
	gSASS2SCSS_PRETTIFY_3
 = 3;

54 cڡ 
	gSASS2SCSS_KEEP_COMMENT
 = 32;

56 cڡ 
	gSASS2SCSS_STRIP_COMMENT
 = 64;

58 cڡ 
	gSASS2SCSS_CONVERT_COMMENT
 = 128;

61 cڡ 
	gd
::
rg
 
SASS2SCSS_FIND_WHITESPACE
 = " \t\n\v\f\r";

65 
	scvr


68 
	gtis
;

70 
bo
 
	g
;

72 
bo
 
	gcomma
;

74 
bo
 
	gݔty
;

76 
bo
 
	gmic
;

78 
	gd
::
rg
 
commt
;

80 
bo
 
	gd_of_fe
;

82 
	gd
::
rg
 
whea
;

84 
	gd
::
ack
<
d
::
rg
> 
dts
;

88 * 
ss2scss
 (cڡ 
d
::
rg
& 
ss
, cڡ 
tis
);

98 
	#SASS2SCSS_PRETTIFY_0
 0

	)

99 
	#SASS2SCSS_PRETTIFY_1
 1

	)

100 
	#SASS2SCSS_PRETTIFY_2
 2

	)

101 
	#SASS2SCSS_PRETTIFY_3
 3

	)

104 
	#SASS2SCSS_KEEP_COMMENT
 32

	)

106 
	#SASS2SCSS_STRIP_COMMENT
 64

	)

108 
	#SASS2SCSS_CONVERT_COMMENT
 128

	)

111 
ADDAPI
 * 
ADDCALL
 
ss2scss
 (cڡ * 
ss
, cڡ 
tis
);

114 
ADDAPI
 cڡ * 
ADDCALL
 
ss2scss_vsi
();

116 #ifde
__lulus


	@node_modules/node-sass/src/libsass/src/ast.cpp

1 
	~"ss.h
"

2 
	~"a.h
"

3 
	~"cڋxt.h
"

4 
	~"node.h
"

5 
	~"exnd.h
"

6 
	~"emr.h
"

7 
	~"c_ms.h
"

8 
	~<t
>

9 
	~<iom
>

10 
	~<ioam
>

11 
	~<gܙhm
>

12 
	~<funiڮ
>

13 
	~<cy
>

14 
	~<lo
>

16 
mea
 
	gSass
 {

18 
Nu
 
ss_nu
(
Sass
::Nu(
PrS
("null")));

20 
bo
 
	gSuts_Ot
::
eds_ns
(
Suts_Cdi
* 
cd
) const {

21  
dymic_
<
Suts_Negi
*>(
cd
) ||

22 (
dymic_
<
Suts_Ot
*>(
cd
) &&

23 
dymic_
<
Suts_Ot
*>(
cd
)->
ݔd
() != operand());

26 
bo
 
	gSuts_Negi
::
eds_ns
(
Suts_Cdi
* 
cd
) const {

27  
dymic_
<
Suts_Negi
*>(
cd
) ||

28 
dymic_
<
Suts_Ot
*>(
cd
);

31 
	gd
::
rg
 & 
r_rim
(
d
::rg & 
r
)

33 aut
2
 = 
d
::
fd_if

r
.
beg
(, s.
d
(, [](
ch
){  !d::
isa
<>(ch , std::
lo
::
assic
() ) ; } );

34 
	gr
.
a

r
.
beg
(, 
2
);

35  
	gr
;

38 
	gd
::
rg
 & 
r_rim
(
d
::rg & 
r
)

40 aut
1
 = 
d
::
fd_if

r
.
rbeg
(, s.
nd
(, [](
ch
){  !d::
isa
<>(ch , std::
lo
::
assic
() ) ; } );

41 
	gr
.
a

1
.
ba
(, 
r
.
d
() );

42  
	gr
;

45 
	gSg_Cڡt
::
rim
()

47 
vue_
 = 
r_rim
(value_);

49 
	gSg_Cڡt
::
rim
()

51 
vue_
 = 
r_rim
(value_);

53 
	gSg_Cڡt
::
im
()

55 
rim
();

56 
rim
();

59 
	gSg_Schema
::
rim
()

61 i(!
emy
()) {

62 i(
Sg
* 
r
 = 
dymic_
<Sg*>(
ϡ
())r->
rim
();

65 
	gSg_Schema
::
rim
()

67 i(!
emy
()) {

68 i(
Sg
* 
r
 = 
dymic_
<Sg*>(
f
())r->
rim
();

71 
	gSg_Schema
::
im
()

73 
rim
();

74 
rim
();

77 
bo
 
	gAt_Ro_Quy
::
exude
(
d
::
rg
 
r
)

79 
bo
 
wh
 = 
u
(&& 
unque
(u()->
to_rg
()).
com
("with") == 0;

80 
Li
* 
	gl
 = 
ic_
<Li*>(
vue
());

81 
	gd
::
rg
 
v
;

83 i(
	gwh
)

85 i(!
	gl
 ||->
ngth
(=0 
r
.
com
("rule") != 0;

86 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i)

88 
	gv
 = 
unque
((*
l
)[
i
]->
to_rg
());

89 i(
	gv
.
com
("l"=0 || 
v
 =
r
 
l
;

91  
	gue
;

95 i(!
	gl
 || !l->
ngth
() 
	gr
.
com
("rule") == 0;

96 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i)

98 
	gv
 = 
unque
((*
l
)[
i
]->
to_rg
());

99 i(
	gv
.
com
("l"=0 || 
v
 =
r
 
ue
;

101  
	gl
;

105 
	gAST_Node
::
upde_pe
(cڡ 
PrS
& 
pe
)

107 
pe_
.
offt
 +
pe
 -state_ +state.offset;

110 
le
 
bo
 
is_ns_eq
(cڡ 
d
::
rg
& 
l
, cڡ std::rg& 
r
)

112 i(
l
.
emy
(&& 
r
.emy() 
ue
;

113 i(
	gl
.
emy
(&& 
	gr
 ="*" 
ue
;

114 i(
	gr
.
emy
(&& 
	gl
 ="*" 
ue
;

115  
	gl
 =
r
;

120 
bo
 
	gCompound_Se
::
ݔ
< (cڡ 
Compound_Se
& 
rhs
) const

122 
size_t
 
L
 = 
d
::
m
(
ngth
(), 
rhs
.length());

123 
size_t
 
	gi
 = 0; i < 
	gL
; ++i)

125 
Sime_Se
* 
	gl
 = (*
this
)[
i
];

126 
Sime_Se
* 
	gr
 = 
rhs
[
i
];

127 i(!
	gl
 && !
	gr
 
	gl
;

128 i(!
	gr
 
	gl
;

129 i(!
	gl
 
	gue
;

130 i(*
	gl
 !*
r
)

131 {  *
l
 < *
r
; }

134  
ngth
(< 
	grhs
.length();

137 
bo
 
	gCompound_Se
::
has__f
()

139 
Sime_Se
* 
s
 : *
this
) {

140 i(
s
 && s->
has__f
() 
ue
;

142  
	gl
;

145 
bo
 
	gComex_Se
::
has__f
()

147  (
hd
(&& hd()->
has__f
()) ||

148 (

(&&a()->
has__f
());

151 
bo
 
	gComex_Se
::
ݔ
< (cڡ 
Comex_Se
& 
rhs
) const

154 cڡ 
Comex_Se
* 
l
 = 
this
;

155 cڡ 
Comex_Se
* 
	gr
 = &
rhs
;

156 
Compound_Se
* 
	gl_h
 = 
l
 ?->
hd
() : 0;

157 
Compound_Se
* 
	gr_h
 = 
r
 ?->
hd
() : 0;

159 
	gue
)

162 i(
	gl
 &&->
is_emy_
())

164 
	gl
 = 
l
->

();

165 
	gl_h
 = 
l
 ?->
hd
() : 0;

169 i(
	gr
 &&->
is_emy_
())

171 
	gr
 = 
r
->

();

172 
	gr_h
 = 
r
 ?->
hd
() : 0;

176 i(!
	gl
 !!
	gr
;

177 i(!
	gr
 
	gl
;

179 i(!
	gl_h
 && !
	gr_h
)

182 i(
	gl
->
comb
(!
r
->combinator())

183 {  
l
->
comb
(< 
r
->combinator(); }

185 
	gl
 = 
l
->

();

186 
	gr
 = 
r
->

();

188 
	gl_h
 = 
l
 ?->
hd
() : 0;

189 
	gr_h
 = 
r
 ?->
hd
() : 0;

192 i(!
	gr_h
 
	gue
;

193 i(!
	gl_h
 
	gl
;

195 i(*
	gl_h
 =*
r_h
)

198 i(
l
->
comb
(!
r
->combinator())

199 {  
l
->
comb
(< 
r
->combinator(); }

201 
	gl
 = 
l
->

();

202 
	gr
 = 
r
->

();

204 
	gl_h
 = 
l
 ?->
hd
() : 0;

205 
	gr_h
 = 
r
 ?->
hd
() : 0;

208  *
	gl_h
 < *
	gr_h
;

210  
	gue
;

213 
bo
 
	gComex_Se
::
ݔ
=(cڡ 
Comex_Se
& 
rhs
) const

216 cڡ 
Comex_Se
* 
l
 = 
this
;

217 cڡ 
Comex_Se
* 
	gr
 = &
rhs
;

218 
Compound_Se
* 
	gl_h
 = 
l
 ?->
hd
() : 0;

219 
Compound_Se
* 
	gr_h
 = 
r
 ?->
hd
() : 0;

221 
	gue
)

224 i(
	gl
 &&->
is_emy_
())

226 
	gl
 = 
l
->

();

227 
	gl_h
 = 
l
 ?->
hd
() : 0;

231 i(
	gr
 &&->
is_emy_
())

233 
	gr
 = 
r
->

();

234 
	gr_h
 = 
r
 ?->
hd
() : 0;

238 i(!
	gr
 !
	gl
;

239 i(!
	gl
 !
	gr
;

241 i(!
	gl_h
 && !
	gr_h
)

244 i(
	gl
->
comb
(!
r
->combinator())

245 {  
l
->
comb
(< 
r
->combinator(); }

247 
	gl
 = 
l
->

();

248 
	gr
 = 
r
->

();

250 
	gl_h
 = 
l
 ?->
hd
() : 0;

251 
	gr_h
 = 
r
 ?->
hd
() : 0;

254 i(!
	gr_h
 !
	gl_h
;

255 i(!
	gl_h
 !
	gr_h
;

257 i(*
	gl_h
 =*
r_h
)

260 i(
l
->
comb
(!
r
->combinator())

261 {  
l
->
comb
(=
r
->combinator(); }

263 
	gl
 = 
l
->

();

264 
	gr
 = 
r
->

();

266 
	gl_h
 = 
l
 ?->
hd
() : 0;

267 
	gr_h
 = 
r
 ?->
hd
() : 0;

273  
	gl
;

276 
Compound_Se
* 
	gCompound_Se
::
unify_wh
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
)

278 
Compound_Se
* 
	gunifd
 = 
rhs
;

279 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

281 i(!
	gunifd
) ;

282 
	gunifd
 = (*
this
)[
i
]->
unify_wh
(
unifd
, 
x
);

284  
	gunifd
;

287 
bo
 
	gSime_Se
::
ݔ
=(cڡ 
Sime_Se
& 
rhs
) const

289 i(cڡ 
Pudo_Se
* 

 = 
dymic_
<cڡ Pudo_Se*>(
this
) * =
rhs
;

290 i(cڡ 
Wed_Se
* 
	glw
 = 
dymic_
<cڡ Wed_Se*>(
this
) *
lw
 =
rhs
;

291 i(cڡ 
Aribu_Se
* 
	g
 = 
dymic_
<cڡ Aribu_Se*>(
this
) *

 =
rhs
;

292 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

293 {  
me
(=
rhs
.name(); }

294  
ns
(=
rhs
.ns();

297 
bo
 
	gSime_Se
::
ݔ
< (cڡ 
Sime_Se
& 
rhs
) const

299 i(cڡ 
Pudo_Se
* 

 = 
dymic_
<cڡ Pudo_Se*>(
this
) * =
rhs
;

300 i(cڡ 
Wed_Se
* 
	glw
 = 
dymic_
<cڡ Wed_Se*>(
this
) *
lw
 < 
rhs
;

301 i(cڡ 
Aribu_Se
* 
	g
 = 
dymic_
<cڡ Aribu_Se*>(
this
) *

 < 
rhs
;

302 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

303 {  
me
(< 
	grhs
.name(); }

304  
ns
(< 
	grhs
.ns();

307 
bo
 
	gSe_Li
::
ݔ
=(cڡ 
Se
& 
rhs
) const

310 i(cڡ 
Se_Li
* 
ls
 = 
dymic_
<cڡ Se_Li*>(&
rhs
){  *
this
 == *ls; }

311 i(cڡ 
Comex_Se
* 
	gls
 = 
dymic_
<cڡ Comex_Se*>(&
rhs
){  *
this
 =*
ls
; }

312 i(cڡ 
Compound_Se
* 
	gls
 = 
dymic_
<cڡ Compound_Se*>(&
rhs
){  *
this
 =*
ls
; }

314  
	gthis
 =&
rhs
;

318 
bo
 
	gSe_Li
::
ݔ
==(cڡ 
Exessi
& 
rhs
) const

321 i(cڡ 
Li
* 
ls
 = 
dymic_
<cڡ Li*>(&
rhs
){  *
this
 == *ls; }

322 i(cڡ 
Se
* 
	gls
 = 
dymic_
<cڡ Se*>(&
rhs
){  *
this
 =*
ls
; }

324  
	gl
;

327 
bo
 
	gSe_Li
::
ݔ
=(cڡ 
Se_Li
& 
rhs
) const

330 
size_t
 
i
 = 0, 
	gn
 = 0;

331 
size_t
 
	giL
 = 
ngth
();

332 
size_t
 
	gnL
 = 
rhs
.
ngth
();

334 
	gd
::
ve
<
Comex_Se
*> 
l_l
 = 
this
->
emts
();

335 
	gd
::
ve
<
Comex_Se
*> 
r_l
 = 
rhs
.
emts
();

336 
	gd
::
st
(
l_l
.
beg
(),_l.
d
(), 
cmp_comex_
());

337 
	gd
::
st
(
r_l
.
beg
(),_l.
d
(), 
cmp_comex_
());

339 
	gue
)

342 i(
	gi
 =
iL
 iL =
nL
;

343 i(
	gn
 =
nL
 
iL
 ==L;

345 
Comex_Se
* 
	gl
 = 
l_l
[
i
];

346 
Comex_Se
* 
	gr
 = 
r_l
[
n
];

348 i(!
	gl
++
	gi
;

349 i(!
	gr
++
	gn
;

351 i(*
	gl
 !*
r
)

352 {  
l
; }

354 ++
	gi
; ++
	gn
;

357  
	gue
;

360 
Compound_Se
* 
	gSime_Se
::
unify_wh
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
)

362 
size_t
 
	gi
 = 0, 
	gL
 = 
rhs
->
ngth
(); i < L; ++i)

363 { i(
to_rg
(
x
.
c_tis
=(*
rhs
)[
i
]->to_string(ctx.c_options)) hs; }

366 
size_t
 
	gi
, 
	gL
;

367 
bo
 
	gfound
 = 
l
;

368 i(
tyid
(*
this
=tyid(
Pudo_Se
||yid(*this=tyid(
Wed_Se
))

370 
i
 = 0, 
	gL
 = 
rhs
->
ngth
(); 
	gi
 < L; ++i)

372 i((
	gdymic_
<
	gPudo_Se
*>((*
	grhs
)[
i
]|| dymic_<
	gWed_Se
*>((*rhs)[i])&& (*rhs)[
L
-1]->
is_pudo_emt
())

373 { 
	gfound
 = 
ue
; ; }

378 
	gi
 = 0, 
	gL
 = 
rhs
->
ngth
(); i < L; ++i)

380 i(
	gdymic_
<
	gPudo_Se
*>((*
	grhs
)[
i
]|| dymic_<
	gWed_Se
*>((*rhs)[i]))

381 { 
	gfound
 = 
ue
; ; }

384 i(!
	gfound
)

386 
Compound_Se
* 
	gy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, *
rhs
);

387 (*
	gy
<< 
	gthis
;

388  
	gy
;

390 
Compound_Se
* 
	gy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
rhs
->
pe
());

391 
size_t
 
	gj
 = 0; j < 
	gi
; ++j)

392 { (*
	gy
<< (*
	grhs
)[
j
]; }

393 (*
	gy
<< 
	gthis
;

394 
size_t
 
	gj
 = 
i
; j < 
	gL
; ++j)

395 { (*
	gy
<< (*
	grhs
)[
j
]; }

396  
	gy
;

399 
Sime_Se
* 
	gTy_Se
::
unify_wh
(Sime_Se* 
rhs
, 
Cڋxt
& 
x
)

403 i(
has_univl_ns
())

407 i(!
	grhs
->
is_univl_ns
())

410 
Ty_Se
* 
	gts
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Ty_Se, *
this
);

412 i(
	gts
->
me
(="*"{ 
ts
->me(
rhs
->name()); }

414 
	gts
->
ns
(
rhs
->ns());s->
has_ns
(rhs->has_ns());

416  
	gts
;

421 i(
me
(="*" && 
rhs
->name() != "*")

424 
Ty_Se
* 
ts
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Ty_Se, *
this
);

426 
	gts
->
me
(
rhs
->name());

428  
	gts
;

431  
	gthis
;

434 
Compound_Se
* 
	gTy_Se
::
unify_wh
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
)

439 i(
	grhs
->
ngth
() == 0) {

440 
Compound_Se
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
rhs
->
pe
());

441 (*
	gy
<< 
	gthis
;

442  
	gy
;

445 
Sime_Se
* 
	grhs_0
 = (*
rhs
)[0];

447 i(
me
() == "*")

449 i(
tyid
(*
rhs_0
=tyid(
Ty_Se
))

452 
Compound_Se
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, *
rhs
);

453 
Ty_Se
* 
	gts
 = 
ic_
<Ty_Se*>(
rhs_0
);

454 (*
	gy
)[0] = 
this
->
unify_wh
(
ts
, 
x
);

455  
	gy
;

457 i(
	gdymic_
<
	gSe_Quifr
*>(
	grhs_0
)) {

459 
Compound_Se
* 
	gy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
rhs
->
pe
());

460 i(
has_ns
(&& !
	grhs_0
->has_ns()) {

461 i(
ns
(!"*"(*
y
<< 
this
;

463 
size_t
 
	gi
 = 0, 
	gL
 = 
rhs
->
ngth
(); i < L; ++i)

464 { (*
	gy
<< (*
	grhs
)[
i
]; }

465  
	gy
;

469  
	grhs
;

472 i(
tyid
(*
rhs_0
=tyid(
Ty_Se
))

475 i(
rhs_0
->
me
(!"*" &&hs_0->
ns
() != "*" &&hs_0->name() !=ame())  0;

477 
Compound_Se
* 
	gcy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, *
rhs
);

478 (*
	gcy
)[0] = 
this
->
unify_wh
(
rhs_0
, 
x
);

479  
	gcy
;

483 
Compound_Se
* 
	gy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
rhs
->
pe
());

484 i(
me
(!"*"(*
y
<< 
this
;

485 (*
	gy
+
rhs
;

486  
	gy
;

489 
Compound_Se
* 
	gSe_Quifr
::
unify_wh
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
)

491 i(
me
()[0] == '#')

493 
size_t
 
i
 = 0, 
	gL
 = 
rhs
->
ngth
(); 
	gi
 < L; ++i)

495 
Sime_Se
* 
	grhs_i
 = (*
rhs
)[
i
];

496 i(
tyid
(*
rhs_i
=tyid(
Se_Quifr
) &&

497 
ic_
<
Se_Quifr
*>(
rhs_i
)->
me
()[0] == '#' &&

498 
ic_
<
Se_Quifr
*>(
rhs_i
)->
me
() !=ame())

502 
	grhs
->
has_le_bak
(has_line_break());

503  
	gSime_Se
::
unify_wh
(
rhs
, 
x
);

506 
Compound_Se
* 
	gPudo_Se
::
unify_wh
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
)

508 i(
is_pudo_emt
())

510 
size_t
 
	gi
 = 0, 
	gL
 = 
rhs
->
ngth
(); i < L; ++i)

512 
Sime_Se
* 
	grhs_i
 = (*
rhs
)[
i
];

513 i(
tyid
(*
rhs_i
=tyid(
Pudo_Se
) &&

514 
ic_
<
Pudo_Se
*>(
rhs_i
)->
is_pudo_emt
() &&

515 
ic_
<
Pudo_Se
*>(
rhs_i
)->
me
() !=ame())

519  
	gSime_Se
::
unify_wh
(
rhs
, 
x
);

522 
bo
 
	gAribu_Se
::
ݔ
< (cڡ 
Aribu_Se
& 
rhs
) const

524 i(
is_ns_eq
(
ns
(), 
rhs
.ns())) {

525 i(
me
(=
rhs
.name()) {

526 i(
mch
(=
rhs
.matcher()) {

527  
vue
(< 
rhs
.value();

528 } {  
mch
(< 
	grhs
.matcher(); }

529 } {  
me
(< 
	grhs
.name(); }

531  
	gl
;

534 
bo
 
	gAribu_Se
::
ݔ
< (cڡ 
Sime_Se
& 
rhs
) const

536 i(cڡ 
Aribu_Se
* 
w
 = 
dymic_
<cڡ Aribu_Se*>(&
rhs
))

538  *
this
 < *
w
;

540 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

541 {  
me
(< 
	grhs
.name(); }

542  
ns
(< 
	grhs
.ns();

545 
bo
 
	gAribu_Se
::
ݔ
=(cڡ 
Aribu_Se
& 
rhs
) const

547 i(
is_ns_eq
(
ns
(), 
rhs
.ns()&& 
me
() ==hs.name())

548 {  
mch
(=
rhs
.mch(&& 
vue
() ==hs.value(); }

549  
	gl
;

552 
bo
 
	gAribu_Se
::
ݔ
=(cڡ 
Sime_Se
& 
rhs
) const

554 i(cڡ 
Aribu_Se
* 
w
 = 
dymic_
<cڡ Aribu_Se*>(&
rhs
))

556  *
this
 =*
w
;

558 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

559 {  
me
(=
rhs
.name(); }

560  
ns
(=
rhs
.ns();

563 
bo
 
	gPudo_Se
::
ݔ
=(cڡ 
Pudo_Se
& 
rhs
) const

565 i(
is_ns_eq
(
ns
(), 
rhs
.ns()&& 
me
() ==hs.name())

567 
Exessi
* 
lhs_ex
 = 
exessi
();

568 
Exessi
* 
	grhs_ex
 = 
rhs
.
exessi
();

569 i(
	grhs_ex
 && 
	glhs_ex
 *lhs_ex =*
rhs_ex
;

570  
	glhs_ex
 =
rhs_ex
;

572  
	gl
;

575 
bo
 
	gPudo_Se
::
ݔ
=(cڡ 
Sime_Se
& 
rhs
) const

577 i(cڡ 
Pudo_Se
* 
w
 = 
dymic_
<cڡ Pudo_Se*>(&
rhs
))

579  *
this
 =*
w
;

581 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

582 {  
me
(=
rhs
.name(); }

583  
ns
(=
rhs
.ns();

586 
bo
 
	gPudo_Se
::
ݔ
< (cڡ 
Pudo_Se
& 
rhs
) const

588 i(
is_ns_eq
(
ns
(), 
rhs
.ns()&& 
me
() ==hs.name())

589 {  *(
exessi
()< *(
rhs
.expression()); }

590 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

591 {  
me
(< 
	grhs
.name(); }

592  
ns
(< 
	grhs
.ns();

595 
bo
 
	gPudo_Se
::
ݔ
< (cڡ 
Sime_Se
& 
rhs
) const

597 i(cڡ 
Pudo_Se
* 
w
 = 
dymic_
<cڡ Pudo_Se*>(&
rhs
))

599  *
this
 < *
w
;

601 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

602 {  
me
(< 
	grhs
.name(); }

603  
ns
(< 
	grhs
.ns();

606 
bo
 
	gWed_Se
::
ݔ
=(cڡ 
Wed_Se
& 
rhs
) const

608 i(
is_ns_eq
(
ns
(), 
rhs
.ns()&& 
me
() ==hs.name())

609 {  *(

()=*(
rhs
.selector()); }

610  
	gl
;

613 
bo
 
	gWed_Se
::
ݔ
=(cڡ 
Sime_Se
& 
rhs
) const

615 i(cڡ 
Wed_Se
* 
w
 = 
dymic_
<cڡ Wed_Se*>(&
rhs
))

617  *
this
 =*
w
;

619 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

620 {  
me
(=
rhs
.name(); }

621  
ns
(=
rhs
.ns();

624 
bo
 
	gWed_Se
::
ݔ
< (cڡ 
Wed_Se
& 
rhs
) const

626 i(
is_ns_eq
(
ns
(), 
rhs
.ns()&& 
me
() ==hs.name())

627 {  *(

()< *(
rhs
.selector()); }

628 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

629 {  
me
(< 
	grhs
.name(); }

630  
ns
(< 
	grhs
.ns();

633 
bo
 
	gWed_Se
::
ݔ
< (cڡ 
Sime_Se
& 
rhs
) const

635 i(cڡ 
Wed_Se
* 
w
 = 
dymic_
<cڡ Wed_Se*>(&
rhs
))

637  *
this
 < *
w
;

639 i(
is_ns_eq
(
ns
(), 
rhs
.ns()))

640 {  
me
(< 
	grhs
.name(); }

641  
ns
(< 
	grhs
.ns();

644 
bo
 
	gWed_Se
::
is_sur_of
(
Wed_Se
* 
sub
)

646 i(
this
->
me
(!
sub
->me() 
l
;

647 i(
	gthis
->
me
(=":cut" 
l
;

648 i(
Se_Li
* 
	grhs_li
 = 
dymic_
<Se_Li*>(
sub
->

())) {

649 i(
Se_Li
* 
lhs_li
 = 
dymic_
<Se_Li*>(

())) {

650  
lhs_li
->
is_sur_of
(
rhs_li
);

652 
r
("is_sur܃xed Se_Li", 
sub
->
pe
());

654 
r
("is_sur܃xed Se_Li", 
sub
->
pe
());

656  
	gl
;

659 
bo
 
	gCompound_Se
::
is_sur_of
(
Se_Li
* 
rhs
, 
d
::
rg
 
wed
)

661 
Comex_Se
* 
em
 : 
rhs
->
emts
()) {

662 i(
is_sur_of
(
em
, 
wed
) 
	gue
;

664  
	gl
;

667 
bo
 
	gCompound_Se
::
is_sur_of
(
Comex_Se
* 
rhs
, 
d
::
rg
 
wed
)

669 i(
rhs
->
hd
() 
is_sur_of
hs->hd(), 
wed
);

670  
	gl
;

673 
bo
 
	gCompound_Se
::
is_sur_of
(
Compound_Se
* 
rhs
, 
d
::
rg
 
wg
)

675 
Compound_Se
* 
lhs
 = 
this
;

676 
Sime_Se
* 
	glba
 = 
lhs
->
ba
();

677 
Sime_Se
* 
	grba
 = 
rhs
->
ba
();

681 
	gd
::
t
<
d
::
rg
> 
suedot
, 
	gsuedot
;

682 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

684 i((*
	gthis
)[
i
]->
is_pudo_emt
()) {

685 
	gd
::
rg
 
pudo
((*
this
)[
i
]->
to_rg
());

686 
	gpudo
 = 
pudo
.
subr
գudo.
fd_f_n_of
(":"));

687 
	gsuedot
.

(
pudo
);

690 
size_t
 
	gi
 = 0, 
	gL
 = 
rhs
->
ngth
(); i < L; ++i)

692 i((*
	grhs
)[
i
]->
is_pudo_emt
()) {

693 
	gd
::
rg
 
pudo
((*
rhs
)[
i
]->
to_rg
());

694 
	gpudo
 = 
pudo
.
subr
գudo.
fd_f_n_of
(":"));

695 
	gsuedot
.

(
pudo
);

698 i(
	gsuedot
 !
suedot
) {

699  
l
;

702 
	gd
::
t
<
d
::
rg
> 
lt
, 
	grt
;

704 i(
	glba
 && 
	grba
)

706 i(
	glba
->
to_rg
(=
rba
->to_string()) {

707 
size_t
 
i
 = 1, 
	gL
 = 
ngth
(); 
	gi
 < L; ++i)

708 { 
	glt
.

((*
this
)[
i
]->
to_rg
()); }

709 
size_t
 
	gi
 = 1, 
	gL
 = 
rhs
->
ngth
(); i < L; ++i)

710 { 
	grt
.

((*
rhs
)[
i
]->
to_rg
()); }

711  
udes
(
rt
.
beg
(),t.
d
(), 
lt
.begin(),set.end());

713  
	gl
;

716 
size_t
 
	gi
 = 0, 
	giL
 = 
ngth
(); i < iL; ++i)

718 
Se
* 
	glhs
 = (*
this
)[
i
];

720 i(
Wed_Se
* 
	gwed
 = 
dymic_
<Wed_Se*>(
lhs
)) {

721 i(
wed
->
me
() == ":not") {

722 i(
Se_Li
* 
n_li
 = 
dymic_
<Se_Li*>(
wed
->

())) {

723 i(
n_li
->
is_sur_of
(
rhs
, 
wed
->
me
()) 
l
;

725 
throw
 
	gd
::
ruime_r
("wrappedot selector isotist");

728 i(
	gwed
->
me
(=":mches" || 
wed
->name() == ":-moz-any") {

729 
lhs
 = 
wed
->

();

730 i(
Se_Li
* 
	gli
 = 
dymic_
<Se_Li*>(
wed
->

())) {

731 i(
Compound_Se
* 
comp
 = 
dymic_
<Compound_Se*>(
rhs
)) {

732 i(!
wg
.
emy
(&& wg !
wed
->
me
() 
l
;

733 i(
	gwg
.
emy
(|| wg !
wed
->
me
()) {;

734 i(
	gli
->
is_sur_of
(
comp
, 
wed
->
me
()) 
	gue
;

739 
Sime_Se
* 
	grhs_l
 = 
rhs
->
emts
().
size
(> 
i
 ? (*rhs)[i] : 0;

740 i(
Wed_Se
* 
	gwed_r
 = 
dymic_
<Wed_Se*>(
rhs_l
)) {

741 i(
wed
->
me
(=
wed_r
->name()) {

742 i(
wed
->
is_sur_of
(
wed_r
)) {

744 
	grt
.

(
lhs
->
to_rg
());

750 
	glt
.

(
lhs
->
to_rg
());

753 
size_t
 
	gn
 = 0, 
	gnL
 = 
rhs
->
ngth
(); <L; ++n)

755 aut
	gr
 = (*
rhs
)[
n
];

756 i(
Wed_Se
* 
	gwed
 = 
dymic_
<Wed_Se*>(
r
)) {

757 i(
wed
->
me
() == ":not") {

758 i(
Se_Li
* 
ls
 = 
dymic_
<Se_Li*>(
wed
->

())) {

759 
ls
->
move__s
();

760 i(
is_sur_of
(
ls
, 
wed
->
me
()) 
	gl
;

763 i(
	gwed
->
me
(=":mches" || 
wed
->name() == ":-moz-any") {

764 i(!
wg
.
emy
()) {

765 i(
wg
 !
wed
->
me
() 
l
;

767 i(
Se_Li
* 
	gls
 = 
dymic_
<Se_Li*>(
wed
->

())) {

768 
ls
->
move__s
();

769  (
is_sur_of
(
ls
, 
wed
->
me
()));

773 
	grt
.

(
r
->
to_rg
());

779 i(
	glt
.
emy
() 
	gue
;

781  
udes
(
rt
.
beg
(),t.
d
(), 
lt
.begin(),set.end());

786 
Comex_Se
* 
	gCompound_Se
::
to_comex
(
Memy_Mag
& 
mem
)

789  
SASS_MEMORY_NEW
(
mem
, 
Comex_Se
,

790 
pe
(),

791 
Comex_Se
::
ANCESTOR_OF
,

792 
this
,

796 
Se_Li
* 
	gComex_Se
::
unify_wh
(
Comex_Se
* 
h
, 
Cڋxt
& 
x
)

800 
Comex_Se
* 
	gl_ϡ
 = 
this
->
ϡ
();

801 
Comex_Se
* 
	gr_ϡ
 = 
h
->
ϡ
();

804 
SASS_ASSERT
(
l_ϡ
, "lhs isull");

805 
SASS_ASSERT
(
r_ϡ
, "rhs isull");

810 i(
	gl_ϡ
->
comb
(!
Comb
::
ANCESTOR_OF
)  0;

811 i(
	gr_ϡ
->
comb
(!
Comb
::
ANCESTOR_OF
 )  0;

814 
Compound_Se
* 
	gl_ϡ_hd
 = 
l_ϡ
->
hd
();

815 
Compound_Se
* 
	gr_ϡ_hd
 = 
r_ϡ
->
hd
();

818 
SASS_ASSERT
(
l_ϡ_hd
, "lhs head isull");

819 
SASS_ASSERT
(
r_ϡ_hd
, "rhs head isull");

822 
Compound_Se
* 
	gunifd
 = 
r_ϡ_hd
->
unify_wh
(
l_ϡ_hd
, 
x
);

825 i(
	gunifd
 == 0)  0;

828 
bo
 
	gis_univl
 = 
l_ϡ_hd
->
is_univl
() ||

829 
r_ϡ_hd
->
is_univl
();

831 i(
	gis_univl
)

834 
	gl_ϡ
->
hd
(0);

835 
	gr_ϡ
->
hd
(
unifd
);

839 
Node
 
	glhsNode
 = 
comexSeToNode
(
this
, 
x
);

840 
Node
 
	grhsNode
 = 
comexSeToNode
(
h
, 
x
);

843 i(!
	gis_univl
)

846 
Comex_Se
* 
	gke
 = 
unifd
->
to_comex
(
x
.
mem
);

847 
Node
 
	gunifd_node
 = 
comexSeToNode
(
ke
, 
x
);

849 
	grhsNode
.
us
(
unifd_node
);

853 
Node
 
	gnode
 = 
Exnd
::
subwve
(
lhsNode
, 
rhsNode
, 
x
);

854 
Se_Li
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pe
());

855 
NodeDequeP
 
	gc
 = 
node
.
ci
();

856 
	gNodeDeque
::

 

 = 
c
->
beg
(), 
	gd
 = c->
d
(); 
	g
 !=nd; it++)

857 { (*
	gsu
<< 
nodeToComexSe
(
Node
::
iveTrim
(*

, 
x
), ctx); }

860  
	gsu
->
ngth
() ?esult : 0;

864 
bo
 
	gCompound_Se
::
ݔ
=(cڡ 
Compound_Se
& 
rhs
) const

867 
size_t
 
i
 = 0, 
	gn
 = 0;

868 
size_t
 
	giL
 = 
ngth
();

869 
size_t
 
	gnL
 = 
rhs
.
ngth
();

871 
	gd
::
ve
<
Sime_Se
*> 
l_l
 = 
this
->
emts
();

872 
	gd
::
ve
<
Sime_Se
*> 
r_l
 = 
rhs
.
emts
();

873 
	gd
::
st
(
l_l
.
beg
(),_l.
d
(), 
cmp_sime_
());

874 
	gd
::
st
(
r_l
.
beg
(),_l.
d
(), 
cmp_sime_
());

876 
	gue
)

879 i(
	gi
 =
iL
 iL =
nL
;

880 i(
	gn
 =
nL
 
iL
 ==L;

882 
Sime_Se
* 
	gl
 = 
l_l
[
i
];

883 
Sime_Se
* 
	gr
 = 
r_l
[
n
];

885 i(!
	gl
++
	gi
;

886 i(!
	gr
++
	gn
;

888 i(*
	gl
 !*
r
)

889 {  
l
; }

891 ++
	gi
; ++
	gn
;

894  
	gue
;

897 
bo
 
	gComex_Se_Por_Com
::
ݔ
((cڡ 
Comex_Se
* cڡ 
pLe
, cڡ Comex_Se* cڡ 
	gpRight
) const {

898  *
	gpLe
 < *
	gpRight
;

901 
bo
 
	gComex_Se
::
is_sur_of
(
Compound_Se
* 
rhs
, 
d
::
rg
 
wg
)

903  
ϡ
()->
hd
(&&a()->hd()->
is_sur_of
(
rhs
, 
wg
);

906 
bo
 
	gComex_Se
::
is_sur_of
(
Comex_Se
* 
rhs
, 
d
::
rg
 
wg
)

908 
Comex_Se
* 
lhs
 = 
this
;

910 i(!
	glhs
->
hd
(|| !
	grhs
->head())

911 {  
	gl
; }

912 cڡ 
Comex_Se
* 
	gl_rmo
 = 
lhs
->
rmo
();

913 i(
	gl_rmo
->
comb
(!
Comex_Se
::
ANCESTOR_OF
)

914 {  
l
; }

915 cڡ 
Comex_Se
* 
	gr_rmo
 = 
rhs
->
rmo
();

916 i(
	gr_rmo
->
comb
(!
Comex_Se
::
ANCESTOR_OF
)

917 {  
l
; }

919 
size_t
 
	gl_n
 = 
lhs
->
ngth
(), 
	gr_n
 = 
rhs
->length();

920 i(
	gl_n
 > 
	gr_n
)

921 {  
	gl
; }

923 i(
	gl_n
 == 1)

924 {  
lhs
->
hd
()->
is_sur_of
(
rhs
->
ϡ
()->hd(), 
wg
); }

928 i(
	grhs
->

(&& 
	glhs
->(&& 
comb
(!
Comex_Se
::
ANCESTOR_OF
) {

929 
Comex_Se
* 
lhs_
 = 
lhs
->

();

930 
Comex_Se
* 
	grhs_
 = 
rhs
->

();

931 i(
	glhs_
->
comb
(!
rhs_
->comb() 
l
;

932 i(
	glhs_
->
hd
(&& !
	grhs_
->hd() 
	gl
;

933 i(!
	glhs_
->
hd
(&& 
	grhs_
->hd() 
	gl
;

934 i(
	glhs_
->
hd
(&& 
	grhs_
->head()) {

935 i(!
	glhs_
->
hd
()->
is_sur_of
(
rhs_
->hd()) 
	gl
;

939 
bo
 
	gfound
 = 
l
;

940 
Comex_Se
* 
	gmk
 = 
rhs
;

941 
size_t
 
	gi
 = 0, 
	gL
 = 
rhs
->
ngth
(); i < L; ++i) {

942 i(
	gi
 =
L
-1)

943 {  
l
; }

944 i(
	glhs
->
hd
(&& 
	gmk
->hd(&&hs->hd()->
is_sur_of
(
mk
->hd(), 
wg
))

945 { 
	gfound
 = 
ue
; ; }

946 
	gmk
 = 
mk
->

();

948 i(!
	gfound
)

949 {  
	gl
; }

964 i(
	glhs
->
comb
(!
Comex_Se
::
ANCESTOR_OF
)

966 i(
mk
->
comb
(=
Comex_Se
::
ANCESTOR_OF
)

967 {  
l
; }

968 i(!(
	glhs
->
comb
(=
Comex_Se
::
PRECEDES
 ? 
mk
->comb(!Comex_Se::
PARENT_OF
 : 
lhs
->combinator() == marker->combinator()))

969 {  
l
; }

970  
	glhs
->

()->
is_sur_of
(
mk
->tail());

972 i(
	gmk
->
comb
(!
Comex_Se
::
ANCESTOR_OF
)

974 i(
mk
->
comb
(!
Comex_Se
::
PARENT_OF
)

975 {  
l
; }

976  
	glhs
->

()->
is_sur_of
(
mk
->tail());

980  
	glhs
->

()->
is_sur_of
(
mk
->tail());

983  
	gl
;

986 
size_t
 
	gComex_Se
::
ngth
() const

989 i(!

())  1;

990  1 + 

()->
ngth
();

993 
Comex_Se
* 
	gComex_Se
::
cڋxt
(
Cڋxt
& 
x
)

995 i(!

())  0;

996 i(!
hd
() 

()->
cڋxt
(
x
);

997 
Comex_Se
* 
	gy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, 
pe
(), 
comb
(), 
hd
(), 

()->
cڋxt
(ctx));

998 
	gy
->
med_block
(media_block());

999  
	gy
;

1006 
	gComex_Se
::
nd
(
Cڋxt
& 
x
, 
Comex_Se
* 
ss
)

1009 
Comex_Se
* 
	gt
 = 
ss
->

();

1010 
Comb
 
	gc
 = 
ss
->
comb
();

1011 
Sg
* 
	gr
 = 
ss
->
n
();

1012 
Compound_Se
* 
	gh
 = 
ss
->
hd
();

1014 i(
	gss
->
has_le_ed
()has_le_ed(
ue
);

1015 i(
	gss
->
has_le_bak
()has_le_bak(
ue
);

1018 i(
	gh
 && h->
ngth
()) {

1019 i(
ϡ
()->
comb
(!
ANCESTOR_OF
 && 
c
 != ANCESTOR_OF) {

1020 
r
("Invid", 
pe_
);

1021 } i(
ϡ
()->
	ghd_
 &&a()->hd_->
ngth
()) {

1022 
Compound_Se
* 
	grh
 = 
ϡ
()->
hd
();

1023 
size_t
 
	gi
 = 0, 
	gL
 = 
h
->
ngth
();

1024 i(
	gdymic_
<
	gTy_Se
*>(
	gh
->
f
())) {

1025 i(
Se_Quifr
* 
	gsq
 = 
dymic_
<Se_Quifr*>(
rh
->
ϡ
())) {

1026 
Se_Quifr
* 
sqs
 = 
w
 Se_Quifr(*
sq
);

1027 
	gsqs
->
me
(
sqs
->me(+ (*
h
)[0]->name());

1028 (*
	grh
)[
rh
->
ngth
()-1] = 
sqs
;

1029 
	gi
 = 1; i < 
	gL
; ++i*
	grh
 << (*
	gh
)[
i
];

1030 } i(
Ty_Se
* 
	gts
 = 
dymic_
<Ty_Se*>(
rh
->
ϡ
())) {

1031 
Ty_Se
* 
tss
 = 
w
 Ty_Se(*
ts
);

1032 
	gtss
->
me
(
tss
->me(+ (*
h
)[0]->name());

1033 (*
	grh
)[
rh
->
ngth
()-1] = 
tss
;

1034 
	gi
 = 1; i < 
	gL
; ++i*
	grh
 << (*
	gh
)[
i
];

1035 } i(
Se_Phd
* 
	gps
 = 
dymic_
<Se_Phd*>(
rh
->
ϡ
())) {

1036 
Se_Phd
* 
pss
 = 
w
 Se_Phd(*
ps
);

1037 
	gpss
->
me
(
pss
->me(+ (*
h
)[0]->name());

1038 (*
	grh
)[
rh
->
ngth
()-1] = 
pss
;

1039 
	gi
 = 1; i < 
	gL
; ++i*
	grh
 << (*
	gh
)[
i
];

1041 *
ϡ
()->
	ghd_
 +
h
;

1044 *
ϡ
()->
	ghd_
 +
h
;

1047 *
ϡ
()->
	ghd_
 +
h
;

1053 i(
ϡ
()) {

1054 i(
ϡ
()->
comb
(!
ANCESTOR_OF
 && 
c
 != ANCESTOR_OF) {

1055 
Comex_Se
* 
r
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, 
pe
());

1056 
	gr
->
n
(
r
);

1057 
	gr
->
comb
(
c
);

1058 
	gr
->

(
t
);

1059 
ϡ
()->

(
r
);

1061 i(
ϡ
()->
comb
(=
ANCESTOR_OF
) {

1062 
ϡ
()->
comb
(
c
);

1063 
ϡ
()->
n
(
r
);

1065 
ϡ
()->

(
t
);

1072 
Se_Li
* 
	gSe_Li
::
ize
(Se_Li* 
ps
, 
Cڋxt
& 
x
)

1074 i(!
	gthis
->
has__f
()) his;

1075 
Se_Li
* 
	gss
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pe
());

1076 
size_t
 
	gpi
 = 0, 
	gpL
 = 
ps
->
ngth
();i <L; ++pi) {

1077 
Se_Li
* 
	gli
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pe
());

1078 *
	gli
 << (*
	gps
)[
pi
];

1079 
size_t
 
	gsi
 = 0, 
	gsL
 = 
this
->
ngth
(); si < sL; ++si) {

1080 *
	gss
 +(*
this
)[
si
]->
ize
(
li
, 
x
);

1083  
	gss
;

1086 
Se_Li
* 
	gComex_Se
::
ize
(Se_Li* 
s
, 
Cڋxt
& 
x
)

1089 
Comex_Se
* 
	g
 = 
this
->

();

1090 
Compound_Se
* 
	ghd
 = 
this
->
hd
();

1093 
Se_Li
* 
	gs
 = 

 ?a->
ize
(
s
, 
x
) : 0;

1095 i(
	ghd
 && hd->
ngth
() > 0) {

1097 
Se_Li
* 
	gtv
 = 0;

1100 i(
	gdymic_
<
	gPt_Se
*>((*
	ghd
)[0])) {

1101 
	gtv
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Se_Li
, 
pe
());

1102 i(
	gs
 &&ts->
ngth
()) {

1103 i(
	gs
 &&as->
ngth
() > 0) {

1104 
size_t
 
	gn
 = 0, 
	gnL
 = 
s
->
ngth
(); <L; ++n) {

1105 
size_t
 
	gi
 = 0, 
	giL
 = 
s
->
ngth
(); i < iL; ++i) {

1106 
Comex_Se
* 
	gt
 = (*
s
)[
n
];

1107 
Comex_Se
* 
	g
 = (*
s
)[
i
];

1108 
Comex_Se
* 
	gs
 = 

->
eFuy
(
x
);

1109 
Comex_Se
* 
	gss
 = 
this
->
e
(
x
);

1110 
	gss
->

(
t
 ?->
e
(
x
) : 0);

1111 
Compound_Se
* 
	gh
 = 
hd_
->
e
(
x
);

1112 i(
	gh
->
ngth
()h->
a
(
h
->
beg
());

1113 
	gss
->
hd
(
h
->
ngth
() ? h : 0);

1114 
	gs
->
nd
(
x
, 
ss
);

1115 *
	gtv
 << 
	gs
;

1122 
size_t
 
	gi
 = 0, 
	giL
 = 
s
->
ngth
(); i < iL; ++i) {

1123 
Comex_Se
* 
	g
 = (*
s
)[
i
];

1124 
Comex_Se
* 
	gs
 = 

->
eFuy
(
x
);

1125 
Comex_Se
* 
	gss
 = 
this
->
e
(
x
);

1128 i(
	g
->
ϡ
()->
comb
(!
ANCESTOR_OF
) {

1129 
throw
 
Exi
::
InvidPt
(

, 
ss
);

1131 
	gss
->

a ?a->
e
(
x
) : 0);

1132 
Compound_Se
* 
	gh
 = 
hd_
->
e
(
x
);

1133 i(
	gh
->
ngth
()h->
a
(
h
->
beg
());

1134 
	gss
->
hd
(
h
->
ngth
() ? h : 0);

1136 
	gss
->
has_le_ed
(
l
);

1137 
	gs
->
nd
(
x
, 
ss
);

1138 *
	gtv
 << 
	gs
;

1144 i(
	gs
 &&as->
ngth
() > 0) {

1145 
size_t
 
	gn
 = 0, 
	gnL
 = 
s
->
ngth
(); <L; ++n) {

1146 
Comex_Se
* 
	gy
 = 
this
->
e
(
x
);

1147 
	gy
->

((*
s
)[
n
]->
eFuy
(
x
));

1148 
	gy
->
hd
(
SASS_MEMORY_NEW
(
x
.
mem
, 
Compound_Se
, hd->
pe
()));

1149 
size_t
 
	gi
 = 1, 
	gL
 = 
this
->
hd
()->
ngth
(); i < L; ++i)

1150 *
	gy
->
hd
(<< (*
	gthis
->hd())[
i
];

1151 i(!
	gy
->
hd
()->
ngth
()) cpy->head(0);

1152 *
	gtv
 << 
	gy
->
sk_emy_n
();

1157 
Comex_Se
* 
	gy
 = 
this
->
e
(
x
);

1158 
	gy
->
hd
(
SASS_MEMORY_NEW
(
x
.
mem
, 
Compound_Se
, hd->
pe
()));

1159 
size_t
 
	gi
 = 1, 
	gL
 = 
this
->
hd
()->
ngth
(); i < L; ++i)

1160 *
	gy
->
hd
(<< (*
	gthis
->hd())[
i
];

1161 i(!
	gy
->
hd
()->
ngth
()) cpy->head(0);

1162 *
	gtv
 << 
	gy
->
sk_emy_n
();

1168 
	gtv
 = 
this
->
s
(
x
,ails);

1171 
Sime_Se
* 
	gss
 : *
hd
) {

1172 i(
Wed_Se
* 
ws
 = 
dymic_
<Wed_Se*>(
ss
)) {

1173 i(
Se_Li
* 

 = 
dymic_
<Se_Li*>(
ws
->

())) {

1174 i(
s

ws
->

(

->
ize
լts, 
x
));

1179  
	gtv
;

1184  
	gthis
->
s
(
x
,ails);

1191 
Se_Li
* 
	gComex_Se
::
s
(
Cڋxt
& 
x
, Selector_List*ails)

1193 
Se_Li
* 
	grv
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pe_
);

1194 i(
	gs
 &&as->
ngth
()) {

1195 
size_t
 
	gi
 = 0, 
	giL
 = 
s
->
ngth
(); i < iL; ++i) {

1196 
Comex_Se
* 
	g
 = 
this
->
e
(
x
);

1197 
	g
->

((*
s
)[
i
]);

1198 *
	grv
 << 
	g
;

1202 *
	grv
 << 
	gthis
;

1204  
	grv
;

1208 
Comex_Se
* 
	gComex_Se
::
f
()

1211 
Comex_Se
* 
cur
 = 
this
;

1212 cڡ 
Compound_Se
* 
	ghd
;

1214 
	gcur
)

1217 
	ghd
 = 
cur
->
hd_
;

1219 i(!
	ghd
 || hd->
ngth
(!1 || !
dymic_
<
Pt_Se
*>((*
hd
)[0])) {

1223 
	gcur
 = 
cur
->
_
;

1226  
	gcur
;

1230 cڡ 
Comex_Se
* 
	gComex_Se
::
f
() const

1233 cڡ 
Comex_Se
* 
cur
 = 
this
->
_
;

1234 cڡ 
Compound_Se
* 
	ghd
 = 
hd_
;

1236 
	gcur
)

1239 
	ghd
 = 
cur
->
hd_
;

1241 i(
	ghd
 && hd->
ngth
() == 1)

1244 i(!
dymic_
<
Pt_Se
*>((*
hd
)[0])) ;

1247 
	gcur
 = 
cur
->
_
;

1250  
	gcur
;

1254 
Comex_Se
* 
	gComex_Se
::
ϡ
()

1257  
_
?a_->
ϡ
(: 
this
;

1261 cڡ 
Comex_Se
* 
	gComex_Se
::
ϡ
() const

1264  
_
?a_->
ϡ
(: 
this
;

1268 
	gComex_Se
::
Comb
 
Comex_Se
::
r_rmo
()

1270 
Comb
 
c
;

1271 i(!

() ||ail()->tail() == 0)

1272 { 
c
 = 
comb
(); comb(
ANCESTOR_OF
); 

(0); }

1274 { 
	gc
 = 

()->
r_rmo
(); }

1275  
	gc
;

1278 
	gComex_Se
::
t_rmo
(
Comex_Se
* 
v
, 
Comb
 
c
)

1280 i(!

())

1281 { 

(
v
); 
comb
(
c
); }

1283 { 

()->
t_rmo
(
v
, 
c
); }

1286 
Comex_Se
* 
	gComex_Se
::
e
(
Cڋxt
& 
x
) const

1288 
Comex_Se
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, *
this
);

1289 
	gy
->
is_tiڮ
(
this
->is_optional());

1290 
	gy
->
med_block
(
this
->media_block());

1291 i(

()
	gy
->a()->
e
(
x
));

1292  
	gy
;

1295 
Comex_Se
* 
	gComex_Se
::
eFuy
(
Cڋxt
& 
x
) const

1297 
Comex_Se
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, *
this
);

1298 
	gy
->
is_tiڮ
(
this
->is_optional());

1299 
	gy
->
med_block
(
this
->media_block());

1300 i(
hd
()) {

1301 
	gy
->
hd
(hd()->
e
(
x
));

1304 i(

()) {

1305 
	gy
->

a()->
eFuy
(
x
));

1308  
	gy
;

1311 
Compound_Se
* 
	gCompound_Se
::
e
(
Cڋxt
& 
x
) const

1313 
Compound_Se
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, *
this
);

1314 
	gy
->
is_tiڮ
(
this
->is_optional());

1315 
	gy
->
med_block
(
this
->media_block());

1316 
	gy
->
exnded
(
this
->extended());

1317  
	gy
;

1320 
Se_Li
* 
	gSe_Li
::
e
(
Cڋxt
& 
x
) const

1322 
Se_Li
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, *
this
);

1323 
	gy
->
is_tiڮ
(
this
->is_optional());

1324 
	gy
->
med_block
(
this
->media_block());

1325  
	gy
;

1328 
Se_Li
* 
	gSe_Li
::
eFuy
(
Cڋxt
& 
x
) const

1330 
Se_Li
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pe
());

1331 
	gy
->
is_tiڮ
(
this
->is_optional());

1332 
	gy
->
med_block
(
this
->media_block());

1333 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i) {

1334 *
	gy
 << (*
	gthis
)[
i
]->
eFuy
(
x
);

1336  
	gy
;

1347 
	gSe_Li
::
move__s
()

1350 
size_t
 
i
 = 0, 
	gL
 = 
ngth
(); 
	gi
 < L; ++i) {

1351 i(!(*
	gthis
)[
i
]->
hd
()) ;

1352 i((*
	gthis
)[
i
]->
hd
()->
is_emy_n
()) {

1354 i((*
	gthis
)[
i
]->
comb
(=
Comex_Se
::
ANCESTOR_OF
) {

1355 i((*
this
)[
i
]->

(!
NULL
) {

1356 i((*
this
)[
i
]->
has_le_ed
()) {

1357 (*
this
)[
i
]->

()->
has_le_ed
(
ue
);

1359 (*
	gthis
)[
i
] = (*
this
)[i]->

();

1364 (*
	gthis
)[
i
]->
hd
()->
a
((*
this
)[i]->hd()->
beg
());

1370 
bo
 
	gSe_Li
::
has__f
()

1372 
Comex_Se
* 
s
 : *
this
) {

1373 i(
s
 && s->
has__f
() 
ue
;

1375  
	gl
;

1378 
bo
 
	gSe_Schema
::
has__f
()

1380 i(
Sg_Schema
* 
schema
 = 
dymic_
<Sg_Schema*>(
cڋs
())) {

1381  
schema
->
ngth
(> 0 && 
dymic_
<
Pt_Se
*>(schema->

(0)!
NULL
;

1383  
	gl
;

1386 
	gSe_Li
::
adju_a_pushg
(
Comex_Se
* 
c
)

1393 
bo
 
Comex_Se
::
is_sur_of
(
Se_Li
 *
sub
, 
d
::
rg
 
wg
)

1396 
size_t
 
i
 = 0, 
	gL
 = 
sub
->
ngth
(); 
	gi
 < L; ++i) {

1397 i(!
is_sur_of
((*
sub
)[
i
], 
wg
) 
	gl
;

1399  
	gue
;

1404 
bo
 
	gSe_Li
::
is_sur_of
(
Se_Li
 *
sub
, 
d
::
rg
 
wg
)

1407 
size_t
 
i
 = 0, 
	gL
 = 
sub
->
ngth
(); 
	gi
 < L; ++i) {

1408 i(!
is_sur_of
((*
sub
)[
i
], 
wg
) 
	gl
;

1410  
	gue
;

1415 
bo
 
	gSe_Li
::
is_sur_of
(
Compound_Se
 *
sub
, 
d
::
rg
 
wg
)

1418 
size_t
 
i
 = 0, 
	gL
 = 
ngth
(); 
	gi
 < L; ++i) {

1419 i((*
	gthis
)[
i
]->
is_sur_of
(
sub
, 
wg
) 
	gue
;

1421  
	gl
;

1426 
bo
 
	gSe_Li
::
is_sur_of
(
Comex_Se
 *
sub
, 
d
::
rg
 
wg
)

1429 
size_t
 
i
 = 0, 
	gL
 = 
ngth
(); 
	gi
 < L; ++i) {

1430 i((*
	gthis
)[
i
]->
is_sur_of
(
sub
) 
	gue
;

1432  
	gl
;

1435 
Se_Li
* 
	gSe_Li
::
unify_wh
(Se_Li* 
rhs
, 
Cڋxt
& 
x
) {

1436 
	gd
::
ve
<
Comex_Se
*> 
unifd_comex_s
;

1438 
size_t
 
	glhs_i
 = 0, 
	glhs_L
 = 
ngth
();hs_i <hs_L; ++lhs_i) {

1439 
Comex_Se
* 
	gq1
 = (*
this
)[
lhs_i
];

1440 
size_t
 
	grhs_i
 = 0, 
	grhs_L
 = 
rhs
->
ngth
();hs_i <hs_L; ++rhs_i) {

1441 
Comex_Se
* 
	gq2
 = (*
rhs
)[
rhs_i
];

1443 
Se_Li
* 
	gsu
 = 
q1
->
unify_wh
(
q2
, 
x
);

1444 if
	gsu
 ) {

1445 
size_t
 
	gi
 = 0, 
	gL
 = 
su
->
ngth
(); i < L; ++i) {

1446 
	gunifd_comex_s
.
push_back
(*
su
)[
i
] );

1453 
Se_Li
* 
	gf_su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pe
());

1454 aut
	gr
 = 
unifd_comex_s
.
beg
(); i !unifd_comex_s.
d
(); ++itr) {

1455 *
	gf_su
 << *
	gr
;

1457  
	gf_su
;

1460 
	gSe_Li
::
puϋ_exnds
(
Se_Li
* 
exnd
, 
Cڋxt
& 
x
, 
ExnsiSubtM
& 
exnds
)

1463 
Se_Li
* 
	gexnd
 = 
this
;

1464 aut
	gcomex_l
 : 
exnd
->
emts
()) {

1465 
Comex_Se
* 
c
 = 
comex_l
;

1469 
Compound_Se
* 
	gcompound_l
 = 
c
->
hd
();

1470 
Comex_Se
* 
	gpIr
 = 
comex_l
;

1471 
	gpIr
) {

1472 
Compound_Se
* 
	gpHd
 = 
pIr
->
hd
();

1473 i(
	gpHd
 && 
	gdymic_
<
	gPt_Se
*>Hd->
emts
()[0]=
NULL
) {

1474 
compound_l
 = 
pHd
;

1478 
	gpIr
 = 
pIr
->

();

1481 i(!
	gpIr
->
hd
(||Ir->

()) {

1482 
r
("áed seܠmay bexnded", 
c
->
pe
());

1485 
	gcompound_l
->
is_tiڮ
(
exnd
->is_optional());

1487 
size_t
 
	gi
 = 0, 
	gL
 = 
exnd
->
ngth
(); i < L; ++i) {

1488 
	gexnds
.
put
(
compound_l
->
to_r_vec
(), 
d
::
make_
((*
exnd
)[
i
], compound_sel));

1493 
	gd
::
ve
<
d
::
rg
> 
Compound_Se
::
to_r_vec
()

1495 
d
::
ve
<d::
rg
> 
su
;

1496 
	gsu
.
rve
(
ngth
());

1497 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

1498 { 
	gsu
.
push_back
((*
this
)[
i
]->
to_rg
()); }

1499  
	gsu
;

1502 
Compound_Se
* 
	gCompound_Se
::
mus
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
)

1504 
Compound_Se
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
pe
());

1508 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

1510 
bo
 
	gfound
 = 
l
;

1511 
	gd
::
rg
 
thisSe
((*
this
)[
i
]->
to_rg
(
x
.
c_tis
));

1512 
size_t
 
	gj
 = 0, 
	gM
 = 
rhs
->
ngth
(); j < M; ++j)

1514 i(
	gthisSe
 =(*
rhs
)[
j
]->
to_rg
(
x
.
c_tis
))

1516 
found
 = 
ue
;

1520 i(!
	gfound
(*
	gsu
<< (*
	gthis
)[
i
];

1523  
	gsu
;

1526 
	gCompound_Se
::
mgeSours
(
SoursS
& 
sours
, 
Cڋxt
& 
x
)

1528 
	gSoursS
::

 it = 
sours
.
beg
(), 
	gdIt
 = sours.
d
(); 
	g
 !
dIt
; ++iterator) {

1529 
	gthis
->
	gsours_
.

((*

)->
e
(
x
));

1533 
Argumt
* 
	gArgumts
::
g__gumt
()

1535 
Argumt
* 
g
 = 0;

1536 i(
	gthis
->
has__gumt
()) {

1537 aut
	ga
 : 
this
->
emts
()) {

1538 i(
a
->
is__gumt
()) {

1539 
g
 = 
a
;

1545  
	gg
;

1548 
Argumt
* 
	gArgumts
::
g_keywd_gumt
()

1550 
Argumt
* 
g
 = 0;

1551 i(
	gthis
->
has_keywd_gumt
()) {

1552 aut
	ga
 : 
this
->
emts
()) {

1553 i(
a
->
is_keywd_gumt
()) {

1554 
g
 = 
a
;

1560  
	gg
;

1563 
	gArgumts
::
adju_a_pushg
(
Argumt
* 
a
)

1565 i(!
a
->
me
().
emy
()) {

1566 i
has_keywd_gumt_
) {

1567 
r
("medrgumtmudvb-ngthrgumt", 
a
->
pe
());

1569 
	ghas_med_gumts_
 = 
ue
;

1571 i(
	ga
->
is__gumt
()) {

1572 i(
	ghas__gumt_
) {

1573 
r
("funiڠd mixmay oy bed wh o vb-ngthrgumt", 
a
->
pe
());

1575 i(
	ghas_keywd_gumt_
) {

1576 
r
("ly keywdrgumtmay flow vbˇrgumts", 
a
->
pe
());

1578 
	ghas__gumt_
 = 
ue
;

1580 i(
	ga
->
is_keywd_gumt
()) {

1581 i(
	ghas_keywd_gumt_
) {

1582 
r
("funiڠd mixmay oy bed wh o keywdrgumt", 
a
->
pe
());

1584 
	ghas_keywd_gumt_
 = 
ue
;

1587 i(
	ghas__gumt_
) {

1588 
r
("drgumtmudvb-ngthrgumts", 
a
->
pe
());

1590 i(
	ghas_med_gumts_
) {

1591 
r
("drgumtmudmedrgumts", 
a
->
pe
());

1596 
bo
 
	gRuˣt
::
is_visib
() const {

1597 
Se_Li
* 

 = 
ic_
<Se_Li*>(

());

1598 
size_t
 
	gi
 = 0, 
	gL
 = 

->
ngth
(); i < L; ++i)

1599 i(!(*
	g
)[
i
]->
has_ahd
() 
	gl
;

1600  
	gue
;

1603 
bo
 
	gMed_Block
::
is_visib
() const {

1604 
size_t
 
i
 = 0, 
	gL
 = 
block
()->
ngth
(); 
	gi
 < L; ++i) {

1605 i(!(*
block
())[
i
]->
is_visib
() 
	gl
;

1607  
	gue
;

1610 
	gNumb
::
Numb
(
PrS
 
pe
, 
v
, 
d
::
rg
 
u
, 
bo
 
zo
)

1611 : 
Vue
(
pe
),

1612 
vue_
(
v
),

1613 
zo_
(
zo
),

1614 
num_uns_
(
d
::
ve
<d::
rg
>()),

1615 
dom_uns_
(
d
::
ve
<d::
rg
>()),

1616 
hash_
(0)

1618 
size_t
 
	gl
 = 0, 
	gr
 = 0;

1619 i(!
	gu
.
emy
()) {

1620 
bo
 
	gnom
 = 
ue
;

1621 
	gue
) {

1622 
	gr
 = 
u
.
fd_f_of
("*/", 
l
);

1623 
	gd
::
rg
 
un
(
u
.
subr
(
l
, 
r
 =
d
::rg::
os
 ? : -));

1624 i(!
	gun
.
emy
()) {

1625 i(
	gnom

	gnum_uns_
.
push_back
(
un
);

1626 
	gdom_uns_
.
push_back
(
un
);

1628 i(
	gr
 =
d
::
rg
::
os
) ;

1631 i(
	gu
[
r
] == '/')

1632 
nom
 = 
l
;

1633 
	gl
 = 
r
 + 1;

1636 
ce_ty
(
NUMBER
);

1639 
	gd
::
rg
 
Numb
::
un
() const

1641 
d
::
rg
 
u
;

1642 
size_t
 
	gi
 = 0, 
	gS
 = 
num_uns_
.
size
(); i < S; ++i) {

1643 i(
	gi

	gu
 += '*';

1644 
	gu
 +
num_uns_
[
i
];

1646 i(!
	gdom_uns_
.
emy
()
	gu
 += '/';

1647 
size_t
 
	gi
 = 0, 
	gS
 = 
dom_uns_
.
size
(); i < S; ++i) {

1648 i(
	gi

	gu
 += '*';

1649 
	gu
 +
dom_uns_
[
i
];

1651  
	gu
;

1654 
bo
 
	gNumb
::
is_vid_css_un
() const

1656  
num_uns
().
size
() <= 1 &&

1657 
dom_uns
().
size
() == 0;

1660 
bo
 
	gNumb
::
is_unss
() const

1661 {  
num_uns_
.
emy
(&& 
dom_uns_
.empty(); }

1663 
	gNumb
::
nmize
(cڡ 
d
::
rg
& 
ed
, 
bo
 
ri
)

1670 
	gd
::
m
<
d
::
rg
, > 
	gexpڒts
;

1673 
size_t
 
	gi
 = 0, 
	gS
 = 
num_uns_
.
size
(); i < S; ++i++ 
	gexpڒts
[num_uns_[
i
]];

1674 
size_t
 
	gi
 = 0, 
	gS
 = 
dom_uns_
.
size
(); i < S; ++i-- 
	gexpڒts
[dom_uns_[
i
]];

1677 
	g
 = 1;

1681 
	gd
::
ve
<
d
::
rg
>::

 
nom_
 = 
num_uns_
.
beg
();

1682 
	gd
::
ve
<
d
::
rg
>::

 
nom_d
 = 
num_uns_
.
d
();

1683 
	gd
::
ve
<
d
::
rg
>::

 
dom_
 = 
dom_uns_
.
beg
();

1684 
	gd
::
ve
<
d
::
rg
>::

 
dom_d
 = 
dom_uns_
.
d
();

1688 
	gdom_
 !
dom_d
)

1691 cڡ 
d
::
rg
 
dom
 = *(
dom_
 ++);

1693 i(
	gexpڒts
[
dom
] >= 0) ;

1695 i(
rg_to_un
(
dom
=
UNKNOWN
) ;

1697 
	gnom_
 !
nom_d
)

1700 cڡ 
d
::
rg
 
nom
 = *(
nom_
 ++);

1702 i(
	gexpڒts
[
nom
] <= 0) ;

1704 i(
rg_to_un
(
nom
=
UNKNOWN
) ;

1707 
	g
 *
cvsi_
(
nom
, 
dom
, 
ri
);

1709 -- 
	gexpڒts
[
nom
]; ++xpڒts[
dom
];

1716 
	gnum_uns_
.
r
();

1717 
	gdom_uns_
.
r
();

1720 aut
	gexp
 : 
expڒts
)

1724 
size_t
 
i
 = 0, 
	gS
 = 
abs
(
exp
.
cd
); 
	gi
 < S; ++i)

1728 i(!
	gexp
.
	gf
.
emy
()) {

1729 i(
	gexp
.
	gcd
 < 0
	gdom_uns_
.
push_back
(
exp
.
f
);

1730 i(
	gexp
.
	gcd
 > 0
	gnum_uns_
.
push_back
(
exp
.
f
);

1737 
	gvue_
 *

;

1741 
	gy
 { 
cvt
(
ed
, 
ri
); }

1742 
tch
 (
comtibUns
& 
r
)

1743 { 
r
(
r
.
wh
(), 
pe
()); }

1744 
tch
 (...{ 
	gthrow
; }

1749 
	gNumb
::
cvt_
(cڡ 
Numb
& 
n
) const

1760 
d
::
ve
<d::
rg
> 
l_miss_nums
(0);

1761 
	gd
::
ve
<
d
::
rg
> 
l_miss_ds
(0);

1763 
	gd
::
ve
<
d
::
rg
> 
r_nums
(
n
.
num_uns_
);

1764 
	gd
::
ve
<
d
::
rg
> 
r_ds
(
n
.
dom_uns_
);

1766 
	gd
::
ve
<
d
::
rg
>::
cڡ_
 
l_num_
 = 
num_uns_
.
beg
();

1767 
	gd
::
ve
<
d
::
rg
>::
cڡ_
 
l_num_d
 = 
num_uns_
.
d
();

1769 
bo
 
	gl_unss
 = 
is_unss
();

1770 
bo
 
	gr_unss
 = 
n
.
is_unss
();

1773 
	g
 = 1;

1776 
	gl_num_
 !
l_num_d
)

1779 cڡ 
d
::
rg
 
l_num
 = *(
l_num_
 ++);

1781 
	gd
::
ve
<
d
::
rg
>::

 
r_num_
 = 
r_nums
.
beg
();

1782 
	gd
::
ve
<
d
::
rg
>::

 
r_num_d
 = 
r_nums
.
d
();

1784 
bo
 
	gfound
 = 
l
;

1786 
	gr_num_
 !
r_num_d
)

1789 cڡ 
d
::
rg
 
r_num
 = *(
r_num_
);

1791 
	gcvsi
 = 
cvsi_
(
l_num
, 
r_num
, 
l
);

1793 i(
	gcvsi
 == 0) {

1794 ++ 
r_num_
;

1798 
	g
 *
cvsi
;

1800 
	gr_nums
.
a
(
r_num_
);

1802 
	gfound
 = 
ue
;

1807 i(!
	gfound

	gl_miss_nums
.
push_back
(
l_num
);

1810 
	gd
::
ve
<
d
::
rg
>::
cڡ_
 
l_d_
 = 
dom_uns_
.
beg
();

1811 
	gd
::
ve
<
d
::
rg
>::
cڡ_
 
l_d_d
 = 
dom_uns_
.
d
();

1814 
	gl_d_
 !
l_d_d
)

1817 cڡ 
d
::
rg
 
l_d
 = *(
l_d_
 ++);

1819 
	gd
::
ve
<
d
::
rg
>::

 
r_d_
 = 
r_ds
.
beg
();

1820 
	gd
::
ve
<
d
::
rg
>::

 
r_d_d
 = 
r_ds
.
d
();

1822 
bo
 
	gfound
 = 
l
;

1824 
	gr_d_
 !
r_d_d
)

1827 cڡ 
d
::
rg
 
r_d
 = *(
r_d_
);

1829 
	gcvsi
 = 
cvsi_
(
l_d
, 
r_d
, 
l
);

1831 i(
	gcvsi
 == 0) {

1832 ++ 
r_d_
;

1836 
	g
 *
cvsi
;

1838 
	gr_ds
.
a
(
r_d_
);

1840 
	gfound
 = 
ue
;

1845 i(!
	gfound

	gl_miss_ds
.
push_back
(
l_d
);

1849 i(
	gl_miss_nums
.
size
(> 0 && !
	gr_unss
) {

1850 
throw
 
	gExi
::
IncomtibUns
(
n
, *
this
);

1852 i(
	gl_miss_ds
.
size
(> 0 && !
	gr_unss
) {

1853 
throw
 
	gExi
::
IncomtibUns
(
n
, *
this
);

1855 i(
	gr_nums
.
size
(> 0 && !
	gl_unss
) {

1856 
throw
 
	gExi
::
IncomtibUns
(
n
, *
this
);

1858 i(
	gr_ds
.
size
(> 0 && !
	gl_unss
) {

1859 
throw
 
	gExi
::
IncomtibUns
(
n
, *
this
);

1862  
	g
;

1866 
bo
 
	gNumb
::
cvt
(cڡ 
d
::
rg
& 
ed
, bo 
ri
)

1869 i(
	ged
.
emy
() 
	gue
;

1875 
	gd
::
m
<
d
::
rg
, > 
	gexpڒts
;

1878 
size_t
 
	gi
 = 0, 
	gS
 = 
num_uns_
.
size
(); i < S; ++i++ 
	gexpڒts
[num_uns_[
i
]];

1879 
size_t
 
	gi
 = 0, 
	gS
 = 
dom_uns_
.
size
(); i < S; ++i-- 
	gexpڒts
[dom_uns_[
i
]];

1882 
	g
 = 1;

1884 
	gd
::
ve
<
d
::
rg
>::

 
dom_
 = 
dom_uns_
.
beg
();

1885 
	gd
::
ve
<
d
::
rg
>::

 
dom_d
 = 
dom_uns_
.
d
();

1889 
	gdom_
 !
dom_d
)

1892 cڡ 
d
::
rg
 
dom
 = *(
dom_
 ++);

1894 i(
	gdom
 =
ed
) ;

1896 i(
	gexpڒts
[
dom
] >= 0) ;

1898 i(
rg_to_un
(
dom
=
UNKNOWN
) ;

1901 
	g
 *
cvsi_
(
dom
, 
ed
, 
ri
);

1903 ++ 
	gexpڒts
[
dom
]; --xpڒts[
ed
];

1906 
	gd
::
ve
<
d
::
rg
>::

 
nom_
 = 
num_uns_
.
beg
();

1907 
	gd
::
ve
<
d
::
rg
>::

 
nom_d
 = 
num_uns_
.
d
();

1910 
	gnom_
 !
nom_d
)

1913 cڡ 
d
::
rg
 
nom
 = *(
nom_
 ++);

1915 i(
	gnom
 =
ed
) ;

1917 i(
	gexpڒts
[
nom
] <= 0) ;

1919 i(
rg_to_un
(
nom
=
UNKNOWN
) ;

1922 
	g
 *
cvsi_
(
nom
, 
ed
, 
ri
);

1924 -- 
	gexpڒts
[
nom
]; ++xpڒts[
ed
];

1928 
	gnum_uns_
.
r
();

1929 
	gdom_uns_
.
r
();

1932 aut
	gexp
 : 
expڒts
)

1936 
size_t
 
i
 = 0, 
	gS
 = 
abs
(
exp
.
cd
); 
	gi
 < S; ++i)

1940 i(!
	gexp
.
	gf
.
emy
()) {

1941 i(
	gexp
.
	gcd
 < 0
	gdom_uns_
.
push_back
(
exp
.
f
);

1942 i(
	gexp
.
	gcd
 > 0
	gnum_uns_
.
push_back
(
exp
.
f
);

1949 
	gvue_
 *

;

1952  
	gue
;

1957 
	gd
::
rg
 
Numb
::
fd_cvtib_un
() const

1959 
size_t
 
i
 = 0, 
	gS
 = 
num_uns_
.
size
(); 
	gi
 < S; ++i) {

1960 
	gd
::
rg
 
u
(
num_uns_
[
i
]);

1961 i(
rg_to_un
(
u
!
UNKNOWN
)  u;

1963 
size_t
 
	gi
 = 0, 
	gS
 = 
dom_uns_
.
size
(); i < S; ++i) {

1964 
	gd
::
rg
 
u
(
dom_uns_
[
i
]);

1965 i(
rg_to_un
(
u
!
UNKNOWN
)  u;

1967  
	gd
::
rg
();

1970 
bo
 
	gCuom_Wng
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

1972 i(cڡ 
Cuom_Wng
* 
r
 = 
dymic_
<cڡ Cuom_Wng*>(&
rhs
)) {

1973  
mesge
(=
r
->message();

1975  
	gl
;

1978 
bo
 
	gCuom_E
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

1980 i(cڡ 
Cuom_E
* 
r
 = 
dymic_
<cڡ Cuom_E*>(&
rhs
)) {

1981  
mesge
(=
r
->message();

1983  
	gl
;

1986 
bo
 
	gNumb
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

1988 i(cڡ 
Numb
* 
r
 = 
dymic_
<cڡ Numb*>(&
rhs
)) {

1989 
size_t
 
lhs_uns
 = 
num_uns_
.
size
(+ 
dom_uns_
.size();

1990 
size_t
 
	grhs_uns
 = 
r
->
num_uns_
.
size
(+->
dom_uns_
.size();

1992 i(!
	glhs_uns
 || !
	grhs_uns
) {

1993  
	gd
::
bs
(
vue
(- 
r
->vue()< 
NUMBER_EPSILON
;

1995  (
	gnum_uns_
 =
r
->
num_uns_
) &&

1996 (
dom_uns_
 =
r
->denominator_units_) &&

1997 
d
::
bs
(
vue
(- 
r
->vue()< 
NUMBER_EPSILON
;

1999  
	gl
;

2002 
bo
 
	gNumb
::
ݔ
< (cڡ 
Numb
& 
rhs
) const

2004 
size_t
 
lhs_uns
 = 
num_uns_
.
size
(+ 
dom_uns_
.size();

2005 
size_t
 
	grhs_uns
 = 
rhs
.
num_uns_
.
size
(+hs.
dom_uns_
.size();

2007 i(!
	glhs_uns
 || !
	grhs_uns
) {

2008  
vue
(< 
	grhs
.value();

2011 
Numb
 
tmp_r
(
rhs
);

2012 
	gtmp_r
.
nmize
(
fd_cvtib_un
());

2013 
	gd
::
rg
 
l_un
(
un
());

2014 
	gd
::
rg
 
r_un
(
tmp_r
.
un
());

2015 i(
un
(!
tmp_r
.unit()) {

2016 
r
(" comumbwh incomtib uns", 
pe
());

2018  
vue
(< 
	gtmp_r
.value();

2021 
bo
 
	gSg_Qued
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2023 i(cڡ 
Sg_Qued
* 
qr
 = 
dymic_
<cڡ Sg_Qued*>(&
rhs
)) {

2024  (
vue
(=
qr
->value());

2025 } i(cڡ 
Sg_Cڡt
* 
	gcr
 = 
dymic_
<cڡ Sg_Cڡt*>(&
rhs
)) {

2026  (
vue
(=
cr
->value());

2028  
	gl
;

2031 
bo
 
	gSg_Cڡt
::
is_visib
() const {

2032  
vue_
.
emy
(&& 
que_mk_
 == 0;

2035 
bo
 
	gSg_Cڡt
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2037 i(cڡ 
Sg_Qued
* 
qr
 = 
dymic_
<cڡ Sg_Qued*>(&
rhs
)) {

2038  (
vue
(=
qr
->value());

2039 } i(cڡ 
Sg_Cڡt
* 
	gcr
 = 
dymic_
<cڡ Sg_Cڡt*>(&
rhs
)) {

2040  (
vue
(=
cr
->value());

2042  
	gl
;

2045 
bo
 
	gSg_Schema
::
is__ުt
() const

2047  
ngth
(&& 
f
()->
is__ުt
();

2049 
bo
 
	gSg_Schema
::
is_right_ުt
() const

2051  
ngth
(&& 
ϡ
()->
is_right_ުt
();

2054 
bo
 
	gSg_Schema
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2056 i(cڡ 
Sg_Schema
* 
r
 = 
dymic_
<cڡ Sg_Schema*>(&
rhs
)) {

2057 i(
ngth
(!
r
->ngth() 
l
;

2058 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i) {

2059 
Exessi
* 
	grv
 = (*
r
)[
i
];

2060 
Exessi
* 
	glv
 = (*
this
)[
i
];

2061 i(!
	glv
 || !
	grv
 
	gl
;

2062 i(!(*
	glv
 =*
rv
) 
l
;

2064  
	gue
;

2066  
	gl
;

2069 
bo
 
	gBoޗn
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2071 i(cڡ 
Boޗn
* 
r
 = 
dymic_
<cڡ Boޗn*>(&
rhs
)) {

2072  (
vue
(=
r
->value());

2074  
	gl
;

2077 
bo
 
	gC
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2079 i(cڡ 
C
* 
r
 = 
dymic_
<cڡ C*>(&
rhs
)) {

2080  
r_
 =
r
->r() &&

2081 
g_
 =
r
->
g
() &&

2082 
b_
 =
r
->
b
() &&

2083 
a_
 =
r
->
a
();

2085  
	gl
;

2088 
bo
 
	gLi
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2090 i(cڡ 
Li
* 
r
 = 
dymic_
<cڡ Li*>(&
rhs
)) {

2091 i(
ngth
(!
r
->ngth() 
l
;

2092 i(
t
(!
r
->t() 
l
;

2093 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i) {

2094 
Exessi
* 
	grv
 = (*
r
)[
i
];

2095 
Exessi
* 
	glv
 = (*
this
)[
i
];

2096 i(!
	glv
 || !
	grv
 
	gl
;

2097 i(!(*
	glv
 =*
rv
) 
l
;

2099  
	gue
;

2101  
	gl
;

2104 
bo
 
	gM
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2106 i(cڡ 
M
* 
r
 = 
dymic_
<cڡ M*>(&
rhs
)) {

2107 i(
ngth
(!
r
->ngth() 
l
;

2108 aut
	gkey
 : 
keys
()) {

2109 
Exessi
* 
lv
 = 

(
key
);

2110 
Exessi
* 
	grv
 = 
r
->

(
key
);

2111 i(!
	grv
 || !
	glv
 
	gl
;

2112 i(!(*
	glv
 =*
rv
) 
l
;

2114  
	gue
;

2116  
	gl
;

2119 
bo
 
	gNu
::
ݔ
=(cڡ 
Exessi
& 
rhs
) const

2121  
rhs
.
ce_ty
(=
NULL_VAL
;

2124 
size_t
 
	gLi
::
size
() const {

2125 i(!
is_gli_
 
ngth
();

2128 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i) {

2129 i(
Argumt
* 
	gg
 = 
dymic_
<Argumt*>((*
this
)[
i
])) {

2130 i(!
g
->
me
().
emy
() 
i
;

2133  
ngth
();

2136 
Exessi
* 
	gHashed
::

(Exessi* 
k
) const

2138 i(
emts_
.
cou
(
k
))

2139 {  
emts_
.

(
k
); }

2140 {  &
	gss_nu
; }

2143 
bo
 
	gBy_Exessi
::
is__ުt
() const

2145  
is_ުt
(|| (

(&&e()->
is__ުt
());

2147 
bo
 
	gBy_Exessi
::
is_right_ުt
() const

2149  
is_ުt
(|| (
right
(&&ight()->
is_right_ުt
());

2154 
bo
 
	gBy_Exessi
::
n_day
() const

2156 
bo
 
l_day
 = 
l
;

2157 
bo
 
	gr_day
 = 
l
;

2158 i(

().
	gݔd
 =
Sass_OP
::
DIV
) {

2159 i(
Textu
* 

 = 
dymic_
<Textu*>(

())) {

2160 
l_day
 = 

->
ty
(=
Textu
::
NUMBER
 ||

2161 

->
ty
(=
Textu
::
DIMENSION
;

2163 
	gl_day
 = 
dymic_
<
Numb
*>(

()!
NULL
;

2165 i(
Textu
* 
	g
 = 
dymic_
<Textu*>(
right
())) {

2166 
r_day
 = 

->
ty
(=
Textu
::
NUMBER
 ||

2167 

->
ty
(=
Textu
::
DIMENSION
;

2169 
	gr_day
 = 
dymic_
<
Numb
*>(
right
()!
NULL
;

2172  
	gl_day
 && 
	gr_day
;

2175 
	gd
::
rg
 
AST_Node
::
to_rg
(
Sass_Ine_Ois
 
t
) const

2177 
Sass_Ouut_Ois
 
out
(
t
);

2178 
Emr
 
emr
(
out
);

2179 
Ine
 
i
(
emr
);

2180 
	gi
.
	g_dei
 = 
ue
;

2182 
	gcڡ_
<
	gAST_Node
*>(
	gthis
)->
rfm
(&
i
);

2183  
	gi
.
g_bufr
();

2186 
	gd
::
rg
 
AST_Node
::
to_rg
() const

2188  
to_rg
({ 
NESTED
, 5 });

2191 
	gd
::
rg
 
Sg_Qued
::
e
() const

2193  
que
(
vue_
, '*');

2196 
	gd
::
rg
 
Sg_Cڡt
::
e
() const

2198  
que
(
vue_
, '*');

2204 
Exessi
* 
	gLi
::
vue__dex
(
size_t
 
i
) {

2205 i(
is_gli_
) {

2206 i(
Argumt
* 
g
 = 
dymic_
<Argumt*>((*
this
)[
i
])) {

2207  
g
->
vue
();

2209  (*
	gthis
)[
i
];

2212  (*
	gthis
)[
i
];

	@node_modules/node-sass/src/libsass/src/ast.hpp

1 #ide
SASS_AST_H


2 
	#SASS_AST_H


	)

4 
	~<t
>

5 
	~<deque
>

6 
	~<ve
>

7 
	~<rg
>

8 
	~<sam
>

9 
	~<ioam
>

10 
	~<tyfo
>

11 
	~<gܙhm
>

12 
	~<unded_m
>

13 
	~"ss/ba.h
"

15 #ifde
__g__


29 #agm
g
 
dgnoic
 
push


30 #agm
g
 
dgnoic
 
igned
 "-Woverloaded-virtual"

34 
	~"ut.h
"

35 
	~"uns.h
"

36 
	~"cڋxt.h
"

37 
	~"posi.h
"

38 
	~"cڡts.h
"

39 
	~"ݔi.h
"

40 
	~"posi.h
"

41 
	~"e.h
"

42 
	~"sour_m.h
"

43 
	~"vmt.h
"

44 
	~"r_hdlg.h
"

45 
	~"a_def_maos.h
"

46 
	~"a_fwd_de.h
"

47 
	~"sour_m.h
"

49 
	~"ss.h
"

51 
mea
 
	gSass
 {

55 cڡ 
	gNUMBER_EPSILON
 = 0.00000000000001;

59 as
	cOnd
 {

60 
	gpublic
:

61 
Ond
(
Sass_OP
 
ݔd
, 
bo
 
ws_befe
 = 
l
, bo 
ws_a
 = false)

62 : 
ݔd
(ݔd), 
ws_befe
(ws_befe), 
ws_a
(ws_after)

64 
	gpublic
:

65 
Sass_OP
 
ݔd
;

66 
bo
 
	gws_befe
;

67 
bo
 
	gws_a
;

74 
	gme
 <
tyme
 
	gT
>

75 
	$hash_combe
 (
d
::
size_t
& 
ed
, cڡ 
T
& 
v
)

77 
ed
 ^
d
::
hash
<
T
>()(
v
) + 0x9e3779b9

78 + (
ed
<<6) + (seed>>2);

79 
	}
}

84 as
	cAST_Node
 : 
public
 
Memy_Obje
 {

85 
ADD_PROPERTY
(
PrS
, 
pe
)

86 
	gpublic
:

87 
AST_Node
(
PrS
 
pe
)

88 : 
pe_
(
pe
)

90 
vtu
 ~
AST_Node
() = 0;

91 
vtu
 
size_t
 
hash
() {  0; }

92 
vtu
 
	gd
::
rg
 
e
(cڡ {  
to_rg
({ 
INSPECT
, 5 }); }

93 
vtu
 
	gd
::
rg
 
to_ss
(cڡ {  
to_rg
({ 
TO_SASS
, 5 }); }

94 
vtu
 
	gd
::
rg
 
to_rg
(
Sass_Ine_Ois
 
t
) const;

95 
vtu
 
	gd
::
rg
 
to_rg
() const;

97 
	gpublic
:

98 
upde_pe
(cڡ 
PrS
& 
pe
);

99 
	gpublic
:

100 
Offt
 
off
({  
pe
(); }

101 
Posi
 
pos
({  
pe
(); }

102 
ATTACH_OPERATIONS
()

104 
le
 
	gAST_Node
::~
	$AST_Node
({ 
	}
}

112 as
	cExessi
 : 
public
 
AST_Node
 {

113 
public
:

114 
	eCe_Ty
 {

115 
NONE
,

116 
	gBOOLEAN
,

117 
	gNUMBER
,

118 
	gCOLOR
,

119 
	gSTRING
,

120 
	gLIST
,

121 
	gMAP
,

122 
	gSELECTOR
,

123 
	gNULL_VAL
,

124 
	gC_WARNING
,

125 
	gC_ERROR
,

126 
	gNUM_TYPES


128 
	give
:

130 
ADD_PROPERTY
(
bo
, 
is_dayed
)

131 
ADD_PROPERTY
(
bo
, 
is_exnded
)

132 
ADD_PROPERTY
(
bo
, 
is_ުt
)

133 
ADD_PROPERTY
(
Ce_Ty
, 
ce_ty
)

134 
	gpublic
:

135 
Exessi
(
PrS
 
pe
,

136 
bo
 
d
 = 
l
, bo 
e
 = f, bo 
i
 = f, 
Ce_Ty
 

 = 
NONE
)

137 : 
AST_Node
(
pe
),

138 
is_dayed_
(
d
),

139 
is_exnded_
(
d
),

140 
is_ުt_
(
i
),

141 
ce_ty_
(

)

143 
vtu
 
ݔ
 
bo
({  
	gue
; }

144 
	gvtu
 ~
Exessi
() { }

145 
vtu
 
	gd
::
rg
 
ty
() {  ""; }

146 
vtu
 
bo
 
is_visib
(cڡ {  
	gl
; }

147 
	gd
::
rg
 
ty_me
() {  ""; }

148 
vtu
 
bo
 
is_l
({  
	gl
; }

149 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
cڡ {  
l
; }

150 
vtu
 
t_dayed
(
bo
 
dayed
{ 
is_dayed
(delayed); }

151 
vtu
 
bo
 
has_ުt
(cڡ {  
is_ުt
(); }

152 
vtu
 
bo
 
is__ުt
(cڡ {  
is_ުt
(); }

153 
vtu
 
bo
 
is_right_ުt
(cڡ {  
is_ުt
(); }

154 
vtu
 
	gd
::
rg
 
e
(cڡ {  
to_rg
({ 
INSPECT
, 5 }); }

155 
vtu
 
	gd
::
rg
 
to_ss
(cڡ {  
to_rg
({ 
TO_SASS
, 5 }); }

156 
vtu
 
size_t
 
hash
() {  0; }

162 as
	cPVue
 : 
public
 
Exessi
 {

163 
public
:

164 
PVue
(
PrS
 
pe
,

165 
bo
 
d
 = 
l
, bo 
e
 = f, bo 
i
 = f, 
Ce_Ty
 

 = 
NONE
)

166 : 
Exessi
(
pe
, 
d
, 
e
, 
i
, 

)

168 
	gvtu
 ~
PVue
() { }

174 as
	cVue
 : 
public
 
Exessi
 {

175 
public
:

176 
Vue
(
PrS
 
pe
,

177 
bo
 
d
 = 
l
, bo 
e
 = f, bo 
i
 = f, 
Ce_Ty
 

 = 
NONE
)

178 : 
Exessi
(
pe
, 
d
, 
e
, 
i
, 

)

180 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const = 0;

188 
mea
 
	gd
 {

189 
	gme
<>

190 
	ghash
<
	gSass
::
Exessi
*>

192 
size_t
 
ݔ
()(
Sass
::
Exessi
* 
s
) const

194  
s
->
hash
();

197 
	gme
<>

198 
	gequ_to
<
	gSass
::
Exessi
*>

200 
bo
 
ݔ
()
Sass
::
Exessi
* 
lhs
, 
	gSass
::Exessi* 
rhs
) const

202  
lhs
->
hash
(=
rhs
->hash();

207 
mea
 
	gSass
 {

214 
	gme
 <
tyme
 
	gT
>

215 as
	cVeized
 {

216 
	gd
::
ve
<
T
> 
emts_
;

217 
	geed
:

218 
size_t
 
hash_
;

219 
t_hash
({ 
	ghash_
 = 0; }

220 
vtu
 
adju_a_pushg
(
T
 
emt
) { }

221 
	gpublic
:

222 
Veized
(
size_t
 
s
 = 0: 
emts_
(
d
::
ve
<
T
>())

223 { 
emts_
.
rve
(
s
); }

224 
	gvtu
 ~
Veized
() = 0;

225 
size_t
 
ngth
(cڡ {  
	gemts_
.
size
(); }

226 
bo
 
emy
(cڡ {  
	gemts_
.empty(); }

227 
T
 
ϡ
(cڡ {  
	gemts_
.
back
(); }

228 
T
 
f
(cڡ {  
	gemts_
.
t
(); }

229 
	gT
& 
	gݔ
[](
size_t
 
	gi
{  
	gemts_
[
i
]; }

230 
vtu
 cڡ 
	gT
& 

(
size_t
 
i
cڡ {  
	gemts_
.at(i); }

231 cڡ 
	gT
& 
	gݔ
[](
size_t
 
	gi
cڡ {  
	gemts_
[
i
]; }

232 
	gVeized
& 
	gݔ
<<(
T
 
	gemt
)

234 i(!
	gemt
 *
	gthis
;

235 
t_hash
();

236 
	gemts_
.
push_back
(
emt
);

237 
adju_a_pushg
(
emt
);

238  *
	gthis
;

240 
	gVeized
& 
	gݔ
+=(
Veized
* 
v
)

242 
size_t
 
i
 = 0, 
	gL
 = 
v
->
ngth
(); 
	gi
 < L; ++i*
	gthis
 << (*
	gv
)[i];

243  *
	gthis
;

245 
	gVeized
& 
unshi
(
T
 
emt
)

247 
	gemts_
.

(
emts_
.
beg
(), 
emt
);

248  *
	gthis
;

250 
	gd
::
ve
<
T
>& 
emts
({  
emts_
; }

251 cڡ 
	gd
::
ve
<
T
>& 
emts
(cڡ {  
emts_
; }

252 
	gd
::
ve
<
T
>& 
emts
(
d
::ve<T>& 
e
{ 
emts_
 =;  
	gemts_
; }

254 
vtu
 
size_t
 
hash
()

256 i(
	ghash_
 == 0) {

257 
T
& 

 : 
emts_
) {

258 
hash_combe
(
hash_
, 

->
hash
());

261  
	ghash_
;

264 
tyme
 
	gd
::
ve
<
T
>::

 
d
({  
emts_
.end(); }

265 
tyme
 
	gd
::
ve
<
T
>::

 
beg
({  
emts_
.begin(); }

266 
tyme
 
	gd
::
ve
<
T
>::
cڡ_
 
d
(cڡ {  
emts_
.end(); }

267 
tyme
 
	gd
::
ve
<
T
>::
cڡ_
 
beg
(cڡ {  
emts_
.begin(); }

268 
tyme
 
	gd
::
ve
<
T
>::

 
a
ym
d
::ve<T>:: 

{  
emts_
.erase(el); }

269 
tyme
 
	gd
::
ve
<
T
>::
cڡ_
 
a
ym
d
::ve<T>::cڡ_ 

{  
emts_
.erase(el); }

272 
	gme
 <
tyme
 
	gT
>

273 
le
 
	gVeized
<
	gT
>::~
	$Veized
({ 
	}
}

279 as
	cHashed
 {

280 
	sHashExessi
 {

281 
size_t
 
ݔ
((
Exessi
* 
ex
) const {

282  
ex
 ?x->
hash
() : 0;

285 
	sComExessi
 {

286 
bo
 
ݔ
()(cڡ 
Exessi
* 
	glhs
, cڡ Exessi* 
	grhs
) const {

287  
	glhs
 && 
	grhs
 && *lh=*
rhs
;

290 
	gd
::
	tunded_m
<

291 
	tExessi
*,

292 
	tExessi
*,

293 
	tHashExessi
,

294 
	tComExessi


295 > 
	tExessiM
;

296 
	give
:

297 
ExessiM
 
emts_
;

298 
	gd
::
ve
<
Exessi
*> 
li_
;

299 
	geed
:

300 
size_t
 
hash_
;

301 
Exessi
* 
	gdui_key_
;

302 
t_hash
({ 
	ghash_
 = 0; }

303 
t_dui_key
({ 
	gdui_key_
 = 0; }

304 
vtu
 
adju_a_pushg
(
d
::

<
Exessi
*, Exessi*> 
p
) { }

305 
	gpublic
:

306 
Hashed
(
size_t
 
s
 = 0: 
emts_
(
ExessiM
(s)), 
li_
(
d
::
ve
<
Exessi
*>())

307 { 
emts_
.
rve
(
s
); 
	gli_
.rve(s); 
t_dui_key
(); }

308 
	gvtu
 ~
Hashed
();

309 
size_t
 
ngth
(cڡ {  
	gli_
.
size
(); }

310 
bo
 
emy
(cڡ {  
	gli_
.empty(); }

311 
bo
 
has
(
Exessi
* 
k
cڡ {  
	gemts_
.
cou
(k) == 1; }

312 
Exessi
* 

(Exessi* 
k
) const;

313 
bo
 
has_dui_key
(cڡ {  
	gdui_key_
 != 0; }

314 
Exessi
* 
g_dui_key
(cڡ {  
	gdui_key_
; }

315 cڡ 
ExessiM
 
emts
({  
	gemts_
; }

316 
	gHashed
& 
	gݔ
<<(
	gd
::

<
Exessi
*, 
	gExessi
*> 
	gp
)

318 
t_hash
();

320 i(!
has
(
p
.
f
)
	gli_
.
push_back
(p.first);

321 i(!
	gdui_key_
dui_key_ = 
p
.
f
;

323 
	gemts_
[
p
.
f
] =.
cd
;

325 
adju_a_pushg
(
p
);

326  *
	gthis
;

328 
	gHashed
& 
	gݔ
+=(
Hashed
* 
h
)

330 i(
ngth
() == 0) {

331 
this
->
emts_
 = 
h
->elements_;

332 
	gthis
->
	gli_
 = 
h
->
li_
;

333  *
	gthis
;

336 aut
	gkey
 : 
h
->
keys
()) {

337 *
this
 << 
d
::
make_
(
key
, 
h
->

(key));

340 
t_dui_key
();

341  *
	gthis
;

343 cڡ 
	gExessiM
& 
s
(cڡ {  
	gemts_
; }

344 cڡ 
	gd
::
ve
<
Exessi
*>& 
keys
(cڡ {  
li_
; }

346 
	gd
::
unded_m
<
Exessi
*, 
	gExessi
*>::

 
d
({  
emts_
.end(); }

347 
	gd
::
unded_m
<
Exessi
*, 
	gExessi
*>::

 
beg
({  
emts_
.begin(); }

348 
	gd
::
unded_m
<
Exessi
*, 
	gExessi
*>::
cڡ_
 
d
(cڡ {  
emts_
.end(); }

349 
	gd
::
unded_m
<
Exessi
*, 
	gExessi
*>::
cڡ_
 
beg
(cڡ {  
emts_
.begin(); }

352 
le
 
	gHashed
::~
	$Hashed
({ 
	}
}

360 as
	cSmt
 : 
public
 
AST_Node
 {

361 
public
:

362 
	eSmt_Ty
 {

363 
NONE
,

364 
	gRULESET
,

365 
	gMEDIA
,

366 
	gDIRECTIVE
,

367 
	gSUPPORTS
,

368 
	gATROOT
,

369 
	gBUBBLE
,

370 
	gCONTENT
,

371 
	gKEYFRAMERULE
,

372 
	gDECLARATION
,

373 
	gASSIGNMENT
,

374 
	gIMPORT_STUB
,

375 
	gIMPORT
,

376 
	gCOMMENT
,

377 
	gWARNING
,

378 
	gRETURN
,

379 
	gEXTEND
,

380 
	gERROR
,

381 
	gDEBUGSTMT
,

382 
	gWHILE
,

383 
	gEACH
,

384 
	gFOR
,

385 
	gIF


387 
	give
:

388 
ADD_PROPERTY
(
Block
*, 
block
)

389 
ADD_PROPERTY
(
Smt_Ty
, 
emt_ty
)

390 
ADD_PROPERTY
(
size_t
, 
bs
)

391 
ADD_PROPERTY
(
bo
, 
group_d
)

392 
	gpublic
:

393 
Smt
(
PrS
 
pe
, 
Smt_Ty
 

 = 
NONE
, 
size_t
 
t
 = 0)

394 : 
AST_Node
(
pe
), 
emt_ty_
(

), 
bs_
(
t
), 
group_d_
(
l
)

396 
	gvtu
 ~
Smt
() = 0;

398 
vtu
 
bo
 
is_hoiab
({  
	gl
; }

399 
vtu
 
bo
 
is_visib
(cڡ {  
	gl
; }

400 
vtu
 
bo
 
bubbs
({  
	gl
; }

401 
vtu
 
Block
* 
block
() {  0; }

402 
vtu
 
bo
 
has_cڋ
()

404  
	gemt_ty_
 =
CONTENT
;

407 
le
 
	gSmt
::~
	$Smt
({ 
	}
}

412 
ass
 
Block
 : 
public
 
Smt
,ubli
	gVeized
<
	gSmt
*> {

413 
ADD_PROPERTY
(
bo
, 
is_ro
)

414 
ADD_PROPERTY
(
bo
, 
is__ro
);

416 
ADD_PROPERTY
(
bo
, 
has_hoiab
)

417 
ADD_PROPERTY
(
bo
, 
has_n_hoiab
)

418 
	geed
:

419 
adju_a_pushg
(
Smt
* 
s
)

421 i(
s
->
is_hoiab
()
has_hoiab_
 = 
ue
;

422 
	ghas_n_hoiab_
 = 
ue
;

424 
	gpublic
:

425 
Block
(
PrS
 
pe
, 
size_t
 
s
 = 0, 
bo
 
r
 = 
l
)

426 : 
Smt
(
pe
),

427 
	gVeized
<
	gSmt
*>(
	gs
),

428 
is_ro_
(
r
),

429 
is__ro_
(
l
),

430 
has_hoiab_
(
l
),

431 
has_n_hoiab_
(
l
)

433 
vtu
 
bo
 
has_cڋ
()

435 
size_t
 
	gi
 = 0, 
	gL
 = 
emts
().
size
(); i < L; ++i) {

436 i(
emts
()[
i
]->
has_cڋ
() 
	gue
;

438  
	gSmt
::
has_cڋ
();

440 
Block
* 
block
({  
	gthis
; }

441 
ATTACH_OPERATIONS
()

447 as
	cHas_Block
 : 
public
 
Smt
 {

448 
ADD_PROPERTY
(
Block
*, 
block
)

449 
	gpublic
:

450 
Has_Block
(
PrS
 
pe
, 
Block
* 
b
)

451 : 
Smt
(
pe
), 
block_
(
b
)

453 
vtu
 
bo
 
has_cڋ
()

455  (
	gblock_
 && block_->
has_cڋ
()|| 
	gSmt
::has_content();

457 
	gvtu
 ~
Has_Block
() = 0;

459 
le
 
	gHas_Block
::~
	$Has_Block
({ 
	}
}

465 as
	cRuˣt
 : 
public
 
Has_Block
 {

466 
ADD_PROPERTY
(
Se
*, 

)

467 
ADD_PROPERTY
(
bo
, 
_ro
);

468 
ADD_PROPERTY
(
bo
, 
is_ro
);

469 
	gpublic
:

470 
Ruˣt
(
PrS
 
pe
, 
Se
* 
s
 = 0, 
Block
* 
b
 = 0)

471 : 
Has_Block
(
pe
, 
b
), 
_
(
s
), 
_ro_
(
l
), 
is_ro_
(false)

472 { 
emt_ty
(
RULESET
); }

473 
bo
 
is_visib
() const;

475 
bo
 
is_hoiab
({  
	gue
; }

476 
ATTACH_OPERATIONS
()

482 as
	cPrݣt
 : 
public
 
Has_Block
 {

483 
ADD_PROPERTY
(
Sg
*, 
ݔty_agmt
)

484 
	gpublic
:

485 
Prݣt
(
PrS
 
pe
, 
Sg
* 
pf
, 
Block
* 
b
 = 0)

486 : 
Has_Block
(
pe
, 
b
), 
ݔty_agmt_
(
pf
)

488 
ATTACH_OPERATIONS
()

494 as
	cBubb
 : 
public
 
Smt
 {

495 
ADD_PROPERTY
(
Smt
*, 
node
)

496 
ADD_PROPERTY
(
bo
, 
group_d
)

497 
	gpublic
:

498 
Bubb
(
PrS
 
pe
, 
Smt
* 
n
, Smt* 
g
 = 0, 
size_t
 
t
 = 0)

499 : 
Smt
(
pe
, Smt::
BUBBLE
, 
t
), 
node_
(
n
), 
group_d_
(
g
 == 0)

501 
bo
 
bubbs
({  
ue
; }

502 
ATTACH_OPERATIONS
()

508 as
	cMed_Block
 : 
public
 
Has_Block
 {

509 
ADD_PROPERTY
(
Li
*, 
med_qus
)

510 
	gpublic
:

511 
Med_Block
(
PrS
 
pe
, 
Li
* 
mqs
, 
Block
* 
b
)

512 : 
Has_Block
(
pe
, 
b
), 
med_qus_
(
mqs
)

513 { 
emt_ty
(
MEDIA
); }

514 
Med_Block
(
PrS
 
pe
, 
Li
* 
mqs
, 
Block
* 
b
, 
Se
* 
s
)

515 : 
Has_Block
(
pe
, 
b
), 
med_qus_
(
mqs
)

516 { 
emt_ty
(
MEDIA
); }

517 
bo
 
bubbs
({  
	gue
; }

518 
bo
 
is_hoiab
({  
	gue
; }

519 
bo
 
is_visib
() const;

520 
ATTACH_OPERATIONS
()

527 as
	cDeive
 : 
public
 
Has_Block
 {

528 
ADD_PROPERTY
(
d
::
rg
, 
keywd
)

529 
ADD_PROPERTY
(
Se
*, 

)

530 
ADD_PROPERTY
(
Exessi
*, 
vue
)

531 
	gpublic
:

532 
Deive
(
PrS
 
pe
, 
d
::
rg
 
kwd
, 
Se
* 
l
 = 0, 
Block
* 
b
 = 0, 
Exessi
* 
v
 = 0)

533 : 
Has_Block
(
pe
, 
b
), 
keywd_
(
kwd
), 
_
(
l
), 
vue_
(
v
)

534 { 
emt_ty
(
DIRECTIVE
); }

535 
bo
 
bubbs
({  
is_keyames
(|| 
is_med
(); }

536 
bo
 
is_med
() {

537  
	gkeywd_
.
com
("@-webkit-media") == 0 ||

538 
keywd_
.
com
("@-moz-media") == 0 ||

539 
keywd_
.
com
("@-o-media") == 0 ||

540 
keywd_
.
com
("@media") == 0;

542 
bo
 
is_keyames
() {

543  
	gkeywd_
.
com
("@-webkit-keyframes") == 0 ||

544 
keywd_
.
com
("@-moz-keyframes") == 0 ||

545 
keywd_
.
com
("@-o-keyframes") == 0 ||

546 
keywd_
.
com
("@keyframes") == 0;

548 
ATTACH_OPERATIONS
()

554 as
	cKeyame_Ru
 : 
public
 
Has_Block
 {

555 
ADD_PROPERTY
(
Se
*, 

)

556 
	gpublic
:

557 
Keyame_Ru
(
PrS
 
pe
, 
Block
* 
b
)

558 : 
Has_Block
(
pe
, 
b
), 
_
(0)

559 { 
emt_ty
(
KEYFRAMERULE
); }

560 
ATTACH_OPERATIONS
()

566 as
	cDei
 : 
public
 
Smt
 {

567 
ADD_PROPERTY
(
Sg
*, 
ݔty
)

568 
ADD_PROPERTY
(
Exessi
*, 
vue
)

569 
ADD_PROPERTY
(
bo
, 
is_imp܏
)

570 
ADD_PROPERTY
(
bo
, 
is_dd
)

571 
	gpublic
:

572 
Dei
(
PrS
 
pe
,

573 
Sg
* 

, 
Exessi
* 
v
, 
bo
 
i
 = 
l
)

574 : 
Smt
(
pe
), 
ݔty_
(

), 
vue_
(
v
), 
is_imp܏_
(
i
), 
is_dd_
(
l
)

575 { 
emt_ty
(
DECLARATION
); }

576 
ATTACH_OPERATIONS
()

582 as
	cAssignmt
 : 
public
 
Smt
 {

583 
ADD_PROPERTY
(
d
::
rg
, 
vb
)

584 
ADD_PROPERTY
(
Exessi
*, 
vue
)

585 
ADD_PROPERTY
(
bo
, 
is_deu
)

586 
ADD_PROPERTY
(
bo
, 
is_glob
)

587 
	gpublic
:

588 
Assignmt
(
PrS
 
pe
,

589 
d
::
rg
 
v
, 
Exessi
* 
v
,

590 
bo
 
is_deu
 = 
l
,

591 
bo
 
is_glob
 = 
l
)

592 : 
Smt
(
pe
), 
vb_
(
v
), 
vue_
(
v
), 
is_deu_
(
is_deu
), 
is_glob_
(
is_glob
)

593 { 
emt_ty
(
ASSIGNMENT
); }

594 
ATTACH_OPERATIONS
()

601 as
	cImpt
 : 
public
 
Smt
 {

602 
d
::
ve
<
Exessi
*> 
us_
;

603 
	gd
::
ve
<
Inude
> 
cs_
;

604 
ADD_PROPERTY
(
Li
*, 
med_qus
);

605 
	gpublic
:

606 
Impt
(
PrS
 
pe
)

607 : 
Smt
(
pe
),

608 
us_
(
d
::
ve
<
Exessi
*>()),

609 
cs_
(
d
::
ve
<
Inude
>()),

610 
med_qus_
(0)

611 { 
emt_ty
(
IMPORT
); }

612 
	gd
::
ve
<
Exessi
*>& 
us
({  
us_
; }

613 
	gd
::
ve
<
Inude
>& 
cs
({  
cs_
; }

614 
ATTACH_OPERATIONS
()

619 as
	cImpt_Stub
 : 
public
 
Smt
 {

620 
Inude
 
sour_
;

621 
	gpublic
:

622 
d
::
rg
 
abs_th
({  
sour_
.abs_path; };

623 
	gd
::
rg
 
imp_th
({  
sour_
.imp_path; };

624 
Inude
 
sour
({  
	gsour_
; };

626 
Impt_Stub
(
PrS
 
pe
, 
Inude
 
s
)

627 : 
Smt
(
pe
), 
sour_
(
s
)

628 { 
emt_ty
(
IMPORT_STUB
); }

629 
ATTACH_OPERATIONS
()

635 as
	cWng
 : 
public
 
Smt
 {

636 
ADD_PROPERTY
(
Exessi
*, 
mesge
)

637 
	gpublic
:

638 
Wng
(
PrS
 
pe
, 
Exessi
* 
msg
)

639 : 
Smt
(
pe
), 
mesge_
(
msg
)

640 { 
emt_ty
(
WARNING
); }

641 
ATTACH_OPERATIONS
()

647 as
	cE
 : 
public
 
Smt
 {

648 
ADD_PROPERTY
(
Exessi
*, 
mesge
)

649 
	gpublic
:

650 
E
(
PrS
 
pe
, 
Exessi
* 
msg
)

651 : 
Smt
(
pe
), 
mesge_
(
msg
)

652 { 
emt_ty
(
ERROR
); }

653 
ATTACH_OPERATIONS
()

659 as
	cDebug
 : 
public
 
Smt
 {

660 
ADD_PROPERTY
(
Exessi
*, 
vue
)

661 
	gpublic
:

662 
Debug
(
PrS
 
pe
, 
Exessi
* 
v
)

663 : 
Smt
(
pe
), 
vue_
(
v
)

664 { 
emt_ty
(
DEBUGSTMT
); }

665 
ATTACH_OPERATIONS
()

671 as
	cCommt
 : 
public
 
Smt
 {

672 
ADD_PROPERTY
(
Sg
*, 
xt
)

673 
ADD_PROPERTY
(
bo
, 
is_imp܏
)

674 
	gpublic
:

675 
Commt
(
PrS
 
pe
, 
Sg
* 
txt
, 
bo
 
is_imp܏
)

676 : 
Smt
(
pe
), 
xt_
(
txt
), 
is_imp܏_
(
is_imp܏
)

677 { 
emt_ty
(
COMMENT
); }

678 
vtu
 
bo
 
is_visib
() const

679 {  
	gl
; }

680 
ATTACH_OPERATIONS
()

686 as
	cIf
 : 
public
 
Has_Block
 {

687 
ADD_PROPERTY
(
Exessi
*, 
edi
)

688 
ADD_PROPERTY
(
Block
*, 
ive
)

689 
	gpublic
:

690 
If
(
PrS
 
pe
, 
Exessi
* 
ed
, 
Block
* 
c
, Block* 
t
 = 0)

691 : 
Has_Block
(
pe
, 
c
), 
edi_
(
ed
), 
ive_
(
t
)

692 { 
emt_ty
(
IF
); }

693 
vtu
 
bo
 
has_cڋ
()

695  
	gHas_Block
::
has_cڋ
(|| (
ive_
 &&lternative_->has_content());

697 
ATTACH_OPERATIONS
()

703 as
	cF
 : 
public
 
Has_Block
 {

704 
ADD_PROPERTY
(
d
::
rg
, 
vb
)

705 
ADD_PROPERTY
(
Exessi
*, 
low_bound
)

706 
ADD_PROPERTY
(
Exessi
*, 
u_bound
)

707 
ADD_PROPERTY
(
bo
, 
is_usive
)

708 
	gpublic
:

709 
F
(
PrS
 
pe
,

710 
d
::
rg
 
v
, 
Exessi
* 
lo
, Exessi* 
hi
, 
Block
* 
b
, 
bo
 
c
)

711 : 
Has_Block
(
pe
, 
b
),

712 
vb_
(
v
), 
low_bound_
(
lo
), 
u_bound_
(
hi
), 
is_usive_
(
c
)

713 { 
emt_ty
(
FOR
); }

714 
ATTACH_OPERATIONS
()

720 as
	cEach
 : 
public
 
Has_Block
 {

721 
ADD_PROPERTY
(
d
::
ve
<d::
rg
>, 
vbs
)

722 
ADD_PROPERTY
(
Exessi
*, 
li
)

723 
	gpublic
:

724 
Each
(
PrS
 
pe
, 
d
::
ve
<d::
rg
> 
vs
, 
Exessi
* 
l
, 
Block
* 
b
)

725 : 
Has_Block
(
pe
, 
b
), 
vbs_
(
vs
), 
li_
(
l
)

726 { 
emt_ty
(
EACH
); }

727 
ATTACH_OPERATIONS
()

733 as
	cWhe
 : 
public
 
Has_Block
 {

734 
ADD_PROPERTY
(
Exessi
*, 
edi
)

735 
	gpublic
:

736 
Whe
(
PrS
 
pe
, 
Exessi
* 
ed
, 
Block
* 
b
)

737 : 
Has_Block
(
pe
, 
b
), 
edi_
(
ed
)

738 { 
emt_ty
(
WHILE
); }

739 
ATTACH_OPERATIONS
()

745 as
	cRu
 : 
public
 
Smt
 {

746 
ADD_PROPERTY
(
Exessi
*, 
vue
)

747 
	gpublic
:

748 
Ru
(
PrS
 
pe
, 
Exessi
* 
v
)

749 : 
Smt
(
pe
), 
vue_
(
v
)

750 { 
emt_ty
(
RETURN
); }

751 
ATTACH_OPERATIONS
()

757 as
	cExnsi
 : 
public
 
Smt
 {

758 
ADD_PROPERTY
(
Se
*, 

)

759 
	gpublic
:

760 
Exnsi
(
PrS
 
pe
, 
Se
* 
s
)

761 : 
Smt
(
pe
), 
_
(
s
)

762 { 
emt_ty
(
EXTEND
); }

763 
ATTACH_OPERATIONS
()

770 
	gBacka
;

771 
	gEnvmt
<
	tAST_Node
*> 
	tEnv
;

772 cڡ * 
	tSigtu
;

773 
	gExessi
* (*
	tNive_Funi
)(
	tEnv
&, Env&, 
	tCڋxt
&, 
	tSigtu
, 
	tPrS
, 
	tBacka
*);

774 cڡ * 
	tSigtu
;

775 as
	cDefi
 : 
public
 
Has_Block
 {

776 
public
:

777 
	eTy
 { 
MIXIN
, 
	gFUNCTION
 };

778 
ADD_PROPERTY
(
d
::
rg
, 
me
)

779 
ADD_PROPERTY
(
Pams
*, 
ms
)

780 
ADD_PROPERTY
(
Env
*, 
vmt
)

781 
ADD_PROPERTY
(
Ty
, 
ty
)

782 
ADD_PROPERTY
(
Nive_Funi
, 
tive_funi
)

783 
ADD_PROPERTY
(
Sass_Funi_Ery
, 
c_funi
)

784 
ADD_PROPERTY
(*, 
cook
)

785 
ADD_PROPERTY
(
bo
, 
is_ovld_ub
)

786 
ADD_PROPERTY
(
Sigtu
, 
sigtu
)

787 
	gpublic
:

788 
Defi
(
PrS
 
pe
,

789 
d
::
rg
 
n
,

790 
Pams
* 
ms
,

791 
Block
* 
b
,

792 
Ty
 
t
)

793 : 
Has_Block
(
pe
, 
b
),

794 
me_
(
n
),

795 
ms_
(
ms
),

796 
vmt_
(0),

797 
ty_
(
t
),

798 
tive_funi_
(0),

799 
c_funi_
(0),

800 
cook_
(0),

801 
is_ovld_ub_
(
l
),

802 
sigtu_
(0)

804 
Defi
(
PrS
 
pe
,

805 
Sigtu
 
sig
,

806 
d
::
rg
 
n
,

807 
Pams
* 
ms
,

808 
Nive_Funi
 
func_r
,

809 
bo
 
ovld_ub
 = 
l
)

810 : 
Has_Block
(
pe
, 0),

811 
me_
(
n
),

812 
ms_
(
ms
),

813 
vmt_
(0),

814 
ty_
(
FUNCTION
),

815 
tive_funi_
(
func_r
),

816 
c_funi_
(0),

817 
cook_
(0),

818 
is_ovld_ub_
(
ovld_ub
),

819 
sigtu_
(
sig
)

821 
Defi
(
PrS
 
pe
,

822 
Sigtu
 
sig
,

823 
d
::
rg
 
n
,

824 
Pams
* 
ms
,

825 
Sass_Funi_Ery
 
c_func
,

826 
bo
 
whev
,

827 
bo
 
whev2
)

828 : 
Has_Block
(
pe
, 0),

829 
me_
(
n
),

830 
ms_
(
ms
),

831 
vmt_
(0),

832 
ty_
(
FUNCTION
),

833 
tive_funi_
(0),

834 
c_funi_
(
c_func
),

835 
cook_
(
ss_funi_g_cook
(
c_func
)),

836 
is_ovld_ub_
(
l
),

837 
sigtu_
(
sig
)

839 
ATTACH_OPERATIONS
()

845 as
	cMix_Cl
 : 
public
 
Has_Block
 {

846 
ADD_PROPERTY
(
d
::
rg
, 
me
)

847 
ADD_PROPERTY
(
Argumts
*, 
gumts
)

848 
	gpublic
:

849 
Mix_Cl
(
PrS
 
pe
, 
d
::
rg
 
n
, 
Argumts
* 
gs
, 
Block
* 
b
 = 0)

850 : 
Has_Block
(
pe
, 
b
), 
me_
(
n
), 
gumts_
(
gs
)

852 
ATTACH_OPERATIONS
()

858 as
	cCڋ
 : 
public
 
Smt
 {

859 
ADD_PROPERTY
(
Med_Block
*, 
med_block
)

860 
	gpublic
:

861 
Cڋ
(
PrS
 
pe
: 
Smt
(pstate)

862 { 
emt_ty
(
CONTENT
); }

863 
ATTACH_OPERATIONS
()

870 
ass
 
	gLi
 : 
public
 
Vue
,ubli
	gVeized
<
	gExessi
*> {

871 
adju_a_pushg
(
Exessi
* 
e
{ 
is_exnded
(
l
); }

872 
	give
:

873 
ADD_PROPERTY
(
Sass_S
, 
t
)

874 
ADD_PROPERTY
(
bo
, 
is_gli
)

875 
ADD_PROPERTY
(
bo
, 
om_
)

876 
	gpublic
:

877 
Li
(
PrS
 
pe
,

878 
size_t
 
size
 = 0, 
Sass_S
 
p
 = 
SASS_SPACE
, 
bo
 
gl
 = 
l
)

879 : 
Vue
(
pe
),

880 
	gVeized
<
	gExessi
*>(
	gsize
),

881 
t_
(
p
),

882 
is_gli_
(
gl
),

883 
om__
(
l
)

884 { 
ce_ty
(
LIST
); }

885 
	gd
::
rg
 
ty
({  
is_gli_
 ? "arglist" : "list"; }

886 
	gd
::
rg
 
ty_me
() {  "list"; }

887 cڡ * 
p_rg
(
bo
 
comesd
 = 
l
) const {

888  
t
(=
SASS_SPACE
 ?

889 " " : (
comesd
 ? "," : ", ");

891 
bo
 
is_visib
(cڡ {  
emy
(); }

892 
Exessi
* 
vue__dex
(
size_t
 
i
);

894 
vtu
 
size_t
 
size
() const;

896 
vtu
 
size_t
 
hash
()

898 i(
	ghash_
 == 0) {

899 
hash_
 = 
d
::
hash
<d::
rg
>()(
p_rg
());

900 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

901 
hash_combe
(
hash_
, (
emts
()[
i
])->
hash
());

903  
	ghash_
;

906 
vtu
 
t_dayed
(
bo
 
dayed
)

908 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

909 (
emts
()[
i
])->
t_dayed
(
dayed
);

910 
is_dayed
(
dayed
);

913 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

915 
ATTACH_OPERATIONS
()

921 
ass
 
	gM
 : 
public
 
Vue
,ubli
	gHashed
 {

922 
adju_a_pushg
(
d
::

<
Exessi
*, Exessi*> 
p
{ 
is_exnded
(
l
); }

923 
	gpublic
:

924 
M
(
PrS
 
pe
,

925 
size_t
 
size
 = 0)

926 : 
Vue
(
pe
),

927 
Hashed
(
size
)

928 { 
ce_ty
(
MAP
); }

929 
	gd
::
rg
 
ty
() {  "map"; }

930 
	gd
::
rg
 
ty_me
() {  "map"; }

931 
bo
 
is_visib
(cڡ {  
emy
(); }

933 
vtu
 
size_t
 
hash
()

935 i(
	ghash_
 == 0) {

936 aut
key
 : 
keys
()) {

937 
hash_combe
(
hash_
, 
key
->
hash
());

938 
hash_combe
(
hash_
, 

(
key
)->
hash
());

942  
	ghash_
;

945 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

947 
ATTACH_OPERATIONS
()

950 
le
 cڡ 
	gd
::
rg
 
	$ss__to_me
(
Sass_OP
 

) {

951 

) {

952 
AND
:  "and"; ;

953 
OR
:  "or"; ;

954 
EQ
:  "eq"; ;

955 
NEQ
:  "neq"; ;

956 
GT
:  "gt"; ;

957 
GTE
:  "gte"; ;

958 
LT
:  "lt"; ;

959 
LTE
:  "lte"; ;

960 
ADD
:  "plus"; ;

961 
SUB
:  "sub"; ;

962 
MUL
:  "times"; ;

963 
DIV
:  "div"; ;

964 
MOD
:  "mod"; ;

966 
NUM_OPS
:  "[OPS]"; ;

969 
	}
}

976 as
	cBy_Exessi
 : 
public
 
PVue
 {

977 
ive
:

978 
ADD_HASHED
(
Ond
, 

)

979 
ADD_HASHED
(
Exessi
*, 

)

980 
ADD_HASHED
(
Exessi
*, 
right
)

981 
size_t
 
	ghash_
;

982 
	gpublic
:

983 
By_Exessi
(
PrS
 
pe
,

984 
Ond
 

, 
Exessi
* 
lhs
, Exessi* 
rhs
)

985 : 
PVue
(
pe
), 
_
(

), 
_
(
lhs
), 
right_
(
rhs
), 
hash_
(0)

987 cڡ 
	gd
::
rg
 
ty_me
() {

988 
ty
()) {

989 
AND
:  "and"; ;

990 
	gOR
:  "or"; ;

991 
	gEQ
:  "eq"; ;

992 
	gNEQ
:  "neq"; ;

993 
	gGT
:  "gt"; ;

994 
	gGTE
:  "gte"; ;

995 
	gLT
:  "lt"; ;

996 
	gLTE
:  "lte"; ;

997 
	gADD
:  "add"; ;

998 
	gSUB
:  "sub"; ;

999 
	gMUL
:  "mul"; ;

1000 
	gDIV
:  "div"; ;

1001 
	gMOD
:  "mod"; ;

1003 
	gNUM_OPS
:  "[OPS]"; ;

1007 cڡ 
	gd
::
rg
 
t
() {

1008 
ty
()) {

1009 
AND
:  "&&"; ;

1010 
	gOR
:  "||"; ;

1011 
	gEQ
:  "=="; ;

1012 
	gNEQ
:  "!="; ;

1013 
	gGT
:  ">"; ;

1014 
	gGTE
:  ">="; ;

1015 
	gLT
:  "<"; ;

1016 
	gLTE
:  "<="; ;

1017 
	gADD
:  "+"; ;

1018 
	gSUB
:  "-"; ;

1019 
	gMUL
:  "*"; ;

1020 
	gDIV
:  "/"; ;

1021 
	gMOD
:  "%"; ;

1023 
	gNUM_OPS
:  "[OPS]"; ;

1027 
bo
 
is__ުt
() const;

1028 
bo
 
is_right_ުt
() const;

1029 
bo
 
has_ުt
() const

1031  
is__ުt
() ||

1032 
is_right_ުt
();

1034 
vtu
 
bo
 
n_day
() const;

1035 
t_whea
()

1037 
	g_
.
	gws_befe
 = 
l
;

1038 
	g_
.
	gws_a
 = 
l
;

1040 
vtu
 
t_dayed
(
bo
 
dayed
)

1042 
right
()->
t_dayed
(
dayed
);

1043 

()->
t_dayed
(
dayed
);

1044 
is_dayed
(
dayed
);

1046 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const

1048 
y


1050 cڡ 
By_Exessi
* 
m
 = 
dymic_
<cڡ By_Exessi*>(&
rhs
);

1051 i(
	gm
 =0 
l
;

1052  
ty
(=
m
->type() &&

1053 

(=
m
->left() &&

1054 
right
(=
m
->right();

1056 
tch
 (
d
::
bad_
&)

1058  
l
;

1060 
tch
 (...{ 
	gthrow
; }

1062 
vtu
 
size_t
 
hash
()

1064 i(
	ghash_
 == 0) {

1065 
hash_
 = 
d
::
hash
<
size_t
>()(
ty
());

1066 
hash_combe
(
hash_
, 

()->
hash
());

1067 
hash_combe
(
hash_
, 
right
()->
hash
());

1069  
	ghash_
;

1071 
Sass_OP
 
ty
(cڡ {  
	g_
.
	gݔd
; }

1072 
ATTACH_OPERATIONS
()

1078 as
	cUry_Exessi
 : 
public
 
Exessi
 {

1079 
public
:

1080 
	eTy
 { 
PLUS
, 
	gMINUS
, 
	gNOT
 };

1081 
	give
:

1082 
ADD_HASHED
(
Ty
, 
ty
)

1083 
ADD_HASHED
(
Exessi
*, 
ݔd
)

1084 
size_t
 
	ghash_
;

1085 
	gpublic
:

1086 
Ury_Exessi
(
PrS
 
pe
, 
Ty
 
t
, 
Exessi
* 
o
)

1087 : 
Exessi
(
pe
), 
ty_
(
t
), 
ݔd_
(
o
), 
hash_
(0)

1089 cڡ 
	gd
::
rg
 
ty_me
() {

1090 
ty_
) {

1091 
PLUS
:  "plus"; ;

1092 
	gMINUS
:  "minus"; ;

1093 
	gNOT
:  "not"; ;

1097 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const

1099 
y


1101 cڡ 
Ury_Exessi
* 
m
 = 
dymic_
<cڡ Ury_Exessi*>(&
rhs
);

1102 i(
	gm
 =0 
l
;

1103  
ty
(=
m
->type() &&

1104 
ݔd
(=
m
->operand();

1106 
tch
 (
d
::
bad_
&)

1108  
l
;

1110 
tch
 (...{ 
	gthrow
; }

1112 
vtu
 
size_t
 
hash
()

1114 i(
	ghash_
 == 0) {

1115 
hash_
 = 
d
::
hash
<
size_t
>()(
ty_
);

1116 
hash_combe
(
hash_
, 
ݔd
()->
hash
());

1118  
	ghash_
;

1120 
ATTACH_OPERATIONS
()

1126 as
	cArgumt
 : 
public
 
Exessi
 {

1127 
ADD_HASHED
(
Exessi
*, 
vue
)

1128 
ADD_HASHED
(
d
::
rg
, 
me
)

1129 
ADD_PROPERTY
(
bo
, 
is__gumt
)

1130 
ADD_PROPERTY
(
bo
, 
is_keywd_gumt
)

1131 
size_t
 
	ghash_
;

1132 
	gpublic
:

1133 
Argumt
(
PrS
 
pe
, 
Exessi
* 
v
, 
d
::
rg
 
n
 = "", 
bo
 

 = 
l
, bo 
keywd
 = false)

1134 : 
Exessi
(
pe
), 
vue_
(
v
), 
me_
(
n
), 
is__gumt_
(

), 
is_keywd_gumt_
(
keywd
), 
hash_
(0)

1136 i(!
	gme_
.
emy
(&& 
	gis__gumt_
) {

1137 
r
("vb-ngthrgummay bsd byame", 
pe
);

1141 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const

1143 
y


1145 cڡ 
Argumt
* 
m
 = 
dymic_
<cڡ Argumt*>(&
rhs
);

1146 i(!(
	gm
 && 
me
(=
m
->me()) 
l
;

1147  *
vue
(=*
m
->value();

1149 
tch
 (
d
::
bad_
&)

1151  
l
;

1153 
tch
 (...{ 
	gthrow
; }

1156 
vtu
 
size_t
 
hash
()

1158 i(
	ghash_
 == 0) {

1159 
hash_
 = 
d
::
hash
<d::
rg
>()(
me
());

1160 
hash_combe
(
hash_
, 
vue
()->
hash
());

1162  
	ghash_
;

1165 
ATTACH_OPERATIONS
()

1173 
ass
 
	gArgumts
 : 
public
 
Exessi
,ubli
	gVeized
<
	gArgumt
*> {

1174 
ADD_PROPERTY
(
bo
, 
has_med_gumts
)

1175 
ADD_PROPERTY
(
bo
, 
has__gumt
)

1176 
ADD_PROPERTY
(
bo
, 
has_keywd_gumt
)

1177 
	geed
:

1178 
adju_a_pushg
(
Argumt
* 
a
);

1179 
	gpublic
:

1180 
Argumts
(
PrS
 
pe
)

1181 : 
Exessi
(
pe
),

1182 
	gVeized
<
	gArgumt
*>(),

1183 
has_med_gumts_
(
l
),

1184 
has__gumt_
(
l
),

1185 
has_keywd_gumt_
(
l
)

1188 
Argumt
* 
g__gumt
();

1189 
Argumt
* 
g_keywd_gumt
();

1191 
ATTACH_OPERATIONS
()

1197 as
	cFuni_Cl
 : 
public
 
PVue
 {

1198 
ADD_HASHED
(
d
::
rg
, 
me
)

1199 
ADD_HASHED
(
Argumts
*, 
gumts
)

1200 
ADD_PROPERTY
(*, 
cook
)

1201 
size_t
 
	ghash_
;

1202 
	gpublic
:

1203 
Funi_Cl
(
PrS
 
pe
, 
d
::
rg
 
n
, 
Argumts
* 
gs
, * 
cook
)

1204 : 
PVue
(
pe
), 
me_
(
n
), 
gumts_
(
gs
), 
cook_
(
cook
), 
hash_
(0)

1205 { 
ce_ty
(
STRING
); }

1206 
Funi_Cl
(
PrS
 
pe
, 
d
::
rg
 
n
, 
Argumts
* 
gs
)

1207 : 
PVue
(
pe
), 
me_
(
n
), 
gumts_
(
gs
), 
cook_
(0), 
hash_
(0)

1208 { 
ce_ty
(
STRING
); }

1210 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const

1212 
y


1214 cڡ 
Funi_Cl
* 
m
 = 
dymic_
<cڡ Funi_Cl*>(&
rhs
);

1215 i(!(
	gm
 && 
me
(=
m
->me()) 
l
;

1216 i(!(
	gm
 && 
gumts
()->
ngth
(=
m
->gumts()->ngth()) 
l
;

1217 
size_t
 
	gi
 =0, 
	gL
 = 
gumts
()->
ngth
(); i < L; ++i)

1218 i(!((*
gumts
())[
i
] =(*
m
->gumts())[i]) 
l
;

1219  
	gue
;

1221 
tch
 (
d
::
bad_
&)

1223  
l
;

1225 
tch
 (...{ 
	gthrow
; }

1228 
vtu
 
size_t
 
hash
()

1230 i(
	ghash_
 == 0) {

1231 
hash_
 = 
d
::
hash
<d::
rg
>()(
me
());

1232 aut
	ggumt
 : 
gumts
()->
emts
())

1233 
hash_combe
(
hash_
, 
gumt
->
hash
());

1235  
	ghash_
;

1238 
ATTACH_OPERATIONS
()

1244 as
	cFuni_Cl_Schema
 : 
public
 
Exessi
 {

1245 
ADD_PROPERTY
(
Sg
*, 
me
)

1246 
ADD_PROPERTY
(
Argumts
*, 
gumts
)

1247 
	gpublic
:

1248 
Funi_Cl_Schema
(
PrS
 
pe
, 
Sg
* 
n
, 
Argumts
* 
gs
)

1249 : 
Exessi
(
pe
), 
me_
(
n
), 
gumts_
(
gs
)

1250 { 
ce_ty
(
STRING
); }

1251 
ATTACH_OPERATIONS
()

1257 as
	cVb
 : 
public
 
PVue
 {

1258 
ADD_PROPERTY
(
d
::
rg
, 
me
)

1259 
	gpublic
:

1260 
Vb
(
PrS
 
pe
, 
d
::
rg
 
n
)

1261 : 
PVue
(
pe
), 
me_
(
n
)

1264 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const

1266 
y


1268 cڡ 
Vb
* 
e
 = 
dymic_
<cڡ Vb*>(&
rhs
);

1269  
	ge
 && 
me
(=
e
->name();

1271 
tch
 (
d
::
bad_
&)

1273  
l
;

1275 
tch
 (...{ 
	gthrow
; }

1278 
vtu
 
size_t
 
hash
()

1280  
	gd
::
hash
<
d
::
rg
>()(
me
());

1283 
ATTACH_OPERATIONS
()

1290 as
	cTextu
 : 
public
 
Exessi
 {

1291 
public
:

1292 
	eTy
 { 
NUMBER
, 
	gPERCENTAGE
, 
	gDIMENSION
, 
	gHEX
 };

1293 
	give
:

1294 
ADD_HASHED
(
Ty
, 
ty
)

1295 
ADD_HASHED
(
d
::
rg
, 
vue
)

1296 
size_t
 
	ghash_
;

1297 
	gpublic
:

1298 
Textu
(
PrS
 
pe
, 
Ty
 
t
, 
d
::
rg
 
v
)

1299 : 
Exessi
(
pe
, 
ue
), 
ty_
(
t
), 
vue_
(
v
),

1300 
hash_
(0)

1303 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const

1305 
y


1307 cڡ 
Textu
* 
e
 = 
dymic_
<cڡ Textu*>(&
rhs
);

1308  
	ge
 && 
vue
(=
e
->vue(&& 
ty
() ==->type();

1310 
tch
 (
d
::
bad_
&)

1312  
l
;

1314 
tch
 (...{ 
	gthrow
; }

1317 
vtu
 
size_t
 
hash
()

1319 i(
	ghash_
 == 0) {

1320 
hash_
 = 
d
::
hash
<d::
rg
>()(
vue_
);

1321 
hash_combe
(
hash_
, 
d
::
hash
<>()(
ty_
));

1323  
	ghash_
;

1326 
ATTACH_OPERATIONS
()

1332 as
	cNumb
 : 
public
 
Vue
 {

1333 
ADD_HASHED
(, 
vue
)

1334 
ADD_PROPERTY
(
bo
, 
zo
)

1335 
	gd
::
ve
<
d
::
rg
> 
num_uns_
;

1336 
	gd
::
ve
<
d
::
rg
> 
dom_uns_
;

1337 
size_t
 
	ghash_
;

1338 
	gpublic
:

1339 
Numb
(
PrS
 
pe
, 
v
, 
d
::
rg
 
u
 = "", 
bo
 
zo
 = 
ue
);

1340 
bo
 
zo
({  
	gzo_
; }

1341 
bo
 
is_vid_css_un
() const;

1342 
	gd
::
ve
<
d
::
rg
>& 
num_uns
({  
num_uns_
; }

1343 
	gd
::
ve
<
d
::
rg
>& 
dom_uns
({  
dom_uns_
; }

1344 cڡ 
	gd
::
ve
<
d
::
rg
>& 
num_uns
(cڡ {  
num_uns_
; }

1345 cڡ 
	gd
::
ve
<
d
::
rg
>& 
dom_uns
(cڡ {  
dom_uns_
; }

1346 
	gd
::
rg
 
ty
() {  "number"; }

1347 
	gd
::
rg
 
ty_me
() {  "number"; }

1348 
	gd
::
rg
 
un
() const;

1350 
bo
 
is_unss
() const;

1351 
cvt_
(cڡ 
Numb
&) const;

1352 
bo
 
cvt
(cڡ 
d
::
rg
& 
un
 = "", bo 
ri
 = 
l
);

1353 
nmize
(cڡ 
d
::
rg
& 
un
 = "", 
bo
 
ri
 = 
l
);

1355 
	gd
::
rg
 
fd_cvtib_un
() const;

1357 
vtu
 
size_t
 
hash
()

1359 i(
	ghash_
 == 0) {

1360 
hash_
 = 
d
::
hash
<>()(
vue_
);

1361 cڡut
	gnum
 : 
num_uns
())

1362 
hash_combe
(
hash_
, 
d
::
hash
<d::
rg
>()(
num
));

1363 cڡut
	gdom
 : 
dom_uns
())

1364 
hash_combe
(
hash_
, 
d
::
hash
<d::
rg
>()(
dom
));

1366  
	ghash_
;

1369 
vtu
 
bo
 
	gݔ
< (cڡ 
	gNumb
& 
	grhs
) const;

1370 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

1372 
ATTACH_OPERATIONS
()

1378 as
	cC
 : 
public
 
Vue
 {

1379 
ADD_HASHED
(, 
r
)

1380 
ADD_HASHED
(, 
g
)

1381 
ADD_HASHED
(, 
b
)

1382 
ADD_HASHED
(, 
a
)

1383 
ADD_PROPERTY
(
d
::
rg
, 
di
)

1384 
size_t
 
	ghash_
;

1385 
	gpublic
:

1386 
C
(
PrS
 
pe
, 
r
, 
g
, 
b
, 
a
 = 1, cڡ 
d
::
rg
 
di
 = "")

1387 : 
Vue
(
pe
), 
r_
(
r
), 
g_
(
g
), 
b_
(
b
), 
a_
(
a
), 
di_
(
di
),

1388 
hash_
(0)

1389 { 
ce_ty
(
COLOR
); }

1390 
	gd
::
rg
 
ty
() {  "color"; }

1391 
	gd
::
rg
 
ty_me
() {  "color"; }

1393 
vtu
 
size_t
 
hash
()

1395 i(
	ghash_
 == 0) {

1396 
hash_
 = 
d
::
hash
<>()(
a_
);

1397 
hash_combe
(
hash_
, 
d
::
hash
<>()(
r_
));

1398 
hash_combe
(
hash_
, 
d
::
hash
<>()(
g_
));

1399 
hash_combe
(
hash_
, 
d
::
hash
<>()(
b_
));

1401  
	ghash_
;

1404 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

1406 
ATTACH_OPERATIONS
()

1412 as
	cCuom_E
 : 
public
 
Vue
 {

1413 
ADD_PROPERTY
(
d
::
rg
, 
mesge
)

1414 
	gpublic
:

1415 
Cuom_E
(
PrS
 
pe
, 
d
::
rg
 
msg
)

1416 : 
Vue
(
pe
), 
mesge_
(
msg
)

1417 { 
ce_ty
(
C_ERROR
); }

1418 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

1419 
ATTACH_OPERATIONS
()

1425 as
	cCuom_Wng
 : 
public
 
Vue
 {

1426 
ADD_PROPERTY
(
d
::
rg
, 
mesge
)

1427 
	gpublic
:

1428 
Cuom_Wng
(
PrS
 
pe
, 
d
::
rg
 
msg
)

1429 : 
Vue
(
pe
), 
mesge_
(
msg
)

1430 { 
ce_ty
(
C_WARNING
); }

1431 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

1432 
ATTACH_OPERATIONS
()

1438 as
	cBoޗn
 : 
public
 
Vue
 {

1439 
ADD_HASHED
(
bo
, 
vue
)

1440 
size_t
 
	ghash_
;

1441 
	gpublic
:

1442 
Boޗn
(
PrS
 
pe
, 
bo
 
v
)

1443 : 
Vue
(
pe
), 
vue_
(
v
),

1444 
hash_
(0)

1445 { 
ce_ty
(
BOOLEAN
); }

1446 
vtu
 
ݔ
 
bo
({  
	gvue_
; }

1447 
	gd
::
rg
 
ty
() {  "bool"; }

1448 
	gd
::
rg
 
ty_me
() {  "bool"; }

1449 
vtu
 
bo
 
is_l
({  !
	gvue_
; }

1451 
vtu
 
size_t
 
hash
()

1453 i(
	ghash_
 == 0) {

1454 
hash_
 = 
d
::
hash
<
bo
>()(
vue_
);

1456  
	ghash_
;

1459 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

1461 
ATTACH_OPERATIONS
()

1468 as
	cSg
 : 
public
 
Vue
 {

1469 
ADD_PROPERTY
(
bo
, 
ss_fix_1291
)

1470 
	gpublic
:

1471 
Sg
(
PrS
 
pe
, 
bo
 
dayed
 = 
l
, bo 
ss_fix_1291
 = false)

1472 : 
Vue
(
pe
, 
dayed
), 
ss_fix_1291_
(
ss_fix_1291
)

1473 { 
ce_ty
(
STRING
); }

1474 
	gd
::
rg
 
ty_me
() {  "string"; }

1475 
	gvtu
 ~
Sg
() = 0;

1476 
vtu
 
rim
() = 0;

1477 
vtu
 
rim
() = 0;

1478 
vtu
 
im
() = 0;

1479 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const = 0;

1480 
ATTACH_OPERATIONS
()

1482 
le
 
	gSg
::~
	$Sg
({ 
	}
};

1488 
ass
 
	gSg_Schema
 : 
public
 
Sg
,ubli
	gVeized
<
	gExessi
*> {

1490 
size_t
 
	ghash_
;

1491 
	gpublic
:

1492 
Sg_Schema
(
PrS
 
pe
, 
size_t
 
size
 = 0, 
bo
 
has_ުts
 = 
l
)

1493 : 
Sg
(
pe
), 
	gVeized
<
	gExessi
*>(
	gsize
), 
hash_
(0)

1494 { 
ce_ty
(
STRING
); }

1495 
	gd
::
rg
 
ty
() {  "string"; }

1496 
	gd
::
rg
 
ty_me
() {  "string"; }

1498 
bo
 
is__ުt
() const;

1499 
bo
 
is_right_ުt
() const;

1501 
bo
 
has_ުts
() {

1502 aut
	g
 : 
emts
()) {

1503 i(

->
is_ުt
() 
ue
;

1505  
	gl
;

1507 
vtu
 
rim
();

1508 
vtu
 
rim
();

1509 
vtu
 
im
();

1511 
vtu
 
size_t
 
hash
()

1513 i(
	ghash_
 == 0) {

1514 aut
rg
 : 
emts
())

1515 
hash_combe
(
hash_
, 
rg
->
hash
());

1517  
	ghash_
;

1520 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const;

1522 
ATTACH_OPERATIONS
()

1528 as
	cSg_Cڡt
 : 
public
 
Sg
 {

1529 
ADD_PROPERTY
(, 
que_mk
)

1530 
ADD_PROPERTY
(
bo
, 
n_comess_whea
)

1531 
ADD_HASHED
(
d
::
rg
, 
vue
)

1532 
	geed
:

1533 
size_t
 
hash_
;

1534 
	gpublic
:

1535 
Sg_Cڡt
(
PrS
 
pe
, 
d
::
rg
 
v
)

1536 : 
Sg
(
pe
), 
que_mk_
(0), 
n_comess_whea_
(
l
), 
vue_
(
ad_css_rg
(
v
)), 
hash_
(0)

1538 
Sg_Cڡt
(
PrS
 
pe
, cڡ * 
beg
)

1539 : 
Sg
(
pe
), 
que_mk_
(0), 
n_comess_whea_
(
l
), 
vue_
(
ad_css_rg
(
d
::
rg
(
beg
))), 
hash_
(0)

1541 
Sg_Cڡt
(
PrS
 
pe
, cڡ * 
beg
, cڡ * 
d
)

1542 : 
Sg
(
pe
), 
que_mk_
(0), 
n_comess_whea_
(
l
), 
vue_
(
ad_css_rg
(
d
::
rg
(
beg
, 
d
-beg))), 
hash_
(0)

1544 
Sg_Cڡt
(
PrS
 
pe
, cڡ 
Tok
& 
tok
)

1545 : 
Sg
(
pe
), 
que_mk_
(0), 
n_comess_whea_
(
l
), 
vue_
(
ad_css_rg
(
d
::
rg
(
tok
.
beg
,ok.
d
))), 
hash_
(0)

1547 
	gd
::
rg
 
ty
() {  "string"; }

1548 
	gd
::
rg
 
ty_me
() {  "string"; }

1549 
vtu
 
bo
 
is_visib
() const;

1550 
vtu
 
rim
();

1551 
vtu
 
rim
();

1552 
vtu
 
im
();

1554 
vtu
 
size_t
 
hash
()

1556 i(
	ghash_
 == 0) {

1557 
hash_
 = 
d
::
hash
<d::
rg
>()(
vue_
);

1559  
	ghash_
;

1562 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const;

1563 
vtu
 
	gd
::
rg
 
e
() const;

1566 
doub_que
() {  '"'; }

1567 
sg_que
() {  '\''; }

1569 
ATTACH_OPERATIONS
()

1575 as
	cSg_Qued
 : 
public
 
Sg_Cڡt
 {

1576 
public
:

1577 
Sg_Qued
(
PrS
 
pe
, 
d
::
rg
 
v
, 
q
 = 0, 
bo
 
kp_utf8_ess
 = 
l
)

1578 : 
Sg_Cڡt
(
pe
, 
v
)

1580 
	gvue_
 = 
unque
(
vue_
, &
que_mk_
, 
kp_utf8_ess
);

1581 i(
	gq
 && 
	gque_mk_
que_mk_ = 
q
;

1583 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const;

1584 
vtu
 
	gd
::
rg
 
e
() const;

1585 
ATTACH_OPERATIONS
()

1591 
ass
 
	gMed_Quy
 : 
public
 
Exessi
,

1592 
public
 
	gVeized
<
	gMed_Quy_Exessi
*> {

1593 
ADD_PROPERTY
(
Sg
*, 
med_ty
)

1594 
ADD_PROPERTY
(
bo
, 
is_ged
)

1595 
ADD_PROPERTY
(
bo
, 
is_ried
)

1596 
	gpublic
:

1597 
Med_Quy
(
PrS
 
pe
,

1598 
Sg
* 
t
 = 0, 
size_t
 
s
 = 0, 
bo
 
n
 = 
l
, bo 
r
 = false)

1599 : 
Exessi
(
pe
), 
	gVeized
<
	gMed_Quy_Exessi
*>(
	gs
),

1600 
med_ty_
(
t
), 
is_ged_
(
n
), 
is_ried_
(
r
)

1602 
ATTACH_OPERATIONS
()

1608 as
	cMed_Quy_Exessi
 : 
public
 
Exessi
 {

1609 
ADD_PROPERTY
(
Exessi
*, 
u
)

1610 
ADD_PROPERTY
(
Exessi
*, 
vue
)

1611 
ADD_PROPERTY
(
bo
, 
is_ީed
)

1612 
	gpublic
:

1613 
Med_Quy_Exessi
(
PrS
 
pe
,

1614 
Exessi
* 
f
, Exessi* 
v
, 
bo
 
i
 = 
l
)

1615 : 
Exessi
(
pe
), 
u_
(
f
), 
vue_
(
v
), 
is_ީed_
(
i
)

1617 
ATTACH_OPERATIONS
()

1623 as
	cSuts_Block
 : 
public
 
Has_Block
 {

1624 
ADD_PROPERTY
(
Suts_Cdi
*, 
cdi
)

1625 
	gpublic
:

1626 
Suts_Block
(
PrS
 
pe
, 
Suts_Cdi
* 
cdi
, 
Block
* 
block
 = 0)

1627 : 
Has_Block
(
pe
, 
block
), 
cdi_
(
cdi
)

1628 { 
emt_ty
(
SUPPORTS
); }

1629 
bo
 
is_hoiab
({  
	gue
; }

1630 
bo
 
bubbs
({  
	gue
; }

1631 
ATTACH_OPERATIONS
()

1637 as
	cSuts_Cdi
 : 
public
 
Exessi
 {

1638 
public
:

1639 
Suts_Cdi
(
PrS
 
pe
)

1640 : 
Exessi
(
pe
)

1642 
vtu
 
bo
 
eds_ns
(
Suts_Cdi
* 
cd
cڡ {  
l
; }

1643 
ATTACH_OPERATIONS
()

1649 as
	cSuts_Ot
 : 
public
 
Suts_Cdi
 {

1650 
public
:

1651 
	eOnd
 { 
AND
, 
	gOR
 };

1652 
	give
:

1653 
ADD_PROPERTY
(
Suts_Cdi
*, 

);

1654 
ADD_PROPERTY
(
Suts_Cdi
*, 
right
);

1655 
ADD_PROPERTY
(
Ond
, 
ݔd
);

1656 
	gpublic
:

1657 
Suts_Ot
(
PrS
 
pe
, 
Suts_Cdi
* 
l
, Suts_Cdi* 
r
, 
Ond
 
o
)

1658 : 
Suts_Cdi
(
pe
), 
_
(
l
), 
right_
(
r
), 
ݔd_
(
o
)

1660 
vtu
 
bo
 
eds_ns
(
Suts_Cdi
* 
cd
) const;

1661 
ATTACH_OPERATIONS
()

1667 as
	cSuts_Negi
 : 
public
 
Suts_Cdi
 {

1668 
ive
:

1669 
ADD_PROPERTY
(
Suts_Cdi
*, 
cdi
);

1670 
	gpublic
:

1671 
Suts_Negi
(
PrS
 
pe
, 
Suts_Cdi
* 
c
)

1672 : 
Suts_Cdi
(
pe
), 
cdi_
(
c
)

1674 
vtu
 
bo
 
eds_ns
(
Suts_Cdi
* 
cd
) const;

1675 
ATTACH_OPERATIONS
()

1681 as
	cSuts_Dei
 : 
public
 
Suts_Cdi
 {

1682 
ive
:

1683 
ADD_PROPERTY
(
Exessi
*, 
u
);

1684 
ADD_PROPERTY
(
Exessi
*, 
vue
);

1685 
	gpublic
:

1686 
Suts_Dei
(
PrS
 
pe
, 
Exessi
* 
f
, Exessi* 
v
)

1687 : 
Suts_Cdi
(
pe
), 
u_
(
f
), 
vue_
(
v
)

1689 
vtu
 
bo
 
eds_ns
(
Suts_Cdi
* 
cd
cڡ {  
	gl
; }

1690 
ATTACH_OPERATIONS
()

1696 as
	cSuts_Ipީi
 : 
public
 
Suts_Cdi
 {

1697 
ive
:

1698 
ADD_PROPERTY
(
Exessi
*, 
vue
);

1699 
	gpublic
:

1700 
Suts_Ipީi
(
PrS
 
pe
, 
Exessi
* 
v
)

1701 : 
Suts_Cdi
(
pe
), 
vue_
(
v
)

1703 
vtu
 
bo
 
eds_ns
(
Suts_Cdi
* 
cd
cڡ {  
	gl
; }

1704 
ATTACH_OPERATIONS
()

1710 as
	cAt_Ro_Quy
 : 
public
 
Exessi
 {

1711 
ive
:

1712 
ADD_PROPERTY
(
Exessi
*, 
u
)

1713 
ADD_PROPERTY
(
Exessi
*, 
vue
)

1714 
	gpublic
:

1715 
At_Ro_Quy
(
PrS
 
pe
, 
Exessi
* 
f
 = 0, Exessi* 
v
 = 0, 
bo
 
i
 = 
l
)

1716 : 
Exessi
(
pe
), 
u_
(
f
), 
vue_
(
v
)

1718 
bo
 
exude
(
d
::
rg
 
r
);

1719 
ATTACH_OPERATIONS
()

1725 as
	cAt_Ro_Block
 : 
public
 
Has_Block
 {

1726 
ADD_PROPERTY
(
At_Ro_Quy
*, 
exessi
)

1727 
	gpublic
:

1728 
At_Ro_Block
(
PrS
 
pe
, 
Block
* 
b
 = 0, 
At_Ro_Quy
* 
e
 = 0)

1729 : 
Has_Block
(
pe
, 
b
), 
exessi_
(
e
)

1730 { 
emt_ty
(
ATROOT
); }

1731 
bo
 
is_hoiab
({  
	gue
; }

1732 
bo
 
bubbs
({  
	gue
; }

1733 
bo
 
exude_node
(
Smt
* 
s
) {

1734 i(
	gs
->
emt_ty
(=
Smt
::
DIRECTIVE
)

1736  
exessi
()->
exude
(
ic_
<
Deive
*>(
s
)->
keywd
().
a
(0, 1));

1738 i(
	gs
->
emt_ty
(=
Smt
::
MEDIA
)

1740  
exessi
()->
exude
("media");

1742 i(
	gs
->
emt_ty
(=
Smt
::
RULESET
)

1744  
exessi
()->
exude
("rule");

1746 i(
	gs
->
emt_ty
(=
Smt
::
SUPPORTS
)

1748  
exessi
()->
exude
("supports");

1750 i(
	gic_
<
	gDeive
*>(
	gs
)->
is_keyames
())

1752  
exessi
()->
exude
("keyframes");

1754  
	gl
;

1756 
ATTACH_OPERATIONS
()

1762 as
	cNu
 : 
public
 
Vue
 {

1763 
public
:

1764 
Nu
(
PrS
 
pe
: 
Vue
աe{ 
ce_ty
(
NULL_VAL
); }

1765 
	gd
::
rg
 
ty
() {  "null"; }

1766 
	gd
::
rg
 
ty_me
() {  "null"; }

1767 
bo
 
is_visib
(cڡ {  
	gue
; }

1768 
ݔ
 
bo
({  
	gl
; }

1769 
bo
 
is_l
({  
	gue
; }

1771 
vtu
 
size_t
 
hash
()

1776 
vtu
 
bo
 
	gݔ
=(cڡ 
Exessi
& 
rhs
) const;

1778 
ATTACH_OPERATIONS
()

1784 as
	cThunk
 : 
public
 
Exessi
 {

1785 
ADD_PROPERTY
(
Exessi
*, 
exessi
)

1786 
ADD_PROPERTY
(
Env
*, 
vmt
)

1787 
	gpublic
:

1788 
Thunk
(
PrS
 
pe
, 
Exessi
* 
exp
, 
Env
* 
v
 = 0)

1789 : 
Exessi
(
pe
), 
exessi_
(
exp
), 
vmt_
(
v
)

1796 as
	cPam
 : 
public
 
AST_Node
 {

1797 
ADD_PROPERTY
(
d
::
rg
, 
me
)

1798 
ADD_PROPERTY
(
Exessi
*, 
deu_vue
)

1799 
ADD_PROPERTY
(
bo
, 
is__m
)

1800 
	gpublic
:

1801 
Pam
(
PrS
 
pe
,

1802 
d
::
rg
 
n
, 
Exessi
* 
def
 = 0, 
bo
 

 = 
l
)

1803 : 
AST_Node
(
pe
), 
me_
(
n
), 
deu_vue_
(
def
), 
is__m_
(

)

1805 i(
	gdeu_vue_
 && 
	gis__m_
) {

1806 
r
("vb-ngtham may havdeu vue", 
pe
);

1809 
ATTACH_OPERATIONS
()

1817 
ass
 
	gPams
 : 
public
 
AST_Node
,ubli
	gVeized
<
	gPam
*> {

1818 
ADD_PROPERTY
(
bo
, 
has_tiڮ_ms
)

1819 
ADD_PROPERTY
(
bo
, 
has__m
)

1820 
	geed
:

1821 
adju_a_pushg
(
Pam
* 
p
)

1823 i(
p
->
deu_vue
()) {

1824 i(
has__m_
) {

1825 
r
("tiڮammay bcombed wh vb-ngthams", 
p
->
pe
());

1827 
	ghas_tiڮ_ms_
 = 
ue
;

1829 i(
	gp
->
is__m
()) {

1830 i(
	ghas__m_
) {

1831 
r
("funiڠd mix havmܐth o vb-ngtham", 
p
->
pe
());

1833 
	ghas__m_
 = 
ue
;

1836 i(
	ghas__m_
) {

1837 
r
("quedammudvb-ngthams", 
p
->
pe
());

1839 i(
	ghas_tiڮ_ms_
) {

1840 
r
("quedammudtiڮams", 
p
->
pe
());

1844 
	gpublic
:

1845 
Pams
(
PrS
 
pe
)

1846 : 
AST_Node
(
pe
),

1847 
	gVeized
<
	gPam
*>(),

1848 
has_tiڮ_ms_
(
l
),

1849 
has__m_
(
l
)

1851 
ATTACH_OPERATIONS
()

1857 as
	cSe
 : 
public
 
Exessi
 {

1859 
ADD_PROPERTY
(
bo
, 
has_ahd
)

1861 
ADD_PROPERTY
(
bo
, 
has_le_ed
)

1863 
ADD_PROPERTY
(
bo
, 
has_le_bak
)

1865 
ADD_PROPERTY
(
bo
, 
is_tiڮ
)

1867 
ADD_PROPERTY
(
Med_Block
*, 
med_block
)

1868 
	geed
:

1869 
size_t
 
hash_
;

1870 
	gpublic
:

1871 
Se
(
PrS
 
pe
, 
bo
 
r
 = 
l
, bo 
h
 = false)

1872 : 
Exessi
(
pe
),

1874 
has_ahd_
(
h
),

1875 
has_le_ed_
(
l
),

1876 
has_le_bak_
(
l
),

1877 
is_tiڮ_
(
l
),

1878 
med_block_
(0),

1879 
hash_
(0)

1880 { 
ce_ty
(
SELECTOR
); }

1881 
	gvtu
 ~
Se
() = 0;

1882 
vtu
 
size_t
 
hash
() = 0;

1883 
vtu
 
bo
 
has__f
() {

1884  
	gl
;

1886 
vtu
 
ecificy
() {

1887  
	gCڡts
::
Scificy_Univl
;

1889 
vtu
 
t_med_block
(
Med_Block
* 
mb
) {

1890 
med_block
(
mb
);

1893 
le
 
	gSe
::~
	$Se
({ 
	}
}

1899 as
	cSe_Schema
 : 
public
 
Se
 {

1900 
ADD_PROPERTY
(
Sg
*, 
cڋs
)

1901 
ADD_PROPERTY
(
bo
, 
_ro
);

1902 
	gpublic
:

1903 
Se_Schema
(
PrS
 
pe
, 
Sg
* 
c
)

1904 : 
Se
(
pe
), 
cڋs_
(
c
), 
_ro_
(
l
)

1906 
vtu
 
bo
 
has__f
();

1907 
vtu
 
size_t
 
hash
() {

1908 i(
	ghash_
 == 0) {

1909 
hash_combe
(
hash_
, 
cڋs_
->
hash
());

1911  
	ghash_
;

1913 
ATTACH_OPERATIONS
()

1919 as
	cSime_Se
 : 
public
 
Se
 {

1920 
ADD_PROPERTY
(
d
::
rg
, 
ns
);

1921 
ADD_PROPERTY
(
d
::
rg
, 
me
)

1922 
ADD_PROPERTY
(
bo
, 
has_ns
)

1923 
	gpublic
:

1924 
Sime_Se
(
PrS
 
pe
, 
d
::
rg
 
n
 = "")

1925 : 
Se
(
pe
), 
ns_
(""), 
me_
(
n
), 
has_ns_
(
l
)

1927 
size_t
 
	gpos
 = 
n
.
fd
('|');

1929 i(
	gpos
 !
d
::
rg
::
os
) {

1930 
has_ns_
 = 
ue
;

1931 
	gns_
 = 
n
.
subr
(0, 
pos
);

1932 
	gme_
 = 
n
.
subr
(
pos
 + 1);

1935 
vtu
 
	gd
::
rg
 
ns_me
() const

1937 
d
::
rg
 
me
("");

1938 i(
	ghas_ns_
)

1939 
	gme
 +
ns_
 + "|";

1940  
	gme
 + 
	gme_
;

1942 
vtu
 
size_t
 
hash
()

1944 i(
	ghash_
 == 0) {

1945 
hash_combe
(
hash_
, 
d
::
hash
<>()(
SELECTOR
));

1946 
hash_combe
(
hash_
, 
d
::
hash
<d::
rg
>()(
ns
()));

1947 
hash_combe
(
hash_
, 
d
::
hash
<d::
rg
>()(
me
()));

1949  
	ghash_
;

1952 
bo
 
is_univl_ns
() const

1954  
	ghas_ns_
 && 
	gns_
 == "*";

1956 
bo
 
has_univl_ns
() const

1958  !
	ghas_ns_
 || 
	gns_
 == "*";

1960 
bo
 
is_emy_ns
() const

1962  !
	ghas_ns_
 || 
	gns_
 == "";

1964 
bo
 
has_emy_ns
() const

1966  
	ghas_ns_
 && 
	gns_
 == "";

1968 
bo
 
has_quifd_ns
() const

1970  
	ghas_ns_
 && 
	gns_
 !"" && 
ns_
 != "*";

1973 
bo
 
is_univl
() const

1975  
	gme_
 == "*";

1978 
	gvtu
 ~
Sime_Se
() = 0;

1979 
vtu
 
Compound_Se
* 
unify_wh
(Compound_Se*, 
Cڋxt
&);

1980 
vtu
 
bo
 
has__f
({  
	gl
; };

1981 
vtu
 
bo
 
is_pudo_emt
({  
	gl
; }

1982 
vtu
 
bo
 
is_pudo_ass
({  
	gl
; }

1984 
vtu
 
bo
 
is_sur_of
(
Compound_Se
* 
sub
{  
	gl
; }

1986 
bo
 
	gݔ
==(cڡ 
Sime_Se
& 
rhs
) const;

1987 
le
 
bo
 
	gݔ
!=(cڡ 
Sime_Se
& 
rhs
cڡ {  !(*
this
 ==hs); }

1989 
bo
 
	gݔ
<(cڡ 
	gSime_Se
& 
	grhs
) const;

1991 
ATTACH_OPERATIONS
();

1993 
le
 
	gSime_Se
::~
	$Sime_Se
({ 
	}
}

2002 as
	cPt_Se
 : 
public
 
Sime_Se
 {

2003 
public
:

2004 
Pt_Se
(
PrS
 
pe
)

2005 : 
Sime_Se
(
pe
, "&")

2007 
vtu
 
bo
 
has__f
({  
	gue
; };

2008 
vtu
 
ecificy
()

2012 
	gd
::
rg
 
ty
() {  "selector"; }

2013 
	gd
::
rg
 
ty_me
() {  "selector"; }

2014 
ATTACH_OPERATIONS
()

2020 as
	cSe_Phd
 : 
public
 
Sime_Se
 {

2021 
public
:

2022 
Se_Phd
(
PrS
 
pe
, 
d
::
rg
 
n
)

2023 : 
Sime_Se
(
pe
, 
n
)

2024 { 
has_ahd
(
ue
); }

2026 
	gvtu
 ~
Se_Phd
() {};

2027 
ATTACH_OPERATIONS
()

2033 as
	cTy_Se
 : 
public
 
Sime_Se
 {

2034 
public
:

2035 
Ty_Se
(
PrS
 
pe
, 
d
::
rg
 
n
)

2036 : 
Sime_Se
(
pe
, 
n
)

2038 
vtu
 
ecificy
()

2041 i(
me
(="*" 
Cڡts
::
Scificy_Univl
;

2042  
	gCڡts
::
Scificy_Ty
;

2044 
vtu
 
Sime_Se
* 
unify_wh
(Sime_Se*, 
Cڋxt
&);

2045 
vtu
 
Compound_Se
* 
unify_wh
(Compound_Se*, 
Cڋxt
&);

2046 
ATTACH_OPERATIONS
()

2052 as
	cSe_Quifr
 : 
public
 
Sime_Se
 {

2053 
public
:

2054 
Se_Quifr
(
PrS
 
pe
, 
d
::
rg
 
n
)

2055 : 
Sime_Se
(
pe
, 
n
)

2057 
vtu
 
ecificy
()

2059 i(
me
()[0] ='#' 
Cڡts
::
Scificy_ID
;

2060 i(
me
()[0] ='.' 
Cڡts
::
Scificy_Css
;

2061  
	gCڡts
::
Scificy_Ty
;

2063 
vtu
 
Compound_Se
* 
unify_wh
(Compound_Se*, 
Cڋxt
&);

2064 
ATTACH_OPERATIONS
()

2070 as
	cAribu_Se
 : 
public
 
Sime_Se
 {

2071 
ADD_PROPERTY
(
d
::
rg
, 
mch
)

2072 
ADD_PROPERTY
(
Sg
*, 
vue
)

2073 
	gpublic
:

2074 
Aribu_Se
(
PrS
 
pe
, 
d
::
rg
 
n
, std::rg 
m
, 
Sg
* 
v
)

2075 : 
Sime_Se
(
pe
, 
n
), 
mch_
(
m
), 
vue_
(
v
)

2077 
vtu
 
size_t
 
hash
()

2079 i(
	ghash_
 == 0) {

2080 
hash_combe
(
hash_
, 
Sime_Se
::
hash
());

2081 
hash_combe
(
hash_
, 
d
::
hash
<d::
rg
>()(
mch
()));

2082 i(
	gvue_

hash_combe
(
hash_
, 
vue_
->
hash
());

2084  
	ghash_
;

2086 
vtu
 
ecificy
()

2088  
	gCڡts
::
Scificy_Ar
;

2090 
bo
 
	gݔ
==(cڡ 
Sime_Se
& 
rhs
) const;

2091 
bo
 
	gݔ
==(cڡ 
Aribu_Se
& 
rhs
) const;

2092 
bo
 
	gݔ
<(cڡ 
	gSime_Se
& 
	grhs
) const;

2093 
bo
 
	gݔ
<(cڡ 
	gAribu_Se
& 
	grhs
) const;

2094 
ATTACH_OPERATIONS
()

2104 
le
 
bo
 
	$is_pudo_ass_emt
(cڡ 
d
::
rg
& 
me
)

2106  
me
 == ":before" ||

2107 
me
 == ":after" ||

2108 
me
 == ":first-line" ||

2109 
me
 == ":first-letter";

2110 
	}
}

2113 as
	cPudo_Se
 : 
public
 
Sime_Se
 {

2114 
ADD_PROPERTY
(
Sg
*, 
exessi
)

2115 
	gpublic
:

2116 
Pudo_Se
(
PrS
 
pe
, 
d
::
rg
 
n
, 
Sg
* 
ex
 = 0)

2117 : 
Sime_Se
(
pe
, 
n
), 
exessi_
(
ex
)

2122 
vtu
 
bo
 
is_pudo_ass
()

2124  (
	gme_
[0] =':' && 
me_
[1] != ':')

2125 && ! 
is_pudo_ass_emt
(
me_
);

2136 
vtu
 
bo
 
is_pudo_emt
()

2138  (
	gme_
[0] =':' && 
me_
[1] == ':')

2139 || 
is_pudo_ass_emt
(
me_
);

2141 
vtu
 
size_t
 
hash
()

2143 i(
	ghash_
 == 0) {

2144 
hash_combe
(
hash_
, 
Sime_Se
::
hash
());

2145 i(
	gexessi_

hash_combe
(
hash_
, 
exessi_
->
hash
());

2147  
	ghash_
;

2149 
vtu
 
ecificy
()

2151 i(
is_pudo_emt
())

2152  
	gCڡts
::
Scificy_Ty
;

2153  
	gCڡts
::
Scificy_Pudo
;

2155 
bo
 
	gݔ
==(cڡ 
Sime_Se
& 
rhs
) const;

2156 
bo
 
	gݔ
==(cڡ 
Pudo_Se
& 
rhs
) const;

2157 
bo
 
	gݔ
<(cڡ 
	gSime_Se
& 
	grhs
) const;

2158 
bo
 
	gݔ
<(cڡ 
	gPudo_Se
& 
	grhs
) const;

2159 
vtu
 
Compound_Se
* 
unify_wh
(Compound_Se*, 
Cڋxt
&);

2160 
ATTACH_OPERATIONS
()

2166 as
	cWed_Se
 : 
public
 
Sime_Se
 {

2167 
ADD_PROPERTY
(
Se
*, 

)

2168 
	gpublic
:

2169 
Wed_Se
(
PrS
 
pe
, 
d
::
rg
 
n
, 
Se
* 
l
)

2170 : 
Sime_Se
(
pe
, 
n
), 
_
(
l
)

2172 
vtu
 
bo
 
has__f
() {

2174 i(!

() 
	gl
;

2175  

()->
has__f
();

2177 
vtu
 
bo
 
is_sur_of
(
Wed_Se
* 
sub
);

2180 
vtu
 
size_t
 
hash
()

2182 i(
	ghash_
 == 0) {

2183 
hash_combe
(
hash_
, 
Sime_Se
::
hash
());

2184 i(
	g_

hash_combe
(
hash_
, 
_
->
hash
());

2186  
	ghash_
;

2188 
vtu
 
ecificy
()

2190  
	g_
 ? se_->
ecificy
() : 0;

2192 
bo
 
	gݔ
==(cڡ 
Sime_Se
& 
rhs
) const;

2193 
bo
 
	gݔ
==(cڡ 
Wed_Se
& 
rhs
) const;

2194 
bo
 
	gݔ
<(cڡ 
	gSime_Se
& 
	grhs
) const;

2195 
bo
 
	gݔ
<(cڡ 
	gWed_Se
& 
	grhs
) const;

2196 
ATTACH_OPERATIONS
()

2199 
	sComex_Se_Por_Com
 {

2200 
bo
 
ݔ
((cڡ 
Comex_Se
* cڡ 
	gpLe
, cڡ Comex_Se* cڡ 
	gpRight
) const;

2207 
	gd
::
	tt
<
	tComex_Se
*, 
	tComex_Se_Por_Com
> 
	tSoursS
;

2208 
ass
 
	gCompound_Se
 : 
public
 
Se
,ubli
	gVeized
<
	gSime_Se
*> {

2209 
	give
:

2210 
SoursS
 
sours_
;

2211 
ADD_PROPERTY
(
bo
, 
exnded
);

2212 
ADD_PROPERTY
(
bo
, 
has__n
);

2213 
	geed
:

2214 
adju_a_pushg
(
Sime_Se
* 
s
)

2217 i(
s
->
has_ahd
()has_ahd(
ue
);

2219 
	gpublic
:

2220 
Compound_Se
(
PrS
 
pe
, 
size_t
 
s
 = 0)

2221 : 
Se
(
pe
),

2222 
	gVeized
<
	gSime_Se
*>(
	gs
),

2223 
exnded_
(
l
),

2224 
has__n_
(
l
)

2226 
bo
 
cڏs_ahd
() {

2227 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i) {

2228 i((*
	gthis
)[
i
]->
has_ahd
() 
	gue
;

2230  
	gl
;

2233 
bo
 
is_univl
() const

2235  
ngth
(=1 && (*
this
)[0]->
is_univl
();

2238 
Comex_Se
* 
to_comex
(
Memy_Mag
& 
mem
);

2239 
Compound_Se
* 
unify_wh
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
);

2241 
vtu
 
bo
 
has__f
();

2242 
Sime_Se
* 
ba
()

2245  
	gcڡ_
<
	gSime_Se
*>(
	gic_
<cڡ 
	gCompound_Se
*>(
	gthis
)->
ba
());

2247 cڡ 
Sime_Se
* 
ba
() const {

2248 i(
ngth
() == 0)  0;

2250 i(
	gdymic_
<
	gTy_Se
*>((*
	gthis
)[0]))

2251  (*
	gthis
)[0];

2254 
vtu
 
bo
 
is_sur_of
(
Compound_Se
* 
sub
, 
d
::
rg
 
wed
 = "");

2255 
vtu
 
bo
 
is_sur_of
(
Comex_Se
* 
sub
, 
d
::
rg
 
wed
 = "");

2256 
vtu
 
bo
 
is_sur_of
(
Se_Li
* 
sub
, 
d
::
rg
 
wed
 = "");

2257 
vtu
 
size_t
 
hash
()

2259 i(
	gSe
::
hash_
 == 0) {

2260 
hash_combe
(
Se
::
hash_
, 
d
::
hash
<>()(
SELECTOR
));

2261 i(
ngth
()
hash_combe
(
Se
::
hash_
, 
Veized
::
hash
());

2263  
	gSe
::
hash_
;

2265 
vtu
 
ecificy
()

2267 
	gsum
 = 0;

2268 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

2269 { 
	gsum
 +(*
this
)[
i
]->
ecificy
(); }

2270  
	gsum
;

2273 
bo
 
is_emy_n
()

2275  
ngth
() == 1 &&

2276 
dymic_
<
Pt_Se
*>((*
this
)[0]);

2278 
	gd
::
ve
<
d
::
rg
> 
to_r_vec
();

2280 
bo
 
	gݔ
<(cڡ 
	gCompound_Se
& 
	grhs
) const;

2282 
bo
 
	gݔ
==(cڡ 
Compound_Se
& 
rhs
) const;

2283 
le
 
bo
 
	gݔ
!=(cڡ 
Compound_Se
& 
rhs
cڡ {  !(*
this
 ==hs); }

2285 
	gSoursS
& 
sours
({  
	gsours_
; }

2286 
rSours
({ 
	gsours_
.
r
(); }

2287 
mgeSours
(
SoursS
& 
sours
, 
Cڋxt
& 
x
);

2289 
Compound_Se
* 
e
(
Cڋxt
&) const;

2291 
Compound_Se
* 
mus
(Compound_Se* 
rhs
, 
Cڋxt
& 
x
);

2292 
ATTACH_OPERATIONS
()

2300 as
	cComex_Se
 : 
public
 
Se
 {

2301 
public
:

2302 
	eComb
 { 
ANCESTOR_OF
, 
	gPARENT_OF
, 
	gPRECEDES
, 
	gADJACENT_TO
, 
	gREFERENCE
 };

2303 
	give
:

2304 
ADD_PROPERTY
(
Comb
, 
comb
)

2305 
ADD_PROPERTY
(
Compound_Se
*, 
hd
)

2306 
ADD_PROPERTY
(
Comex_Se
*, 

)

2307 
ADD_PROPERTY
(
Sg
*, 
n
);

2308 
	gpublic
:

2309 
bo
 
cڏs_ahd
() {

2310 i(
hd
(&& hd()->
cڏs_ahd
() 
ue
;

2311 i(

(&&a()->
cڏs_ahd
() 
	gue
;

2312  
	gl
;

2314 
Comex_Se
(
PrS
 
pe
,

2315 
Comb
 
c
 = 
ANCESTOR_OF
,

2316 
Compound_Se
* 
h
 = 0,

2317 
Comex_Se
* 
t
 = 0,

2318 
Sg
* 
r
 = 0)

2319 : 
Se
(
pe
),

2320 
comb_
(
c
),

2321 
hd_
(
h
), 
_
(
t
),

2322 
n_
(
r
)

2325 i((
	gh
 && h->
has_ahd
()|| (
	gt
 &&->has_ahd())has_ahd(
ue
);

2327 
vtu
 
bo
 
has__f
();

2329 
Comex_Se
* 
sk_emy_n
()

2331 i((!
	ghd_
 || !hd_->
ngth
(|| hd_->
is_emy_n
()) &&

2332 
comb
(=
Comb
::
ANCESTOR_OF
)

2334 i(!
_
)  0;

2335 
	g_
->
	ghas_le_ed_
 = 
this
->
has_le_ed_
;

2337  
	g_
->
sk_emy_n
();

2339  
	gthis
;

2343 
bo
 
is_emy_
() const

2345  (!
hd
(|| hd()->
ngth
() == 0) &&

2346 
comb
(=
Comb
::
ANCESTOR_OF
;

2349 
Comex_Se
* 
cڋxt
(
Cڋxt
&);

2354 cڡ 
Comex_Se
* 
f
() const;

2357 cڡ 
Comex_Se
* 
ϡ
() const;

2359 
Se_Li
* 
s
(
Cڋxt
& 
x
, Selector_List*ails);

2362 
Comex_Se
* 
f
();

2363 
Comex_Se
* 
ϡ
();

2366 cڡ 
Comex_Se
* 
rmo
(cڡ {  
ϡ
(); };

2367 
Comex_Se
* 
rmo
({  
ϡ
(); };

2369 
size_t
 
ngth
() const;

2370 
Se_Li
* 
ize
(Se_Li* 
s
, 
Cڋxt
& 
x
);

2371 
vtu
 
bo
 
is_sur_of
(
Compound_Se
* 
sub
, 
d
::
rg
 
wg
 = "");

2372 
vtu
 
bo
 
is_sur_of
(
Comex_Se
* 
sub
, 
d
::
rg
 
wg
 = "");

2373 
vtu
 
bo
 
is_sur_of
(
Se_Li
* 
sub
, 
d
::
rg
 
wg
 = "");

2375 
Se_Li
* 
unify_wh
(
Comex_Se
* 
rhs
, 
Cڋxt
& 
x
);

2376 
Comb
 
r_rmo
();

2377 
nd
(
Cڋxt
&, 
Comex_Se
*);

2378 
t_rmo
(
Comex_Se
*, 
Comb
);

2379 
vtu
 
size_t
 
hash
()

2381 i(
	ghash_
 == 0) {

2382 
hash_combe
(
hash_
, 
d
::
hash
<>()(
SELECTOR
));

2383 
hash_combe
(
hash_
, 
d
::
hash
<>()(
comb_
));

2384 i(
	ghd_

hash_combe
(
hash_
, 
hd_
->
hash
());

2385 i(
	g_

hash_combe
(
hash_
, 
_
->
hash
());

2387  
	ghash_
;

2389 
vtu
 
ecificy
() const

2391 
	gsum
 = 0;

2392 i(
hd
()
	gsum
 +hd()->
ecificy
();

2393 i(

()
	gsum
 +()->
ecificy
();

2394  
	gsum
;

2396 
vtu
 
t_med_block
(
Med_Block
* 
mb
) {

2397 
med_block
(
mb
);

2398 i(
	g_
菞_->
t_med_block
(
mb
);

2399 i(
	ghd_
hd_->
t_med_block
(
mb
);

2401 
bo
 
	gݔ
<(cڡ 
	gComex_Se
& 
	grhs
) const;

2402 
bo
 
	gݔ
==(cڡ 
Comex_Se
& 
rhs
) const;

2403 
le
 
bo
 
	gݔ
!=(cڡ 
Comex_Se
& 
rhs
cڡ {  !(*
this
 ==hs); }

2404 
SoursS
 
sours
()

2410 
SoursS
 
	gcs
;

2412 
Compound_Se
* 
	gpHd
 = 
hd
();

2413 
Comex_Se
* 
	gpTa
 = 

();

2415 i(
	gpHd
) {

2416 
	gSoursS
& 
	ghdSours
 = 
pHd
->
sours
();

2417 
	gcs
.

(
hdSours
.
beg
(), hdSours.
d
());

2420 i(
	gpTa
) {

2421 
SoursS
 
	gSours
 = 
pTa
->
sours
();

2422 
	gcs
.

(
Sours
.
beg
(),aSours.
d
());

2425  
	gcs
;

2427 
addSours
(
SoursS
& 
sours
, 
Cڋxt
& 
x
) {

2429 
Comex_Se
* 
	gpIr
 = 
this
;

2430 
	gpIr
) {

2431 
Compound_Se
* 
	gpHd
 = 
pIr
->
hd
();

2433 i(
	gpHd
) {

2434 
	gpHd
->
mgeSours
(
sours
, 
x
);

2437 
	gpIr
 = 
pIr
->

();

2440 
rSours
() {

2441 
Comex_Se
* 
	gpIr
 = 
this
;

2442 
	gpIr
) {

2443 
Compound_Se
* 
	gpHd
 = 
pIr
->
hd
();

2445 i(
	gpHd
) {

2446 
	gpHd
->
rSours
();

2449 
	gpIr
 = 
pIr
->

();

2452 
Comex_Se
* 
e
(
Cڋxt
&) const;

2453 
Comex_Se
* 
eFuy
(
Cڋxt
&) const;

2455 
ATTACH_OPERATIONS
()

2458 
	gd
::
	tdeque
<
	tComex_Se
*> 
	tComexSeDeque
;

2459 
	gSubt_M
<
	td
::
	trg
, std::
	t
<
	tComex_Se
*, 
	tCompound_Se
*> > 
	tExnsiSubtM
;

2464 
ass
 
	gSe_Li
 : 
public
 
Se
,ubli
	gVeized
<
	gComex_Se
*> {

2465 
ADD_PROPERTY
(
d
::
ve
<d::
rg
>, 
wa
)

2466 
	geed
:

2467 
adju_a_pushg
(
Comex_Se
* 
c
);

2468 
	gpublic
:

2469 
Se_Li
(
PrS
 
pe
, 
size_t
 
s
 = 0)

2470 : 
Se
(
pe
), 
	gVeized
<
	gComex_Se
*>(
	gs
), 
wa_
(0)

2472 
	gd
::
rg
 
ty
() {  "list"; }

2475 
vtu
 
bo
 
has__f
();

2476 
move__s
();

2478 
Se_Li
* 
ize
(Se_Li* 
s
, 
Cڋxt
& 
x
);

2479 
vtu
 
bo
 
is_sur_of
(
Compound_Se
* 
sub
, 
d
::
rg
 
wg
 = "");

2480 
vtu
 
bo
 
is_sur_of
(
Comex_Se
* 
sub
, 
d
::
rg
 
wg
 = "");

2481 
vtu
 
bo
 
is_sur_of
(
Se_Li
* 
sub
, 
d
::
rg
 
wg
 = "");

2482 
Se_Li
* 
unify_wh
(Se_Li*, 
Cڋxt
&);

2483 
puϋ_exnds
(
Se_Li
*, 
Cڋxt
&, 
ExnsiSubtM
&);

2484 
vtu
 
size_t
 
hash
()

2486 i(
	gSe
::
hash_
 == 0) {

2487 
hash_combe
(
Se
::
hash_
, 
d
::
hash
<>()(
SELECTOR
));

2488 
hash_combe
(
Se
::
hash_
, 
Veized
::
hash
());

2490  
	gSe
::
hash_
;

2492 
vtu
 
ecificy
()

2494 
	gsum
 = 0;

2495 
	gecificy
 = 0;

2496 
size_t
 
	gi
 = 0, 
	gL
 = 
ngth
(); i < L; ++i)

2498 
	gecificy
 = (*
this
)[
i
]->
ecificy
();

2499 i(
	gsum
 < 
	gecificy
sum = 
ecificy
;

2501  
	gsum
;

2503 
vtu
 
t_med_block
(
Med_Block
* 
mb
) {

2504 
med_block
(
mb
);

2505 
Comex_Se
* 
	gcs
 : 
emts
()) {

2506 
cs
->
t_med_block
(
mb
);

2509 
Se_Li
* 
e
(
Cڋxt
&) const;

2510 
Se_Li
* 
eFuy
(
Cڋxt
&) const;

2511 
vtu
 
bo
 
	gݔ
==(cڡ 
Se
& 
rhs
) const;

2512 
vtu
 
bo
 
	gݔ
==(cڡ 
Se_Li
& 
rhs
) const;

2514 
vtu
 
bo
 
	gݔ
==(cڡ 
Exessi
& 
rhs
) const;

2515 
ATTACH_OPERATIONS
()

2518 
	gme
<
tyme
 
	gSeTy
>

2519 
bo
 
	$s_equ
(cڡ 
SeTy
& 
e
, cڡ SeTy& 
two
, 
bo
 
simeSeOrdDdt
) {

2529 i(
simeSeOrdDdt
) {

2530  !(
e
 < 
two
) && !(two < one);

2532  
e
 =
two
;

2534 
	}
}

2537 
	scmp_comex_
 { 
le
 
bo
 
ݔ
((cڡ 
Comex_Se
* 
	gl
, cڡ Comex_Se* 
	gr
) {  (*l < *r); } };

2538 
	scmp_compound_
 { 
le
 
bo
 
ݔ
((cڡ 
Compound_Se
* 
	gl
, cڡ Compound_Se* 
	gr
) {  (*l < *r); } };

2539 
	scmp_sime_
 { 
le
 
bo
 
ݔ
((cڡ 
Sime_Se
* 
	gl
, cڡ Sime_Se* 
	gr
) {  (*l < *r); } };

2543 #ifde
__g__


2545 #agm
g
 
dgnoic
 
p


	@node_modules/node-sass/src/libsass/src/ast_def_macros.hpp

1 #ide
SASS_AST_DEF_MACROS_H


2 
	#SASS_AST_DEF_MACROS_H


	)

5 
	gme
 <
ass
 
	gT
>

6 as
	cLolOi
 {

7 
	mive
:

8 
T
* 
v
;

9 
T
 
	mig
;

10 
	mpublic
:

11 
	$LolOi
(
T
& 
v
)

13 
this
->
v
 = &var;

14 
this
->
ig
 = 
v
;

16 
	$LolOi
(
T
& 
v
, T 
ig
)

18 
this
->
v
 = &var;

19 
this
->
ig
 = 
v
;

20 *(
this
->
v

ig
;

21 
	}
}

22 ~
	$LolOi
() {

23 *(
this
->
v
this->
ig
;

24 
	}
}

27 
	#LOCAL_FLAG
(
me
,
t

LolOi
<
bo
> 
ag_
##
	`me
ame, o)

	)

29 
	#ATTACH_OPERATIONS
()\

30 
vtu
 
	`rfm
(
Oti
<>* 

{ (*)(
this
); }\

31 
vtu
 
AST_Node
* 
	`rfm
(
Oti
<AST_Node*>* 

{  (*)(
this
); }\

32 
vtu
 
Smt
* 
	`rfm
(
Oti
<Smt*>* 

{  (*)(
this
); }\

33 
vtu
 
Exessi
* 
	`rfm
(
Oti
<Exessi*>* 

{  (*)(
this
); }\

34 
vtu
 
Se
* 
	`rfm
(
Oti
<Se*>* 

{  (*)(
this
); }\

35 
vtu
 
d
::
rg
 
	`rfm
(
Oti
<d::rg>* 

{  (*)(
this
); }\

36 
vtu
 
Sass_Vue
* 
	`rfm
(
Oti
<Sass_Vue*>* 

{  (*)(
this
); }\

37 
vtu
 
Vue
* 
	`rfm
(
Oti
<Vue*>* 

{  (*)(
this
); }

	)

39 
	#ADD_PROPERTY
(
ty
, 
me
)\

40 
eed
:\

41 
ty
 
me
##
_
;\

42 
public
:\

43 
ty
 
	`me
(cڡ {  
me
##
_
; }\

44 
ty
 
	`me
y 
me
##
__
{ ame##
_
 =ame##__; }\

45 
ive
:

	)

47 
	#ADD_HASHED
(
ty
, 
me
)\

48 
eed
:\

49 
ty
 
me
##
_
;\

50 
public
:\

51 
ty
 
	`me
(cڡ {  
me
##
_
; }\

52 
ty
 
	`me
y 
me
##
__
{ 
hash_
 = 0; ame##
_
 =ame##__; }\

53 
ive
:

	)

	@node_modules/node-sass/src/libsass/src/ast_factory.hpp

1 #ide
SASS_AST_FACTORY_H


2 
	#SASS_AST_FACTORY_H


	)

4 
	~<ve
>

6 
	~"a.h
"

8 
mea
 
	gSass
 {

10 as
	cAST_Fay
 {

11 
	gd
::
ve
<
AST_Node
*> 
nodes
;

12 
	gpublic
:

14 
Block
* 
w_Block
(
d
::
rg
 
p
, 
size_t
 
l
, size_
s
 = 0, 
bo
 
r
 = 
l
);

15 
Ruˣt
* 
w_Ruˣt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Se
* 
s
, 
Block
* 
b
);

16 
Prݣt
* 
w_Prݣt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 
pf
, 
Block
* 
b
);

17 
Suts_Quy
* 
w_Suts_Quy
(
d
::
rg
 
p
, 
size_t
 
l
, Suts_Quy* 
f
, 
Block
* 
b
);

18 
Med_Quy
* 
w_Med_Quy
(
d
::
rg
 
p
, 
size_t
 
l
, 
Li
* 
q
, 
Block
* 
b
);

19 
At_Ro_Block
* 
w_At_Ro_Block
(
d
::
rg
 
p
, 
size_t
 
l
, 
Se
* 
l
, 
Block
* 
b
);

20 
Deive
* 
w_At_Ru
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
kwd
, 
Se
* 
l
, 
Block
* 
b
);

21 
Keyame_Ru
* 
w_Keyame_Ru
(
d
::
rg
 
p
, 
size_t
 
l
, 
Block
* 
b
);

22 
Dei
* 
w_Dei
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 

, 
Li
* 
vs
);

23 
Assignmt
* 
w_Assignmt
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
v
, 
Exessi
* 
v
, 
bo
 
guded
 = 
l
);

24 
	gImpt
<
	gFuni_Cl
*>* 
w_CSS_Impt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Funi_Cl
* 
loc
);

25 
	gImpt
<
	gSg
*>* 
w_SASS_Impt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 
loc
);

26 
Cuom_Wng
* 
w_Cuom_Wng
(
d
::
rg
 
msg
, 
size_t
 
l
, std::string msg);

27 
Cuom_E
* 
w_Cuom_E
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
msg
);

28 
Wng
* 
w_Wng
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
msg
);

29 
E
* 
w_E
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
msg
);

30 
Debug
* 
w_Debug
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
v
);

31 
Commt
* 
w_Commt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 
txt
);

32 
If
* 
w_If
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
ed
, 
Block
* 
c
, Block* 
t
 = 0);

33 
F
* 
w_F
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
v
, 
Exessi
* 
lo
, Exessi* 
hi
, 
Block
* 
b
, 
bo
 
c
);

34 
Each
* 
w_Each
(
d
::
rg
 
p
, 
size_t
 
l
, std::
ve
<d::rg> 
vs
, 
Exessi
* 
l
, 
Block
* 
b
);

35 
Whe
* 
w_Whe
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
ed
, 
Block
* 
b
);

36 
Exnsi
* 
w_Exnsi
(
d
::
rg
 
p
, 
size_t
 
l
, 
Se
* 
s
);

37 
	gDefi
<
	gMIXIN
>* 
w_Mix_Defi
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
, 
Pams
* 
ms
, 
Block
* 
b
);

38 
	gDefi
<
	gFUNCTION
>* 
w_Funi_Defi
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
, 
Pams
* 
ms
, 
Block
* 
b
);

39 
Mix_Cl
* 
w_Mix_Cl
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
, 
Argumts
* 
gs
, 
Block
* 
b
 = 0);

41 
Li
* 
w_Li
(
d
::
rg
 
p
, 
size_t
 
l
, size_
size
 = 0, 
Sass_S
 
p
 = Li::
a
, 
bo
 
gl
 = 
l
);

42 
M
* 
w_M
(
d
::
rg
 
p
, 
size_t
 
l
, size_
size
 = 0);

43 
	gBy_Exessi
<
	gAND
>* 
w_And
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

44 
	gBy_Exessi
<
	gOR
>* 
w_Or
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

45 
	gBy_Exessi
<
	gEQ
>* 
w_Eq
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

46 
	gBy_Exessi
<
	gNEQ
>* 
w_Neq
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

47 
	gBy_Exessi
<
	gGT
>* 
w_Gt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

48 
	gBy_Exessi
<
	gGTE
>* 
w_G
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

49 
	gBy_Exessi
<
	gLT
>* 
w_Lt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

50 
	gBy_Exessi
<
	gLTE
>* 
w_L
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

51 
	gBy_Exessi
<
	gADD
>* 
w_Add
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

52 
	gBy_Exessi
<
	gSUB
>* 
w_Sub
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

53 
	gBy_Exessi
<
	gMUL
>* 
w_Mul
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

54 
	gBy_Exessi
<
	gDIV
>* 
w_Div
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
lhs
, Exessi* 
rhs
);

55 
Negi
* 
w_Negi
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
o
);

56 
Funi_Cl
* 
w_Funi_Cl
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 
n
, 
Argumts
* 
gs
);

57 
Vb
* 
w_Vb
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
);

58 
	gTextu
<
	gNUMBER
>* 
w_Textu_Numb
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
v
);

59 
	gTextu
<
	gPERCENTAGE
>* 
w_Textu_Page
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
v
);

60 
	gTextu
<
	gDIMENSION
>* 
w_Textu_Dimsi
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
v
);

61 
	gTextu
<
	gHEX
>* 
w_Textu_Hex
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
v
);

62 
Numb
* 
w_Numb
(
d
::
rg
 
p
, 
size_t
 
l
, 
v
);

63 
Page
* 
w_Page
(
d
::
rg
 
p
, 
size_t
 
l
, 
v
);

64 
Dimsi
* 
w_Dimsi
(
d
::
rg
 
p
, 
size_t
 
l
, 
v
, std::rg 
un
);

65 
C
* 
w_C
(
d
::
rg
 
p
, 
size_t
 
l
, 
r
, 
g
, 
b
, 
a
 = 1, std::rg 
di
 = "");

66 
Boޗn
* 
w_Boޗn
(
d
::
rg
 
p
, 
size_t
 
l
, 
bo
 
v
);

67 
Sg_Schema
* 
w_Sg_Schema
(
d
::
rg
 
p
, 
size_t
 
l
, size_
size
 = 0);

68 
Sg_Cڡt
* 
w_Sg_Cڡt
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
v
);

69 
Sg_Cڡt
* 
w_Sg_Cڡt
(
d
::
rg
 
p
, 
size_t
 
l
, cڡ * 
beg
);

70 
Sg_Cڡt
* 
w_Sg_Cڡt
(
d
::
rg
 
p
, 
size_t
 
l
, cڡ * 
beg
, cڡ * 
d
);

71 
Suts_Cdi
* 
w_Suts_Cdi
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 
f
, 
Exessi
* 
v
);

72 
Med_Exessi
* 
w_Med_Exessi
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 
f
, 
Exessi
* 
v
);

73 
Pt_Se
* 
w_Pt_Se
(
d
::
rg
 
p
, 
size_t
 
l
, 
Se
* 
s
);

75 
Pam
* 
w_Pam
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
, 
Exessi
* 
def
 = 0, 
bo
 

 = 
l
);

76 
Pams
* 
w_Pams
(
d
::
rg
 
p
, 
size_t
 
l
);

77 
Argumt
* 
w_Argumt
(
d
::
rg
 
p
, 
size_t
 
l
, 
Exessi
* 
v
, std::rg 
n
 = "", 
bo
 

 = 
l
);

78 
Argumts
* 
w_Argumts
(
d
::
rg
 
p
, 
size_t
 
l
);

80 
Se_Schema
* 
w_Se_Schema
(
d
::
rg
 
p
, 
size_t
 
l
, 
Sg
* 
c
);

81 
Aribu_Se
* 
w_Aribu_Se
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
, std::rg 
m
, 
Sg
* 
v
);

82 
Sime_Se
* 
w_Sime_Se
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
c
);

83 
Ren_Se
* 
w_Ren_Se
(
d
::
rg
 
p
, 
size_t
 
l
);

84 
Phd_Se
* 
w_Phd_Se
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
);

85 
Pudo_Se
* 
w_Pudo_Se
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
, 
Exessi
* 
ex
 = 0);

86 
Wed_Se
* 
w_Wed_Se
(
d
::
rg
 
p
, 
size_t
 
l
, std::rg 
n
, 
Sime_Ba
* 
l
);

87 
Compound_Se
* 
w_Compound_Se
(
d
::
rg
 
p
, 
size_t
 
l
, size_
s
 = 0);

88 
Comex_Se
* 
w_Comex_Se
(
d
::
rg
 
p
, 
size_t
 
l
, Comex_Se::
Comb
 
c
, Comex_Se* 
x
, 
Compound_Se
* 
l
);

89 
Se_Li
* 
w_Se_Li
(
d
::
rg
 
p
, 
size_t
 
l
, size_
s
 = 0);

	@node_modules/node-sass/src/libsass/src/ast_fwd_decl.hpp

1 #ide
SASS_AST_FWD_DECL_H


2 
	#SASS_AST_FWD_DECL_H


	)

7 
mea
 
	gSass
 {

9 
ass
 
	gAST_Node
;

11 
ass
 
	gSmt
;

12 
ass
 
	gBlock
;

13 
ass
 
	gRuˣt
;

14 
ass
 
	gPrݣt
;

15 
ass
 
	gBubb
;

16 
ass
 
	gMed_Block
;

17 
ass
 
	gSuts_Block
;

18 
ass
 
	gDeive
;

19 
ass
 
	gKeyame_Ru
;

20 
ass
 
	gAt_Ro_Block
;

21 
ass
 
	gDei
;

22 
ass
 
	gAssignmt
;

23 
ass
 
	gImpt
;

24 
ass
 
	gImpt_Stub
;

25 
ass
 
	gWng
;

26 
ass
 
	gE
;

27 
ass
 
	gDebug
;

28 
ass
 
	gCommt
;

29 
ass
 
	gIf
;

30 
ass
 
	gF
;

31 
ass
 
	gEach
;

32 
ass
 
	gWhe
;

33 
ass
 
	gRu
;

34 
ass
 
	gCڋ
;

35 
ass
 
	gExnsi
;

36 
ass
 
	gDefi
;

37 
ass
 
	gMix_Cl
;

39 
ass
 
	gVue
;

40 
ass
 
	gExessi
;

41 
ass
 
	gLi
;

42 
ass
 
	gM
;

43 
ass
 
	gBy_Exessi
;

44 
ass
 
	gUry_Exessi
;

45 
ass
 
	gFuni_Cl
;

46 
ass
 
	gFuni_Cl_Schema
;

47 
ass
 
	gCuom_Wng
;

48 
ass
 
	gCuom_E
;

49 
ass
 
	gVb
;

50 
ass
 
	gTextu
;

51 
ass
 
	gNumb
;

52 
ass
 
	gC
;

53 
ass
 
	gBoޗn
;

54 
ass
 
	gSg_Schema
;

55 
ass
 
	gSg
;

56 
ass
 
	gSg_Cڡt
;

57 
ass
 
	gSg_Qued
;

58 
ass
 
	gMed_Quy
;

59 
ass
 
	gMed_Quy_Exessi
;

60 
ass
 
	gSuts_Cdi
;

61 
ass
 
	gSuts_Ot
;

62 
ass
 
	gSuts_Negi
;

63 
ass
 
	gSuts_Dei
;

64 
ass
 
	gSuts_Ipީi
;

65 
ass
 
	gAt_Ro_Quy
;

66 
ass
 
	gNu
;

67 
ass
 
	gPt_Se
;

69 
ass
 
	gPam
;

70 
ass
 
	gPams
;

71 
ass
 
	gArgumt
;

72 
ass
 
	gArgumts
;

74 
ass
 
	gSe
;

75 
ass
 
	gSe_Schema
;

76 
ass
 
	gSe_Phd
;

77 
ass
 
	gTy_Se
;

78 
ass
 
	gSe_Quifr
;

79 
ass
 
	gAribu_Se
;

80 
ass
 
	gPudo_Se
;

81 
ass
 
	gWed_Se
;

82 
ass
 
	gCompound_Se
;

83 
ass
 
	gComex_Se
;

84 
ass
 
	gSe_Li
;

87 
ass
 
	gCڋxt
;

	@node_modules/node-sass/src/libsass/src/b64/cencode.h

8 #ide
BASE64_CENCODE_H


9 
	#BASE64_CENCODE_H


	)

13 
	m_A
, 
	m_B
, 
	m_C


14 } 
	tba64_code
;

18 
ba64_code
 
	m
;

19 
	msu
;

20 
	mcou
;

21 } 
	tba64_codee
;

23 
ba64__codee
(
ba64_codee
* 
e_
);

25 
ba64_code_vue
(
vue_
);

27 
ba64_code_block
(cڡ * 
axt_
, 
ngth_
, * 
code_out
, 
ba64_codee
* 
e_
);

29 
ba64_code_blockd
(* 
code_out
, 
ba64_codee
* 
e_
);

	@node_modules/node-sass/src/libsass/src/b64/encode.h

8 #ide
BASE64_ENCODE_H


9 
	#BASE64_ENCODE_H


	)

11 
	~<ioam
>

13 
mea
 
	gba64


17 
	~"ncode.h
"

20 
	scod


22 
ba64_codee
 
_e
;

23 
_bufrsize
;

25 
cod
(
bufrsize_
 = 
BUFFERSIZE
)

26 : 
_bufrsize
(
bufrsize_
)

29 
code
(
vue_
)

31  
ba64_code_vue
(
vue_
);

34 
code
(cڡ * 
code_
, cڡ 
ngth_
, * 
axt_out
)

36  
ba64_code_block
(
code_
, 
ngth_
, 
axt_out
, &
_e
);

39 
code_d
(* 
axt_out
)

41  
ba64_code_blockd
(
axt_out
, &
_e
);

44 
code
(
d
::
iam
& 
iam_
, std::
oam
& 
oam_
)

46 
ba64__codee
(&
_e
);

48 cڡ 
N
 = 
_bufrsize
;

49 * 
axt
 = 
w
 [
N
];

50 * 
code
 = 
w
 [2*
N
];

51 
angth
;

52 
codgth
;

56 
iam_
.
ad
(
axt
, 
N
);

57 
angth
 = 
ic_
<>(
iam_
.
gcou
());

59 
codgth
 = 
code
(
axt
, 
angth
, 
code
);

60 
oam_
.
wre
(
code
, 
codgth
);

62 
iam_
.
good
(&& 
angth
 > 0);

64 
codgth
 = 
code_d
(
code
);

65 
oam_
.
wre
(
code
, 
codgth
);

67 
ba64__codee
(&
_e
);

69 
de
 [] 
code
;

70 
de
 [] 
axt
;

	@node_modules/node-sass/src/libsass/src/backtrace.hpp

1 #ide
SASS_BACKTRACE_H


2 
	#SASS_BACKTRACE_H


	)

4 
	~<sam
>

6 
	~"fe.h
"

7 
	~"posi.h
"

9 
mea
 
	gSass
 {

12 
	sBacka
 {

14 
Backa
* 
	g
;

15 
PrS
 
	gpe
;

16 
	gd
::
rg
 
Δ
;

18 
Backa
(Backa* 
n
, 
PrS
 
pe
, 
d
::
rg
 
c
)

19 : 

(
n
),

20 
pe
(pstate),

21 
Δ
(
c
)

24 
	gd
::
rg
 
to_rg
(
bo
 
wng
 = 
l
)

26 
size_t
 
i
 = -1;

27 
	gd
::
rgam
 
ss
;

28 
	gd
::
rg
 
cwd
(
Sass
::
Fe
::
g_cwd
());

29 
Backa
* 
	gthis_pot
 = 
this
;

31 i(!
	gwng

	gss
 << 
	gd
::
dl
 << "Backtrace:";

33 
	gthis_pot
->
	g
) {

36 
	gd
::
rg
 
l_th
(
Sass
::
Fe
::
abs2l
(
this_pot
->
pe
.
th
, 
cwd
, cwd));

38 i(
	gwng
) {

39 
	gss
 << 
	gd
::
dl


41 << (++
i
 == 0 ? "on" : "from")

43 << 
this_pot
->
pe
.
le
 + 1

45 << 
l_th
;

47 
	gss
 << 
	gd
::
dl


49 << 
l_th


51 << 
this_pot
->
pe
.
le
 + 1

52 << 
this_pot
->

->
Δ
;

55 
	gthis_pot
 = 
this_pot
->

;

58  
	gss
.
r
();

61 
size_t
 
dth
()

63 
size_t
 
	gd
 = 0;

64 
Backa
* 
	gp
 = 

;

65 
	gp
) {

66 ++
	gd
;

67 
	gp
 = 
p
->

;

69  
	gd
-1;

	@node_modules/node-sass/src/libsass/src/base64vlq.cpp

1 
	~"ss.h
"

2 
	~"ba64vlq.h
"

4 
mea
 
	gSass
 {

6 
	gd
::
rg
 
Ba64VLQ
::
code
(cڡ 
numb
) const

8 
d
::
rg
 
coded
 = "";

10 
	gvlq
 = 
to_vlq_sigd
(
numb
);

13 
	gdig
 = 
vlq
 & 
VLQ_BASE_MASK
;

14 
	gvlq
 >>
VLQ_BASE_SHIFT
;

15 i(
	gvlq
 > 0) {

16 
	gdig
 |
VLQ_CONTINUATION_BIT
;

18 
	gcoded
 +
ba64_code
(
dig
);

19 } 
	gvlq
 > 0);

21  
	gcoded
;

24 
	gBa64VLQ
::
ba64_code
(cڡ 
numb
) const

26 
dex
 = 
numb
;

27 i(
	gdex
 < 0) index = 0;

28 i(
	gdex
 > 63) index = 63;

29  
	gCHARACTERS
[
dex
];

32 
	gBa64VLQ
::
to_vlq_sigd
(cڡ 
numb
) const

34  (
numb
 < 0) ? ((-number) << 1) + 1 : (number << 1) + 0;

37 cڡ * 
	gBa64VLQ
::
CHARACTERS
 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

39 cڡ 
	gBa64VLQ
::
VLQ_BASE_SHIFT
 = 5;

40 cڡ 
	gBa64VLQ
::
VLQ_BASE
 = 1 << 
VLQ_BASE_SHIFT
;

41 cڡ 
	gBa64VLQ
::
VLQ_BASE_MASK
 = 
VLQ_BASE
 - 1;

42 cڡ 
	gBa64VLQ
::
VLQ_CONTINUATION_BIT
 = 
VLQ_BASE
;

	@node_modules/node-sass/src/libsass/src/base64vlq.hpp

1 #ide
SASS_BASE64VLQ_H


2 
	#SASS_BASE64VLQ_H


	)

4 
	~<rg
>

6 
mea
 
	gSass
 {

8 as
	cBa64VLQ
 {

10 
	gpublic
:

12 
d
::
rg
 
code
(cڡ 
numb
) const;

14 
	give
:

16 
ba64_code
(cڡ 
numb
) const;

18 
to_vlq_sigd
(cڡ 
numb
) const;

20 cڡ * 
	gCHARACTERS
;

22 cڡ 
	gVLQ_BASE_SHIFT
;

23 cڡ 
	gVLQ_BASE
;

24 cڡ 
	gVLQ_BASE_MASK
;

25 cڡ 
	gVLQ_CONTINUATION_BIT
;

	@node_modules/node-sass/src/libsass/src/bind.cpp

1 
	~"ss.h
"

2 
	~"bd.h
"

3 
	~"a.h
"

4 
	~"cڋxt.h
"

5 
	~"ev.h
"

6 
	~<m
>

7 
	~<ioam
>

8 
	~<sam
>

10 
mea
 
	gSass
 {

12 
bd
(
d
::
rg
 
ty
, std::rg 
me
, 
Pams
* 
ps
, 
Argumts
* 
as
, 
Cڋxt
* 
x
, 
Env
* 
v
, 
Ev
* 
ev
)

14 
	gd
::
rg
 
Γ
(
ty
 + " " + 
me
);

16 
Liize
 
liize
(
x
->
mem
);

17 
	gd
::
m
<
d
::
rg
, 
	gPam
*> 
	gm_m
;

19 
size_t
 
	gi
 = 0, 
	gL
 = 
as
->
ngth
(); i < L; ++i) {

20 iut
	gr
 = 
dymic_
<
Sg_Qued
*>((*
as
)[
i
]->
vue
())) {

22 i(
r
->
que_mk
()) {

23 
r
->
que_mk
('*');

24 
	gr
->
is_dayed
(
ue
);

31 
size_t
 
	gi
 = 0, 
	gL
 = 
ps
->
ngth
(); i < L; ++i) {

32 
Pam
* 
	gp
 = (*
ps
)[
i
];

33 
	gm_m
[
p
->
me
()] =;

40 
size_t
 
	g
 = 0, 
	gLP
 = 
ps
->
ngth
();

41 
size_t
 
	g
 = 0, 
	gLA
 = 
as
->
ngth
();

42 
	g
 < 
	gLA
) {

43 
Argumt
* 
	ga
 = (*
as
)[

];

44 i(
	g
 >
LP
) {

46 i(
a
->
is__gumt
()) {

47 i(
Li
* 
l
 = 
dymic_
<Li*>(
a
->
vue
())) {

48 i(
l
->
ngth
() == 0) {

49 ++ 

; ;

53 
	gd
::
rgam
 
msg
;

54 
	gmsg
 << "wrgumb ogumt(" << 
	gLA
 << " f " << 
	gLP
 << ")";

55 
	gmsg
 << " f `" << 
	gme
 << "'";

56  
r
(
msg
.
r
(), 
as
->
pe
());

58 
Pam
* 
	gp
 = (*
ps
)[

];

61 i(
	gp
->
is__m
()) {

63 i(
	ga
->
is__gumt
()) {

66 i(
Li
* 
	g
 = 
dymic_
<Li*>(
a
->
vue
())) {

68 
Li
* 
gli
 = 
SASS_MEMORY_NEW
(
x
->
mem
, List,

69 
p
->
pe
(),

71 

->
t
(),

72 
ue
);

74 
Exessi
* 
	gem
 : 

->
emts
()) {

75 i(
Argumt
* 
g
 = 
dymic_
<Argumt*>(
em
)) {

76 (*
gli
<< 
SASS_MEMORY_NEW
(
x
->
mem
, 
Argumt
, *
g
);

78 (*
	ggli
<< 
SASS_MEMORY_NEW
(
x
->
mem
, 
Argumt
,

79 
em
->
pe
(),

80 
em
,

82 
l
,

83 
l
);

87 
	gv
->
lol_ame
()[
p
->
me
()] = 
gli
;

91 
throw
 
	gd
::
ruime_r
("invalid state");

93 } i(
	ga
->
is_keywd_gumt
()) {

96 
Li
* 
	ggli
 = 
SASS_MEMORY_NEW
(
x
->
mem
, Li, 
p
->
pe
(), 0, 
SASS_COMMA
, 
ue
);

97 
	gv
->
lol_ame
()[
p
->
me
()] = 
gli
;

98 
M
* 
	ggm
 = 
ic_
<M*>(
a
->
vue
());

99 aut
	gkey
 : 
gm
->
keys
()) {

100 
d
::
rg
 
me
 = 
unque
(
ic_
<
Sg_Cڡt
*>(
key
)->
vue
());

101 (*
	ggli
<< 
SASS_MEMORY_NEW
(
x
->
mem
, 
Argumt
,

102 
key
->
pe
(),

103 
gm
->

(
key
),

104 "$" + 
me
,

105 
l
,

106 
l
);

112 
Li
* 
	ggli
 = 
SASS_MEMORY_NEW
(
x
->
mem
, List,

113 
p
->
pe
(),

115 
SASS_COMMA
,

116 
ue
);

118 
	g
 < 
	gLA
) {

120 
	ga
 = (*
as
)[

++];

122 
Li
* 
	gls
 = 
dymic_
<Li*>(
a
->
vue
());

124 i(
	gls
 &&s->
emy
(&& 
	ga
->
is__gumt
()) ;

126 i(
Argumt
* 
	gg
 = 
dymic_
<Argumt*>(
a
->
vue
())) {

127 (*
gli
<< 
SASS_MEMORY_NEW
(
x
->
mem
, 
Argumt
, *
g
);

130 i(
	ga
->
is__gumt
()) {

132 i(
Li
* 
	g
 = 
dymic_
<Li*>(
a
->
vue
())) {

133 
gli
->
t
(

->separator());

135 
size_t
 
	gi
 = 0, 
	gL
 = 

->
size
(); i < L; ++i) {

136 (*
	ggli
<< 
SASS_MEMORY_NEW
(
x
->
mem
, 
Argumt
,

137 (*

)[
i
]->
pe
(),

138 (*

)[
i
],

140 
l
,

141 
l
);

149 (*
	ggli
<< 
SASS_MEMORY_NEW
(
x
->
mem
, 
Argumt
,

150 
a
->
pe
(),

151 
a
->
vue
(),

152 
a
->
me
(),

153 
l
,

154 
l
);

158 
	gv
->
lol_ame
()[
p
->
me
()] = 
gli
;

161 ++
	g
;

167 i(
	ga
->
is__gumt
()) {

169 
Li
* 
	ggli
 = 
ic_
<Li*>(
a
->
vue
());

171 i(!
	ggli
->
ngth
()) {

174 i(
	ggli
->
ngth
(> 
	gLP
 - 
	g
 && !
	gps
->
has__m
()) {

175 
	gg_cou
 = (
gli
->
ngth
(+ 
LA
 - 1);

176 
	gd
::
rgam
 
msg
;

177 
	gmsg
 << 
	gΓ
 << "ake" << 
	gLP
;

178 
	gmsg
 << (
	gLP
 == 1 ? "rgument" : "rguments");

179 
	gmsg
 << " bu" << 
	gg_cou
;

180 
	gmsg
 << (
	gg_cou
 == 1 ? " wasassed" : " wereassed.");

181 
dd_bd
(
msg
.
r
(), 
as
->
pe
());

183 
	ggli
->
ngth
(> 
	gLP
 - 
	g
) {

184 
	ggli
->
emts
().
a
(
gli
->emts().
d
() - 1);

189 i(!(
	ga
 = 
dymic_
<
Argumt
*>((*
gli
)[0]))) {

190 
Exessi
* 
a_to_cvt
 = (*
gli
)[0];

191 
	ga
 = 
SASS_MEMORY_NEW
(
x
->
mem
, 
Argumt
,

192 
a_to_cvt
->
pe
(),

193 
a_to_cvt
,

195 
l
,

196 
l
);

198 
	ggli
->
emts
().
a
(
gli
->emts().
beg
());

199 i(!
	ggli
->
ngth
(|| (!gli->
is_gli
(&& 
	g
 + 1 =
LP
)) {

200 ++

;

203 } i(
	ga
->
is_keywd_gumt
()) {

204 
M
* 
	ggm
 = 
ic_
<M*>(
a
->
vue
());

206 aut
	gkey
 : 
gm
->
keys
()) {

207 
d
::
rg
 
me
 = "$" + 
unque
(
ic_
<
Sg_Cڡt
*>(
key
)->
vue
());

209 i(!
	gm_m
.
cou
(
me
)) {

210 
	gd
::
rgam
 
msg
;

211 
	gmsg
 << 
	gΓ
 << " hanطmamed " << 
	gme
;

212 
r
(
msg
.
r
(), 
a
->
pe
());

214 
	gv
->
lol_ame
()[
me
] = 
gm
->

(
key
);

216 ++
	g
;

219 ++
	g
;

222 i(
	ga
->
me
().
emy
()) {

223 i(
	gv
->
has_lol
(
p
->
me
())) {

224 
	gd
::
rgam
 
msg
;

225 
	gmsg
 << "m " << 
	gp
->
me
()

226 << "rovided mܐth on i΁" << 
	gΓ
;

227 
r
(
msg
.
r
(), 
a
->
pe
());

230 
	gv
->
lol_ame
()[
p
->
me
()] = 
a
->
vue
();

231 ++
	g
;

235 i(!
	gm_m
.
cou
(
a
->
me
())) {

236 
	gd
::
rgam
 
msg
;

237 
	gmsg
 << 
	gΓ
 << " hanطmamed " << 
	ga
->
me
();

238 
r
(
msg
.
r
(), 
a
->
pe
());

240 i(
	gm_m
[
a
->
me
()]->
is__m
()) {

241 
	gd
::
rgam
 
msg
;

242 
	gmsg
 << "gum" << 
	ga
->
me
(<< " o" << 
	gΓ


244 
r
(
msg
.
r
(), 
a
->
pe
());

246 i(
	gv
->
has_lol
(
a
->
me
())) {

247 
	gd
::
rgam
 
msg
;

248 
	gmsg
 << "m " << 
	gp
->
me
()

249 << "ovided mܐth on i΁" << 
	gΓ
;

250 
r
(
msg
.
r
(), 
a
->
pe
());

252 
	gv
->
lol_ame
()[
a
->
me
()] =->
vue
();

260 
size_t
 
	gi
 = 

; i < 
	gLP
; ++i) {

261 
Pam
* 
	gov
 = (*
ps
)[
i
];

265 i(!
	gv
->
has_lol
(
ov
->
me
())) {

266 i(
	gov
->
is__m
()) {

267 
	gv
->
lol_ame
()[
ov
->
me
()] = 
SASS_MEMORY_NEW
(
x
->
mem
, 
Li
,

268 
ov
->
pe
(),

270 
SASS_COMMA
,

271 
ue
);

273 i(
	gov
->
deu_vue
()) {

274 
Exessi
* 
	gdv
 = 
ov
->
deu_vue
()->
rfm
(
ev
);

275 
	gv
->
lol_ame
()[
ov
->
me
()] = 
dv
;

279 
	gd
::
rgam
 
msg
;

280 
	gmsg
 << "quedam " << 
	gov
->
me
()

281 << " imissg i΁" << 
	gΓ
;

282 
r
(
msg
.
r
(), 
as
->
pe
());

	@node_modules/node-sass/src/libsass/src/bind.hpp

1 #ide
SASS_BIND_H


2 
	#SASS_BIND_H


	)

4 
	~<rg
>

5 
	~"liize.h
"

6 
	~"vmt.h
"

8 
mea
 
	gSass
 {

9 
ass
 
	gAST_Node
;

10 
ass
 
	gPams
;

11 
ass
 
	gArgumts
;

12 
ass
 
	gCڋxt
;

13 
ass
 
	gEv
;

14 
	gEnvmt
<
	tAST_Node
*> 
	tEnv
;

16 
bd
(
d
::
rg
 
ty
, std::rg 
me
, 
Pams
*, 
Argumts
*, 
Cڋxt
*, 
Env
*, 
Ev
*);

	@node_modules/node-sass/src/libsass/src/c99func.c

24 #i
defed
(
_MSC_VER
) && _MSC_VER < 1900

26 
	~<dio.h
>

27 
	~<dlib.h
>

28 
	~<dg.h
>

30 
	$c99_vtf
(* 
r
, 
size_t
 
size
, cڡ * 
fm
, 
va_li
 

)

32 
cou
 = -1;

34 i(
size
 != 0)

35 
cou
 = 
	`_vtf_s
(
r
, 
size
, 
_TRUNCATE
, 
fm
, 

);

36 i(
cou
 == -1)

37 
cou
 = 
	`_vsrtf
(
fm
, 

);

39  
cou
;

40 
	}
}

42 
	$tf
(* 
r
, 
size_t
 
size
, cڡ * 
fm
, ...)

44 
cou
;

45 
va_li
 

;

47 
	`va_t
(

, 
fm
);

48 
cou
 = 
	`c99_vtf
(
r
, 
size
, 
fm
, 

);

49 
	`va_d
(

);

51  
cou
;

52 
	}
}

	@node_modules/node-sass/src/libsass/src/cencode.c

8 
	~"b64/ncode.h
"

10 
	$ba64__codee
(
ba64_codee
* 
e_
)

12 
e_
->

 = 
_A
;

13 
e_
->
su
 = 0;

14 
e_
->
cou
 = 0;

15 
	}
}

17 
	$ba64_code_vue
(
vue_
)

19 cڡ * 
codg
 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

20 i(
vue_
 > 63)  '=';

21  
codg
[()
vue_
];

22 
	}
}

24 
	$ba64_code_block
(cڡ * 
axt_
, 
ngth_
, * 
code_out
, 
ba64_codee
* 
e_
)

26 cڡ * 
ach
 = 
axt_
;

27 cڡ * cڡ 
axnd
 = 
axt_
 + 
ngth_
;

28 * 
codech
 = 
code_out
;

29 
su
;

30 
agmt
;

32 
su
 = 
e_
->result;

34 
e_
->

)

38 
_A
:

39 i(
ach
 =
axnd
)

41 
e_
->
su
 =esult;

42 
e_
->

 = 
_A
;

43  ()(
codech
 - 
code_out
);

45 
agmt
 = *
ach
++;

46 
su
 = (
agmt
 & 0x0fc) >> 2;

47 *
codech
++ = 
	`ba64_code_vue
(
su
);

48 
su
 = (
agmt
 & 0x003) << 4;

49 
_B
:

50 i(
ach
 =
axnd
)

52 
e_
->
su
 =esult;

53 
e_
->

 = 
_B
;

54  ()(
codech
 - 
code_out
);

56 
agmt
 = *
ach
++;

57 
su
 |(
agmt
 & 0x0f0) >> 4;

58 *
codech
++ = 
	`ba64_code_vue
(
su
);

59 
su
 = (
agmt
 & 0x00f) << 2;

60 
_C
:

61 i(
ach
 =
axnd
)

63 
e_
->
su
 =esult;

64 
e_
->

 = 
_C
;

65  ()(
codech
 - 
code_out
);

67 
agmt
 = *
ach
++;

68 
su
 |(
agmt
 & 0x0c0) >> 6;

69 *
codech
++ = 
	`ba64_code_vue
(
su
);

70 
su
 = (
agmt
 & 0x03f) >> 0;

71 *
codech
++ = 
	`ba64_code_vue
(
su
);

73 ++(
e_
->
cou
);

77  ()(
codech
 - 
code_out
);

78 
	}
}

80 
	$ba64_code_blockd
(* 
code_out
, 
ba64_codee
* 
e_
)

82 * 
codech
 = 
code_out
;

84 
e_
->

)

86 
_B
:

87 *
codech
++ = 
	`ba64_code_vue
(
e_
->
su
);

88 *
codech
++ = '=';

89 *
codech
++ = '=';

91 
_C
:

92 *
codech
++ = 
	`ba64_code_vue
(
e_
->
su
);

93 *
codech
++ = '=';

95 
_A
:

98 *
codech
++ = '\n';

100  ()(
codech
 - 
code_out
);

101 
	}
}

	@node_modules/node-sass/src/libsass/src/color_maps.cpp

1 
	~"ss.h
"

2 
	~"a.h
"

3 
	~"c_ms.h
"

5 
mea
 
	gSass
 {

7 
mea
 
	gCNames


9 cڡ 
	giblue
 [] = "aliceblue";

10 cڡ 
	gtiquewhe
 [] = "antiquewhite";

11 cڡ 
	gcy
 [] = "cyan";

12 cڡ 
	gaqua
 [] = "aqua";

13 cڡ 
	gaquame
 [] = "aquamarine";

14 cڡ 
	gazu
 [] = "azure";

15 cڡ 
	gbeige
 [] = "beige";

16 cڡ 
	gbisque
 [] = "bisque";

17 cڡ 
	gbck
 [] = "black";

18 cڡ 
	gbnchedmd
 [] = "blanchedalmond";

19 cڡ 
	gblue
 [] = "blue";

20 cڡ 
	gblueviޑ
 [] = "blueviolet";

21 cڡ 
	gbrown
 [] = "brown";

22 cڡ 
	gbuywood
 [] = "burlywood";

23 cڡ 
	gdblue
 [] = "cadetblue";

24 cڡ 
	gcheu
 [] = "chartreuse";

25 cڡ 
	gchocީe
 [] = "chocolate";

26 cڡ 
	gcܮ
 [] = "coral";

27 cڡ 
	gcnowblue
 [] = "cornflowerblue";

28 cڡ 
	gcnsk
 [] = "cornsilk";

29 cڡ 
	gims
 [] = "crimson";

30 cڡ 
	gdkblue
 [] = "darkblue";

31 cڡ 
	gdkcy
 [] = "darkcyan";

32 cڡ 
	gdkgdrod
 [] = "darkgoldenrod";

33 cڡ 
	gdkgy
 [] = "darkgray";

34 cڡ 
	gdkgy
 [] = "darkgrey";

35 cڡ 
	gdkg
 [] = "darkgreen";

36 cڡ 
	gdkkhaki
 [] = "darkkhaki";

37 cڡ 
	gdkmag
 [] = "darkmagenta";

38 cڡ 
	gdkiveg
 [] = "darkolivegreen";

39 cڡ 
	gdkܪge
 [] = "darkorange";

40 cڡ 
	gdkchid
 [] = "darkorchid";

41 cڡ 
	gdkd
 [] = "darkred";

42 cڡ 
	gdklm
 [] = "darksalmon";

43 cڡ 
	gdkag
 [] = "darkseagreen";

44 cڡ 
	gdkeblue
 [] = "darkslateblue";

45 cڡ 
	gdkegy
 [] = "darkslategray";

46 cڡ 
	gdkegy
 [] = "darkslategrey";

47 cڡ 
	gdkturquoi
 [] = "darkturquoise";

48 cڡ 
	gdkviޑ
 [] = "darkviolet";

49 cڡ 
	gdk
 [] = "deeppink";

50 cڡ 
	gdpskyblue
 [] = "deepskyblue";

51 cڡ 
	gdimgy
 [] = "dimgray";

52 cڡ 
	gdimgy
 [] = "dimgrey";

53 cڡ 
	gdodgblue
 [] = "dodgerblue";

54 cڡ 
	gfebrick
 [] = "firebrick";

55 cڡ 
	gܮwhe
 [] = "floralwhite";

56 cڡ 
	gfeg
 [] = "forestgreen";

57 cڡ 
	gmag
 [] = "magenta";

58 cڡ 
	gfuchs
 [] = "fuchsia";

59 cڡ 
	ggasbo
 [] = "gainsboro";

60 cڡ 
	gghowhe
 [] = "ghostwhite";

61 cڡ 
	ggd
 [] = "gold";

62 cڡ 
	ggdrod
 [] = "goldenrod";

63 cڡ 
	ggy
 [] = "gray";

64 cڡ 
	ggy
 [] = "grey";

65 cڡ 
	gg
 [] = "green";

66 cڡ 
	ggylow
 [] = "greenyellow";

67 cڡ 
	gheydew
 [] = "honeydew";

68 cڡ 
	ghpk
 [] = "hotpink";

69 cڡ 
	gded
 [] = "indianred";

70 cڡ 
	gdigo
 [] = "indigo";

71 cڡ 
	givy
 [] = "ivory";

72 cڡ 
	gkhaki
 [] = "khaki";

73 cڡ 
	gvd
 [] = "lavender";

74 cڡ 
	gvdblush
 [] = "lavenderblush";

75 cڡ 
	gwng
 [] = "lawngreen";

76 cڡ 
	gmchiff
 [] = "lemonchiffon";

77 cڡ 
	glightblue
 [] = "lightblue";

78 cڡ 
	glightcܮ
 [] = "lightcoral";

79 cڡ 
	glightcy
 [] = "lightcyan";

80 cڡ 
	glightgdrodylow
 [] = "lightgoldenrodyellow";

81 cڡ 
	glightgy
 [] = "lightgray";

82 cڡ 
	glightgy
 [] = "lightgrey";

83 cڡ 
	glightg
 [] = "lightgreen";

84 cڡ 
	glighk
 [] = "lightpink";

85 cڡ 
	glightlm
 [] = "lightsalmon";

86 cڡ 
	glightag
 [] = "lightseagreen";

87 cڡ 
	glightskyblue
 [] = "lightskyblue";

88 cڡ 
	glightegy
 [] = "lightslategray";

89 cڡ 
	glightegy
 [] = "lightslategrey";

90 cڡ 
	glightlblue
 [] = "lightsteelblue";

91 cڡ 
	glightylow
 [] = "lightyellow";

92 cڡ 
	glime
 [] = "lime";

93 cڡ 
	glimeg
 [] = "limegreen";

94 cڡ 
	gl
 [] = "linen";

95 cڡ 
	gmo
 [] = "maroon";

96 cڡ 
	gmediumaquame
 [] = "mediumaquamarine";

97 cڡ 
	gmediumblue
 [] = "mediumblue";

98 cڡ 
	gmediumchid
 [] = "mediumorchid";

99 cڡ 
	gmediumpu
 [] = "mediumpurple";

100 cڡ 
	gmediumag
 [] = "mediumseagreen";

101 cڡ 
	gmediumeblue
 [] = "mediumslateblue";

102 cڡ 
	gmediumrgg
 [] = "mediumspringgreen";

103 cڡ 
	gmediumturquoi
 [] = "mediumturquoise";

104 cڡ 
	gmediumviޑd
 [] = "mediumvioletred";

105 cڡ 
	gmidnightblue
 [] = "midnightblue";

106 cڡ 
	gmtm
 [] = "mintcream";

107 cڡ 
	gmiyro
 [] = "mistyrose";

108 cڡ 
	gmocs
 [] = "moccasin";

109 cڡ 
	gvajowhe
 [] = "navajowhite";

110 cڡ 
	gvy
 [] = "navy";

111 cڡ 
	gd
 [] = "oldlace";

112 cڡ 
	give
 [] = "olive";

113 cڡ 
	givedb
 [] = "olivedrab";

114 cڡ 
	gܪge
 [] = "orange";

115 cڡ 
	gܪged
 [] = "orangered";

116 cڡ 
	gchid
 [] = "orchid";

117 cڡ 
	ggdrod
 [] = "palegoldenrod";

118 cڡ 
	gg
 [] = "palegreen";

119 cڡ 
	gturquoi
 [] = "paleturquoise";

120 cڡ 
	gviޑd
 [] = "palevioletred";

121 cڡ 
	gyawh
 [] = "papayawhip";

122 cڡ 
	gachpuff
 [] = "peachpuff";

123 cڡ 
	gru
 [] = "peru";

124 cڡ 
	gpk
 [] = "pink";

125 cڡ 
	gum
 [] = "plum";

126 cڡ 
	gpowdblue
 [] = "powderblue";

127 cڡ 
	gpu
 [] = "purple";

128 cڡ 
	gd
 [] = "red";

129 cڡ 
	grosybrown
 [] = "rosybrown";

130 cڡ 
	groyblue
 [] = "royalblue";

131 cڡ 
	gddbrown
 [] = "saddlebrown";

132 cڡ 
	glm
 [] = "salmon";

133 cڡ 
	gndybrown
 [] = "sandybrown";

134 cڡ 
	gag
 [] = "seagreen";

135 cڡ 
	gashl
 [] = "seashell";

136 cڡ 
	gsa
 [] = "sienna";

137 cڡ 
	gsv
 [] = "silver";

138 cڡ 
	gskyblue
 [] = "skyblue";

139 cڡ 
	geblue
 [] = "slateblue";

140 cڡ 
	gegy
 [] = "slategray";

141 cڡ 
	gegy
 [] = "slategrey";

142 cڡ 
	gow
 [] = "snow";

143 cڡ 
	grgg
 [] = "springgreen";

144 cڡ 
	glblue
 [] = "steelblue";

145 cڡ 
	gn
 [] = "tan";

146 cڡ 
	g
 [] = "teal";

147 cڡ 
	gthi
 [] = "thistle";

148 cڡ 
	gtomo
 [] = "tomato";

149 cڡ 
	gturquoi
 [] = "turquoise";

150 cڡ 
	gviޑ
 [] = "violet";

151 cڡ 
	gwht
 [] = "wheat";

152 cڡ 
	gwhe
 [] = "white";

153 cڡ 
	gwhesmoke
 [] = "whitesmoke";

154 cڡ 
	gylow
 [] = "yellow";

155 cڡ 
	gylowg
 [] = "yellowgreen";

156 cڡ 
	gbecpu
 [] = "rebeccapurple";

157 cڡ 
	gt
 [] = "transparent";

160 
mea
 
	gCs
 {

161 cڡ 
PrS
 
c_b
("[COLOR TABLE]");

162 cڡ 
C
 
iblue
(
c_b
, 240, 248, 255, 1);

163 cڡ 
C
 
tiquewhe
(
c_b
, 250, 235, 215, 1);

164 cڡ 
C
 
cy
(
c_b
, 0, 255, 255, 1);

165 cڡ 
C
 
aqua
(
c_b
, 0, 255, 255, 1);

166 cڡ 
C
 
aquame
(
c_b
, 127, 255, 212, 1);

167 cڡ 
C
 
azu
(
c_b
, 240, 255, 255, 1);

168 cڡ 
C
 
beige
(
c_b
, 245, 245, 220, 1);

169 cڡ 
C
 
bisque
(
c_b
, 255, 228, 196, 1);

170 cڡ 
C
 
bck
(
c_b
, 0, 0, 0, 1);

171 cڡ 
C
 
bnchedmd
(
c_b
, 255, 235, 205, 1);

172 cڡ 
C
 
blue
(
c_b
, 0, 0, 255, 1);

173 cڡ 
C
 
blueviޑ
(
c_b
, 138, 43, 226, 1);

174 cڡ 
C
 
brown
(
c_b
, 165, 42, 42, 1);

175 cڡ 
C
 
buywood
(
c_b
, 222, 184, 135, 1);

176 cڡ 
C
 
dblue
(
c_b
, 95, 158, 160, 1);

177 cڡ 
C
 
cheu
(
c_b
, 127, 255, 0, 1);

178 cڡ 
C
 
chocީe
(
c_b
, 210, 105, 30, 1);

179 cڡ 
C
 
cܮ
(
c_b
, 255, 127, 80, 1);

180 cڡ 
C
 
cnowblue
(
c_b
, 100, 149, 237, 1);

181 cڡ 
C
 
cnsk
(
c_b
, 255, 248, 220, 1);

182 cڡ 
C
 
ims
(
c_b
, 220, 20, 60, 1);

183 cڡ 
C
 
dkblue
(
c_b
, 0, 0, 139, 1);

184 cڡ 
C
 
dkcy
(
c_b
, 0, 139, 139, 1);

185 cڡ 
C
 
dkgdrod
(
c_b
, 184, 134, 11, 1);

186 cڡ 
C
 
dkgy
(
c_b
, 169, 169, 169, 1);

187 cڡ 
C
 
dkgy
(
c_b
, 169, 169, 169, 1);

188 cڡ 
C
 
dkg
(
c_b
, 0, 100, 0, 1);

189 cڡ 
C
 
dkkhaki
(
c_b
, 189, 183, 107, 1);

190 cڡ 
C
 
dkmag
(
c_b
, 139, 0, 139, 1);

191 cڡ 
C
 
dkiveg
(
c_b
, 85, 107, 47, 1);

192 cڡ 
C
 
dkܪge
(
c_b
, 255, 140, 0, 1);

193 cڡ 
C
 
dkchid
(
c_b
, 153, 50, 204, 1);

194 cڡ 
C
 
dkd
(
c_b
, 139, 0, 0, 1);

195 cڡ 
C
 
dklm
(
c_b
, 233, 150, 122, 1);

196 cڡ 
C
 
dkag
(
c_b
, 143, 188, 143, 1);

197 cڡ 
C
 
dkeblue
(
c_b
, 72, 61, 139, 1);

198 cڡ 
C
 
dkegy
(
c_b
, 47, 79, 79, 1);

199 cڡ 
C
 
dkegy
(
c_b
, 47, 79, 79, 1);

200 cڡ 
C
 
dkturquoi
(
c_b
, 0, 206, 209, 1);

201 cڡ 
C
 
dkviޑ
(
c_b
, 148, 0, 211, 1);

202 cڡ 
C
 
dk
(
c_b
, 255, 20, 147, 1);

203 cڡ 
C
 
dpskyblue
(
c_b
, 0, 191, 255, 1);

204 cڡ 
C
 
dimgy
(
c_b
, 105, 105, 105, 1);

205 cڡ 
C
 
dimgy
(
c_b
, 105, 105, 105, 1);

206 cڡ 
C
 
dodgblue
(
c_b
, 30, 144, 255, 1);

207 cڡ 
C
 
febrick
(
c_b
, 178, 34, 34, 1);

208 cڡ 
C
 
ܮwhe
(
c_b
, 255, 250, 240, 1);

209 cڡ 
C
 
feg
(
c_b
, 34, 139, 34, 1);

210 cڡ 
C
 
mag
(
c_b
, 255, 0, 255, 1);

211 cڡ 
C
 
fuchs
(
c_b
, 255, 0, 255, 1);

212 cڡ 
C
 
gasbo
(
c_b
, 220, 220, 220, 1);

213 cڡ 
C
 
ghowhe
(
c_b
, 248, 248, 255, 1);

214 cڡ 
C
 
gd
(
c_b
, 255, 215, 0, 1);

215 cڡ 
C
 
gdrod
(
c_b
, 218, 165, 32, 1);

216 cڡ 
C
 
gy
(
c_b
, 128, 128, 128, 1);

217 cڡ 
C
 
gy
(
c_b
, 128, 128, 128, 1);

218 cڡ 
C
 
g
(
c_b
, 0, 128, 0, 1);

219 cڡ 
C
 
gylow
(
c_b
, 173, 255, 47, 1);

220 cڡ 
C
 
heydew
(
c_b
, 240, 255, 240, 1);

221 cڡ 
C
 
hpk
(
c_b
, 255, 105, 180, 1);

222 cڡ 
C
 
ded
(
c_b
, 205, 92, 92, 1);

223 cڡ 
C
 
digo
(
c_b
, 75, 0, 130, 1);

224 cڡ 
C
 
ivy
(
c_b
, 255, 255, 240, 1);

225 cڡ 
C
 
khaki
(
c_b
, 240, 230, 140, 1);

226 cڡ 
C
 
vd
(
c_b
, 230, 230, 250, 1);

227 cڡ 
C
 
vdblush
(
c_b
, 255, 240, 245, 1);

228 cڡ 
C
 
wng
(
c_b
, 124, 252, 0, 1);

229 cڡ 
C
 
mchiff
(
c_b
, 255, 250, 205, 1);

230 cڡ 
C
 
lightblue
(
c_b
, 173, 216, 230, 1);

231 cڡ 
C
 
lightcܮ
(
c_b
, 240, 128, 128, 1);

232 cڡ 
C
 
lightcy
(
c_b
, 224, 255, 255, 1);

233 cڡ 
C
 
lightgdrodylow
(
c_b
, 250, 250, 210, 1);

234 cڡ 
C
 
lightgy
(
c_b
, 211, 211, 211, 1);

235 cڡ 
C
 
lightgy
(
c_b
, 211, 211, 211, 1);

236 cڡ 
C
 
lightg
(
c_b
, 144, 238, 144, 1);

237 cڡ 
C
 
lighk
(
c_b
, 255, 182, 193, 1);

238 cڡ 
C
 
lightlm
(
c_b
, 255, 160, 122, 1);

239 cڡ 
C
 
lightag
(
c_b
, 32, 178, 170, 1);

240 cڡ 
C
 
lightskyblue
(
c_b
, 135, 206, 250, 1);

241 cڡ 
C
 
lightegy
(
c_b
, 119, 136, 153, 1);

242 cڡ 
C
 
lightegy
(
c_b
, 119, 136, 153, 1);

243 cڡ 
C
 
lightlblue
(
c_b
, 176, 196, 222, 1);

244 cڡ 
C
 
lightylow
(
c_b
, 255, 255, 224, 1);

245 cڡ 
C
 
lime
(
c_b
, 0, 255, 0, 1);

246 cڡ 
C
 
limeg
(
c_b
, 50, 205, 50, 1);

247 cڡ 
C
 
l
(
c_b
, 250, 240, 230, 1);

248 cڡ 
C
 
mo
(
c_b
, 128, 0, 0, 1);

249 cڡ 
C
 
mediumaquame
(
c_b
, 102, 205, 170, 1);

250 cڡ 
C
 
mediumblue
(
c_b
, 0, 0, 205, 1);

251 cڡ 
C
 
mediumchid
(
c_b
, 186, 85, 211, 1);

252 cڡ 
C
 
mediumpu
(
c_b
, 147, 112, 219, 1);

253 cڡ 
C
 
mediumag
(
c_b
, 60, 179, 113, 1);

254 cڡ 
C
 
mediumeblue
(
c_b
, 123, 104, 238, 1);

255 cڡ 
C
 
mediumrgg
(
c_b
, 0, 250, 154, 1);

256 cڡ 
C
 
mediumturquoi
(
c_b
, 72, 209, 204, 1);

257 cڡ 
C
 
mediumviޑd
(
c_b
, 199, 21, 133, 1);

258 cڡ 
C
 
midnightblue
(
c_b
, 25, 25, 112, 1);

259 cڡ 
C
 
mtm
(
c_b
, 245, 255, 250, 1);

260 cڡ 
C
 
miyro
(
c_b
, 255, 228, 225, 1);

261 cڡ 
C
 
mocs
(
c_b
, 255, 228, 181, 1);

262 cڡ 
C
 
vajowhe
(
c_b
, 255, 222, 173, 1);

263 cڡ 
C
 
vy
(
c_b
, 0, 0, 128, 1);

264 cڡ 
C
 
d
(
c_b
, 253, 245, 230, 1);

265 cڡ 
C
 
ive
(
c_b
, 128, 128, 0, 1);

266 cڡ 
C
 
ivedb
(
c_b
, 107, 142, 35, 1);

267 cڡ 
C
 
ܪge
(
c_b
, 255, 165, 0, 1);

268 cڡ 
C
 
ܪged
(
c_b
, 255, 69, 0, 1);

269 cڡ 
C
 
chid
(
c_b
, 218, 112, 214, 1);

270 cڡ 
C
 
gdrod
(
c_b
, 238, 232, 170, 1);

271 cڡ 
C
 
g
(
c_b
, 152, 251, 152, 1);

272 cڡ 
C
 
turquoi
(
c_b
, 175, 238, 238, 1);

273 cڡ 
C
 
viޑd
(
c_b
, 219, 112, 147, 1);

274 cڡ 
C
 
yawh
(
c_b
, 255, 239, 213, 1);

275 cڡ 
C
 
achpuff
(
c_b
, 255, 218, 185, 1);

276 cڡ 
C
 
ru
(
c_b
, 205, 133, 63, 1);

277 cڡ 
C
 
pk
(
c_b
, 255, 192, 203, 1);

278 cڡ 
C
 
um
(
c_b
, 221, 160, 221, 1);

279 cڡ 
C
 
powdblue
(
c_b
, 176, 224, 230, 1);

280 cڡ 
C
 
pu
(
c_b
, 128, 0, 128, 1);

281 cڡ 
C
 
d
(
c_b
, 255, 0, 0, 1);

282 cڡ 
C
 
rosybrown
(
c_b
, 188, 143, 143, 1);

283 cڡ 
C
 
royblue
(
c_b
, 65, 105, 225, 1);

284 cڡ 
C
 
ddbrown
(
c_b
, 139, 69, 19, 1);

285 cڡ 
C
 
lm
(
c_b
, 250, 128, 114, 1);

286 cڡ 
C
 
ndybrown
(
c_b
, 244, 164, 96, 1);

287 cڡ 
C
 
ag
(
c_b
, 46, 139, 87, 1);

288 cڡ 
C
 
ashl
(
c_b
, 255, 245, 238, 1);

289 cڡ 
C
 
sa
(
c_b
, 160, 82, 45, 1);

290 cڡ 
C
 
sv
(
c_b
, 192, 192, 192, 1);

291 cڡ 
C
 
skyblue
(
c_b
, 135, 206, 235, 1);

292 cڡ 
C
 
eblue
(
c_b
, 106, 90, 205, 1);

293 cڡ 
C
 
egy
(
c_b
, 112, 128, 144, 1);

294 cڡ 
C
 
egy
(
c_b
, 112, 128, 144, 1);

295 cڡ 
C
 
ow
(
c_b
, 255, 250, 250, 1);

296 cڡ 
C
 
rgg
(
c_b
, 0, 255, 127, 1);

297 cڡ 
C
 
lblue
(
c_b
, 70, 130, 180, 1);

298 cڡ 
C
 
n
(
c_b
, 210, 180, 140, 1);

299 cڡ 
C
 

(
c_b
, 0, 128, 128, 1);

300 cڡ 
C
 
thi
(
c_b
, 216, 191, 216, 1);

301 cڡ 
C
 
tomo
(
c_b
, 255, 99, 71, 1);

302 cڡ 
C
 
turquoi
(
c_b
, 64, 224, 208, 1);

303 cڡ 
C
 
viޑ
(
c_b
, 238, 130, 238, 1);

304 cڡ 
C
 
wht
(
c_b
, 245, 222, 179, 1);

305 cڡ 
C
 
whe
(
c_b
, 255, 255, 255, 1);

306 cڡ 
C
 
whesmoke
(
c_b
, 245, 245, 245, 1);

307 cڡ 
C
 
ylow
(
c_b
, 255, 255, 0, 1);

308 cڡ 
C
 
ylowg
(
c_b
, 154, 205, 50, 1);

309 cڡ 
C
 
becpu
(
c_b
, 102, 51, 153, 1);

310 cڡ 
C
 
t
(
c_b
, 0, 0, 0, 0);

313 cڡ 
	gd
::
m
<cڡ , cڡ *> 
	gcs_to_mes
 {

314 { 240 * 0x10000 + 248 * 0x100 + 255, 
	gCNames
::
iblue
 },

315 { 250 * 0x10000 + 235 * 0x100 + 215, 
	gCNames
::
tiquewhe
 },

316 { 0 * 0x10000 + 255 * 0x100 + 255, 
	gCNames
::
cy
 },

317 { 127 * 0x10000 + 255 * 0x100 + 212, 
	gCNames
::
aquame
 },

318 { 240 * 0x10000 + 255 * 0x100 + 255, 
	gCNames
::
azu
 },

319 { 245 * 0x10000 + 245 * 0x100 + 220, 
	gCNames
::
beige
 },

320 { 255 * 0x10000 + 228 * 0x100 + 196, 
	gCNames
::
bisque
 },

321 { 0 * 0x10000 + 0 * 0x100 + 0, 
	gCNames
::
bck
 },

322 { 255 * 0x10000 + 235 * 0x100 + 205, 
	gCNames
::
bnchedmd
 },

323 { 0 * 0x10000 + 0 * 0x100 + 255, 
	gCNames
::
blue
 },

324 { 138 * 0x10000 + 43 * 0x100 + 226, 
	gCNames
::
blueviޑ
 },

325 { 165 * 0x10000 + 42 * 0x100 + 42, 
	gCNames
::
brown
 },

326 { 222 * 0x10000 + 184 * 0x100 + 135, 
	gCNames
::
buywood
 },

327 { 95 * 0x10000 + 158 * 0x100 + 160, 
	gCNames
::
dblue
 },

328 { 127 * 0x10000 + 255 * 0x100 + 0, 
	gCNames
::
cheu
 },

329 { 210 * 0x10000 + 105 * 0x100 + 30, 
	gCNames
::
chocީe
 },

330 { 255 * 0x10000 + 127 * 0x100 + 80, 
	gCNames
::
cܮ
 },

331 { 100 * 0x10000 + 149 * 0x100 + 237, 
	gCNames
::
cnowblue
 },

332 { 255 * 0x10000 + 248 * 0x100 + 220, 
	gCNames
::
cnsk
 },

333 { 220 * 0x10000 + 20 * 0x100 + 60, 
	gCNames
::
ims
 },

334 { 0 * 0x10000 + 0 * 0x100 + 139, 
	gCNames
::
dkblue
 },

335 { 0 * 0x10000 + 139 * 0x100 + 139, 
	gCNames
::
dkcy
 },

336 { 184 * 0x10000 + 134 * 0x100 + 11, 
	gCNames
::
dkgdrod
 },

337 { 169 * 0x10000 + 169 * 0x100 + 169, 
	gCNames
::
dkgy
 },

338 { 0 * 0x10000 + 100 * 0x100 + 0, 
	gCNames
::
dkg
 },

339 { 189 * 0x10000 + 183 * 0x100 + 107, 
	gCNames
::
dkkhaki
 },

340 { 139 * 0x10000 + 0 * 0x100 + 139, 
	gCNames
::
dkmag
 },

341 { 85 * 0x10000 + 107 * 0x100 + 47, 
	gCNames
::
dkiveg
 },

342 { 255 * 0x10000 + 140 * 0x100 + 0, 
	gCNames
::
dkܪge
 },

343 { 153 * 0x10000 + 50 * 0x100 + 204, 
	gCNames
::
dkchid
 },

344 { 139 * 0x10000 + 0 * 0x100 + 0, 
	gCNames
::
dkd
 },

345 { 233 * 0x10000 + 150 * 0x100 + 122, 
	gCNames
::
dklm
 },

346 { 143 * 0x10000 + 188 * 0x100 + 143, 
	gCNames
::
dkag
 },

347 { 72 * 0x10000 + 61 * 0x100 + 139, 
	gCNames
::
dkeblue
 },

348 { 47 * 0x10000 + 79 * 0x100 + 79, 
	gCNames
::
dkegy
 },

349 { 0 * 0x10000 + 206 * 0x100 + 209, 
	gCNames
::
dkturquoi
 },

350 { 148 * 0x10000 + 0 * 0x100 + 211, 
	gCNames
::
dkviޑ
 },

351 { 255 * 0x10000 + 20 * 0x100 + 147, 
	gCNames
::
dk
 },

352 { 0 * 0x10000 + 191 * 0x100 + 255, 
	gCNames
::
dpskyblue
 },

353 { 105 * 0x10000 + 105 * 0x100 + 105, 
	gCNames
::
dimgy
 },

354 { 30 * 0x10000 + 144 * 0x100 + 255, 
	gCNames
::
dodgblue
 },

355 { 178 * 0x10000 + 34 * 0x100 + 34, 
	gCNames
::
febrick
 },

356 { 255 * 0x10000 + 250 * 0x100 + 240, 
	gCNames
::
ܮwhe
 },

357 { 34 * 0x10000 + 139 * 0x100 + 34, 
	gCNames
::
feg
 },

358 { 255 * 0x10000 + 0 * 0x100 + 255, 
	gCNames
::
mag
 },

359 { 220 * 0x10000 + 220 * 0x100 + 220, 
	gCNames
::
gasbo
 },

360 { 248 * 0x10000 + 248 * 0x100 + 255, 
	gCNames
::
ghowhe
 },

361 { 255 * 0x10000 + 215 * 0x100 + 0, 
	gCNames
::
gd
 },

362 { 218 * 0x10000 + 165 * 0x100 + 32, 
	gCNames
::
gdrod
 },

363 { 128 * 0x10000 + 128 * 0x100 + 128, 
	gCNames
::
gy
 },

364 { 0 * 0x10000 + 128 * 0x100 + 0, 
	gCNames
::
g
 },

365 { 173 * 0x10000 + 255 * 0x100 + 47, 
	gCNames
::
gylow
 },

366 { 240 * 0x10000 + 255 * 0x100 + 240, 
	gCNames
::
heydew
 },

367 { 255 * 0x10000 + 105 * 0x100 + 180, 
	gCNames
::
hpk
 },

368 { 205 * 0x10000 + 92 * 0x100 + 92, 
	gCNames
::
ded
 },

369 { 75 * 0x10000 + 0 * 0x100 + 130, 
	gCNames
::
digo
 },

370 { 255 * 0x10000 + 255 * 0x100 + 240, 
	gCNames
::
ivy
 },

371 { 240 * 0x10000 + 230 * 0x100 + 140, 
	gCNames
::
khaki
 },

372 { 230 * 0x10000 + 230 * 0x100 + 250, 
	gCNames
::
vd
 },

373 { 255 * 0x10000 + 240 * 0x100 + 245, 
	gCNames
::
vdblush
 },

374 { 124 * 0x10000 + 252 * 0x100 + 0, 
	gCNames
::
wng
 },

375 { 255 * 0x10000 + 250 * 0x100 + 205, 
	gCNames
::
mchiff
 },

376 { 173 * 0x10000 + 216 * 0x100 + 230, 
	gCNames
::
lightblue
 },

377 { 240 * 0x10000 + 128 * 0x100 + 128, 
	gCNames
::
lightcܮ
 },

378 { 224 * 0x10000 + 255 * 0x100 + 255, 
	gCNames
::
lightcy
 },

379 { 250 * 0x10000 + 250 * 0x100 + 210, 
	gCNames
::
lightgdrodylow
 },

380 { 211 * 0x10000 + 211 * 0x100 + 211, 
	gCNames
::
lightgy
 },

381 { 144 * 0x10000 + 238 * 0x100 + 144, 
	gCNames
::
lightg
 },

382 { 255 * 0x10000 + 182 * 0x100 + 193, 
	gCNames
::
lighk
 },

383 { 255 * 0x10000 + 160 * 0x100 + 122, 
	gCNames
::
lightlm
 },

384 { 32 * 0x10000 + 178 * 0x100 + 170, 
	gCNames
::
lightag
 },

385 { 135 * 0x10000 + 206 * 0x100 + 250, 
	gCNames
::
lightskyblue
 },

386 { 119 * 0x10000 + 136 * 0x100 + 153, 
	gCNames
::
lightegy
 },

387 { 176 * 0x10000 + 196 * 0x100 + 222, 
	gCNames
::
lightlblue
 },

388 { 255 * 0x10000 + 255 * 0x100 + 224, 
	gCNames
::
lightylow
 },

389 { 0 * 0x10000 + 255 * 0x100 + 0, 
	gCNames
::
lime
 },

390 { 50 * 0x10000 + 205 * 0x100 + 50, 
	gCNames
::
limeg
 },

391 { 250 * 0x10000 + 240 * 0x100 + 230, 
	gCNames
::
l
 },

392 { 128 * 0x10000 + 0 * 0x100 + 0, 
	gCNames
::
mo
 },

393 { 102 * 0x10000 + 205 * 0x100 + 170, 
	gCNames
::
mediumaquame
 },

394 { 0 * 0x10000 + 0 * 0x100 + 205, 
	gCNames
::
mediumblue
 },

395 { 186 * 0x10000 + 85 * 0x100 + 211, 
	gCNames
::
mediumchid
 },

396 { 147 * 0x10000 + 112 * 0x100 + 219, 
	gCNames
::
mediumpu
 },

397 { 60 * 0x10000 + 179 * 0x100 + 113, 
	gCNames
::
mediumag
 },

398 { 123 * 0x10000 + 104 * 0x100 + 238, 
	gCNames
::
mediumeblue
 },

399 { 0 * 0x10000 + 250 * 0x100 + 154, 
	gCNames
::
mediumrgg
 },

400 { 72 * 0x10000 + 209 * 0x100 + 204, 
	gCNames
::
mediumturquoi
 },

401 { 199 * 0x10000 + 21 * 0x100 + 133, 
	gCNames
::
mediumviޑd
 },

402 { 25 * 0x10000 + 25 * 0x100 + 112, 
	gCNames
::
midnightblue
 },

403 { 245 * 0x10000 + 255 * 0x100 + 250, 
	gCNames
::
mtm
 },

404 { 255 * 0x10000 + 228 * 0x100 + 225, 
	gCNames
::
miyro
 },

405 { 255 * 0x10000 + 228 * 0x100 + 181, 
	gCNames
::
mocs
 },

406 { 255 * 0x10000 + 222 * 0x100 + 173, 
	gCNames
::
vajowhe
 },

407 { 0 * 0x10000 + 0 * 0x100 + 128, 
	gCNames
::
vy
 },

408 { 253 * 0x10000 + 245 * 0x100 + 230, 
	gCNames
::
d
 },

409 { 128 * 0x10000 + 128 * 0x100 + 0, 
	gCNames
::
ive
 },

410 { 107 * 0x10000 + 142 * 0x100 + 35, 
	gCNames
::
ivedb
 },

411 { 255 * 0x10000 + 165 * 0x100 + 0, 
	gCNames
::
ܪge
 },

412 { 255 * 0x10000 + 69 * 0x100 + 0, 
	gCNames
::
ܪged
 },

413 { 218 * 0x10000 + 112 * 0x100 + 214, 
	gCNames
::
chid
 },

414 { 238 * 0x10000 + 232 * 0x100 + 170, 
	gCNames
::
gdrod
 },

415 { 152 * 0x10000 + 251 * 0x100 + 152, 
	gCNames
::
g
 },

416 { 175 * 0x10000 + 238 * 0x100 + 238, 
	gCNames
::
turquoi
 },

417 { 219 * 0x10000 + 112 * 0x100 + 147, 
	gCNames
::
viޑd
 },

418 { 255 * 0x10000 + 239 * 0x100 + 213, 
	gCNames
::
yawh
 },

419 { 255 * 0x10000 + 218 * 0x100 + 185, 
	gCNames
::
achpuff
 },

420 { 205 * 0x10000 + 133 * 0x100 + 63, 
	gCNames
::
ru
 },

421 { 255 * 0x10000 + 192 * 0x100 + 203, 
	gCNames
::
pk
 },

422 { 221 * 0x10000 + 160 * 0x100 + 221, 
	gCNames
::
um
 },

423 { 176 * 0x10000 + 224 * 0x100 + 230, 
	gCNames
::
powdblue
 },

424 { 128 * 0x10000 + 0 * 0x100 + 128, 
	gCNames
::
pu
 },

425 { 255 * 0x10000 + 0 * 0x100 + 0, 
	gCNames
::
d
 },

426 { 188 * 0x10000 + 143 * 0x100 + 143, 
	gCNames
::
rosybrown
 },

427 { 65 * 0x10000 + 105 * 0x100 + 225, 
	gCNames
::
royblue
 },

428 { 139 * 0x10000 + 69 * 0x100 + 19, 
	gCNames
::
ddbrown
 },

429 { 250 * 0x10000 + 128 * 0x100 + 114, 
	gCNames
::
lm
 },

430 { 244 * 0x10000 + 164 * 0x100 + 96, 
	gCNames
::
ndybrown
 },

431 { 46 * 0x10000 + 139 * 0x100 + 87, 
	gCNames
::
ag
 },

432 { 255 * 0x10000 + 245 * 0x100 + 238, 
	gCNames
::
ashl
 },

433 { 160 * 0x10000 + 82 * 0x100 + 45, 
	gCNames
::
sa
 },

434 { 192 * 0x10000 + 192 * 0x100 + 192, 
	gCNames
::
sv
 },

435 { 135 * 0x10000 + 206 * 0x100 + 235, 
	gCNames
::
skyblue
 },

436 { 106 * 0x10000 + 90 * 0x100 + 205, 
	gCNames
::
eblue
 },

437 { 112 * 0x10000 + 128 * 0x100 + 144, 
	gCNames
::
egy
 },

438 { 255 * 0x10000 + 250 * 0x100 + 250, 
	gCNames
::
ow
 },

439 { 0 * 0x10000 + 255 * 0x100 + 127, 
	gCNames
::
rgg
 },

440 { 70 * 0x10000 + 130 * 0x100 + 180, 
	gCNames
::
lblue
 },

441 { 210 * 0x10000 + 180 * 0x100 + 140, 
	gCNames
::
n
 },

442 { 0 * 0x10000 + 128 * 0x100 + 128, 
	gCNames
::

 },

443 { 216 * 0x10000 + 191 * 0x100 + 216, 
	gCNames
::
thi
 },

444 { 255 * 0x10000 + 99 * 0x100 + 71, 
	gCNames
::
tomo
 },

445 { 64 * 0x10000 + 224 * 0x100 + 208, 
	gCNames
::
turquoi
 },

446 { 238 * 0x10000 + 130 * 0x100 + 238, 
	gCNames
::
viޑ
 },

447 { 245 * 0x10000 + 222 * 0x100 + 179, 
	gCNames
::
wht
 },

448 { 255 * 0x10000 + 255 * 0x100 + 255, 
	gCNames
::
whe
 },

449 { 245 * 0x10000 + 245 * 0x100 + 245, 
	gCNames
::
whesmoke
 },

450 { 255 * 0x10000 + 255 * 0x100 + 0, 
	gCNames
::
ylow
 },

451 { 154 * 0x10000 + 205 * 0x100 + 50, 
	gCNames
::
ylowg
 },

452 { 102 * 0x10000 + 51 * 0x100 + 153, 
	gCNames
::
becpu
 }

455 cڡ 
	gd
::
m
<cڡ *, cڡ 
	gC
*, 
	gm_cmp_r
> 
	gmes_to_cs


457 { 
	gCNames
::
iblue
, &
	gCs
::aliceblue },

458 { 
	gCNames
::
tiquewhe
, &
	gCs
::antiquewhite },

459 { 
	gCNames
::
cy
, &
	gCs
::cyan },

460 { 
	gCNames
::
aqua
, &
	gCs
::aqua },

461 { 
	gCNames
::
aquame
, &
	gCs
::aquamarine },

462 { 
	gCNames
::
azu
, &
	gCs
::azure },

463 { 
	gCNames
::
beige
, &
	gCs
::beige },

464 { 
	gCNames
::
bisque
, &
	gCs
::bisque },

465 { 
	gCNames
::
bck
, &
	gCs
::black },

466 { 
	gCNames
::
bnchedmd
, &
	gCs
::blanchedalmond },

467 { 
	gCNames
::
blue
, &
	gCs
::blue },

468 { 
	gCNames
::
blueviޑ
, &
	gCs
::blueviolet },

469 { 
	gCNames
::
brown
, &
	gCs
::brown },

470 { 
	gCNames
::
buywood
, &
	gCs
::burlywood },

471 { 
	gCNames
::
dblue
, &
	gCs
::cadetblue },

472 { 
	gCNames
::
cheu
, &
	gCs
::chartreuse },

473 { 
	gCNames
::
chocީe
, &
	gCs
::chocolate },

474 { 
	gCNames
::
cܮ
, &
	gCs
::coral },

475 { 
	gCNames
::
cnowblue
, &
	gCs
::cornflowerblue },

476 { 
	gCNames
::
cnsk
, &
	gCs
::cornsilk },

477 { 
	gCNames
::
ims
, &
	gCs
::crimson },

478 { 
	gCNames
::
dkblue
, &
	gCs
::darkblue },

479 { 
	gCNames
::
dkcy
, &
	gCs
::darkcyan },

480 { 
	gCNames
::
dkgdrod
, &
	gCs
::darkgoldenrod },

481 { 
	gCNames
::
dkgy
, &
	gCs
::darkgray },

482 { 
	gCNames
::
dkgy
, &
	gCs
::darkgrey },

483 { 
	gCNames
::
dkg
, &
	gCs
::darkgreen },

484 { 
	gCNames
::
dkkhaki
, &
	gCs
::darkkhaki },

485 { 
	gCNames
::
dkmag
, &
	gCs
::darkmagenta },

486 { 
	gCNames
::
dkiveg
, &
	gCs
::darkolivegreen },

487 { 
	gCNames
::
dkܪge
, &
	gCs
::darkorange },

488 { 
	gCNames
::
dkchid
, &
	gCs
::darkorchid },

489 { 
	gCNames
::
dkd
, &
	gCs
::darkred },

490 { 
	gCNames
::
dklm
, &
	gCs
::darksalmon },

491 { 
	gCNames
::
dkag
, &
	gCs
::darkseagreen },

492 { 
	gCNames
::
dkeblue
, &
	gCs
::darkslateblue },

493 { 
	gCNames
::
dkegy
, &
	gCs
::darkslategray },

494 { 
	gCNames
::
dkegy
, &
	gCs
::darkslategrey },

495 { 
	gCNames
::
dkturquoi
, &
	gCs
::darkturquoise },

496 { 
	gCNames
::
dkviޑ
, &
	gCs
::darkviolet },

497 { 
	gCNames
::
dk
, &
	gCs
::deeppink },

498 { 
	gCNames
::
dpskyblue
, &
	gCs
::deepskyblue },

499 { 
	gCNames
::
dimgy
, &
	gCs
::dimgray },

500 { 
	gCNames
::
dimgy
, &
	gCs
::dimgrey },

501 { 
	gCNames
::
dodgblue
, &
	gCs
::dodgerblue },

502 { 
	gCNames
::
febrick
, &
	gCs
::firebrick },

503 { 
	gCNames
::
ܮwhe
, &
	gCs
::floralwhite },

504 { 
	gCNames
::
feg
, &
	gCs
::forestgreen },

505 { 
	gCNames
::
mag
, &
	gCs
::magenta },

506 { 
	gCNames
::
fuchs
, &
	gCs
::fuchsia },

507 { 
	gCNames
::
gasbo
, &
	gCs
::gainsboro },

508 { 
	gCNames
::
ghowhe
, &
	gCs
::ghostwhite },

509 { 
	gCNames
::
gd
, &
	gCs
::gold },

510 { 
	gCNames
::
gdrod
, &
	gCs
::goldenrod },

511 { 
	gCNames
::
gy
, &
	gCs
::gray },

512 { 
	gCNames
::
gy
, &
	gCs
::grey },

513 { 
	gCNames
::
g
, &
	gCs
::green },

514 { 
	gCNames
::
gylow
, &
	gCs
::greenyellow },

515 { 
	gCNames
::
heydew
, &
	gCs
::honeydew },

516 { 
	gCNames
::
hpk
, &
	gCs
::hotpink },

517 { 
	gCNames
::
ded
, &
	gCs
::indianred },

518 { 
	gCNames
::
digo
, &
	gCs
::indigo },

519 { 
	gCNames
::
ivy
, &
	gCs
::ivory },

520 { 
	gCNames
::
khaki
, &
	gCs
::khaki },

521 { 
	gCNames
::
vd
, &
	gCs
::lavender },

522 { 
	gCNames
::
vdblush
, &
	gCs
::lavenderblush },

523 { 
	gCNames
::
wng
, &
	gCs
::lawngreen },

524 { 
	gCNames
::
mchiff
, &
	gCs
::lemonchiffon },

525 { 
	gCNames
::
lightblue
, &
	gCs
::lightblue },

526 { 
	gCNames
::
lightcܮ
, &
	gCs
::lightcoral },

527 { 
	gCNames
::
lightcy
, &
	gCs
::lightcyan },

528 { 
	gCNames
::
lightgdrodylow
, &
	gCs
::lightgoldenrodyellow },

529 { 
	gCNames
::
lightgy
, &
	gCs
::lightgray },

530 { 
	gCNames
::
lightgy
, &
	gCs
::lightgrey },

531 { 
	gCNames
::
lightg
, &
	gCs
::lightgreen },

532 { 
	gCNames
::
lighk
, &
	gCs
::lightpink },

533 { 
	gCNames
::
lightlm
, &
	gCs
::lightsalmon },

534 { 
	gCNames
::
lightag
, &
	gCs
::lightseagreen },

535 { 
	gCNames
::
lightskyblue
, &
	gCs
::lightskyblue },

536 { 
	gCNames
::
lightegy
, &
	gCs
::lightslategray },

537 { 
	gCNames
::
lightegy
, &
	gCs
::lightslategrey },

538 { 
	gCNames
::
lightlblue
, &
	gCs
::lightsteelblue },

539 { 
	gCNames
::
lightylow
, &
	gCs
::lightyellow },

540 { 
	gCNames
::
lime
, &
	gCs
::lime },

541 { 
	gCNames
::
limeg
, &
	gCs
::limegreen },

542 { 
	gCNames
::
l
, &
	gCs
::linen },

543 { 
	gCNames
::
mo
, &
	gCs
::maroon },

544 { 
	gCNames
::
mediumaquame
, &
	gCs
::mediumaquamarine },

545 { 
	gCNames
::
mediumblue
, &
	gCs
::mediumblue },

546 { 
	gCNames
::
mediumchid
, &
	gCs
::mediumorchid },

547 { 
	gCNames
::
mediumpu
, &
	gCs
::mediumpurple },

548 { 
	gCNames
::
mediumag
, &
	gCs
::mediumseagreen },

549 { 
	gCNames
::
mediumeblue
, &
	gCs
::mediumslateblue },

550 { 
	gCNames
::
mediumrgg
, &
	gCs
::mediumspringgreen },

551 { 
	gCNames
::
mediumturquoi
, &
	gCs
::mediumturquoise },

552 { 
	gCNames
::
mediumviޑd
, &
	gCs
::mediumvioletred },

553 { 
	gCNames
::
midnightblue
, &
	gCs
::midnightblue },

554 { 
	gCNames
::
mtm
, &
	gCs
::mintcream },

555 { 
	gCNames
::
miyro
, &
	gCs
::mistyrose },

556 { 
	gCNames
::
mocs
, &
	gCs
::moccasin },

557 { 
	gCNames
::
vajowhe
, &
	gCs
::navajowhite },

558 { 
	gCNames
::
vy
, &
	gCs
::navy },

559 { 
	gCNames
::
d
, &
	gCs
::oldlace },

560 { 
	gCNames
::
ive
, &
	gCs
::olive },

561 { 
	gCNames
::
ivedb
, &
	gCs
::olivedrab },

562 { 
	gCNames
::
ܪge
, &
	gCs
::orange },

563 { 
	gCNames
::
ܪged
, &
	gCs
::orangered },

564 { 
	gCNames
::
chid
, &
	gCs
::orchid },

565 { 
	gCNames
::
gdrod
, &
	gCs
::palegoldenrod },

566 { 
	gCNames
::
g
, &
	gCs
::palegreen },

567 { 
	gCNames
::
turquoi
, &
	gCs
::paleturquoise },

568 { 
	gCNames
::
viޑd
, &
	gCs
::palevioletred },

569 { 
	gCNames
::
yawh
, &
	gCs
::papayawhip },

570 { 
	gCNames
::
achpuff
, &
	gCs
::peachpuff },

571 { 
	gCNames
::
ru
, &
	gCs
::peru },

572 { 
	gCNames
::
pk
, &
	gCs
::pink },

573 { 
	gCNames
::
um
, &
	gCs
::plum },

574 { 
	gCNames
::
powdblue
, &
	gCs
::powderblue },

575 { 
	gCNames
::
pu
, &
	gCs
::purple },

576 { 
	gCNames
::
d
, &
	gCs
::red },

577 { 
	gCNames
::
rosybrown
, &
	gCs
::rosybrown },

578 { 
	gCNames
::
royblue
, &
	gCs
::royalblue },

579 { 
	gCNames
::
ddbrown
, &
	gCs
::saddlebrown },

580 { 
	gCNames
::
lm
, &
	gCs
::salmon },

581 { 
	gCNames
::
ndybrown
, &
	gCs
::sandybrown },

582 { 
	gCNames
::
ag
, &
	gCs
::seagreen },

583 { 
	gCNames
::
ashl
, &
	gCs
::seashell },

584 { 
	gCNames
::
sa
, &
	gCs
::sienna },

585 { 
	gCNames
::
sv
, &
	gCs
::silver },

586 { 
	gCNames
::
skyblue
, &
	gCs
::skyblue },

587 { 
	gCNames
::
eblue
, &
	gCs
::slateblue },

588 { 
	gCNames
::
egy
, &
	gCs
::slategray },

589 { 
	gCNames
::
egy
, &
	gCs
::slategrey },

590 { 
	gCNames
::
ow
, &
	gCs
::snow },

591 { 
	gCNames
::
rgg
, &
	gCs
::springgreen },

592 { 
	gCNames
::
lblue
, &
	gCs
::steelblue },

593 { 
	gCNames
::
n
, &
	gCs
::tan },

594 { 
	gCNames
::

, &
	gCs
::teal },

595 { 
	gCNames
::
thi
, &
	gCs
::thistle },

596 { 
	gCNames
::
tomo
, &
	gCs
::tomato },

597 { 
	gCNames
::
turquoi
, &
	gCs
::turquoise },

598 { 
	gCNames
::
viޑ
, &
	gCs
::violet },

599 { 
	gCNames
::
wht
, &
	gCs
::wheat },

600 { 
	gCNames
::
whe
, &
	gCs
::white },

601 { 
	gCNames
::
whesmoke
, &
	gCs
::whitesmoke },

602 { 
	gCNames
::
ylow
, &
	gCs
::yellow },

603 { 
	gCNames
::
ylowg
, &
	gCs
::yellowgreen },

604 { 
	gCNames
::
becpu
, &
	gCs
::rebeccapurple },

605 { 
	gCNames
::
t
, &
	gCs
::transparent }

608 cڡ 
C
* 
me_to_c
(cڡ * 
key
)

610 aut
	gp
 = 
mes_to_cs
.
fd
(
key
);

611 i(
	gp
 !
mes_to_cs
.
d
()) {

612  
p
->
cd
;

617 cڡ 
C
* 
me_to_c
(cڡ 
d
::
rg
& 
key
)

619  
me_to_c
(
key
.
c_r
());

622 cڡ * 
c_to_me
(cڡ 
key
)

624 aut
	gp
 = 
cs_to_mes
.
fd
(
key
);

625 i(
	gp
 !
cs_to_mes
.
d
()) {

626  
p
->
cd
;

631 cڡ * 
c_to_me
(cڡ 
key
)

633  
c_to_me
(()
key
);

636 cڡ * 
c_to_me
(cڡ 
C
& 
c
)

638 
	gkey
 = 
c
.
r
() * 0x10000

639 + 
c
.
g
() * 0x100

640 + 
c
.
b
();

641  
c_to_me
(
key
);

	@node_modules/node-sass/src/libsass/src/color_maps.hpp

1 #ide
SASS_COLOR_MAPS_H


2 
	#SASS_COLOR_MAPS_H


	)

4 
	~<m
>

5 
	~"a.h
"

7 
mea
 
	gSass
 {

9 
	sm_cmp_r


11 
bo
 
ݔ
()(cڡ *
	ga
, cڡ *
	gb
) const

13  
	gd
::
rcmp
(
a
, 
b
) < 0;

17 
mea
 
	gCNames


19 cڡ 
iblue
[];

20 cڡ 
tiquewhe
[];

21 cڡ 
cy
[];

22 cڡ 
aqua
[];

23 cڡ 
aquame
[];

24 cڡ 
azu
[];

25 cڡ 
beige
[];

26 cڡ 
bisque
[];

27 cڡ 
bck
[];

28 cڡ 
bnchedmd
[];

29 cڡ 
blue
[];

30 cڡ 
blueviޑ
[];

31 cڡ 
brown
[];

32 cڡ 
buywood
[];

33 cڡ 
dblue
[];

34 cڡ 
cheu
[];

35 cڡ 
chocީe
[];

36 cڡ 
cܮ
[];

37 cڡ 
cnowblue
[];

38 cڡ 
cnsk
[];

39 cڡ 
ims
[];

40 cڡ 
dkblue
[];

41 cڡ 
dkcy
[];

42 cڡ 
dkgdrod
[];

43 cڡ 
dkgy
[];

44 cڡ 
dkgy
[];

45 cڡ 
dkg
[];

46 cڡ 
dkkhaki
[];

47 cڡ 
dkmag
[];

48 cڡ 
dkiveg
[];

49 cڡ 
dkܪge
[];

50 cڡ 
dkchid
[];

51 cڡ 
dkd
[];

52 cڡ 
dklm
[];

53 cڡ 
dkag
[];

54 cڡ 
dkeblue
[];

55 cڡ 
dkegy
[];

56 cڡ 
dkegy
[];

57 cڡ 
dkturquoi
[];

58 cڡ 
dkviޑ
[];

59 cڡ 
dk
[];

60 cڡ 
dpskyblue
[];

61 cڡ 
dimgy
[];

62 cڡ 
dimgy
[];

63 cڡ 
dodgblue
[];

64 cڡ 
febrick
[];

65 cڡ 
ܮwhe
[];

66 cڡ 
feg
[];

67 cڡ 
mag
[];

68 cڡ 
fuchs
[];

69 cڡ 
gasbo
[];

70 cڡ 
ghowhe
[];

71 cڡ 
gd
[];

72 cڡ 
gdrod
[];

73 cڡ 
gy
[];

74 cڡ 
gy
[];

75 cڡ 
g
[];

76 cڡ 
gylow
[];

77 cڡ 
heydew
[];

78 cڡ 
hpk
[];

79 cڡ 
ded
[];

80 cڡ 
digo
[];

81 cڡ 
ivy
[];

82 cڡ 
khaki
[];

83 cڡ 
vd
[];

84 cڡ 
vdblush
[];

85 cڡ 
wng
[];

86 cڡ 
mchiff
[];

87 cڡ 
lightblue
[];

88 cڡ 
lightcܮ
[];

89 cڡ 
lightcy
[];

90 cڡ 
lightgdrodylow
[];

91 cڡ 
lightgy
[];

92 cڡ 
lightgy
[];

93 cڡ 
lightg
[];

94 cڡ 
lighk
[];

95 cڡ 
lightlm
[];

96 cڡ 
lightag
[];

97 cڡ 
lightskyblue
[];

98 cڡ 
lightegy
[];

99 cڡ 
lightegy
[];

100 cڡ 
lightlblue
[];

101 cڡ 
lightylow
[];

102 cڡ 
lime
[];

103 cڡ 
limeg
[];

104 cڡ 
l
[];

105 cڡ 
mo
[];

106 cڡ 
mediumaquame
[];

107 cڡ 
mediumblue
[];

108 cڡ 
mediumchid
[];

109 cڡ 
mediumpu
[];

110 cڡ 
mediumag
[];

111 cڡ 
mediumeblue
[];

112 cڡ 
mediumrgg
[];

113 cڡ 
mediumturquoi
[];

114 cڡ 
mediumviޑd
[];

115 cڡ 
midnightblue
[];

116 cڡ 
mtm
[];

117 cڡ 
miyro
[];

118 cڡ 
mocs
[];

119 cڡ 
vajowhe
[];

120 cڡ 
vy
[];

121 cڡ 
d
[];

122 cڡ 
ive
[];

123 cڡ 
ivedb
[];

124 cڡ 
ܪge
[];

125 cڡ 
ܪged
[];

126 cڡ 
chid
[];

127 cڡ 
gdrod
[];

128 cڡ 
g
[];

129 cڡ 
turquoi
[];

130 cڡ 
viޑd
[];

131 cڡ 
yawh
[];

132 cڡ 
achpuff
[];

133 cڡ 
ru
[];

134 cڡ 
pk
[];

135 cڡ 
um
[];

136 cڡ 
powdblue
[];

137 cڡ 
pu
[];

138 cڡ 
d
[];

139 cڡ 
rosybrown
[];

140 cڡ 
royblue
[];

141 cڡ 
ddbrown
[];

142 cڡ 
lm
[];

143 cڡ 
ndybrown
[];

144 cڡ 
ag
[];

145 cڡ 
ashl
[];

146 cڡ 
sa
[];

147 cڡ 
sv
[];

148 cڡ 
skyblue
[];

149 cڡ 
eblue
[];

150 cڡ 
egy
[];

151 cڡ 
egy
[];

152 cڡ 
ow
[];

153 cڡ 
rgg
[];

154 cڡ 
lblue
[];

155 cڡ 
n
[];

156 cڡ 

[];

157 cڡ 
thi
[];

158 cڡ 
tomo
[];

159 cڡ 
turquoi
[];

160 cڡ 
viޑ
[];

161 cڡ 
wht
[];

162 cڡ 
whe
[];

163 cڡ 
whesmoke
[];

164 cڡ 
ylow
[];

165 cڡ 
ylowg
[];

166 cڡ 
becpu
[];

167 cڡ 
t
[];

170 
mea
 
	gCs
 {

171 cڡ 
C
 
iblue
;

172 cڡ 
C
 
tiquewhe
;

173 cڡ 
C
 
cy
;

174 cڡ 
C
 
aqua
;

175 cڡ 
C
 
aquame
;

176 cڡ 
C
 
azu
;

177 cڡ 
C
 
beige
;

178 cڡ 
C
 
bisque
;

179 cڡ 
C
 
bck
;

180 cڡ 
C
 
bnchedmd
;

181 cڡ 
C
 
blue
;

182 cڡ 
C
 
blueviޑ
;

183 cڡ 
C
 
brown
;

184 cڡ 
C
 
buywood
;

185 cڡ 
C
 
dblue
;

186 cڡ 
C
 
cheu
;

187 cڡ 
C
 
chocީe
;

188 cڡ 
C
 
cܮ
;

189 cڡ 
C
 
cnowblue
;

190 cڡ 
C
 
cnsk
;

191 cڡ 
C
 
ims
;

192 cڡ 
C
 
dkblue
;

193 cڡ 
C
 
dkcy
;

194 cڡ 
C
 
dkgdrod
;

195 cڡ 
C
 
dkgy
;

196 cڡ 
C
 
dkgy
;

197 cڡ 
C
 
dkg
;

198 cڡ 
C
 
dkkhaki
;

199 cڡ 
C
 
dkmag
;

200 cڡ 
C
 
dkiveg
;

201 cڡ 
C
 
dkܪge
;

202 cڡ 
C
 
dkchid
;

203 cڡ 
C
 
dkd
;

204 cڡ 
C
 
dklm
;

205 cڡ 
C
 
dkag
;

206 cڡ 
C
 
dkeblue
;

207 cڡ 
C
 
dkegy
;

208 cڡ 
C
 
dkegy
;

209 cڡ 
C
 
dkturquoi
;

210 cڡ 
C
 
dkviޑ
;

211 cڡ 
C
 
dk
;

212 cڡ 
C
 
dpskyblue
;

213 cڡ 
C
 
dimgy
;

214 cڡ 
C
 
dimgy
;

215 cڡ 
C
 
dodgblue
;

216 cڡ 
C
 
febrick
;

217 cڡ 
C
 
ܮwhe
;

218 cڡ 
C
 
feg
;

219 cڡ 
C
 
mag
;

220 cڡ 
C
 
fuchs
;

221 cڡ 
C
 
gasbo
;

222 cڡ 
C
 
ghowhe
;

223 cڡ 
C
 
gd
;

224 cڡ 
C
 
gdrod
;

225 cڡ 
C
 
gy
;

226 cڡ 
C
 
gy
;

227 cڡ 
C
 
g
;

228 cڡ 
C
 
gylow
;

229 cڡ 
C
 
heydew
;

230 cڡ 
C
 
hpk
;

231 cڡ 
C
 
ded
;

232 cڡ 
C
 
digo
;

233 cڡ 
C
 
ivy
;

234 cڡ 
C
 
khaki
;

235 cڡ 
C
 
vd
;

236 cڡ 
C
 
vdblush
;

237 cڡ 
C
 
wng
;

238 cڡ 
C
 
mchiff
;

239 cڡ 
C
 
lightblue
;

240 cڡ 
C
 
lightcܮ
;

241 cڡ 
C
 
lightcy
;

242 cڡ 
C
 
lightgdrodylow
;

243 cڡ 
C
 
lightgy
;

244 cڡ 
C
 
lightgy
;

245 cڡ 
C
 
lightg
;

246 cڡ 
C
 
lighk
;

247 cڡ 
C
 
lightlm
;

248 cڡ 
C
 
lightag
;

249 cڡ 
C
 
lightskyblue
;

250 cڡ 
C
 
lightegy
;

251 cڡ 
C
 
lightegy
;

252 cڡ 
C
 
lightlblue
;

253 cڡ 
C
 
lightylow
;

254 cڡ 
C
 
lime
;

255 cڡ 
C
 
limeg
;

256 cڡ 
C
 
l
;

257 cڡ 
C
 
mo
;

258 cڡ 
C
 
mediumaquame
;

259 cڡ 
C
 
mediumblue
;

260 cڡ 
C
 
mediumchid
;

261 cڡ 
C
 
mediumpu
;

262 cڡ 
C
 
mediumag
;

263 cڡ 
C
 
mediumeblue
;

264 cڡ 
C
 
mediumrgg
;

265 cڡ 
C
 
mediumturquoi
;

266 cڡ 
C
 
mediumviޑd
;

267 cڡ 
C
 
midnightblue
;

268 cڡ 
C
 
mtm
;

269 cڡ 
C
 
miyro
;

270 cڡ 
C
 
mocs
;

271 cڡ 
C
 
vajowhe
;

272 cڡ 
C
 
vy
;

273 cڡ 
C
 
d
;

274 cڡ 
C
 
ive
;

275 cڡ 
C
 
ivedb
;

276 cڡ 
C
 
ܪge
;

277 cڡ 
C
 
ܪged
;

278 cڡ 
C
 
chid
;

279 cڡ 
C
 
gdrod
;

280 cڡ 
C
 
g
;

281 cڡ 
C
 
turquoi
;

282 cڡ 
C
 
viޑd
;

283 cڡ 
C
 
yawh
;

284 cڡ 
C
 
achpuff
;

285 cڡ 
C
 
ru
;

286 cڡ 
C
 
pk
;

287 cڡ 
C
 
um
;

288 cڡ 
C
 
powdblue
;

289 cڡ 
C
 
pu
;

290 cڡ 
C
 
d
;

291 cڡ 
C
 
rosybrown
;

292 cڡ 
C
 
royblue
;

293 cڡ 
C
 
ddbrown
;

294 cڡ 
C
 
lm
;

295 cڡ 
C
 
ndybrown
;

296 cڡ 
C
 
ag
;

297 cڡ 
C
 
ashl
;

298 cڡ 
C
 
sa
;

299 cڡ 
C
 
sv
;

300 cڡ 
C
 
skyblue
;

301 cڡ 
C
 
eblue
;

302 cڡ 
C
 
egy
;

303 cڡ 
C
 
egy
;

304 cڡ 
C
 
ow
;

305 cڡ 
C
 
rgg
;

306 cڡ 
C
 
lblue
;

307 cڡ 
C
 
n
;

308 cڡ 
C
 

;

309 cڡ 
C
 
thi
;

310 cڡ 
C
 
tomo
;

311 cڡ 
C
 
turquoi
;

312 cڡ 
C
 
viޑ
;

313 cڡ 
C
 
wht
;

314 cڡ 
C
 
whe
;

315 cڡ 
C
 
whesmoke
;

316 cڡ 
C
 
ylow
;

317 cڡ 
C
 
ylowg
;

318 cڡ 
C
 
becpu
;

319 cڡ 
C
 
t
;

322 cڡ 
d
::
m
<cڡ , cڡ *> 
cs_to_mes
;

323 cڡ 
d
::
m
<cڡ *, cڡ 
C
*, 
m_cmp_r
> 
mes_to_cs
;

325 cڡ 
C
* 
me_to_c
(const *);

326 cڡ 
C
* 
me_to_c
(cڡ 
d
::
rg
&);

327 cڡ * 
c_to_me
(const );

328 cڡ * 
c_to_me
(cڡ 
C
&);

329 cڡ * 
c_to_me
(const );

	@node_modules/node-sass/src/libsass/src/constants.cpp

1 
	~"ss.h
"

2 
	~"cڡts.h
"

4 
mea
 
	gSass
 {

5 
mea
 
	gCڡts
 {

7 cڡ 
MaxClSck
 = 1024;

12 cڡ 
Scificy_Sr
 = 0;

13 cڡ 
Scificy_Univl
 = 1 << 0;

14 cڡ 
Scificy_Ty
 = 1 << 8;

15 cڡ 
Scificy_Css
 = 1 << 16;

16 cڡ 
Scificy_Ar
 = 1 << 16;

17 cڡ 
Scificy_Pudo
 = 1 << 16;

18 cڡ 
Scificy_ID
 = 1 << 24;

21 cڡ 
_ro_kwd
[] = "@at-root";

22 cڡ 
impt_kwd
[] = "@import";

23 cڡ 
mix_kwd
[] = "@mixin";

24 cڡ 
funi_kwd
[] = "@function";

25 cڡ 
tu_kwd
[] = "@return";

26 cڡ 
ude_kwd
[] = "@include";

27 cڡ 
cڋ_kwd
[] = "@content";

28 cڡ 
exnd_kwd
[] = "@extend";

29 cڡ 
if_kwd
[] = "@if";

30 cڡ 
_kwd
[] = "@else";

31 cڡ 
if_a__kwd
[] = "if";

32 cڡ 
f_kwd
[] = "@for";

33 cڡ 
om_kwd
[] = "from";

34 cڡ 
to_kwd
[] = "to";

35 cڡ 
through_kwd
[] = "through";

36 cڡ 
ch_kwd
[] = "@each";

37 cڡ 
_kwd
[] = "in";

38 cڡ 
whe_kwd
[] = "@while";

39 cڡ 
wn_kwd
[] = "@warn";

40 cڡ 
r_kwd
[] = "@error";

41 cڡ 
debug_kwd
[] = "@debug";

42 cڡ 
deu_kwd
[] = "default";

43 cڡ 
glob_kwd
[] = "global";

44 cڡ 
nu_kwd
[] = "null";

45 cڡ 
tiڮ_kwd
[] = "optional";

46 cڡ 
wh_kwd
[] = "with";

47 cڡ 
whout_kwd
[] = "without";

48 cڡ 
l_kwd
[] = "all";

49 cڡ 
ru_kwd
[] = "rule";

52 cڡ 
em_kwd
[] = "em";

53 cڡ 
ex_kwd
[] = "ex";

54 cڡ 
px_kwd
[] = "px";

55 cڡ 
cm_kwd
[] = "cm";

56 cڡ 
mm_kwd
[] = "mm";

57 cڡ 
_kwd
[] = "pt";

58 cڡ 
pc_kwd
[] = "pc";

59 cڡ 
deg_kwd
[] = "deg";

60 cڡ 
d_kwd
[] = "rad";

61 cڡ 
gd_kwd
[] = "grad";

62 cڡ 
tu_kwd
[] = "turn";

63 cڡ 
ms_kwd
[] = "ms";

64 cڡ 
s_kwd
[] = "s";

65 cڡ 
Hz_kwd
[] = "Hz";

66 cڡ 
kHz_kwd
[] = "kHz";

69 cڡ 
vd_ݔa_kwd
[] = "-o-";

70 cڡ 
vd_webk_kwd
[] = "-webkit-";

71 cڡ 
vd_moz_kwd
[] = "-moz-";

72 cڡ 
vd_ms_kwd
[] = "-ms-";

73 cڡ 
vd_khtml_kwd
[] = "-khtml-";

76 cڡ 
cht_kwd
[] = "@charset";

77 cڡ 
med_kwd
[] = "@media";

78 cڡ 
suts_kwd
[] = "@supports";

79 cڡ 
keyames_kwd
[] = "keyframes";

80 cڡ 
ly_kwd
[] = "only";

81 cڡ 
rgb_kwd
[] = "rgb(";

82 cڡ 
u_kwd
[] = "url";

84 cڡ 
imp܏_kwd
[] = "important";

85 cڡ 
pudo_n_kwd
[] = ":not(";

86 cڡ 
ev_kwd
[] = "even";

87 cڡ 
odd_kwd
[] = "odd";

88 cڡ 
ogid_kwd
[] = "progid";

89 cڡ 
exessi_kwd
[] = "expression";

90 cڡ 
lc__kwd
[] = "calc";

92 cڡ 
mo_y_vue_ass
[] = "\"'#!;{}";

95 cڡ 
l_dp_kwd
[] = "/deep/";

98 cڡ 
tde_equ
[] = "~=";

99 cڡ 
pe_equ
[] = "|=";

100 cڡ 
t_equ
[] = "^=";

101 cڡ 
dr_equ
[] = "$=";

102 cڡ 
_equ
[] = "*=";

105 cڡ 
d_kwd
[] = "and";

106 cڡ 
_kwd
[] = "or";

107 cڡ 
n_kwd
[] = "not";

108 cڡ 
gt
[] = ">";

109 cڡ 
g
[] = ">=";

110 cڡ 

[] = "<";

111 cڡ 
e
[] = "<=";

112 cڡ 
eq
[] = "==";

113 cڡ 
q
[] = "!=";

114 cڡ 
ue_kwd
[] = "true";

115 cڡ 
l_kwd
[] = "false";

118 cڡ 
r_r
[] = "%";

119 cڡ 
emy_r
[] = "";

120 cڡ 
ash_ash
[] = "//";

121 cڡ 
ash_
[] = "/*";

122 cڡ 
_ash
[] = "*/";

123 cڡ 
hash_lb
[] = "#{";

124 cڡ 
rb
[] = "}";

125 cڡ 

[] = ")";

126 cڡ 
sign_chs
[] = "-+";

127 cڡ 
_chs
[] = "-+";

128 cڡ 
hyph
[] = "-";

129 cڡ 
lsis
[] = "...";

132 cڡ 
numic_me
[] = "numeric value";

133 cڡ 
numb_me
[] = "number";

134 cڡ 
rage_me
[] = "percentage";

135 cڡ 
dimsi_me
[] = "numeric dimension";

136 cڡ 
rg_me
[] = "string";

137 cڡ 
bo_me
[] = "bool";

138 cڡ 
c_me
[] = "color";

139 cڡ 
li_me
[] = "list";

140 cڡ 
m_me
[] = "map";

141 cڡ 
gli_me
[] = "arglist";

144 cڡ 
uri_chs
[] = ":;/?!%&#@|[]{}'`^\"*+-.,_=~";

145 cڡ 
_uri_chs
[] = "#%&";

149 cڡ 
ic_s
[] = "*/%";

151 cڡ 
_li_dims
[] = "){};!";

152 cڡ 
comex__dims
[] = ",){};!";

153 cڡ 
_comb_s
[] = "+~>";

155 cڡ 
ibu_com_modifrs
[] = "~|^$*";

156 cڡ 
_lookahd_s
[] = "*&%,()[]";

160 cڡ 
utf_8_bom
[] = { 0xEF, 0xBB, 0xBF };

161 cڡ 
utf_16_bom_be
[] = { 0xFE, 0xFF };

162 cڡ 
utf_16_bom_
[] = { 0xFF, 0xFE };

163 cڡ 
utf_32_bom_be
[] = { 0x00, 0x00, 0xFE, 0xFF };

164 cڡ 
utf_32_bom_
[] = { 0xFF, 0xFE, 0x00, 0x00 };

165 cڡ 
utf_7_bom_1
[] = { 0x2B, 0x2F, 0x76, 0x38 };

166 cڡ 
utf_7_bom_2
[] = { 0x2B, 0x2F, 0x76, 0x39 };

167 cڡ 
utf_7_bom_3
[] = { 0x2B, 0x2F, 0x76, 0x2B };

168 cڡ 
utf_7_bom_4
[] = { 0x2B, 0x2F, 0x76, 0x2F };

169 cڡ 
utf_7_bom_5
[] = { 0x2B, 0x2F, 0x76, 0x38, 0x2D };

170 cڡ 
utf_1_bom
[] = { 0xF7, 0x64, 0x4C };

171 cڡ 
utf_ebcdic_bom
[] = { 0xDD, 0x73, 0x66, 0x73 };

172 cڡ 
scsu_bom
[] = { 0x0E, 0xFE, 0xFF };

173 cڡ 
bocu_1_bom
[] = { 0xFB, 0xEE, 0x28 };

174 cڡ 
gb_18030_bom
[] = { 0x84, 0x31, 0x95, 0x33 };

	@node_modules/node-sass/src/libsass/src/constants.hpp

1 #ide
SASS_CONSTANTS_H


2 
	#SASS_CONSTANTS_H


	)

4 
mea
 
	gSass
 {

5 
mea
 
	gCڡts
 {

8 cڡ 
MaxClSck
;

12 cڡ 
Scificy_Sr
;

13 cڡ 
Scificy_Univl
;

14 cڡ 
Scificy_Ty
;

15 cڡ 
Scificy_Css
;

16 cڡ 
Scificy_Ar
;

17 cڡ 
Scificy_Pudo
;

18 cڡ 
Scificy_ID
;

21 cڡ 
_ro_kwd
[];

22 cڡ 
impt_kwd
[];

23 cڡ 
mix_kwd
[];

24 cڡ 
funi_kwd
[];

25 cڡ 
tu_kwd
[];

26 cڡ 
ude_kwd
[];

27 cڡ 
cڋ_kwd
[];

28 cڡ 
exnd_kwd
[];

29 cڡ 
if_kwd
[];

30 cڡ 
_kwd
[];

31 cڡ 
if_a__kwd
[];

32 cڡ 
f_kwd
[];

33 cڡ 
om_kwd
[];

34 cڡ 
to_kwd
[];

35 cڡ 
through_kwd
[];

36 cڡ 
ch_kwd
[];

37 cڡ 
_kwd
[];

38 cڡ 
whe_kwd
[];

39 cڡ 
wn_kwd
[];

40 cڡ 
r_kwd
[];

41 cڡ 
debug_kwd
[];

42 cڡ 
deu_kwd
[];

43 cڡ 
glob_kwd
[];

44 cڡ 
nu_kwd
[];

45 cڡ 
tiڮ_kwd
[];

46 cڡ 
wh_kwd
[];

47 cڡ 
whout_kwd
[];

48 cڡ 
l_kwd
[];

49 cڡ 
ru_kwd
[];

52 cڡ 
em_kwd
[];

53 cڡ 
ex_kwd
[];

54 cڡ 
px_kwd
[];

55 cڡ 
cm_kwd
[];

56 cڡ 
mm_kwd
[];

57 cڡ 
_kwd
[];

58 cڡ 
pc_kwd
[];

59 cڡ 
deg_kwd
[];

60 cڡ 
d_kwd
[];

61 cڡ 
gd_kwd
[];

62 cڡ 
tu_kwd
[];

63 cڡ 
ms_kwd
[];

64 cڡ 
s_kwd
[];

65 cڡ 
Hz_kwd
[];

66 cڡ 
kHz_kwd
[];

69 cڡ 
vd_ݔa_kwd
[];

70 cڡ 
vd_webk_kwd
[];

71 cڡ 
vd_moz_kwd
[];

72 cڡ 
vd_ms_kwd
[];

73 cڡ 
vd_khtml_kwd
[];

76 cڡ 
cht_kwd
[];

77 cڡ 
med_kwd
[];

78 cڡ 
suts_kwd
[];

79 cڡ 
keyames_kwd
[];

80 cڡ 
ly_kwd
[];

81 cڡ 
rgb_kwd
[];

82 cڡ 
u_kwd
[];

84 cڡ 
imp܏_kwd
[];

85 cڡ 
pudo_n_kwd
[];

86 cڡ 
ev_kwd
[];

87 cڡ 
odd_kwd
[];

88 cڡ 
ogid_kwd
[];

89 cڡ 
exessi_kwd
[];

90 cڡ 
lc__kwd
[];

93 cڡ 
mo_y_vue_ass
[];

96 cڡ 
l_dp_kwd
[];

99 cڡ 
tde_equ
[];

100 cڡ 
pe_equ
[];

101 cڡ 
t_equ
[];

102 cڡ 
dr_equ
[];

103 cڡ 
_equ
[];

106 cڡ 
d_kwd
[];

107 cڡ 
_kwd
[];

108 cڡ 
n_kwd
[];

109 cڡ 
gt
[];

110 cڡ 
g
[];

111 cڡ 

[];

112 cڡ 
e
[];

113 cڡ 
eq
[];

114 cڡ 
q
[];

115 cڡ 
ue_kwd
[];

116 cڡ 
l_kwd
[];

119 cڡ 
r_r
[];

120 cڡ 
emy_r
[];

121 cڡ 
ash_ash
[];

122 cڡ 
ash_
[];

123 cڡ 
_ash
[];

124 cڡ 
hash_lb
[];

125 cڡ 
rb
[];

126 cڡ 

[];

127 cڡ 
sign_chs
[];

128 cڡ 
_chs
[];

129 cڡ 
hyph
[];

130 cڡ 
lsis
[];

134 cڡ 
numic_me
[];

135 cڡ 
numb_me
[];

136 cڡ 
rage_me
[];

137 cڡ 
dimsi_me
[];

138 cڡ 
rg_me
[];

139 cڡ 
bo_me
[];

140 cڡ 
c_me
[];

141 cڡ 
li_me
[];

142 cڡ 
m_me
[];

143 cڡ 
gli_me
[];

146 cڡ 
uri_chs
[];

147 cڡ 
_uri_chs
[];

151 cڡ 
ic_s
[];

152 cڡ 
_li_dims
[];

153 cڡ 
comex__dims
[];

154 cڡ 
_comb_s
[];

155 cڡ 
ibu_com_modifrs
[];

156 cڡ 
_lookahd_s
[];

160 cڡ 
utf_8_bom
[];

161 cڡ 
utf_16_bom_be
[];

162 cڡ 
utf_16_bom_
[];

163 cڡ 
utf_32_bom_be
[];

164 cڡ 
utf_32_bom_
[];

165 cڡ 
utf_7_bom_1
[];

166 cڡ 
utf_7_bom_2
[];

167 cڡ 
utf_7_bom_3
[];

168 cڡ 
utf_7_bom_4
[];

169 cڡ 
utf_7_bom_5
[];

170 cڡ 
utf_1_bom
[];

171 cڡ 
utf_ebcdic_bom
[];

172 cڡ 
scsu_bom
[];

173 cڡ 
bocu_1_bom
[];

174 cڡ 
gb_18030_bom
[];

	@node_modules/node-sass/src/libsass/src/context.cpp

1 
	~"ss.h
"

2 
	~<rg
>

3 
	~<cdlib
>

4 
	~<crg
>

5 
	~<iom
>

6 
	~<sam
>

7 
	~<ioam
>

9 
	~"a.h
"

10 
	~"ut.h
"

11 
	~"ss.h
"

12 
	~"cڋxt.h
"

13 
	~"ugs.h
"

14 
	~"cڡts.h
"

15 
	~"rr.h
"

16 
	~"fe.h
"

17 
	~"e.h
"

18 
	~"ouut.h
"

19 
	~"exnd.h
"

20 
	~"ev.h
"

21 
	~"cssize.h
"

22 
	~"liize.h
"

23 
	~"exnd.h
"

24 
	~"move_ahds.h
"

25 
	~"funis.h
"

26 
	~"ss_funis.h
"

27 
	~"backa.h
"

28 
	~"ss2scss.h
"

29 
	~"ex.h
"

30 
	~"emr.h
"

32 
mea
 
	gSass
 {

33 
usg
 
mea
 
	gCڡts
;

34 
usg
 
mea
 
	gFe
;

35 
usg
 
mea
 
	gSass
;

37 
le
 
bo
 
st_imp܋rs
 (cڡ 
Sass_Imp܋r_Ery
& 
i
, cڡ Sass_Imp܋r_Ery& 
j
)

38 {  
ss_imp܋r_g_iܙy
(
i
> sass_imp܋r_g_iܙy(
j
); }

40 
	gd
::
rg
 
_put
(cڡ * 
_th
)

44 
d
::
rg
 
_th
(
_th
 ? in_path : "");

45  
	g_th
 ="" ? "d" : 
_th
;

48 
	gd
::
rg
 
_ouut
(cڡ * 
out_th
, cڡ 
d
::rg& 
put_th
 = "")

50 
d
::
rg
 
_th
(
out_th
 ? out_path : "");

52 i(
	g_th
 ="" && 
put_th
 != "") {

53 
ϡdex
 = 
ic_
<>(
put_th
.
fd_ϡ_of
("."));

54  (
	gϡdex
 > -1 ? 
	gput_th
.
subr
(0, 
ϡdex
: 
put_th
) + ".css";

58  
	g_th
 ="" ? "dout" : 
_th
;

61 
	gCڋxt
::
Cڋxt
(
Sass_Cڋxt
& 
c_x
)

62 : 
CWD
(
Fe
::
g_cwd
()),

63 
c_tis
(
c_x
),

64 
y_th
(""),

65 
hd_impts
(0),

66 
mem
(
Memy_Mag
()),

67 
ugs
(),

68 
emr
(
c_tis
),

70 
rgs
(),

71 
sours
(),

72 
shts
(),

73 
subt_m
(),

74 
impt_ack
(),

76 
c_hds
 (
d
::
ve
<
Sass_Imp܋r_Ery
>()),

77 
c_imp܋rs
 (
d
::
ve
<
Sass_Imp܋r_Ery
>()),

78 
c_funis
 (
d
::
ve
<
Sass_Funi_Ery
>()),

80 
dt
 (
_r
(
c_tis
.indent, " ")),

81 
leed
 (
_r
(
c_tis
.linefeed, "\n")),

83 
put_th
 (
make_nil_th
(
_put
(
c_tis
.input_path))),

84 
ouut_th
 (
make_nil_th
(
_ouut
(
c_tis
.ouut_th, 
put_th
))),

85 
sour_m_fe
 (
make_nil_th
(
_r
(
c_tis
.source_map_file, ""))),

86 
sour_m_ro
 (
make_nil_th
(
_r
(
c_tis
.source_map_root, "")))

91 
	gude_ths
.
push_back
(
CWD
);

94 
c_ude_ths
(
c_tis
.
ude_th
);

95 
c_ude_ths
(
c_tis
.
ude_ths
);

96 
c_ug_ths
(
c_tis
.
ug_th
);

97 
c_ug_ths
(
c_tis
.
ug_ths
);

100 aut
	gug
 : 
ug_ths

ugs
.
ld_ugs
(
ug
);

101 aut
	g
 : 
ugs
.
g_hds
()
c_hds
.
push_back
(

);

102 aut
	g
 : 
ugs
.
g_imp܋rs
()
c_imp܋rs
.
push_back
(

);

103 aut
	g
 : 
ugs
.
g_funis
()
c_funis
.
push_back
(

);

106 
st
 (
c_hds
.
beg
(), c_hds.
d
(), 
st_imp܋rs
);

107 
st
 (
c_imp܋rs
.
beg
(), c_imp܋rs.
d
(), 
st_imp܋rs
);

109 
	gemr
.
t_fame
(
abs2l
(
ouut_th
, 
sour_m_fe
, 
CWD
));

113 
	gCڋxt
::
add_c_funi
(
Sass_Funi_Ery
 
funi
)

115 
c_funis
.
push_back
(
funi
);

117 
	gCڋxt
::
add_c_hd
(
Sass_Imp܋r_Ery
 
hd
)

119 
c_hds
.
push_back
(
hd
);

121 
st
 (
c_hds
.
beg
(), c_hds.
d
(), 
st_imp܋rs
);

123 
	gCڋxt
::
add_c_imp܋r
(
Sass_Imp܋r_Ery
 
imp܋r
)

125 
c_imp܋rs
.
push_back
(
imp܋r
);

127 
st
 (
c_imp܋rs
.
beg
(), c_imp܋rs.
d
(), 
st_imp܋rs
);

130 
	gCڋxt
::~
Cڋxt
()

133 
size_t
 
i
 = 0; 
	gi
 < 
	gsours
.
size
(); ++i) {

134 

(
sours
[
i
].
cڋs
);

135 

(
sours
[
i
].
cm
);

138 
size_t
 
	gn
 = 0; < 
	grgs
.
size
(); ++n

(
rgs
[
n
]);

141 
size_t
 
	gm
 = 0; m < 
	gimpt_ack
.
size
(); ++m) {

142 
ss_impt_ke_sour
(
impt_ack
[
m
]);

143 
ss_impt_ke_cm
(
impt_ack
[
m
]);

144 
ss_de_impt
(
impt_ack
[
m
]);

147 
	gsours
.
r
(); 
	gimpt_ack
.clear();

150 
	gDa_Cڋxt
::~
Da_Cڋxt
()

159 
Fe_Cڋxt
::~File_Context()

163 
Cڋxt
::
c_ude_ths
(cڡ * 
ths_r
)

165 i(
ths_r
) {

166 cڡ * 
beg
 = 
ths_r
;

167 cڡ * 
	gd
 = 
Px
::
fd_f
<
PATH_SEP
>(
beg
);

169 
	gd
) {

170 
	gd
::
rg
 
th
(
beg
, 
d
 - beg);

171 i(!
	gth
.
emy
()) {

172 i(*
	gth
.
rbeg
(!'/'
th
 += '/';

173 
	gude_ths
.
push_back
(
th
);

175 
	gbeg
 = 
d
 + 1;

176 
	gd
 = 
Px
::
fd_f
<
PATH_SEP
>(
beg
);

179 
	gd
::
rg
 
th
(
beg
);

180 i(!
	gth
.
emy
()) {

181 i(*
	gth
.
rbeg
(!'/'
th
 += '/';

182 
	gude_ths
.
push_back
(
th
);

187 
	gCڋxt
::
c_ude_ths
(
rg_li
* 
ths_y
)

189 
ths_y
)

191 
c_ude_ths
(
ths_y
->
rg
);

192 
	gths_y
 = 
ths_y
->
xt
;

196 
	gCڋxt
::
c_ug_ths
(cڡ * 
ths_r
)

198 i(
ths_r
) {

199 cڡ * 
beg
 = 
ths_r
;

200 cڡ * 
	gd
 = 
Px
::
fd_f
<
PATH_SEP
>(
beg
);

202 
	gd
) {

203 
	gd
::
rg
 
th
(
beg
, 
d
 - beg);

204 i(!
	gth
.
emy
()) {

205 i(*
	gth
.
rbeg
(!'/'
th
 += '/';

206 
	gug_ths
.
push_back
(
th
);

208 
	gbeg
 = 
d
 + 1;

209 
	gd
 = 
Px
::
fd_f
<
PATH_SEP
>(
beg
);

212 
	gd
::
rg
 
th
(
beg
);

213 i(!
	gth
.
emy
()) {

214 i(*
	gth
.
rbeg
(!'/'
th
 += '/';

215 
	gug_ths
.
push_back
(
th
);

220 
	gCڋxt
::
c_ug_ths
(
rg_li
* 
ths_y
)

222 
ths_y
)

224 
c_ug_ths
(
ths_y
->
rg
);

225 
	gths_y
 = 
ths_y
->
xt
;

231 
	gd
::
ve
<
Inude
> 
Cڋxt
::
fd_udes
(cڡ 
Imp܋r
& 
impt
)

234 
d
::
rg
 
ba_th
(
l2abs
(
impt
.base_path));

236 
	gd
::
ve
<
Inude
> 
vec
(
sve_udes
(
ba_th
, 
impt
.
imp_th
));

238 
size_t
 
	gi
 = 0, 
	gS
 = 
ude_ths
.
size
(); 
	gvec
.size(=0 && 
i
 < 
S
; ++i)

241 
	gd
::
ve
<
Inude
> 
sved
(
sve_udes
(
ude_ths
[
i
], 
impt
.
imp_th
));

242 i(
	gsved
.
size
()
	gvec
.

(
vec
.
d
(), 
sved
.
beg
(),esolved.end());

245  
	gvec
;

251 
	gCڋxt
::
gi_sour
(cڡ 
Inude
& 
c
, cڡ 
Resour
& 
s
, 
PrS
* 
e
)

263 
size_t
 
	gidx
 = 
sours
.
size
();

266 
	gemr
.
add_sour_dex
(
idx
);

270 
	gsours
.
push_back
(
s
);

273 
	guded_fes
.
push_back
(
c
.
abs_th
);

275 
	gcm_lks
.
push_back
(
abs2l
(
c
.
abs_th
, 
sour_m_fe
, 
CWD
));

278 
Sass_Impt_Ery
 
	gimpt
 = 
ss_make_impt
(

279 
c
.
imp_th
.
c_r
(),

280 
c
.
abs_th
.
c_r
(),

281 
s
.
cڋs
,

282 
s
.
cm


285 
	gimpt_ack
.
push_back
(
impt
);

288 cڡ * 
	gcڋs
 = 
sours
[
idx
].
cڋs
;

291 
	grgs
.
push_back
(
ss_cy_c_rg
(
c
.
abs_th
.
c_r
()));

293 
PrS
 
pe
(
rgs
.
back
(), 
cڋs
, 
idx
);

296 
size_t
 
	gi
 = 0; i < 
	gimpt_ack
.
size
() - 2; ++i) {

297 aut
	g
 = 
impt_ack
[
i
];

298 i(
	gd
::
rcmp
(

->
abs_th
, 
impt
->abs_path) == 0) {

299 
d
::
rg
 
ack
("An @importoop has been found:");

300 
size_t
 
	gn
 = 1; < 
	gi
 + 2; ++n) {

301 
	gack
 +"\ " + 
d
::
rg
(
impt_ack
[
n
]->
imp_th
) +

302 " impt" + 
d
::
rg
(
impt_ack
[
n
+1]->
imp_th
);

306 
PrS
 
	ge
 = 
e
 ? *: 
pe
;

307 
throw
 
	gExi
::
InvidSyax
(
e
, 
ack
, &
impt_ack
);

313 
Pr
 
p
(Pr::
om_c_r
(
cڋs
, *
this
, 
pe
));

315 
ss_impt_ke_sour
(
impt
);

316 
ss_impt_ke_cm
(
impt
);

318 
Block
* 
	gro
 = 
p
.
r
();

320 
ss_de_impt
(
impt_ack
.
back
());

322 
	gimpt_ack
.
p_back
();

324 
	gd
::

<cڡ 
d
::
rg
, cڡ 
	gStySht
>

325 
a_
(
c
.
abs_th
, { 
s
, 
ro
 });

327 
	gshts
.

(
a_
);

332 
Inude
 
	gCڋxt
::
ld_impt
(cڡ 
Imp܋r
& 
imp
, 
PrS
 
pe
)

337 cڡ 
	gd
::
ve
<
Inude
> 
sved
(
fd_udes
(
imp
));

340 i(
	gsved
.
size
() > 1) {

341 
	gd
::
rgam
 
msg_am
;

342 
	gmsg_am
 << "It'sot clear which fileo import for ";

343 
	gmsg_am
 << "'@imp܈\"" << 
	gimp
.
	gimp_th
 << "\"'." << "\n";

344 
	gmsg_am
 << "Candidates:" << "\n";

345 
size_t
 
	gi
 = 0, 
	gL
 = 
sved
.
size
(); i < L; ++i)

346 { 
	gmsg_am
 << " " << 
	gsved
[
i
].
	gimp_th
 << "\n"; }

347 
	gmsg_am
 << "Please delete orenamell but one ofhese files." << "\n";

348 
r
(
msg_am
.
r
(), 
pe
);

352 i(
	gsved
.
size
() == 1) {

353 
bo
 
u_che
 = 
c_imp܋rs
.
size
() == 0;

355 i(
	gu_che
 && 
	gshts
.
cou
(
sved
[0].
abs_th
) 
	gsved
[0];

358 i(* 
	gcڋs
 = 
ad_fe
(
sved
[0].
abs_th
)) {

360 
gi_sour
(
sved
[0], { 
cڋs
, 0 }, &
pe
);

362  
	gsved
[0];

367  { 
	gimp
, "" };

371 
	gCڋxt
::
impt_u
 (
Impt
* 
imp
, 
d
::
rg
 
ld_th
, cڡ std::rg& 
x_th
) {

373 
PrS
 
pe
(
imp
->pstate());

374 
	gd
::
rg
 
imp_th
(
unque
(
ld_th
));

375 
	gd
::
rg
 
oc
("file");

377 
usg
 
mea
 
	gPx
;

378 i(cڡ * 
	go
 = 
qu
< 
idtifr
, 
	gexaly
<':'>,xaly<'/'>,xaly<'/'> >(
	gimp_th
.
c_r
())) {

380 
	goc
 = 
d
::
rg
(
imp_th
.
c_r
(), 
o
 - 3);

386 i(
	gimp
->
med_qus
(|| 
	goc
 !"fe" || 
imp_th
.
subr
(0, 2) == "//") {

387 
imp
->
us
().
push_back
(
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, imp->
pe
(), 
ld_th
));

389 i(
	gimp_th
.
ngth
(> 4 && imp_th.
subr
(
imp_th
.length() - 4, 4) == ".css") {

390 
Sg_Cڡt
* 
loc
 = 
SASS_MEMORY_NEW
(
mem
, Sg_Cڡt, 
pe
, 
unque
(
ld_th
));

391 
Argumt
* 
	gloc_g
 = 
SASS_MEMORY_NEW
(
mem
, Argumt, 
pe
, 
loc
);

392 
Argumts
* 
	gloc_gs
 = 
SASS_MEMORY_NEW
(
mem
, Argumts, 
pe
);

393 (*
	gloc_gs
<< 
	gloc_g
;

394 
Funi_Cl
* 
	gw_u
 = 
SASS_MEMORY_NEW
(
mem
, Funi_Cl, 
pe
, "u", 
loc_gs
);

395 
	gimp
->
us
().
push_back
(
w_u
);

398 cڡ 
Imp܋r
 
imp܋r
(
imp_th
, 
x_th
);

399 
Inude
 
ude
(
ld_impt
(
imp܋r
, 
pe
));

400 i(
	gude
.
	gabs_th
.
emy
()) {

401 
r
("Ftimp܈n found ouėdab: " + 
imp_th
 + "\nPy sht: " + 
x_th
, 
pe
);

403 
	gimp
->
cs
().
push_back
(
ude
);

410 
bo
 
	gCڋxt
::
_ld
(cڡ 
d
::
rg
& 
ld_th
, cڡ * 
x_th
, 
PrS
& 
pe
, 
Impt
* 
imp
, std::
ve
<
Sass_Imp܋r_Ery
> 
imp܋rs
, bo 
ly_e
)

413 
size_t
 
	gcou
 = 0;

415 
bo
 
	ghas_impt
 = 
l
;

417 
	gSass_Imp܋r_Ery
& 
	gimp܋r
 : 
imp܋rs
) {

419 
Sass_Imp܋r_Fn
 

 = 
ss_imp܋r_g_funi
(
imp܋r
);

421 i(
Sass_Impt_Li
 
	gudes
 =

422 

(
ld_th
.
c_r
(), 
imp܋r
, 
c_comp
)

425 
Sass_Impt_Li
 
	g_udes
 = 
udes
;

426 *
	g_udes
{ ++
	gcou
;

428 
	gd
::
rg
 
uniq_th
 = 
ld_th
;

429 i(!
	gly_e
 && 
	gcou
) {

430 
	gd
::
rgam
 
th_rm
;

431 
	gth_rm
 << 
	guniq_th
 << ":" << 
	gcou
;

432 
	guniq_th
 = 
th_rm
.
r
();

435 
Imp܋r
 
imp܋r
(
uniq_th
, 
x_th
);

437 
Sass_Impt_Ery
 
	gude
 = *
_udes
;

438 * 
	gsour
 = 
ss_impt_ke_sour
(
ude
);

439 * 
	gcm
 = 
ss_impt_ke_cm
(
ude
);

440 
size_t
 
	gle
 = 
ss_impt_g_r_le
(
ude
);

441 
size_t
 
	gcumn
 = 
ss_impt_g_r_cumn
(
ude
);

442 cڡ *
	gabs_th
 = 
ss_impt_g_abs_th
(
ude
);

445 i(cڡ * 
	gr_mesge
 = 
ss_impt_g_r_mesge
(
ude
)) {

446 i(
sour
 || 
cm

gi_sour
({ 
imp܋r
, 
uniq_th
 }, { sour, srcm }, &
pe
);

447 i(
	gle
 =
d
::
rg
::
os
 && 
cumn
 =d::rg::os
r
(
r_mesge
, 
pe
);

448 
r
(
r_mesge
, 
PrS
(
x_th
, 
sour
, 
Posi
(
le
, 
cumn
)));

451 i(
	gsour
) {

454 
	gd
::
rg
 
th_key
(
abs_th
 ?bs_th : 
uniq_th
);

456 
Inude
 
ude
(
imp܋r
, 
th_key
);

458 
	gimp
->
cs
().
push_back
(
ude
);

460 
gi_sour
(
ude
, { 
sour
, 
cm
 }, &
pe
);

464 if(
	gabs_th
) {

472 
impt_u
(
imp
, 
abs_th
, 
x_th
);

475 ++
	g_udes
;

478 
ss_de_impt_li
(
udes
);

480 
	ghas_impt
 = 
ue
;

482 i(
	gly_e
) ;

486  
	ghas_impt
;

489 
gi_funi
(
Cڋxt
&, 
Sigtu
 
sig
, 
Nive_Funi
 
f
, 
Env
* 
v
);

490 
gi_funi
(
Cڋxt
&, 
Sigtu
 
sig
, 
Nive_Funi
 
f
, 
size_t
 
y
, 
Env
* 
v
);

491 
gi_ovld_ub
(
Cڋxt
&, 
d
::
rg
 
me
, 
Env
* 
v
);

492 
gi_but__funis
(
Cڋxt
&, 
Env
* 
v
);

493 
gi_c_funis
(
Cڋxt
&, 
Env
* 
v
, 
Sass_Funi_Li
);

494 
gi_c_funi
(
Cڋxt
&, 
Env
* 
v
, 
Sass_Funi_Ery
);

496 * 
	gCڋxt
::
nd
(
Block
* 
ro
)

499 i(!
ro
)  0;

501 
	gro
->
rfm
(&
emr
);

503 
	gemr
.
fize
();

505 
OuutBufr
 
	gemd
 = 
emr
.
g_bufr
();

507 i(!
	gc_tis
.
	gom_sour_m_u
) {

509 i(
	gc_tis
.
	gsour_m_embed
) {

510 
	gemd
.
	gbufr
 +
leed
;

511 
	gemd
.
	gbufr
 +
fm_embedded_sour_m
();

514 i(
	gsour_m_fe
 != "") {

515 
emd
.
bufr
 +
leed
;

516 
	gemd
.
	gbufr
 +
fm_sour_mpg_u
(
sour_m_fe
);

521  
ss_cy_c_rg
(
emd
.
bufr
.
c_r
());

524 
	gCڋxt
::
y_cuom_hds
(
Block
* 
ro
, cڡ * 
x_th
, 
PrS
 
pe
)

527 
Impt
* 
	gimp
 = 
SASS_MEMORY_NEW
(
mem
, Impt, 
pe
);

530 
_hds
(
y_th
, 
x_th
, 
pe
, 
imp
);

532 
	ghd_impts
 +
sours
.
size
() - 1;

534 i(!
	gimp
->
us
().
emy
()(*
	gro
) << imp;

536 
size_t
 
	gi
 = 0, 
	gS
 = 
imp
->
cs
().
size
(); i < S; ++i) {

537 (*
	gro
<< 
SASS_MEMORY_NEW
(
mem
, 
Impt_Stub
, 
pe
, 
imp
->
cs
()[
i
]);

541 
Block
* 
	gFe_Cڋxt
::
r
()

545 i(
put_th
.
emy
())  0;

549 
	gd
::
rg
 
abs_th
(
l2abs
(
put_th
, 
CWD
));

552 * 
	gcڋs
 = 
ad_fe
(
abs_th
);

556 
size_t
 
	gi
 = 0, 
	gS
 = 
ude_ths
.
size
(); 
	gcڋs
 =0 && 
i
 < 
S
; ++i) {

558 
	gabs_th
 = 
l2abs
(
put_th
, 
ude_ths
[
i
]);

560 
	gcڋs
 = 
ad_fe
(
abs_th
);

564 i(!
	gcڋs

	gthrow
 "Ftػad found ouėdab: " + 
	gput_th
;

567 
	gy_th
 = 
abs_th
;

570 
Sass_Impt_Ery
 
	gimpt
 = 
ss_make_impt
(

571 
put_th
.
c_r
(),

572 
y_th
.
c_r
(),

573 
cڋs
,

577 
	gimpt_ack
.
push_back
(
impt
);

580 
gi_sour
({{ 
put_th
, "." }, 
abs_th
 }, { 
cڋs
, 0 });

583  
compe
();

587 
Block
* 
	gDa_Cڋxt
::
r
()

591 i(!
sour_c_r
)  0;

594 if(
	gc_tis
.
	gis_dd_syax_c
) {

596 * 
	gcvd
 = 
ss2scss
(
sour_c_r
,

598 
SASS2SCSS_PRETTIFY_1
 | 
SASS2SCSS_KEEP_COMMENT
);

600 

(
sour_c_r
); 
	gsour_c_r
 = 
cvd
;

604 
	gy_th
 = 
put_th
.
emy
() ? "stdin" : input_path;

607 
	gd
::
rg
 
abs_th
(
l2abs
(
y_th
));

608 * 
	gabs_th_c_r
 = 
ss_cy_c_rg
(
abs_th
.
c_r
());

609 
	grgs
.
push_back
(
abs_th_c_r
);

612 
Sass_Impt_Ery
 
	gimpt
 = 
ss_make_impt
(

613 
y_th
.
c_r
(),

614 
abs_th_c_r
,

615 
sour_c_r
,

616 
cm_c_r


619 
	gimpt_ack
.
push_back
(
impt
);

622 
gi_sour
({{ 
put_th
, "." }, iut_th }, { 
sour_c_r
, 
cm_c_r
 });

625  
compe
();

631 
Block
* 
	gCڋxt
::
compe
()

634 i(
sours
.
size
() == 0)  0;

636 
Block
* 
	gro
 = 
shts
.

(
y_th
).
ro
;

638 i(
	gro
 == 0)  0;

640 
Env
 
	gglob
;

642 
gi_but__funis
(*
this
, &
glob
);

644 
size_t
 
	gi
 = 0, 
	gS
 = 
c_funis
.
size
(); i < S; ++i)

645 { 
gi_c_funi
(*
this
, &
glob
, 
c_funis
[
i
]); }

647 
Backa
 
backa
(0, 
PrS
("", 0), "");

649 
Exnd
 
exnd
(*
this
, &
glob
, &
backa
);

650 
Cssize
 
cssize
(*
this
, &
backa
);

652 
	gro
 = 
ro
->
rfm
(&
exnd
)->
block
();

654 
	gro
 = 
ro
->
rfm
(&
cssize
)->
block
();

656 i(!
	gsubt_m
.
emy
()) {

658 
Exnd
 
exnd
(*
this
, 
subt_m
);

660 
	gro
->
rfm
(&
exnd
);

665 
Remove_Phds
 
move_ahds
(*
this
);

666 
	gro
->
rfm
(&
move_ahds
);

668  
	gro
;

672 
	gd
::
rg
 
Cڋxt
::
fm_embedded_sour_m
()

674 
d
::
rg
 
m
 = 
emr
.
nd_cm
(*
this
);

675 
	gd
::
irgam
 
is

m
 );

676 
	gd
::
orgam
 
bufr
;

677 
	gba64
::
cod
 
E
;

678 
	gE
.
code
(
is
, 
bufr
);

679 
	gd
::
rg
 
u
 = "da:iti/js;ba64," + 
bufr
.
r
();

680 
	gu
.
a
(
u
.
size
() - 1);

681  "/*# sourMpgURL=" + 
	gu
 + " */";

684 
	gd
::
rg
 
Cڋxt
::
fm_sour_mpg_u
(cڡ 
d
::rg& 
fe
)

686 
d
::
rg
 
u
 = 
abs2l
(
fe
, 
ouut_th
, 
CWD
);

687  "/*# sourMpgURL=" + 
	gu
 + " */";

690 * 
	gCڋxt
::
nd_cm
()

692 i(
sour_m_fe
 == "")  0;

693 * 
	gsu
 = 0;

694 
	gd
::
rg
 
m
 = 
emr
.
nd_cm
(*
this
);

695 
	gsu
 = 
ss_cy_c_rg
(
m
.
c_r
());

696  
	gsu
;

702 
	gd
::
ve
<
d
::
rg
> 
Cڋxt
::
g_uded_fes
(
bo
 
sk
, 
size_t
 
hds
)

705 
	gd
::
ve
<
d
::
rg
> 
udes
 = 
uded_fes
;

706 i(
	gudes
.
size
(=0 
udes
;

707 i(
	gsk
{ 
	gudes
.
a

udes
.
beg
(), inudes.beg(+ 1 + 
hds
); }

708 { 
	gudes
.
a

udes
.
beg
(+ 1, inudes.beg(+ 1 + 
hds
); }

709 
	gudes
.
a

d
::
unique

udes
.
beg
(), inudes.
d
() ), includes.end() );

710 
	gd
::
st

udes
.
beg
(+ (
sk
 ? 0 : 1), inudes.
d
() );

711  
	gudes
;

714 
gi_funi
(
Cڋxt
& 
x
, 
Sigtu
 
sig
, 
Nive_Funi
 
f
, 
Env
* 
v
)

716 
Defi
* 
	gdef
 = 
make_tive_funi
(
sig
, 
f
, 
x
);

717 
	gdef
->
vmt
(
v
);

718 (*
	gv
)[
def
->
me
() + "[f]"] = def;

721 
gi_funi
(
Cڋxt
& 
x
, 
Sigtu
 
sig
, 
Nive_Funi
 
f
, 
size_t
 
y
, 
Env
* 
v
)

723 
Defi
* 
	gdef
 = 
make_tive_funi
(
sig
, 
f
, 
x
);

724 
	gd
::
rgam
 
ss
;

725 
	gss
 << 
	gdef
->
me
(<< "[f]" << 
	gy
;

726 
	gdef
->
vmt
(
v
);

727 (*
	gv
)[
ss
.
r
()] = 
def
;

730 
gi_ovld_ub
(
Cڋxt
& 
x
, 
d
::
rg
 
me
, 
Env
* 
v
)

732 
Defi
* 
	gub
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Definition,

733 
PrS
("[built-in function]"),

735 
me
,

738 
ue
);

739 (*
	gv
)[
me
 + "[f]"] = 
ub
;

743 
gi_but__funis
(
Cڋxt
& 
x
, 
Env
* 
v
)

745 
usg
 
mea
 
	gFunis
;

747 
gi_funi
(
x
, 
rgb_sig
, 
rgb
, 
v
);

748 
gi_ovld_ub
(
x
, "rgba", 
v
);

749 
gi_funi
(
x
, 
rgba_4_sig
, 
rgba_4
, 4, 
v
);

750 
gi_funi
(
x
, 
rgba_2_sig
, 
rgba_2
, 2, 
v
);

751 
gi_funi
(
x
, 
d_sig
, 
d
, 
v
);

752 
gi_funi
(
x
, 
g_sig
, 
g
, 
v
);

753 
gi_funi
(
x
, 
blue_sig
, 
blue
, 
v
);

754 
gi_funi
(
x
, 
mix_sig
, 
mix
, 
v
);

756 
gi_funi
(
x
, 
h_sig
, 
h
, 
v
);

757 
gi_funi
(
x
, 
ha_sig
, 
ha
, 
v
);

758 
gi_funi
(
x
, 
hue_sig
, 
hue
, 
v
);

759 
gi_funi
(
x
, 
tuti_sig
, 
tuti
, 
v
);

760 
gi_funi
(
x
, 
lighess_sig
, 
lighess
, 
v
);

761 
gi_funi
(
x
, 
adju_hue_sig
, 
adju_hue
, 
v
);

762 
gi_funi
(
x
, 
lighn_sig
, 
lighn
, 
v
);

763 
gi_funi
(
x
, 
dk_sig
, 
dk
, 
v
);

764 
gi_funi
(
x
, 
tu_sig
, 
tu
, 
v
);

765 
gi_funi
(
x
, 
detu_sig
, 
detu
, 
v
);

766 
gi_funi
(
x
, 
gys_sig
, 
gys
, 
v
);

767 
gi_funi
(
x
, 
comemt_sig
, 
comemt
, 
v
);

768 
gi_funi
(
x
, 
vt_sig
, 
vt
, 
v
);

770 
gi_funi
(
x
, 
pha_sig
, 
pha
, 
v
);

771 
gi_funi
(
x
, 
acy_sig
, 
pha
, 
v
);

772 
gi_funi
(
x
, 
acify_sig
, 
acify
, 
v
);

773 
gi_funi
(
x
, 
de__sig
, 
acify
, 
v
);

774 
gi_funi
(
x
, 
tize_sig
, 
tize
, 
v
);

775 
gi_funi
(
x
, 
de_out_sig
, 
tize
, 
v
);

777 
gi_funi
(
x
, 
adju_c_sig
, 
adju_c
, 
v
);

778 
gi_funi
(
x
, 
s_c_sig
, 
s_c
, 
v
);

779 
gi_funi
(
x
, 
chge_c_sig
, 
chge_c
, 
v
);

780 
gi_funi
(
x
, 
_hex_r_sig
, 
_hex_r
, 
v
);

782 
gi_funi
(
x
, 
unque_sig
, 
ss_unque
, 
v
);

783 
gi_funi
(
x
, 
que_sig
, 
ss_que
, 
v
);

784 
gi_funi
(
x
, 
r_ngth_sig
, 
r_ngth
, 
v
);

785 
gi_funi
(
x
, 
r__sig
, 
r_
, 
v
);

786 
gi_funi
(
x
, 
r_dex_sig
, 
r_dex
, 
v
);

787 
gi_funi
(
x
, 
r_i_sig
, 
r_i
, 
v
);

788 
gi_funi
(
x
, 
to_u__sig
, 
to_u_
, 
v
);

789 
gi_funi
(
x
, 
to_low__sig
, 
to_low_
, 
v
);

791 
gi_funi
(
x
, 
rage_sig
, 
rage
, 
v
);

792 
gi_funi
(
x
, 
round_sig
, 
round
, 
v
);

793 
gi_funi
(
x
, 
_sig
, 

, 
v
);

794 
gi_funi
(
x
, 
o_sig
, 
o
, 
v
);

795 
gi_funi
(
x
, 
abs_sig
, 
abs
, 
v
);

796 
gi_funi
(
x
, 
m_sig
, 
m
, 
v
);

797 
gi_funi
(
x
, 
max_sig
, 
max
, 
v
);

798 
gi_funi
(
x
, 
ndom_sig
, 
ndom
, 
v
);

800 
gi_funi
(
x
, 
ngth_sig
, 
ngth
, 
v
);

801 
gi_funi
(
x
, 
h_sig
, 
h
, 
v
);

802 
gi_funi
(
x
, 
t_h_sig
, 
t_h
, 
v
);

803 
gi_funi
(
x
, 
dex_sig
, 
dex
, 
v
);

804 
gi_funi
(
x
, 
jo_sig
, 
jo
, 
v
);

805 
gi_funi
(
x
, 
nd_sig
, 
nd
, 
v
);

806 
gi_funi
(
x
, 
z_sig
, 
z
, 
v
);

807 
gi_funi
(
x
, 
li_t_sig
, 
li_t
, 
v
);

809 
gi_funi
(
x
, 
m_g_sig
, 
m_g
, 
v
);

810 
gi_funi
(
x
, 
m_mge_sig
, 
m_mge
, 
v
);

811 
gi_funi
(
x
, 
m_move_sig
, 
m_move
, 
v
);

812 
gi_funi
(
x
, 
m_keys_sig
, 
m_keys
, 
v
);

813 
gi_funi
(
x
, 
m_vues_sig
, 
m_vues
, 
v
);

814 
gi_funi
(
x
, 
m_has_key_sig
, 
m_has_key
, 
v
);

815 
gi_funi
(
x
, 
keywds_sig
, 
keywds
, 
v
);

817 
gi_funi
(
x
, 
ty_of_sig
, 
ty_of
, 
v
);

818 
gi_funi
(
x
, 
un_sig
, 
un
, 
v
);

819 
gi_funi
(
x
, 
unss_sig
, 
unss
, 
v
);

820 
gi_funi
(
x
, 
comb_sig
, 
comb
, 
v
);

821 
gi_funi
(
x
, 
vb_exis_sig
, 
vb_exis
, 
v
);

822 
gi_funi
(
x
, 
glob_vb_exis_sig
, 
glob_vb_exis
, 
v
);

823 
gi_funi
(
x
, 
funi_exis_sig
, 
funi_exis
, 
v
);

824 
gi_funi
(
x
, 
mix_exis_sig
, 
mix_exis
, 
v
);

825 
gi_funi
(
x
, 
u_exis_sig
, 
u_exis
, 
v
);

826 
gi_funi
(
x
, 
_sig
, 

, 
v
);

828 
gi_funi
(
x
, 
n_sig
, 
ss_n
, 
v
);

829 
gi_funi
(
x
, 
if_sig
, 
ss_if
, 
v
);

831 
gi_funi
(
x
, 
e_sig
, 
e
, 
v
);

832 
gi_funi
(
x
, 
unique_id_sig
, 
unique_id
, 
v
);

834 
gi_funi
(
x
, 
_á_sig
, 
_á
, 
v
);

835 
gi_funi
(
x
, 
_nd_sig
, 
_nd
, 
v
);

836 
gi_funi
(
x
, 
_exnd_sig
, 
_exnd
, 
v
);

837 
gi_funi
(
x
, 
_a_sig
, 
_a
, 
v
);

838 
gi_funi
(
x
, 
_unify_sig
, 
_unify
, 
v
);

839 
gi_funi
(
x
, 
is_sur_sig
, 
is_sur
, 
v
);

840 
gi_funi
(
x
, 
sime_s_sig
, 
sime_s
, 
v
);

841 
gi_funi
(
x
, 
_r_sig
, 
_r
, 
v
);

844 
gi_c_funis
(
Cڋxt
& 
x
, 
Env
* 
v
, 
Sass_Funi_Li
 
dess
)

846 
	gdess
 && *descrs) {

847 
gi_c_funi
(
x
, 
v
, *
dess
);

848 ++
	gdess
;

851 
gi_c_funi
(
Cڋxt
& 
x
, 
Env
* 
v
, 
Sass_Funi_Ery
 
des
)

853 
Defi
* 
	gdef
 = 
make_c_funi
(
des
, 
x
);

854 
	gdef
->
vmt
(
v
);

855 (*
	gv
)[
def
->
me
() + "[f]"] = def;

	@node_modules/node-sass/src/libsass/src/context.hpp

1 #ide
SASS_CONTEXT_H


2 
	#SASS_CONTEXT_H


	)

4 
	~<rg
>

5 
	~<ve
>

6 
	~<m
>

8 
	#BUFFERSIZE
 255

	)

9 
	~"b64/code.h
"

11 
	~"a_fwd_de.h
"

12 
	~"kwd_g_maos.h
"

13 
	~"memy_mag.h
"

14 
	~"a_fwd_de.h
"

15 
	~"ss_cڋxt.h
"

16 
	~"vmt.h
"

17 
	~"sour_m.h
"

18 
	~"subt_m.h
"

19 
	~"ouut.h
"

20 
	~"ugs.h
"

21 
	~"fe.h
"

24 
	gSass_Funi
;

26 
mea
 
	gSass
 {

28 as
	cCڋxt
 {

29 
	gpublic
:

30 
impt_u
 (
Impt
* 
imp
, 
d
::
rg
 
ld_th
, cڡ std::rg& 
x_th
);

31 
bo
 
_hds
(cڡ 
d
::
rg
& 
ld_th
, cڡ * 
x_th
, 
PrS
& 
pe
, 
Impt
* 
imp
)

32 {  
_ld
(
ld_th
, 
x_th
, 
pe
, 
imp
, 
c_hds
, 
l
); };

33 
bo
 
_imp܋rs
(cڡ 
d
::
rg
& 
ld_th
, cڡ * 
x_th
, 
PrS
& 
pe
, 
Impt
* 
imp
)

34 {  
_ld
(
ld_th
, 
x_th
, 
pe
, 
imp
, 
c_imp܋rs
, 
ue
); };

36 
	give
:

37 
bo
 
_ld
(cڡ 
d
::
rg
& 
ld_th
, cڡ * 
x_th
, 
PrS
& 
pe
, 
Impt
* 
imp
, std::
ve
<
Sass_Imp܋r_Ery
> 
imp܋rs
, bo 
ly_e
 = 
ue
);

39 
	gpublic
:

40 cڡ 
d
::
rg
 
CWD
;

41 
	gSass_Ois
& 
	gc_tis
;

42 
	gd
::
rg
 
y_th
;

43 
size_t
 
	ghd_impts
;

44 
Memy_Mag
 
	gmem
;

45 
Plugs
 
	gugs
;

46 
Ouut
 
	gemr
;

50 
	gd
::
ve
<*> 
rgs
;

51 
	gd
::
ve
<
Resour
> 
sours
;

52 
	gd
::
m
<cڡ 
d
::
rg
, cڡ 
	gStySht
> 
	gshts
;

53 
	gSubt_M
<
	gd
::
rg
, std::

<
Comex_Se
*, 
	gCompound_Se
*> > 
	gsubt_m
;

54 
	gd
::
ve
<
Sass_Impt_Ery
> 
impt_ack
;

56 
Sass_Comp
* 
	gc_comp
;

59 
	gd
::
ve
<
d
::
rg
> 
uded_fes
;

61 
	gd
::
ve
<
d
::
rg
> 
cm_lks
;

64 
	gd
::
ve
<
d
::
rg
> 
ug_ths
;

65 
	gd
::
ve
<
d
::
rg
> 
ude_ths
;

71 
y_cuom_hds
(
Block
* 
ro
, cڡ * 
th
, 
PrS
 
pe
);

73 
	gd
::
ve
<
Sass_Imp܋r_Ery
> 
c_hds
;

74 
	gd
::
ve
<
Sass_Imp܋r_Ery
> 
c_imp܋rs
;

75 
	gd
::
ve
<
Sass_Funi_Ery
> 
c_funis
;

77 
add_c_hd
(
Sass_Imp܋r_Ery
 
hd
);

78 
add_c_imp܋r
(
Sass_Imp܋r_Ery
 
imp܋r
);

79 
add_c_funi
(
Sass_Funi_Ery
 
funi
);

81 cڡ 
	gd
::
rg
 
dt
;

82 cڡ 
	gd
::
rg
 
leed
;

83 cڡ 
	gd
::
rg
 
put_th
;

84 cڡ 
	gd
::
rg
 
ouut_th
;

85 cڡ 
	gd
::
rg
 
sour_m_fe
;

86 cڡ 
	gd
::
rg
 
sour_m_ro
;

88 
	gvtu
 ~
Cڋxt
();

89 
Cڋxt
(
Sass_Cڋxt
&);

90 
vtu
 
Block
* 
r
() = 0;

91 
vtu
 
Block
* 
compe
();

92 
vtu
 * 
nd
(
Block
* 
ro
);

93 
vtu
 * 
nd_cm
();

95 
gi_sour
(cڡ 
Inude
&, cڡ 
Resour
&, 
PrS
* = 0);

96 
	gd
::
ve
<
Inude
> 
fd_udes
(cڡ 
Imp܋r
& 
impt
);

97 
Inude
 
ld_impt
(cڡ 
Imp܋r
&, 
PrS
 
pe
);

99 
Sass_Ouut_Sty
 
ouut_y
({  
	gc_tis
.
	gouut_y
; };

100 
	gd
::
ve
<
d
::
rg
> 
g_uded_fes
(
bo
 
sk
 = 
l
, 
size_t
 
hds
 = 0);

102 
	give
:

103 
c_ug_ths
(cڡ * 
ths_r
);

104 
c_ug_ths
(
rg_li
* 
ths_y
);

105 
c_ude_ths
(cڡ * 
ths_r
);

106 
c_ude_ths
(
rg_li
* 
ths_y
);

107 
	gd
::
rg
 
fm_embedded_sour_m
();

108 
	gd
::
rg
 
fm_sour_mpg_u
(cڡ 
d
::rg& 
out_th
);

116 
	gpublic
:

117 cڡ 
d
::
rg
& 
cwd
({  
CWD
; };

120 as
	cFe_Cڋxt
 : 
public
 
Cڋxt
 {

121 
public
:

122 
Fe_Cڋxt
(
Sass_Fe_Cڋxt
& 
x
)

123 : 
Cڋxt
(
x
)

125 
vtu
 ~
Fe_Cڋxt
();

126 
vtu
 
Block
* 
r
();

129 as
	cDa_Cڋxt
 : 
public
 
Cڋxt
 {

130 
public
:

131 * 
sour_c_r
;

132 * 
	gcm_c_r
;

133 
Da_Cڋxt
(
Sass_Da_Cڋxt
& 
x
)

134 : 
Cڋxt
(
x
)

136 
sour_c_r
 = 
x
.
sour_rg
;

137 
	gcm_c_r
 = 
x
.
cm_rg
;

138 
	gx
.
	gsour_rg
 = 0;

139 
	gx
.
	gcm_rg
 = 0;

141 
	gvtu
 ~
Da_Cڋxt
();

142 
vtu
 
Block
* 
r
();

	@node_modules/node-sass/src/libsass/src/cssize.cpp

1 
	~"ss.h
"

2 
	~<ioam
>

3 
	~<tyfo
>

4 
	~<ve
>

6 
	~"cssize.h
"

7 
	~"cڋxt.h
"

8 
	~"backa.h
"

10 
mea
 
	gSass
 {

12 
	gCssize
::
Cssize
(
Cڋxt
& 
x
, 
Backa
* 
bt
)

13 : 
x
(ctx),

14 
block_ack
(
d
::
ve
<
Block
*>()),

15 
p_ack
(
d
::
ve
<
Smt
*>()),

16 
s_ack
(
d
::
ve
<
Se_Li
*>()),

17 
backa
(
bt
)

19 
	gs_ack
.
push_back
(
NULL
);

22 
Smt
* 
	gCssize
::

()

24  
p_ack
.
size
(?_ack.
back
(: 
block_ack
.
t
();

27 
Se_Li
* 
	gCssize
::

()

29  
s_ack
.
size
(? s_ack.
back
(: 
NULL
;

32 
Smt
* 
	gCssize
::
ݔ
()(
Block
* 
b
)

34 
Block
* 
bb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
b
->
pe
(), b->
ngth
(), b->
is_ro
());

36 
	gblock_ack
.
push_back
(
bb
);

37 
nd_block
(
b
);

38 
	gblock_ack
.
p_back
();

39  
	gbb
;

42 
Smt
* 
	gCssize
::
ݔ
()(
Deive
* 
r
)

44 i(!
r
->
block
(|| !r->block()->
ngth
()) ;

46 i(

()->
emt_ty
(=
Smt
::
RULESET
)

48  (
r
->
is_keyames
()? 
SASS_MEMORY_NEW
(
x
.
mem
, 
Bubb
,->
pe
(),: 
bubb
(r);

51 
	gp_ack
.
push_back
(
r
);

52 
Deive
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Directive,

53 
r
->
pe
(),

54 
r
->
keywd
(),

55 
r
->

(),

56 
r
->
block
(?->block()->
rfm
(
this
)->block() : 0);

57 i(
	gr
->
vue
()
	g
->vue(
r
->value());

58 
	gp_ack
.
p_back
();

60 
bo
 
	gdeive_exis
 = 
l
;

61 
size_t
 
	gL
 = 

->
block
(?r->block()->
ngth
() : 0;

62 
size_t
 
	gi
 = 0; i < 
	gL
 && !
	gdeive_exis
; ++i) {

63 
Smt
* 
	gs
 = (*
r
->
block
())[
i
];

64 i(
	gs
->
emt_ty
(!
Smt
::
BUBBLE

deive_exis
 = 
ue
;

66 
	gs
 = 
ic_
<
Bubb
*>(
s
)->
node
();

67 i(
	gs
->
emt_ty
(!
Smt
::
DIRECTIVE

deive_exis
 = 
l
;

68 
	gdeive_exis
 = (
ic_
<
Deive
*>(
s
)->
keywd
(=

->keyword());

73 
Block
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 

->
pe
());

74 i(!(
	gdeive_exis
 || 
	g
->
is_keyames
()))

76 
Deive
* 
	gemy_node
 = 
ic_
<Deive*>(

);

77 
	gemy_node
->
block
(
SASS_MEMORY_NEW
(
x
.
mem
, 
Block
, 

->block(?r->block()->
pe
() :r->pstate()));

78 *
	gsu
 << 
	gemy_node
;

81 
Smt
* 
	gss
 = 
debubb
(

->
block
(?r->block(: 
SASS_MEMORY_NEW
(
x
.
mem
, 
Block
,r->
pe
()),r);

82 
size_t
 
	gi
 = 0, 
	gL
 = 
ss
->
block
()->
ngth
(); i < L; ++i) {

83 *
	gsu
 << (*
	gss
->
block
())[
i
];

86  
	gsu
;

89 
Smt
* 
	gCssize
::
ݔ
()(
Keyame_Ru
* 
r
)

91 i(!
r
->
block
(|| !r->block()->
ngth
()) ;

93 
Keyame_Ru
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Keyframe_Rule,

94 
r
->
pe
(),

95 
r
->
block
()->
rfm
(
this
)->block());

96 i(
	gr
->

()
	g
->(
r
->selector());

98  
debubb
(

->
block
(),r)->block();

101 
Smt
* 
	gCssize
::
ݔ
()(
Ruˣt
* 
r
)

103 
p_ack
.
push_back
(
r
);

104 
	gs_ack
.
push_back
(
dymic_
<
Se_Li
*>(
r
->

()));

105 
Ruˣt
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Ruleset,

106 
r
->
pe
(),

107 
r
->

(),

108 
r
->
block
()->
rfm
(
this
)->block());

109 
	g
->
is_ro
(
r
->is_root());

111 
	gs_ack
.
p_back
();

112 
	gp_ack
.
p_back
();

114 i(!
	g
->
block
()) {

115 
r
("Iegeg: Oyrݔtmay báed bthrݔts.", 
r
->
block
()->
pe
());

118 
Block
* 
	gs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 

->
block
()->
pe
());

119 
Block
* 
	grus
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 

->
block
()->
pe
());

120 
size_t
 
	gi
 = 0, 
	gL
 = 

->
block
()->
ngth
(); i < L; i++)

122 
Smt
* 
	gs
 = (*

->
block
())[
i
];

123 i(
bubbb
(
s
)*
	grus
 << 
	gs
;

124 i(!
bubbb
(
s
)*
	gs
 << 
	gs
;

127 i(
	gs
->
ngth
())

129 
Block
* 
	gbb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 

->
block
()->
pe
());

130 *
	gbb
 +
s
;

131 
	g
->
block
(
bb
);

133 
size_t
 
	gi
 = 0, 
	gL
 = 
rus
->
ngth
(); i < L; i++)

135 (*
	grus
)[
i
]->
bs
((*
rus
)[i]->tabs() + 1);

138 
	grus
->
unshi
(

);

141 
	grus
 = 
debubb
(
rus
)->
block
();

143 i(!(!
	grus
->
ngth
() ||

144 !
bubbb
(
rus
->
ϡ
()) ||

145 

()->
emt_ty
(=
Smt
::
RULESET
))

147 
rus
->
ϡ
()->
group_d
(
ue
);

150  
	grus
;

153 
Smt
* 
	gCssize
::
ݔ
()(
Nu
* 
m
)

158 
Smt
* 
	gCssize
::
ݔ
()(
Med_Block
* 
m
)

160 i(

()->
emt_ty
(=
Smt
::
RULESET
)

161 {  
bubb
(
m
); }

163 i(

()->
emt_ty
(=
Smt
::
MEDIA
)

164 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Bubb
, 
m
->
pe
(), m); }

166 
	gp_ack
.
push_back
(
m
);

168 
Med_Block
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Media_Block,

169 
m
->
pe
(),

170 
m
->
med_qus
(),

171 
m
->
block
()->
rfm
(
this
)->block());

172 
	gmm
->
bs
(
m
->tabs());

174 
	gp_ack
.
p_back
();

176  
debubb
(
mm
->
block
(), mm)->block();

179 
Smt
* 
	gCssize
::
ݔ
()(
Suts_Block
* 
m
)

181 i(!
m
->
block
()->
ngth
())

182 {  
m
; }

184 i(

()->
emt_ty
(=
Smt
::
RULESET
)

185 {  
bubb
(
m
); }

187 
	gp_ack
.
push_back
(
m
);

189 
Suts_Block
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Supports_Block,

190 
m
->
pe
(),

191 
m
->
cdi
(),

192 
m
->
block
()->
rfm
(
this
)->block());

193 
	gmm
->
bs
(
m
->tabs());

195 
	gp_ack
.
p_back
();

197  
debubb
(
mm
->
block
(), mm)->block();

200 
Smt
* 
	gCssize
::
ݔ
()(
At_Ro_Block
* 
m
)

202 
bo
 
tmp
 = 
l
;

203 
size_t
 
	gi
 = 0, 
	gL
 = 
p_ack
.
size
(); i < L; ++i) {

204 
Smt
* 
	gs
 = 
p_ack
[
i
];

205 
	gtmp
 |
m
->
exude_node
(
s
);

208 i(!
	gtmp
)

210 
Block
* 
	gbb
 = 
m
->
block
()->
rfm
(
this
)->block();

211 
size_t
 
	gi
 = 0, 
	gL
 = 
bb
->
ngth
(); i < L; ++i) {

213 i(
bubbb
((*
bb
)[
i
])(*
	gbb
)[i]->
bs
((*bb)[i]->bs(+ 
m
->tabs());

215 i(
	gbb
->
ngth
(&& 
bubbb
(
bb
->
ϡ
())bb->ϡ()->
group_d
(
m
->group_end());

216  
	gbb
;

219 i(
	gm
->
exude_node
(

()))

221  
SASS_MEMORY_NEW
(
x
.
mem
, 
Bubb
, 
m
->
pe
(), m);

224  
bubb
(
m
);

227 
Smt
* 
	gCssize
::
bubb
(
Deive
* 
m
)

229 
Block
* 
bb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
this
->

()->
pe
());

230 
Has_Block
* 
	gw_ru
 = 
ic_
<Has_Block*>(
shlow_cy
(
this
->

()));

231 
	gw_ru
->
block
(
bb
);

232 
	gw_ru
->
bs
(
this
->

()->tabs());

234 
size_t
 
	gL
 = 
m
->
block
(? m->block()->
ngth
() : 0;

235 
size_t
 
	gi
 = 0; i < 
	gL
; ++i) {

236 *
	gw_ru
->
block
(<< (*
	gm
->block())[
i
];

239 
Block
* 
	gw_block
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
m
->
block
(? m->block()->
pe
() : m->pstate());

240 *
	gw_block
 << 
	gw_ru
;

241 
Deive
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Directive,

242 
m
->
pe
(),

243 
m
->
keywd
(),

244 
m
->

(),

245 
w_block
);

246 i(
	gm
->
vue
()
	gmm
->vue(
m
->value());

248 
Bubb
* 
	gbubb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Bubb, 
mm
->
pe
(), mm);

249  
	gbubb
;

252 
Smt
* 
	gCssize
::
bubb
(
At_Ro_Block
* 
m
)

254 
Block
* 
bb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
this
->

()->
pe
());

255 
Has_Block
* 
	gw_ru
 = 
ic_
<Has_Block*>(
shlow_cy
(
this
->

()));

256 
	gw_ru
->
block
(
bb
);

257 
	gw_ru
->
bs
(
this
->

()->tabs());

259 
size_t
 
	gi
 = 0, 
	gL
 = 
m
->
block
()->
ngth
(); i < L; ++i) {

260 *
	gw_ru
->
block
(<< (*
	gm
->block())[
i
];

263 
Block
* 
	gw_block
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
m
->
block
()->
pe
());

264 *
	gw_block
 << 
	gw_ru
;

265 
At_Ro_Block
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, At_Root_Block,

266 
m
->
pe
(),

267 
w_block
,

268 
m
->
exessi
());

269 
Bubb
* 
	gbubb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Bubb, 
mm
->
pe
(), mm);

270  
	gbubb
;

273 
Smt
* 
	gCssize
::
bubb
(
Suts_Block
* 
m
)

275 
Ruˣt
* 

 = 
ic_
<Ruˣt*>(
shlow_cy
(
this
->parent()));

277 
Block
* 
	gbb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 

->
block
()->
pe
());

278 
Ruˣt
* 
	gw_ru
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Ruleset,

279 

->
pe
(),

280 

->

(),

281 
bb
);

282 
	gw_ru
->
bs
(

->tabs());

284 
size_t
 
	gi
 = 0, 
	gL
 = 
m
->
block
()->
ngth
(); i < L; ++i) {

285 *
	gw_ru
->
block
(<< (*
	gm
->block())[
i
];

288 
Block
* 
	gw_block
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
m
->
block
()->
pe
());

289 *
	gw_block
 << 
	gw_ru
;

290 
Suts_Block
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Supports_Block,

291 
m
->
pe
(),

292 
m
->
cdi
(),

293 
w_block
);

295 
	gmm
->
bs
(
m
->tabs());

297 
Bubb
* 
	gbubb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Bubb, 
mm
->
pe
(), mm);

298  
	gbubb
;

301 
Smt
* 
	gCssize
::
bubb
(
Med_Block
* 
m
)

303 
Ruˣt
* 

 = 
ic_
<Ruˣt*>(
shlow_cy
(
this
->parent()));

305 
Block
* 
	gbb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 

->
block
()->
pe
());

306 
Ruˣt
* 
	gw_ru
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Ruleset,

307 

->
pe
(),

308 

->

(),

309 
bb
);

310 
	gw_ru
->
bs
(

->tabs());

312 
size_t
 
	gi
 = 0, 
	gL
 = 
m
->
block
()->
ngth
(); i < L; ++i) {

313 *
	gw_ru
->
block
(<< (*
	gm
->block())[
i
];

316 
Block
* 
	gw_block
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
m
->
block
()->
pe
());

317 *
	gw_block
 << 
	gw_ru
;

318 
Med_Block
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Media_Block,

319 
m
->
pe
(),

320 
m
->
med_qus
(),

321 
w_block
,

324 
	gmm
->
bs
(
m
->tabs());

326 
Bubb
* 
	gbubb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Bubb, 
mm
->
pe
(), mm);

328  
	gbubb
;

331 
bo
 
	gCssize
::
bubbb
(
Smt
* 
s
)

333  
s
->
emt_ty
(=
Smt
::
RULESET
 || s->
bubbs
();

336 
Smt
* 
	gCssize
::
橋n
(Smt* 
s
)

338 
Block
* 
bb
 = 
s
->
block
();

339 
Block
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
bb
->
pe
(), 0, bb->
is_ro
());

340 
size_t
 
	gi
 = 0, 
	gL
 = 
bb
->
ngth
(); i < L; ++i) {

341 
Smt
* 
	gss
 = (*
bb
)[
i
];

342 i(
	gss
->
block
()) {

343 
	gss
 = 
橋n
(
ss
);

344 
size_t
 
	gj
 = 0, 
	gK
 = 
ss
->
block
()->
ngth
(); j < K; ++j) {

345 *
	gsu
 << (*
	gss
->
block
())[
j
];

349 *
	gsu
 << 
	gss
;

352  
	gsu
;

355 
	gd
::
ve
<
d
::

<
bo
, 
	gBlock
*>> 
	gCssize
::
i_by_bubb
(
Smt
* 
b
)

357 
d
::
ve
<d::

<
bo
, 
	gBlock
*>> 
	gsus
;

358 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
block
()->
ngth
(); i < L; ++i) {

359 
Smt
* 
	gvue
 = (*
b
->
block
())[
i
];

360 
bo
 
	gkey
 = 
vue
->
emt_ty
(=
Smt
::
BUBBLE
;

362 i(!
	gsus
.
emy
(&&esus.
back
().
	gf
 =
key
)

364 
Block
* 
w_block
 = 
sus
.
back
().
cd
;

365 *
	gw_block
 << 
	gvue
;

369 
Block
* 
	gw_block
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
vue
->
pe
());

370 *
	gw_block
 << 
	gvue
;

371 
	gsus
.
push_back
(
d
::
make_
(
key
, 
w_block
));

374  
	gsus
;

377 
Smt
* 
	gCssize
::
shlow_cy
(Smt* 
s
)

379 
s
->
emt_ty
())

381 
Smt
::
RULESET
:

382  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ruˣt
, *
ic_
<Ruˣt*>(
s
));

383 
	gSmt
::
MEDIA
:

384  
SASS_MEMORY_NEW
(
x
.
mem
, 
Med_Block
, *
ic_
<Med_Block*>(
s
));

385 
	gSmt
::
BUBBLE
:

386  
SASS_MEMORY_NEW
(
x
.
mem
, 
Bubb
, *
ic_
<Bubb*>(
s
));

387 
	gSmt
::
DIRECTIVE
:

388  
SASS_MEMORY_NEW
(
x
.
mem
, 
Deive
, *
ic_
<Deive*>(
s
));

389 
	gSmt
::
SUPPORTS
:

390  
SASS_MEMORY_NEW
(
x
.
mem
, 
Suts_Block
, *
ic_
<Suts_Block*>(
s
));

391 
	gSmt
::
ATROOT
:

392  
SASS_MEMORY_NEW
(
x
.
mem
, 
At_Ro_Block
, *
ic_
<At_Ro_Block*>(
s
));

393 
	gSmt
::
KEYFRAMERULE
:

394  
SASS_MEMORY_NEW
(
x
.
mem
, 
Keyame_Ru
, *
ic_
<Keyame_Ru*>(
s
));

395 
	gSmt
::
NONE
:

397 
r
("unknow;a cڏhLibSasmas", 
s
->
pe
(), 
backa
);

398 
Sg_Qued
* 
	gmsg
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, 
PrS
("[WARN]"), 
d
::
rg
("`CSSize` c'ڐ"+ 
tyid
(*
s
).
me
());

399  
SASS_MEMORY_NEW
(
x
.
mem
, 
Wng
, 
PrS
("[WARN]"), 
msg
);

403 
Smt
* 
	gCssize
::
debubb
(
Block
* 
chdn
, Smt* 

)

405 
Has_Block
* 
	gevious_
 = 0;

406 
	gd
::
ve
<
d
::

<
bo
, 
	gBlock
*>> 
	gbaz
 = 
i_by_bubb
(
chdn
);

407 
Block
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
chdn
->
pe
());

409 
size_t
 
	gi
 = 0, 
	gL
 = 
baz
.
size
(); i < L; ++i) {

410 
bo
 
	gis_bubb
 = 
baz
[
i
].
f
;

411 
Block
* 
	gi
 = 
baz
[
i
].
cd
;

413 i(!
	gis_bubb
) {

414 i(!
	g
) {

415 *
	gsu
 << 
	gi
;

417 i(
	gevious_
) {

418 *
	gevious_
->
block
(+
i
;

421 
	gevious_
 = 
ic_
<
Has_Block
*>(
shlow_cy
(

));

422 
	gevious_
->
bs
(

->tabs());

424 
Has_Block
* 
	gw_
 = 
ic_
<Has_Block*>(
shlow_cy
(

));

425 
	gw_
->
block
(
i
);

426 
	gw_
->
bs
(

->tabs());

428 *
	gsu
 << 
	gw_
;

433 
Block
* 
	gw_block
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block,

434 
chdn
->
block
()->
pe
(),

435 
chdn
->
block
()->
ngth
(),

436 
chdn
->
block
()->
is_ro
());

438 
size_t
 
	gj
 = 0, 
	gK
 = 
i
->
ngth
(); j < K; ++j)

440 
Smt
* 
	gss
 = 0;

441 
Bubb
* 
	gb
 = 
ic_
<Bubb*>((*
i
)[
j
]);

443 i(!
	g
 ||

444 
	g
->
emt_ty
(!
Smt
::
MEDIA
 ||

445 
b
->
node
()->
emt_ty
(!
Smt
::
MEDIA
 ||

446 
ic_
<
Med_Block
*>(
b
->
node
())->
med_qus
(=ic_<Med_Block*>(

)->media_queries())

448 
ss
 = 
b
->
node
();

452 
Li
* 
	gmq
 = 
mge_med_qus
(
ic_
<
Med_Block
*>(
b
->
node
()), stic_<Med_Block*>(

));

453 i(!
	gmq
->
ngth
()) ;

454 
	gic_
<
	gMed_Block
*>(
	gb
->
node
())->
med_qus
(
mq
);

455 
	gss
 = 
b
->
node
();

458 i(!
	gss
) ;

460 
	gss
->
bs
(
ss
->bs(+ 
b
->tabs());

461 
	gss
->
group_d
(
b
->group_end());

463 i(!
	gss
) ;

465 
Block
* 
	gbb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block,

466 
chdn
->
block
()->
pe
(),

467 
chdn
->
block
()->
ngth
(),

468 
chdn
->
block
()->
is_ro
());

469 *
	gbb
 << 
	gss
->
rfm
(
this
);

470 
Smt
* 
	gw
 = 
橋n
(
bb
);

471 *
	gw_block
 << 
	gw
;

473 i(
	gw
->
block
()->
ngth
()) {

474 
	gevious_
 = 0;

478 i(
	gw_block
) {

479 *
	gsu
 << 
橋n
(
w_block
);

483  
橋n
(
su
);

486 
Smt
* 
	gCssize
::
back_im
(
AST_Node
* 
n
)

488  
ic_
<
Smt
*>(
n
);

491 
	gCssize
::
nd_block
(
Block
* 
b
)

493 
Block
* 
cut_block
 = 
block_ack
.
back
();

495 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

496 
Smt
* 
	gh
 = (*
b
)[
i
]->
rfm
(
this
);

497 i(
	gh
 && ith->
block
()) {

498 
size_t
 
	gj
 = 0, 
	gK
 = 
h
->
block
()->
ngth
(); j < K; ++j) {

499 *
	gcut_block
 << (*
	gh
->
block
())[
j
];

502 i(
	gh
) {

503 *
	gcut_block
 << 
	gh
;

508 
Li
* 
	gCssize
::
mge_med_qus
(
Med_Block
* 
m1
, Med_Block* 
m2
)

510 
Li
* 
	gqq
 = 
SASS_MEMORY_NEW
(
x
.
mem
, List,

511 
m1
->
med_qus
()->
pe
(),

512 
m1
->
med_qus
()->
ngth
(),

513 
SASS_COMMA
);

515 
size_t
 
	gi
 = 0, 
	gL
 = 
m1
->
med_qus
()->
ngth
(); i < L; i++) {

516 
size_t
 
	gj
 = 0, 
	gK
 = 
m2
->
med_qus
()->
ngth
(); j < K; j++) {

517 
Med_Quy
* 
	gmq1
 = 
ic_
<Med_Quy*>((*
m1
->
med_qus
())[
i
]);

518 
Med_Quy
* 
	gmq2
 = 
ic_
<Med_Quy*>((*
m2
->
med_qus
())[
j
]);

519 
Med_Quy
* 
	gmq
 = 
mge_med_quy
(
mq1
, 
mq2
);

521 i(
	gmq
*
	gqq
 << mq;

525  
	gqq
;

529 
Med_Quy
* 
	gCssize
::
mge_med_quy
(Med_Quy* 
mq1
, Med_Quy* 
mq2
)

532 
	gd
::
rg
 
ty
;

533 
	gd
::
rg
 
mod
;

535 
	gd
::
rg
 
m1
 = 
d
::rg(
mq1
->
is_ried
(? "ly" : mq1->
is_ged
() ? "not" : "");

536 
	gd
::
rg
 
t1
 = 
mq1
->
med_ty
(? mq1->med_ty()->
to_rg
(
x
.
c_tis
) : "";

537 
	gd
::
rg
 
m2
 = 
d
::rg(
mq2
->
is_ried
(? "ly" : 
mq1
->
is_ged
() ? "not" : "");

538 
	gd
::
rg
 
t2
 = 
mq2
->
med_ty
(? mq2->med_ty()->
to_rg
(
x
.
c_tis
) : "";

541 i(
	gt1
.
emy
()t1 = 
t2
;

542 i(
	gt2
.
emy
()t2 = 
t1
;

544 i((
	gm1
 ="n"^ (
m2
 == "not")) {

545 i(
t1
 =
t2
) {

548 
	gty
 = 
m1
 ="n" ? 
t2
 : 
t1
;

549 
	gmod
 = 
m1
 ="n" ? 
m2
 : m1;

551 i(
	gm1
 ="n" && 
m2
 == "not") {

552 i(
t1
 !
t2
) {

555 
	gty
 = 
t1
;

556 
	gmod
 = "not";

558 i(
	gt1
 !
t2
) {

561 
	gty
 = 
t1
;

562 
	gmod
 = 
m1
.
emy
(? 
m2
 : m1;

565 
Med_Quy
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Media_Query,

567 
mq1
->
pe
(), 0,

568 
mq1
->
ngth
(+ 
mq2
->ngth(), 
mod
 == "not", mod == "only"

571 i(!
	gty
.
emy
()) {

572 
	gmm
->
med_ty
(
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
mq1
->
pe
(), 
ty
));

575 *
	gmm
 +
mq2
;

576 *
	gmm
 +
mq1
;

577  
	gmm
;

	@node_modules/node-sass/src/libsass/src/cssize.hpp

1 #ide
SASS_CSSIZE_H


2 
	#SASS_CSSIZE_H


	)

4 
	~"a.h
"

5 
	~"cڋxt.h
"

6 
	~"ݔi.h
"

7 
	~"vmt.h
"

9 
mea
 
	gSass
 {

11 
	gEnvmt
<
	tAST_Node
*> 
	tEnv
;

12 
	gBacka
;

14 
ass
 
	gCssize
 : 
public
 
Oti_CRTP
<
Smt
*, Cssize> {

16 
	gCڋxt
& 
	gx
;

17 
	gd
::
ve
<
Block
*> 
block_ack
;

18 
	gd
::
ve
<
Smt
*> 
p_ack
;

19 
	gd
::
ve
<
Se_Li
*> 
s_ack
;

20 
Backa
* 
	gbacka
;

22 
Smt
* 
back_im
(
AST_Node
* 
n
);

24 
	gpublic
:

25 
Cssize
(
Cڋxt
&, 
Backa
*);

26 ~
Cssize
() { }

28 
Se_Li
* 

();

30 
Smt
* 
ݔ
()(
	gBlock
*);

31 
Smt
* 
ݔ
()(
	gRuˣt
*);

34 
Smt
* 
ݔ
()(
	gMed_Block
*);

35 
Smt
* 
ݔ
()(
	gSuts_Block
*);

36 
Smt
* 
ݔ
()(
	gAt_Ro_Block
*);

37 
Smt
* 
ݔ
()(
	gDeive
*);

38 
Smt
* 
ݔ
()(
	gKeyame_Ru
*);

55 
Smt
* 
ݔ
()(
	gNu
*);

57 
Smt
* 

();

58 
	gd
::
ve
<
d
::

<
bo
, 
	gBlock
*>> 
i_by_bubb
(
Smt
*);

59 
Smt
* 
bubb
(
Deive
*);

60 
Smt
* 
bubb
(
At_Ro_Block
*);

61 
Smt
* 
bubb
(
Med_Block
*);

62 
Smt
* 
bubb
(
Suts_Block
*);

63 
Smt
* 
shlow_cy
(Statement*);

64 
Smt
* 
debubb
(
Block
* 
chdn
, Smt* 

 = 0);

65 
Smt
* 
橋n
(Statement*);

66 
bo
 
bubbb
(
Smt
*);

68 
Li
* 
mge_med_qus
(
Med_Block
*, Media_Block*);

69 
Med_Quy
* 
mge_med_quy
(Media_Query*, Media_Query*);

71 
	gme
 <
tyme
 
	gU
>

72 
Smt
* 
back
(
U
 
x
{  
back_im
(x); }

74 
nd_block
(
Block
*);

	@node_modules/node-sass/src/libsass/src/debug.hpp

1 #ide
SASS_DEBUG_H


2 
	#SASS_DEBUG_H


	)

4 
	~<dt.h
>

6 #ide
UINT32_MAX


7 
	#UINT32_MAX
 0xffffffffU

	)

10 
	gdbg_lvl_t
 : 
ut32_t
 {

11 
NONE
 = 0,

12 
	gTRIM
 = 1,

13 
	gCHUNKS
 = 2,

14 
	gSUBWEAVE
 = 4,

15 
	gWEAVE
 = 8,

16 
	gEXTEND_COMPOUND
 = 16,

17 
	gEXTEND_COMPLEX
 = 32,

18 
	gLCS
 = 64,

19 
	gEXTEND_OBJECT
 = 128,

20 
	gALL
 = 
UINT32_MAX


23 #ifde
DEBUG


25 #ide
DEBUG_LVL


26 cڡ 
ut32_t
 
	gdebug_lvl
 = 
UINT32_MAX
;

28 cڡ 
ut32_t
 
	gdebug_lvl
 = (
DEBUG_LVL
);

31 
	#DEBUG_PRINT
(
lvl
, 
x
if(vl& 
debug_lvl
{ 
d
::

 << x; }

	)

32 
	#DEBUG_PRINTLN
(
lvl
, 
x
if(vl& 
debug_lvl
{ 
d
::

 << x << std::
dl
; }

	)

33 
	#DEBUG_EXEC
(
lvl
, 
x
if(vl& 
debug_lvl
{ x; }

	)

37 
	#DEBUG_PRINT
(
lvl
, 
x
)

	)

38 
	#DEBUG_PRINTLN
(
lvl
, 
x
)

	)

39 
	#DEBUG_EXEC
(
lvl
, 
x
)

	)

	@node_modules/node-sass/src/libsass/src/debugger.hpp

1 #ide
SASS_DEBUGGER_H


2 
	#SASS_DEBUGGER_H


	)

4 
	~<rg
>

5 
	~<sam
>

6 
	~"node.h
"

7 
	~"a_fwd_de.h
"

9 
usg
 
mea
 
	gSass
;

11 
le
 
debug_a
(
AST_Node
* 
node
, 
d
::
rg
 
d
 = "", 
Env
* 
v
 = 0);

13 
le
 
debug_sours_t
(
SoursS
& 
t
, 
d
::
rg
 
d
 = "")

15 i(
d
 =""
d
::

 << "#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

16 autcڡ &
	g
 : 
t
) {

17 
debug_a
(

, 
d
 + "");

20 i(
	gd
 =""
d
::

 << "#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

23 
le
 
	gd
::
rg
 
	$r_a
(
d
::
rg
 
r
, cڡ std::rg& 
dS
, cڡ std::rg& 
wS
)

25 
size_t
 
pos
 = 0;

26 (
pos
 = 
r
.
	`fd
(
dS
,os)!
d
::
rg
::
os
)

28 
r
.
	`a
(
pos
, 
dS
.
	`ngth
(), 
wS
);

29 
pos
 +
wS
.
	`ngth
();

31  
r
;

32 
	}
}

34 
le
 
	gd
::
rg
 
	$tyt
(cڡ 
d
::
rg
& 
r
) {

35 
d
::
rg
 
n
 = 
	`r_a
(
r
, "\n", "\\n");

36 
n
 = 
	`r_a
(clean, " ", "\\t");

37 
n
 = 
	`r_a
(clean, "\r", "\\r");

38  
n
;

39 
	}
}

41 
le
 
	gd
::
rg
 
	$lgToHex
(
t
) {

42 
d
::
rgam
 
is
;

43 
is
 << 
d
::
hex
 << 
t
;

44  
is
.
	`r
();

45 
	}
}

47 
le
 
	gd
::
rg
 
	$pe_sour_posi
(
AST_Node
* 
node
)

49 
d
::
rgam
 
r
;

50 
Posi
 
	`t
(
node
->
	`pe
());

51 
Posi
 
	`d
(
t
 + 
node
->
	`pe
().
offt
);

52 
r
 << (
t
.
fe
 =
d
::
rg
::
os
 ? -1 : start.file)

53 << "@[" << 
t
.
le
 << ":" << s.
cumn
 << "]"

54 << "-[" << 
d
.
le
 << ":" <<nd.
cumn
 << "]";

55  
r
.
	`r
();

56 
	}
}

58 
le
 
	$debug_a
(
AST_Node
* 
node
, 
d
::
rg
 
d
, 
Env
* 
v
)

60 i(
node
 == 0) ;

61 i(
d
 =""
d
::

 << "####################################################################\n";

62 i(
dymic_
<
Bubb
*>(
node
)) {

63 
Bubb
* 
bubb
 = 
dymic_
<Bubb*>(
node
);

64 
d
::

 << 
d
 << "Bubb " << 
bubb
;

65 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

66 
d
::

 << " " << 
bubb
->
	`bs
();

67 
d
::

 << std::
dl
;

68 } i(
dymic_
<
At_Ro_Block
*>(
node
)) {

69 
At_Ro_Block
* 
ro_block
 = 
dymic_
<At_Ro_Block*>(
node
);

70 
d
::

 << 
d
 << "At_Ro_Block " << 
ro_block
;

71 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

72 
d
::

 << " " << 
ro_block
->
	`bs
();

73 
d
::

 << std::
dl
;

74 
	`debug_a
(
ro_block
->
	`exessi
(), 
d
 + ":", 
v
);

75 
	`debug_a
(
ro_block
->
	`block
(), 
d
 + " ", 
v
);

76 } i(
dymic_
<
Se_Li
*>(
node
)) {

77 
Se_Li
* 

 = 
dymic_
<Se_Li*>(
node
);

78 
d
::

 << 
d
 << "Se_Li " << 

;

79 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

80 
d
::

 << " <" << 

->
	`hash
() << ">";

81 
d
::

 << " [@med:" << 

->
	`med_block
() << "]";

82 
d
::

 << (

->
	`is_tiڮ
() ? " [is_optional]": " -");

83 
d
::

 << (

->
	`has__f
() ? " [has-parent]": " -");

84 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -");

85 
d
::

 << (

->
	`has_le_ed
() ? " [line-feed]": " -");

86 
d
::

 << std::
dl
;

88 aut
i
 : 

->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

94 } i(
dymic_
<
Pt_Se
*>(
node
)) {

95 
Pt_Se
* 

 = 
dymic_
<Pt_Se*>(
node
);

96 
d
::

 << 
d
 << "Pt_Se " << 

;

98 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

99 
d
::

 << " <" << 

->
	`hash
() << ">";

100 
d
::

 << " <" << 
	`tyt
(

->
	`pe
().
tok
.
	`ws_befe
()<< ">" << std::
dl
;

103 } i(
dymic_
<
Comex_Se
*>(
node
)) {

104 
Comex_Se
* 

 = 
dymic_
<Comex_Se*>(
node
);

105 
d
::

 << 
d
 << "Comex_Se " << 



106 << " (" << 
	`pe_sour_posi
(
node
) << ")"

107 << " <" << 

->
	`hash
() << ">"

108 << " [weight:" << 
	`lgToHex
(

->
	`ecificy
()) << "]"

109 << " [@med:" << 

->
	`med_block
() << "]"

110 << (

->
	`is_tiڮ
() ? " [is_optional]": " -")

111 << (

->
	`has__f
() ? " [hasarent]": " -")

112 << (

->
	`has_le_ed
() ? " [line-feed]": " -")

113 << (

->
	`has_le_bak
() ? " [line-break]": " -")

115 
d
::
rg
 
d
;

116 

->
	`comb
()) {

117 
Comex_Se
::
PARENT_OF
: 
d
 = ">"; ;

118 
Comex_Se
::
PRECEDES
: 
d
 = "~"; ;

119 
Comex_Se
::
ADJACENT_TO
: 
d
 = "+"; ;

120 
Comex_Se
::
ANCESTOR_OF
: 
d
 = " "; ;

121 
Comex_Se
::
REFERENCE
: 
d
 = "//"; ;

124 
d
::

 << " <" << 
	`tyt
(

->
	`pe
().
tok
.
	`ws_befe
()<< ">" << std::
dl
;

125 
	`debug_a
(

->
	`hd
(), 
d
 + " " , 
v
);

126 i(

->
	`
()) {

127 
	`debug_a
(

->
	`
(), 
d
 + "{" + 
d
 + "}", 
v
);

128 } if(
d
 != " ") {

129 
d
::

 << 
d
 << " |" << 
d
 << "| {ag op}" << std::
dl
;

131 
SoursS
 
t
 = 

->
	`sours
();

133 } i(
dymic_
<
Compound_Se
*>(
node
)) {

134 
Compound_Se
* 

 = 
dymic_
<Compound_Se*>(
node
);

135 
d
::

 << 
d
 << "Compound_Se " << 

;

136 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

137 
d
::

 << " <" << 

->
	`hash
() << ">";

138 
d
::

 << " [weight:" << 
	`lgToHex
(

->
	`ecificy
()) << "]";

139 
d
::

 << " [@med:" << 

->
	`med_block
() << "]";

140 
d
::

 << (

->
	`exnded
() ? " [extended]": " -");

141 
d
::

 << (

->
	`is_tiڮ
() ? " [is_optional]": " -");

142 
d
::

 << (

->
	`has__f
() ? " [has-parent]": " -");

143 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -");

144 
d
::

 << (

->
	`has_le_ed
() ? " [line-feed]": " -");

145 
d
::

 << " <" << 
	`tyt
(

->
	`pe
().
tok
.
	`ws_befe
()<< ">" << std::
dl
;

146 aut
i
 : 

->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

147 } i(
dymic_
<
Prݣt
*>(
node
)) {

148 
Prݣt
* 

 = 
dymic_
<Prݣt*>(
node
);

149 
d
::

 << 
d
 << "Prݣ" << 

;

150 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

151 
d
::

 << " " << 

->
	`bs
(<< std::
dl
;

152 i(

->
	`block
()aut
i
 : se->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

153 } i(
dymic_
<
Wed_Se
*>(
node
)) {

154 
Wed_Se
* 

 = 
dymic_
<Wed_Se*>(
node
);

155 
d
::

 << 
d
 << "Wed_Se " << 

;

156 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

157 
d
::

 << " <" << 

->
	`hash
() << ">";

158 
d
::

 << " <<" << 

->
	`ns_me
() << ">>";

159 
d
::

 << (

->
	`is_tiڮ
() ? " [is_optional]": " -");

160 
d
::

 << (

->
	`has__f
() ? " [has-parent]": " -");

161 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -");

162 
d
::

 << (

->
	`has_le_ed
() ? " [line-feed]": " -");

163 
d
::

 << std::
dl
;

164 
	`debug_a
(

->
	`
(), 
d
 + " (", 
v
);

165 } i(
dymic_
<
Pudo_Se
*>(
node
)) {

166 
Pudo_Se
* 

 = 
dymic_
<Pudo_Se*>(
node
);

167 
d
::

 << 
d
 << "Pudo_Se " << 

;

168 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

169 
d
::

 << " <" << 

->
	`hash
() << ">";

170 
d
::

 << " <<" << 

->
	`ns_me
() << ">>";

171 
d
::

 << (

->
	`is_tiڮ
() ? " [is_optional]": " -");

172 
d
::

 << (

->
	`has__f
() ? " [has-parent]": " -");

173 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -");

174 
d
::

 << (

->
	`has_le_ed
() ? " [line-feed]": " -");

175 
d
::

 << std::
dl
;

176 
	`debug_a
(

->
	`exessi
(), 
d
 + " <", 
v
);

177 } i(
dymic_
<
Aribu_Se
*>(
node
)) {

178 
Aribu_Se
* 

 = 
dymic_
<Aribu_Se*>(
node
);

179 
d
::

 << 
d
 << "Aribu_Se " << 

;

180 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

181 
d
::

 << " <" << 

->
	`hash
() << ">";

182 
d
::

 << " <<" << 

->
	`ns_me
() << ">>";

183 
d
::

 << (

->
	`is_tiڮ
() ? " [is_optional]": " -");

184 
d
::

 << (

->
	`has__f
() ? " [has-parent]": " -");

185 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -");

186 
d
::

 << (

->
	`has_le_ed
() ? " [line-feed]": " -");

187 
d
::

 << std::
dl
;

188 
	`debug_a
(

->
	`vue
(), 
d
 + "[" + se->
	`mch
(+ "] ", 
v
);

189 } i(
dymic_
<
Se_Quifr
*>(
node
)) {

190 
Se_Quifr
* 

 = 
dymic_
<Se_Quifr*>(
node
);

191 
d
::

 << 
d
 << "Se_Quif" << 

;

192 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

193 
d
::

 << " <" << 

->
	`hash
() << ">";

194 
d
::

 << " <<" << 

->
	`ns_me
() << ">>";

195 
d
::

 << (

->
	`is_tiڮ
() ? " [is_optional]": " -");

196 
d
::

 << (

->
	`has__f
() ? " [has-parent]": " -");

197 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -");

198 
d
::

 << (

->
	`has_le_ed
() ? " [line-feed]": " -");

199 
d
::

 << std::
dl
;

200 } i(
dymic_
<
Ty_Se
*>(
node
)) {

201 
Ty_Se
* 

 = 
dymic_
<Ty_Se*>(
node
);

202 
d
::

 << 
d
 << "Ty_Se " << 

;

203 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

204 
d
::

 << " <" << 

->
	`hash
() << ">";

205 
d
::

 << " <<" << 

->
	`ns_me
() << ">>";

206 
d
::

 << (

->
	`is_tiڮ
() ? " [is_optional]": " -");

207 
d
::

 << (

->
	`has__f
() ? " [has-parent]": " -");

208 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -");

209 
d
::

 << (

->
	`has_le_ed
() ? " [line-feed]": " -");

210 
d
::

 << " <" << 
	`tyt
(

->
	`pe
().
tok
.
	`ws_befe
()) << ">";

211 
d
::

 << std::
dl
;

212 } i(
dymic_
<
Se_Phd
*>(
node
)) {

214 
Se_Phd
* 

 = 
dymic_
<Se_Phd*>(
node
);

215 
d
::

 << 
d
 << "Se_Phd [" << 

->
	`ns_me
() << "] " << selector

216 << " <" << 

->
	`hash
() << ">"

217 << " [@med:" << 

->
	`med_block
() << "]"

218 << (

->
	`is_tiڮ
() ? " [is_optional]": " -")

219 << (

->
	`has_le_bak
() ? " [line-break]": " -")

220 << (

->
	`has_le_ed
() ? " [line-feed]": " -")

221 << 
d
::
dl
;

223 } i(
dymic_
<
Sime_Se
*>(
node
)) {

224 
Sime_Se
* 

 = 
dymic_
<Sime_Se*>(
node
);

225 
d
::

 << 
d
 << "Sime_Se " << 

;

226 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

227 
d
::

 << (

->
	`has_le_bak
(? " [le-bak]": " -"<< (->
	`has_le_ed
(? " [le-ed]": " -"<< std::
dl
;

229 } i(
dymic_
<
Se_Schema
*>(
node
)) {

230 
Se_Schema
* 

 = 
dymic_
<Se_Schema*>(
node
);

231 
d
::

 << 
d
 << "Se_Schem" << 

;

232 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")"

233 << (

->
	`_ro
() && selector->at_root() ? " [@ROOT]" : "")

234 << " [@med:" << 

->
	`med_block
() << "]"

235 << (

->
	`has_le_bak
() ? " [line-break]": " -")

236 << (

->
	`has_le_ed
() ? " [line-feed]": " -")

237 << 
d
::
dl
;

239 
	`debug_a
(

->
	`cڋs
(), 
d
 + " ");

242 } i(
dymic_
<
Se
*>(
node
)) {

243 
Se
* 

 = 
dymic_
<Se*>(
node
);

244 
d
::

 << 
d
 << "Se " << 

;

245 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

246 
d
::

 << (

->
	`has_le_bak
() ? " [line-break]": " -")

247 << (

->
	`has_le_ed
() ? " [line-feed]": " -")

248 << 
d
::
dl
;

250 } i(
dymic_
<
Med_Quy_Exessi
*>(
node
)) {

251 
Med_Quy_Exessi
* 
block
 = 
dymic_
<Med_Quy_Exessi*>(
node
);

252 
d
::

 << 
d
 << "Med_Quy_Exessi " << 
block
;

253 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

254 
d
::

 << (
block
->
	`is_ީed
() ? " [is_interpolated]": " -")

255 << 
d
::
dl
;

256 
	`debug_a
(
block
->
	`u
(), 
d
 + " feature) ");

257 
	`debug_a
(
block
->
	`vue
(), 
d
 + " value) ");

259 } i(
dymic_
<
Med_Quy
*>(
node
)) {

260 
Med_Quy
* 
block
 = 
dymic_
<Med_Quy*>(
node
);

261 
d
::

 << 
d
 << "Med_Quy " << 
block
;

262 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

263 
d
::

 << (
block
->
	`is_ged
() ? " [is_negated]": " -")

264 << (
block
->
	`is_ried
() ? " [is_restricted]": " -")

265 << 
d
::
dl
;

266 
	`debug_a
(
block
->
	`med_ty
(), 
d
 + " ");

267 aut
i
 : 
block
->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

269 } i(
dymic_
<
Med_Block
*>(
node
)) {

270 
Med_Block
* 
block
 = 
dymic_
<Med_Block*>(
node
);

271 
d
::

 << 
d
 << "Med_Block " << 
block
;

272 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

273 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

274 
	`debug_a
(
block
->
	`med_qus
(), 
d
 + " =@ ");

275 i(
block
->
	`block
()aut
i
 : block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

276 } i(
dymic_
<
Suts_Block
*>(
node
)) {

277 
Suts_Block
* 
block
 = 
dymic_
<Suts_Block*>(
node
);

278 
d
::

 << 
d
 << "Suts_Block " << 
block
;

279 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

280 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

281 
	`debug_a
(
block
->
	`cdi
(), 
d
 + " =@ ");

282 } i(
dymic_
<
Suts_Ot
*>(
node
)) {

283 
Suts_Ot
* 
block
 = 
dymic_
<Suts_Ot*>(
node
);

284 
d
::

 << 
d
 << "Suts_Ot " << 
block
;

285 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")"

286 << 
d
::
dl
;

287 
	`debug_a
(
block
->
	`
(), 
d
 + "eft) ");

288 
	`debug_a
(
block
->
	`right
(), 
d
 + "ight) ");

289 } i(
dymic_
<
Suts_Negi
*>(
node
)) {

290 
Suts_Negi
* 
block
 = 
dymic_
<Suts_Negi*>(
node
);

291 
d
::

 << 
d
 << "Suts_Negi " << 
block
;

292 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")"

293 << 
d
::
dl
;

294 
	`debug_a
(
block
->
	`cdi
(), 
d
 + " condition) ");

295 } i(
dymic_
<
Suts_Dei
*>(
node
)) {

296 
Suts_Dei
* 
block
 = 
dymic_
<Suts_Dei*>(
node
);

297 
d
::

 << 
d
 << "Suts_Dei " << 
block
;

298 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")"

299 << 
d
::
dl
;

300 
	`debug_a
(
block
->
	`u
(), 
d
 + " feature) ");

301 
	`debug_a
(
block
->
	`vue
(), 
d
 + " value) ");

302 } i(
dymic_
<
Block
*>(
node
)) {

303 
Block
* 
ro_block
 = 
dymic_
<Block*>(
node
);

304 
d
::

 << 
d
 << "Block " << 
ro_block
;

305 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

306 i(
ro_block
->
	`is_ro
()
d
::

 << " [root]";

307 
d
::

 << " " << 
ro_block
->
	`bs
(<< std::
dl
;

308 i(
ro_block
->
	`block
()aut
i
 :o_block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

309 } i(
dymic_
<
Wng
*>(
node
)) {

310 
Wng
* 
block
 = 
dymic_
<Wng*>(
node
);

311 
d
::

 << 
d
 << "Wng " << 
block
;

312 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

313 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

314 } i(
dymic_
<
E
*>(
node
)) {

315 
E
* 
block
 = 
dymic_
<E*>(
node
);

316 
d
::

 << 
d
 << "E " << 
block
;

317 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

318 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

319 } i(
dymic_
<
Debug
*>(
node
)) {

320 
Debug
* 
block
 = 
dymic_
<Debug*>(
node
);

321 
d
::

 << 
d
 << "Debug " << 
block
;

322 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

323 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

324 
	`debug_a
(
block
->
	`vue
(), 
d
 + " ");

325 } i(
dymic_
<
Commt
*>(
node
)) {

326 
Commt
* 
block
 = 
dymic_
<Commt*>(
node
);

327 
d
::

 << 
d
 << "Comm" << 
block
;

328 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

329 
d
::

 << " " << 
block
->
	`bs
() <<

330 " <" << 
	`tyt
(
block
->
	`pe
().
tok
.
	`ws_befe
()<< ">" << 
d
::
dl
;

331 
	`debug_a
(
block
->
	`xt
(), 
d
 + "// ", 
v
);

332 } i(
dymic_
<
If
*>(
node
)) {

333 
If
* 
block
 = 
dymic_
<If*>(
node
);

334 
d
::

 << 
d
 << "I" << 
block
;

335 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

336 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

337 
	`debug_a
(
block
->
	`edi
(), 
d
 + " = ");

338 
	`debug_a
(
block
->
	`block
(), 
d
 + " <>");

339 
	`debug_a
(
block
->
	`ive
(), 
d
 + " ><");

340 } i(
dymic_
<
Ru
*>(
node
)) {

341 
Ru
* 
block
 = 
dymic_
<Ru*>(
node
);

342 
d
::

 << 
d
 << "Ru " << 
block
;

343 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

344 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

345 } i(
dymic_
<
Exnsi
*>(
node
)) {

346 
Exnsi
* 
block
 = 
dymic_
<Exnsi*>(
node
);

347 
d
::

 << 
d
 << "Exnsi " << 
block
;

348 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

349 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

350 
	`debug_a
(
block
->
	`
(), 
d
 + "-> ", 
v
);

351 } i(
dymic_
<
Cڋ
*>(
node
)) {

352 
Cڋ
* 
block
 = 
dymic_
<Cڋ*>(
node
);

353 
d
::

 << 
d
 << "Cڋ " << 
block
;

354 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

355 
d
::

 << " [@med:" << 
block
->
	`med_block
() << "]";

356 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

357 } i(
dymic_
<
Impt_Stub
*>(
node
)) {

358 
Impt_Stub
* 
block
 = 
dymic_
<Impt_Stub*>(
node
);

359 
d
::

 << 
d
 << "Impt_Stub " << 
block
;

360 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

361 
d
::

 << " [" << 
block
->
	`imp_th
() << "] ";

362 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

363 } i(
dymic_
<
Impt
*>(
node
)) {

364 
Impt
* 
block
 = 
dymic_
<Impt*>(
node
);

365 
d
::

 << 
d
 << "Imp܈" << 
block
;

366 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

367 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

369 aut
imp
 : 
block
->
	`us
()
	`debug_a
(imp, 
d
 + "@: ", 
v
);

370 
	`debug_a
(
block
->
	`med_qus
(), 
d
 + "@@ ");

371 } i(
dymic_
<
Assignmt
*>(
node
)) {

372 
Assignmt
* 
block
 = 
dymic_
<Assignmt*>(
node
);

373 
d
::

 << 
d
 << "Assignm" << 
block
;

374 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

375 
d
::

 << " <<" << 
block
->
	`vb
(<< ">> " << block->
	`bs
(<< std::
dl
;

376 
	`debug_a
(
block
->
	`vue
(), 
d
 + "=", 
v
);

377 } i(
dymic_
<
Dei
*>(
node
)) {

378 
Dei
* 
block
 = 
dymic_
<Dei*>(
node
);

379 
d
::

 << 
d
 << "Dei " << 
block
;

380 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

381 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

382 
	`debug_a
(
block
->
	`ݔty
(), 
d
 + "r: ", 
v
);

383 
	`debug_a
(
block
->
	`vue
(), 
d
 + " vue: ", 
v
);

384 } i(
dymic_
<
Keyame_Ru
*>(
node
)) {

385 
Keyame_Ru
* 
has_block
 = 
dymic_
<Keyame_Ru*>(
node
);

386 
d
::

 << 
d
 << "Keyame_Ru " << 
has_block
;

387 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

388 
d
::

 << " " << 
has_block
->
	`bs
(<< std::
dl
;

389 i(
has_block
->
	`
()
	`debug_a
(has_block->(), 
d
 + "@");

390 i(
has_block
->
	`block
()aut
i
 : has_block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

391 } i(
dymic_
<
Deive
*>(
node
)) {

392 
Deive
* 
block
 = 
dymic_
<Deive*>(
node
);

393 
d
::

 << 
d
 << "Deiv" << 
block
;

394 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

395 
d
::

 << " [" << 
block
->
	`keywd
(<< "] " << block->
	`bs
(<< std::
dl
;

396 
	`debug_a
(
block
->
	`
(), 
d
 + "~", 
v
);

397 
	`debug_a
(
block
->
	`vue
(), 
d
 + "+", 
v
);

398 i(
block
->
	`block
()aut
i
 : block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

399 } i(
dymic_
<
Each
*>(
node
)) {

400 
Each
* 
block
 = 
dymic_
<Each*>(
node
);

401 
d
::

 << 
d
 << "Each " << 
block
;

402 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

403 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

404 i(
block
->
	`block
()aut
i
 : block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

405 } i(
dymic_
<
F
*>(
node
)) {

406 
F
* 
block
 = 
dymic_
<F*>(
node
);

407 
d
::

 << 
d
 << "F " << 
block
;

408 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

409 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

410 i(
block
->
	`block
()aut
i
 : block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

411 } i(
dymic_
<
Whe
*>(
node
)) {

412 
Whe
* 
block
 = 
dymic_
<Whe*>(
node
);

413 
d
::

 << 
d
 << "Wh" << 
block
;

414 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

415 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

416 i(
block
->
	`block
()aut
i
 : block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

417 } i(
dymic_
<
Defi
*>(
node
)) {

418 
Defi
* 
block
 = 
dymic_
<Defi*>(
node
);

419 
d
::

 << 
d
 << "Defi " << 
block
;

420 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

421 
d
::

 << " [me: " << 
block
->
	`me
() << "] ";

422 
d
::

 << " [ty: " << (
block
->
	`ty
(=
Sass
::
Defi
::
Ty
::
MIXIN
 ? "Mixin " : "Function ") << "] ";

425 
d
::

 << " [tive: " << 
block
->
	`tive_funi
() << "] ";

426 
d
::

 << " " << 
block
->
	`bs
(<< std::
dl
;

427 
	`debug_a
(
block
->
	`ms
(), 
d
 + "ams: ", 
v
);

428 i(
block
->
	`block
()aut
i
 : block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

429 } i(
dymic_
<
Mix_Cl
*>(
node
)) {

430 
Mix_Cl
* 
block
 = 
dymic_
<Mix_Cl*>(
node
);

431 
d
::

 << 
d
 << "Mix_C" << 
block
 << " " << block->
	`bs
();

432 
d
::

 << " [" << 
block
->
	`me
() << "]";

433 
d
::

 << " [has_cڋ: " << 
block
->
	`has_cڋ
(<< "] " << std::
dl
;

434 
	`debug_a
(
block
->
	`gumts
(), 
d
 + "rgs: ");

435 i(
block
->
	`block
()aut
i
 : block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

436 } i(
Ruˣt
* 
ruˣt
 = 
dymic_
<Ruˣt*>(
node
)) {

437 
d
::

 << 
d
 << "Ruˣ" << 
ruˣt
;

438 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

439 
d
::

 << " [dt: " << 
ruˣt
->
	`bs
() << "]";

440 
d
::

 << (
ruˣt
->
	`_ro
() ? " [@ROOT]" : "");

441 
d
::

 << (
ruˣt
->
	`is_ro
() ? " [root]" : "");

442 
d
::

 << std::
dl
;

443 
	`debug_a
(
ruˣt
->
	`
(), 
d
 + ">");

444 
	`debug_a
(
ruˣt
->
	`block
(), 
d
 + " ");

445 } i(
dymic_
<
Block
*>(
node
)) {

446 
Block
* 
block
 = 
dymic_
<Block*>(
node
);

447 
d
::

 << 
d
 << "Block " << 
block
;

448 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

449 
d
::

 << " [dt: " << 
block
->
	`bs
(<< "]" << std::
dl
;

450 aut
i
 : 
block
->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

451 } i(
dymic_
<
Textu
*>(
node
)) {

452 
Textu
* 
exessi
 = 
dymic_
<Textu*>(
node
);

453 
d
::

 << 
d
 << "Textual ";

454 i(
exessi
->
	`ty
(=
Textu
::
NUMBER

d
::

 << " [NUMBER]";

455 i(
exessi
->
	`ty
(=
Textu
::
PERCENTAGE

d
::

 << " [PERCENTAGE]";

456 i(
exessi
->
	`ty
(=
Textu
::
DIMENSION

d
::

 << " [DIMENSION]";

457 i(
exessi
->
	`ty
(=
Textu
::
HEX

d
::

 << " [HEX]";

458 
d
::

 << 
exessi
 << " [" <<xessi->
	`vue
() << "]";

459 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

460 i(
exessi
->
	`is_dayed
()
d
::

 << " [delayed]";

461 
d
::

 << std::
dl
;

462 } i(
dymic_
<
Vb
*>(
node
)) {

463 
Vb
* 
exessi
 = 
dymic_
<Vb*>(
node
);

464 
d
::

 << 
d
 << "Vb " << 
exessi
;

465 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

466 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

467 
d
::

 << " [" << 
exessi
->
	`me
(<< "]" << std::
dl
;

468 
d
::
rg
 
	`me
(
exessi
->name());

469 i(
v
 &&nv->
	`has
(
me
)
	`debug_a
(
ic_
<
Exessi
*>((*v)[me]), 
d
 + " -> ",nv);

470 } i(
dymic_
<
Funi_Cl_Schema
*>(
node
)) {

471 
Funi_Cl_Schema
* 
exessi
 = 
dymic_
<Funi_Cl_Schema*>(
node
);

472 
d
::

 << 
d
 << "Funi_Cl_Schem" << 
exessi
;

473 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

474 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

475 
d
::

 << "" << std::
dl
;

476 
	`debug_a
(
exessi
->
	`me
(), 
d
 + "me: ", 
v
);

477 
	`debug_a
(
exessi
->
	`gumts
(), 
d
 + "rgs: ", 
v
);

478 } i(
dymic_
<
Funi_Cl
*>(
node
)) {

479 
Funi_Cl
* 
exessi
 = 
dymic_
<Funi_Cl*>(
node
);

480 
d
::

 << 
d
 << "Funi_C" << 
exessi
;

481 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

482 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

483 
d
::

 << " [" << 
exessi
->
	`me
() << "]";

484 i(
exessi
->
	`is_dayed
()
d
::

 << " [delayed]";

485 i(
exessi
->
	`is_ުt
()
d
::

 << " [interpolant]";

486 
d
::

 << std::
dl
;

487 
	`debug_a
(
exessi
->
	`gumts
(), 
d
 + "rgs: ", 
v
);

488 } i(
dymic_
<
Argumts
*>(
node
)) {

489 
Argumts
* 
exessi
 = 
dymic_
<Argumts*>(
node
);

490 
d
::

 << 
d
 << "Argumt" << 
exessi
;

491 i(
exessi
->
	`is_dayed
()
d
::

 << " [delayed]";

492 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

493 i(
exessi
->
	`has_med_gumts
()
d
::

 << " [has_named_arguments]";

494 i(
exessi
->
	`has__gumt
()
d
::

 << " [has_rest_argument]";

495 i(
exessi
->
	`has_keywd_gumt
()
d
::

 << " [has_keyword_argument]";

496 
d
::

 << std::
dl
;

497 aut
i
 : 
exessi
->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

498 } i(
dymic_
<
Argumt
*>(
node
)) {

499 
Argumt
* 
exessi
 = 
dymic_
<Argumt*>(
node
);

500 
d
::

 << 
d
 << "Argum" << 
exessi
;

501 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

502 
d
::

 << " [" << 
exessi
->
	`vue
() << "]";

503 
d
::

 << " [me: " << 
exessi
->
	`me
() << "] ";

504 
d
::

 << " [: " << 
exessi
->
	`is__gumt
() << "] ";

505 
d
::

 << " [keywd: " << 
exessi
->
	`is_keywd_gumt
(<< "] " << std::
dl
;

506 
	`debug_a
(
exessi
->
	`vue
(), 
d
 + " vue: ", 
v
);

507 } i(
dymic_
<
Pams
*>(
node
)) {

508 
Pams
* 
exessi
 = 
dymic_
<Pams*>(
node
);

509 
d
::

 << 
d
 << "Pam" << 
exessi
;

510 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

511 
d
::

 << " [has_tiڮ: " << 
exessi
->
	`has_tiڮ_ms
() << "] ";

512 
d
::

 << " [has_: " << 
exessi
->
	`has__m
() << "] ";

513 
d
::

 << std::
dl
;

514 aut
i
 : 
exessi
->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

515 } i(
dymic_
<
Pam
*>(
node
)) {

516 
Pam
* 
exessi
 = 
dymic_
<Pam*>(
node
);

517 
d
::

 << 
d
 << "Pam " << 
exessi
;

518 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

519 
d
::

 << " [me: " << 
exessi
->
	`me
() << "] ";

520 
d
::

 << " [deu: " << 
exessi
->
	`deu_vue
() << "] ";

521 
d
::

 << " [: " << 
exessi
->
	`is__m
(<< "] " << std::
dl
;

522 } i(
dymic_
<
Ury_Exessi
*>(
node
)) {

523 
Ury_Exessi
* 
exessi
 = 
dymic_
<Ury_Exessi*>(
node
);

524 
d
::

 << 
d
 << "Ury_Exessi " << 
exessi
;

525 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

526 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

527 
d
::

 << " [" << 
exessi
->
	`ty
(<< "]" << std::
dl
;

528 
	`debug_a
(
exessi
->
	`ݔd
(), 
d
 + " ond: ", 
v
);

529 } i(
dymic_
<
By_Exessi
*>(
node
)) {

530 
By_Exessi
* 
exessi
 = 
dymic_
<By_Exessi*>(
node
);

531 
d
::

 << 
d
 << "By_Exessi " << 
exessi
;

532 i(
exessi
->
	`is_ުt
()
d
::

 << " [is interpolant] ";

533 i(
exessi
->
	`is__ުt
()
d
::

 << " [left interpolant] ";

534 i(
exessi
->
	`is_right_ުt
()
d
::

 << " [right interpolant] ";

535 
d
::

 << " [dayed: " << 
exessi
->
	`is_dayed
() << "] ";

536 
d
::

 << " [ws_befe: " << 
exessi
->
	`
().
ws_befe
 << "] ";

537 
d
::

 << " [ws_a: " << 
exessi
->
	`
().
ws_a
 << "] ";

538 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

539 
d
::

 << " [" << 
exessi
->
	`ty_me
(<< "]" << std::
dl
;

540 
	`debug_a
(
exessi
->
	`
(), 
d
 + "e: ", 
v
);

541 
	`debug_a
(
exessi
->
	`right
(), 
d
 + "ight: ", 
v
);

542 } i(
dymic_
<
M
*>(
node
)) {

543 
M
* 
exessi
 = 
dymic_
<M*>(
node
);

544 
d
::

 << 
d
 << "M " << 
exessi
;

545 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

546 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

547 
d
::

 << " [Hashed]" << std::
dl
;

548 aut
i
 : 
exessi
->
	`emts
()) {

549 
	`debug_a
(
i
.
f
, 
d
 + " key: ");

550 
	`debug_a
(
i
.
cd
, 
d
 + " val: ");

552 } i(
dymic_
<
Li
*>(
node
)) {

553 
Li
* 
exessi
 = 
dymic_
<Li*>(
node
);

554 
d
::

 << 
d
 << "Li " << 
exessi
;

555 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

556 
d
::

 << " (" << 
exessi
->
	`ngth
() << ") " <<

557 (
exessi
->
	`t
(=
SASS_COMMA
 ? "Comm" :xessi->t(=
SASS_HASH
 ? "Map" : "Space ") <<

558 " [dayed: " << 
exessi
->
	`is_dayed
() << "] " <<

559 " [ުt: " << 
exessi
->
	`is_ުt
() << "] " <<

560 " [liized: " << 
exessi
->
	`om_
() << "] " <<

561 " [gli: " << 
exessi
->
	`is_gli
() << "] " <<

562 " [hash: " << 
exessi
->
	`hash
() << "] " <<

563 
d
::
dl
;

564 aut
i
 : 
exessi
->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

565 } i(
dymic_
<
Cڋ
*>(
node
)) {

566 
Cڋ
* 
exessi
 = 
dymic_
<Cڋ*>(
node
);

567 
d
::

 << 
d
 << "Cڋ " << 
exessi
;

568 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

569 
d
::

 << " [@med:" << 
exessi
->
	`med_block
() << "]";

570 
d
::

 << " [Smt]" << std::
dl
;

571 } i(
dymic_
<
Boޗn
*>(
node
)) {

572 
Boޗn
* 
exessi
 = 
dymic_
<Boޗn*>(
node
);

573 
d
::

 << 
d
 << "Boޗ" << 
exessi
;

574 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

575 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

576 
d
::

 << " [" << 
exessi
->
	`vue
(<< "]" << std::
dl
;

577 } i(
dymic_
<
C
*>(
node
)) {

578 
C
* 
exessi
 = 
dymic_
<C*>(
node
);

579 
d
::

 << 
d
 << "C " << 
exessi
;

580 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

581 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

582 
d
::

 << " [" << 
exessi
->
	`r
(<< ":" <<xessi->
	`g
(<< ":" <<xessi->
	`b
(<< "@" <<xessi->
	`a
(<< "]" << std::
dl
;

583 } i(
dymic_
<
Numb
*>(
node
)) {

584 
Numb
* 
exessi
 = 
dymic_
<Numb*>(
node
);

585 
d
::

 << 
d
 << "Numb " << 
exessi
;

586 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

587 
d
::

 << " [ުt: " << 
exessi
->
	`is_ުt
() << "] ";

588 
d
::

 << " [" << 
exessi
->
	`vue
(<<xessi->
	`un
() << "]" <<

589 " [hash: " << 
exessi
->
	`hash
() << "] " <<

590 
d
::
dl
;

591 } i(
dymic_
<
Sg_Qued
*>(
node
)) {

592 
Sg_Qued
* 
exessi
 = 
dymic_
<Sg_Qued*>(
node
);

593 
d
::

 << 
d
 << "Sg_Qued " << 
exessi
;

594 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

595 
d
::

 << " [" << 
	`tyt
(
exessi
->
	`vue
()) << "]";

596 i(
exessi
->
	`is_dayed
()
d
::

 << " [delayed]";

597 i(
exessi
->
	`ss_fix_1291
()
d
::

 << " [sass_fix_1291]";

598 i(
exessi
->
	`is_ުt
()
d
::

 << " [interpolant]";

599 i(
exessi
->
	`que_mk
()
d
::

 << " [quote_mark: " <<xpression->quote_mark() << "]";

600 
d
::

 << " <" << 
	`tyt
(
exessi
->
	`pe
().
tok
.
	`ws_befe
()<< ">" << std::
dl
;

601 } i(
dymic_
<
Sg_Cڡt
*>(
node
)) {

602 
Sg_Cڡt
* 
exessi
 = 
dymic_
<Sg_Cڡt*>(
node
);

603 
d
::

 << 
d
 << "Sg_Cڡ" << 
exessi
;

604 i(
exessi
->
	`ce_ty
()) {

605 
d
::

 << " " << 
exessi
->
	`ce_ty
();

607 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

608 
d
::

 << " [" << 
	`tyt
(
exessi
->
	`vue
()) << "]";

609 i(
exessi
->
	`is_dayed
()
d
::

 << " [delayed]";

610 i(
exessi
->
	`ss_fix_1291
()
d
::

 << " [sass_fix_1291]";

611 i(
exessi
->
	`is_ުt
()
d
::

 << " [interpolant]";

612 
d
::

 << " <" << 
	`tyt
(
exessi
->
	`pe
().
tok
.
	`ws_befe
()<< ">" << std::
dl
;

613 } i(
dymic_
<
Sg_Schema
*>(
node
)) {

614 
Sg_Schema
* 
exessi
 = 
dymic_
<Sg_Schema*>(
node
);

615 
d
::

 << 
d
 << "Sg_Schem" << 
exessi
;

616 
d
::

 << " " << 
exessi
->
	`ce_ty
();

617 i(
exessi
->
	`is_dayed
()
d
::

 << " [delayed]";

618 i(
exessi
->
	`is_ުt
()
d
::

 << " [is interpolant]";

619 i(
exessi
->
	`has_ުt
()
d
::

 << " [has interpolant]";

620 i(
exessi
->
	`is__ުt
()
d
::

 << " [left interpolant] ";

621 i(
exessi
->
	`is_right_ުt
()
d
::

 << " [right interpolant] ";

622 
d
::

 << " <" << 
	`tyt
(
exessi
->
	`pe
().
tok
.
	`ws_befe
()<< ">" << std::
dl
;

623 aut
i
 : 
exessi
->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

624 } i(
dymic_
<
Sg
*>(
node
)) {

625 
Sg
* 
exessi
 = 
dymic_
<Sg*>(
node
);

626 
d
::

 << 
d
 << "Sg " << 
exessi
;

627 
d
::

 << " " << 
exessi
->
	`ce_ty
();

628 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

629 i(
exessi
->
	`ss_fix_1291
()
d
::

 << " [sass_fix_1291]";

630 i(
exessi
->
	`is_ުt
()
d
::

 << " [interpolant]";

631 
d
::

 << " <" << 
	`tyt
(
exessi
->
	`pe
().
tok
.
	`ws_befe
()<< ">" << std::
dl
;

632 } i(
dymic_
<
Exessi
*>(
node
)) {

633 
Exessi
* 
exessi
 = 
dymic_
<Exessi*>(
node
);

634 
d
::

 << 
d
 << "Exessi " << 
exessi
;

635 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

636 
exessi
->
	`ce_ty
()) {

637 
Exessi
::
Ce_Ty
::
NONE
: 
d
::

 << " [NONE]"; ;

638 
Exessi
::
Ce_Ty
::
BOOLEAN
: 
d
::

 << " [BOOLEAN]"; ;

639 
Exessi
::
Ce_Ty
::
NUMBER
: 
d
::

 << " [NUMBER]"; ;

640 
Exessi
::
Ce_Ty
::
COLOR
: 
d
::

 << " [COLOR]"; ;

641 
Exessi
::
Ce_Ty
::
STRING
: 
d
::

 << " [STRING]"; ;

642 
Exessi
::
Ce_Ty
::
LIST
: 
d
::

 << " [LIST]"; ;

643 
Exessi
::
Ce_Ty
::
MAP
: 
d
::

 << " [MAP]"; ;

644 
Exessi
::
Ce_Ty
::
SELECTOR
: 
d
::

 << " [SELECTOR]"; ;

645 
Exessi
::
Ce_Ty
::
NULL_VAL
: 
d
::

 << " [NULL_VAL]"; ;

646 
Exessi
::
Ce_Ty
::
C_WARNING
: 
d
::

 << " [C_WARNING]"; ;

647 
Exessi
::
Ce_Ty
::
C_ERROR
: 
d
::

 << " [C_ERROR]"; ;

648 
Exessi
::
Ce_Ty
::
NUM_TYPES
: 
d
::

 << " [NUM_TYPES]"; ;

650 
d
::

 << std::
dl
;

651 } i(
dymic_
<
Has_Block
*>(
node
)) {

652 
Has_Block
* 
has_block
 = 
dymic_
<Has_Block*>(
node
);

653 
d
::

 << 
d
 << "Has_Block " << 
has_block
;

654 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

655 
d
::

 << " " << 
has_block
->
	`bs
(<< std::
dl
;

656 i(
has_block
->
	`block
()aut
i
 : has_block->block()->
	`emts
(){ 
	`debug_a
(i, 
d
 + " ", 
v
); }

657 } i(
dymic_
<
Smt
*>(
node
)) {

658 
Smt
* 
emt
 = 
dymic_
<Smt*>(
node
);

659 
d
::

 << 
d
 << "Sm" << 
emt
;

660 
d
::

 << " (" << 
	`pe_sour_posi
(
node
) << ")";

661 
d
::

 << " " << 
emt
->
	`bs
(<< std::
dl
;

664 i(
d
 =""
d
::

 << "####################################################################\n";

665 
	}
}

667 
le
 
debug_node
(
Node
* 
node
, 
d
::
rg
 
d
 = "")

669 i(
d
 =""
d
::

 << "#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n";

670 i(
	gnode
->
isComb
()) {

671 
	gd
::

 << 
d
;

672 
	gd
::

 << "Combinator ";

673 
	gd
::

 << 
node
 << " ";

674 i(
	gnode
->
	gg_le_ed

	gd
::

 << "[LF] ";

675 
	gnode
->
comb
()) {

676 
	gComex_Se
::
ADJACENT_TO
: 
d
::

 << "{+} "; ;

677 
	gComex_Se
::
PARENT_OF
: 
d
::

 << "{>} "; ;

678 
	gComex_Se
::
PRECEDES
: 
d
::

 << "{~} "; ;

679 
	gComex_Se
::
REFERENCE
: 
d
::

 << "{@} "; ;

680 
	gComex_Se
::
ANCESTOR_OF
: 
d
::

 << "{ } "; ;

682 
	gd
::

 << 
d
::
dl
;

684 } i(
	gnode
->
isSe
()) {

685 
	gd
::

 << 
d
;

686 
	gd
::

 << "Selector ";

687 
	gd
::

 << 
node
 << " ";

688 i(
	gnode
->
	gg_le_ed

	gd
::

 << "[LF] ";

689 
	gd
::

 << 
d
::
dl
;

690 
debug_a
(
node
->

(), 
d
 + " ");

691 } i(
	gnode
->
isCi
()) {

692 
	gd
::

 << 
d
;

693 
	gd
::

 << "Collection ";

694 
	gd
::

 << 
node
 << " ";

695 i(
	gnode
->
	gg_le_ed

	gd
::

 << "[LF] ";

696 
	gd
::

 << 
d
::
dl
;

697 aut
	gn
 : (*
node
->
ci
())) {

698 
debug_node
(&
n
, 
d
 + " ");

700 } i(
	gnode
->
isN
()) {

701 
	gd
::

 << 
d
;

702 
	gd
::

 << "Nil ";

703 
	gd
::

 << 
node
 << " ";

704 i(
	gnode
->
	gg_le_ed

	gd
::

 << "[LF] ";

705 
	gd
::

 << 
d
::
dl
;

707 
	gd
::

 << 
d
;

708 
	gd
::

 << "OTHER ";

709 
	gd
::

 << 
node
 << " ";

710 i(
	gnode
->
	gg_le_ed

	gd
::

 << "[LF] ";

711 
	gd
::

 << 
d
::
dl
;

713 i(
	gd
 =""
d
::

 << "#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n";

716 
le
 
debug_a
(cڡ 
AST_Node
* 
node
, 
d
::
rg
 
d
 = "", 
Env
* 
v
 = 0)

718 
debug_a
(
cڡ_
<
AST_Node
*>(
node
), 
d
, 
v
);

721 
le
 
debug_node
(cڡ 
Node
* 
node
, 
d
::
rg
 
d
 = "")

723 
debug_node
(
cڡ_
<
Node
*>(
node
), 
d
);

726 
le
 
debug_subt_m
(
Sass
::
ExnsiSubtM
& 
m
, 
d
::
rg
 
d
 = "")

728 i(
d
 =""
d
::

 << "#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

729 autcڡ &
	g
 : 
m
.
vues
()) {

730 
debug_a
(

.
f
, 
d
 + "first: ");

731 
debug_a
(

.
cd
, 
d
 + "second: ");

733 i(
	gd
 =""
d
::

 << "#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

736 
	gd
::
	t
<
	tComex_Se
*, 
	tCompound_Se
*> 
	tExnsiPa
;

737 
	gd
::
	tve
<
	tExnsiPa
> 
	tSubtMErs
;

739 
le
 
debug_subt_s
(
SubtMErs
* 
s
, 
d
::
rg
 
d
 = "")

741 i(
d
 =""
d
::

 << "#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

742 autcڡ &
	g
 : *
s
) {

743 
debug_a
(

.
f
, 
d
 + "first: ");

744 
debug_a
(

.
cd
, 
d
 + "second: ");

746 i(
	gd
 =""
d
::

 << "#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

	@node_modules/node-sass/src/libsass/src/emitter.cpp

1 
	~"ss.h
"

2 
	~"ut.h
"

3 
	~"cڋxt.h
"

4 
	~"ouut.h
"

5 
	~"emr.h
"

6 
	~"utf8_rg.h
"

8 
mea
 
	gSass
 {

10 
	gEmr
::
Emr
(
Sass_Ouut_Ois
& 
t
)

11 : 
wbuf
(),

12 
t
(opt),

13 
dti
(0),

14 
schedud_a
(0),

15 
schedud_leed
(0),

16 
schedud_dim
(
l
),

17 
schedud_mpg
(0),

18 
_commt
(
l
),

19 
_wed
(
l
),

20 
_med_block
(
l
),

21 
_dei
(
l
),

22 
_a_y
(
l
),

23 
_comma_y
(
l
)

27 
	gd
::
rg
 
Emr
::
g_bufr
()

29  
wbuf
.
bufr
;

32 
Sass_Ouut_Sty
 
	gEmr
::
ouut_y
() const

34  
t
.
ouut_y
;

39 
	gEmr
::
add_sour_dex
(
size_t
 
idx
)

40 { 
wbuf
.
sm
.
sour_dex
.
push_back
(
idx
); }

42 
	gd
::
rg
 
Emr
::
nd_cm
(
Cڋxt
 &
x
)

43 {  
wbuf
.
sm
.
nd_cm
(
x
); }

45 
	gEmr
::
t_fame
(cڡ 
d
::
rg
& 
r
)

46 { 
wbuf
.
sm
.
fe
 = 
r
; }

48 
	gEmr
::
schedu_mpg
(cڡ 
AST_Node
* 
node
)

49 { 
schedud_mpg
 = 
node
; }

50 
	gEmr
::
add_ݒ_mpg
(cڡ 
AST_Node
* 
node
)

51 { 
wbuf
.
sm
.
add_ݒ_mpg
(
node
); }

52 
	gEmr
::
add_o_mpg
(cڡ 
AST_Node
* 
node
)

53 { 
wbuf
.
sm
.
add_o_mpg
(
node
); }

54 
PrS
 
	gEmr
::
m
(cڡ PrS& 
pe
)

55 {  
wbuf
.
sm
.
m
(
pe
); }

60 
	gEmr
::
fize
(
bo
 
f
)

62 
schedud_a
 = 0;

63 i(
ouut_y
(=
SASS_STYLE_COMPRESSED
)

64 i(
f

schedud_dim
 = 
l
;

65 i(
	gschedud_leed
)

66 
	gschedud_leed
 = 1;

67 
ush_schedus
();

71 
	gEmr
::
ush_schedus
()

74 i(
schedud_leed
) {

75 
d
::
rg
 
leeds
 = "";

77 
size_t
 
	gi
 = 0; i < 
	gschedud_leed
; i++)

78 
	gleeds
 +
t
.
leed
;

79 
	gschedud_a
 = 0;

80 
	gschedud_leed
 = 0;

81 
nd_rg
(
leeds
);

83 } i(
	gschedud_a
) {

84 
	gd
::
rg
 
as
(
schedud_a
, ' ');

85 
	gschedud_a
 = 0;

86 
nd_rg
(
as
);

88 i(
	gschedud_dim
) {

89 
	gschedud_dim
 = 
l
;

90 
nd_rg
(";");

95 
	gEmr
::
d_ouut
(cڡ 
OuutBufr
& 
ouut
)

97 
wbuf
.
sm
.
d
(
ouut
);

98 
	gwbuf
.
	gbufr
 = 
ouut
.
bufr
 + 
wbuf
.buffer;

102 
	gEmr
::
d_rg
(cڡ 
d
::
rg
& 
xt
)

104 
wbuf
.
sm
.
d
(
Offt
(
xt
));

105 
	gwbuf
.
	gbufr
 = 
xt
 + 
wbuf
.
bufr
;

109 
	gEmr
::
nd_rg
(cڡ 
d
::
rg
& 
xt
)

113 
ush_schedus
();

115 i(
	g_commt
 && 
ouut_y
(=
COMPACT
) {

117 
d
::
rg
 
out
 = 
commt_to_rg
(
xt
);

119 
	gwbuf
.
	gbufr
 +
out
;

121 
	gwbuf
.
	gsm
.
nd
(
Offt
(
out
));

124 
	gwbuf
.
	gbufr
 +
xt
;

126 
	gwbuf
.
	gsm
.
nd
(
Offt
(
xt
));

131 
	gEmr
::
nd_wa
(cڡ 
d
::
rg
& 
xt
)

133 i(
xt
.
emy
()) ;

134 i(
ek_leed
(
xt
.
c_r
())) {

135 
	gschedud_a
 = 0;

136 
nd_mdy_leed
();

142 
	gEmr
::
nd_tok
(cڡ 
d
::
rg
& 
xt
, cڡ 
AST_Node
* 
node
)

144 
ush_schedus
();

145 
add_ݒ_mpg
(
node
);

148 i(
	gschedud_mpg
) {

149 
add_ݒ_mpg
(
schedud_mpg
);

150 
	gschedud_mpg
 = 0;

152 
nd_rg
(
xt
);

153 
add_o_mpg
(
node
);

158 
	gEmr
::
nd_dti
()

160 i(
ouut_y
(=
COMPRESSED
) ;

161 i(
ouut_y
(=
COMPACT
) ;

162 i(
	g_dei
 && 
	g_comma_y
) ;

163 i(
	gschedud_leed
 && 
	gdti
)

164 
	gschedud_leed
 = 1;

165 
	gd
::
rg
 
dt
 = "";

166 
size_t
 
	gi
 = 0; i < 
	gdti
; i++)

167 
	gdt
 +
t
.
dt
;

168 
nd_rg
(
dt
);

171 
	gEmr
::
nd_dim
()

173 
schedud_dim
 = 
ue
;

174 i(
ouut_y
(=
COMPACT
) {

175 i(
dti
 == 0) {

176 
nd_mdy_leed
();

178 
nd_mdy_a
();

180 } i(
ouut_y
(!
COMPRESSED
) {

181 
nd_tiڮ_leed
();

185 
	gEmr
::
nd_comma_t
()

188 
nd_rg
(",");

189 
nd_tiڮ_a
();

192 
	gEmr
::
nd_c_t
()

194 
schedud_a
 = 0;

195 
nd_rg
(":");

196 
nd_tiڮ_a
();

199 
	gEmr
::
nd_mdy_a
()

201 
schedud_a
 = 1;

204 
	gEmr
::
nd_tiڮ_a
()

206 i((
ouut_y
(!
COMPRESSED
&& 
bufr
().
size
()) {

207 
l
 = 
bufr
().

(bufr().
ngth
() - 1);

208 i(!
isa
(
l
|| 
	gschedud_dim
) {

209 
nd_mdy_a
();

214 
	gEmr
::
nd_ecl_leed
()

216 i(
ouut_y
(=
COMPACT
) {

217 
nd_mdy_leed
();

218 
size_t
 
	gp
 = 0; < 
	gdti
;++)

219 
nd_rg
(
t
.
dt
);

223 
	gEmr
::
nd_tiڮ_leed
()

225 i(
_dei
 && 
_comma_y
) ;

226 i(
ouut_y
(=
COMPACT
) {

227 
nd_mdy_a
();

229 
nd_mdy_leed
();

233 
	gEmr
::
nd_mdy_leed
()

235 i(
ouut_y
(!
COMPRESSED
) {

236 
schedud_leed
 = 1;

237 
	gschedud_a
 = 0;

242 
	gEmr
::
nd_sce_ݒ
(
AST_Node
* 
node
)

244 
schedud_leed
 = 0;

245 
nd_tiڮ_a
();

246 
ush_schedus
();

247 i(
	gnode

add_ݒ_mpg
(
node
);

248 
nd_rg
("{");

249 
nd_tiڮ_leed
();

251 ++ 
	gdti
;

253 
	gEmr
::
nd_sce_or
(
AST_Node
* 
node
)

255 -- 
dti
;

256 
	gschedud_leed
 = 0;

257 i(
ouut_y
(=
COMPRESSED
)

258 
schedud_dim
 = 
l
;

259 i(
ouut_y
(=
EXPANDED
) {

260 
nd_tiڮ_leed
();

261 
nd_dti
();

263 
nd_tiڮ_a
();

265 
nd_rg
("}");

266 i(
	gnode

add_o_mpg
(
node
);

267 
nd_tiڮ_leed
();

268 i(
	gdti
 != 0) ;

269 i(
ouut_y
(!
COMPRESSED
)

270 
schedud_leed
 = 2;

	@node_modules/node-sass/src/libsass/src/emitter.hpp

1 #ide
SASS_EMITTER_H


2 
	#SASS_EMITTER_H


	)

4 
	~<rg
>

5 
	~"ss.h
"

6 
	~"ss/ba.h
"

7 
	~"sour_m.h
"

8 
	~"a_fwd_de.h
"

10 
mea
 
	gSass
 {

11 
ass
 
	gCڋxt
;

13 as
	cEmr
 {

15 
	gpublic
:

16 
Emr
(
Sass_Ouut_Ois
& 
t
);

17 
	gvtu
 ~
Emr
() { }

19 
	geed
:

20 
OuutBufr
 
wbuf
;

21 
	gpublic
:

22 cڡ 
d
::
rg
& 
bufr
({  
wbuf
.buffer; }

23 cڡ 
SourM
 
sm
({  
	gwbuf
.
	gsm
; }

24 cڡ 
OuutBufr
 
ouut
({  
	gwbuf
; }

26 
add_sour_dex
(
size_t
 
idx
);

27 
t_fame
(cڡ 
d
::
rg
& 
r
);

28 
add_ݒ_mpg
(cڡ 
AST_Node
* 
node
);

29 
add_o_mpg
(cڡ 
AST_Node
* 
node
);

30 
schedu_mpg
(cڡ 
AST_Node
* 
node
);

31 
	gd
::
rg
 
nd_cm
(
Cڋxt
 &
x
);

32 
PrS
 
m
(cڡ PrS& 
pe
);

34 
	gpublic
:

35 
Sass_Ouut_Ois
& 
t
;

36 
size_t
 
	gdti
;

37 
size_t
 
	gschedud_a
;

38 
size_t
 
	gschedud_leed
;

39 
bo
 
	gschedud_dim
;

40 cڡ 
AST_Node
* 
	gschedud_mpg
;

42 
	gpublic
:

44 
bo
 
_commt
;

46 
bo
 
	g_wed
;

48 
bo
 
	g_med_block
;

50 
bo
 
	g_dei
;

52 
bo
 
	g_a_y
;

53 
bo
 
	g_comma_y
;

55 
	gpublic
:

57 
d
::
rg
 
g_bufr
();

59 
Sass_Ouut_Sty
 
ouut_y
() const;

61 
fize
(
bo
 
f
 = 
ue
);

63 
ush_schedus
();

65 
d_rg
(cڡ 
d
::
rg
& 
xt
);

66 
d_ouut
(cڡ 
OuutBufr
& 
out
);

68 
nd_rg
(cڡ 
d
::
rg
& 
xt
);

70 
nd_wa
(cڡ 
d
::
rg
& 
xt
);

73 
nd_tok
(cڡ 
d
::
rg
& 
xt
, cڡ 
AST_Node
* 
node
);

75 
	gpublic
:

76 
nd_dti
();

77 
nd_tiڮ_a
();

78 
nd_mdy_a
();

79 
nd_ecl_leed
();

80 
nd_tiڮ_leed
();

81 
nd_mdy_leed
();

82 
nd_sce_ݒ
(
AST_Node
* 
node
 = 0);

83 
nd_sce_or
(
AST_Node
* 
node
 = 0);

84 
nd_comma_t
();

85 
nd_c_t
();

86 
nd_dim
();

	@node_modules/node-sass/src/libsass/src/environment.cpp

1 
	~"ss.h
"

2 
	~"a.h
"

3 
	~"vmt.h
"

5 
mea
 
	gSass
 {

7 
	gme
 <
tyme
 
	gT
>

8 
	gEnvmt
<
	gT
>::
Envmt
(
bo
 
is_shadow
)

9 : 
lol_ame_
(
d
::
m
<d::
rg
, 
T
>()),

10 
_
(0), 
is_shadow_
(
l
)

12 
	gme
 <
tyme
 
	gT
>

13 
	gEnvmt
<
	gT
>::
Envmt
(Envmt<
T
>* 
v
, 
bo
 
is_shadow
)

14 : 
lol_ame_
(
d
::
m
<d::
rg
, 
T
>()),

15 
_
(
v
), 
is_shadow_
(
is_shadow
)

17 
	gme
 <
tyme
 
	gT
>

18 
	gEnvmt
<
	gT
>::
Envmt
(Envmt<
T
>& 
v
, 
bo
 
is_shadow
)

19 : 
lol_ame_
(
d
::
m
<d::
rg
, 
T
>()),

20 
_
(&
v
), 
is_shadow_
(
is_shadow
)

24 
	gme
 <
tyme
 
	gT
>

25 
	gEnvmt
<
	gT
>::
lk
(
Envmt
& 
v
{ 
_
 = &env; }

26 
	gme
 <
tyme
 
	gT
>

27 
	gEnvmt
<
	gT
>::
lk
(
Envmt
* 
v
{ 
_
 =nv; }

31 
	gme
 <
tyme
 
	gT
>

32 
bo
 
	gEnvmt
<
	gT
>::
is_xil
() const

34  !! 
_
 &&arent_->parent_;

41 
	gme
 <
tyme
 
	gT
>

42 
bo
 
	gEnvmt
<
	gT
>::
is_glob
() const

44  
_
 && !arent_->parent_;

47 
	gme
 <
tyme
 
	gT
>

48 
	gd
::
m
<
d
::
rg
, 
	gT
>& 
	gEnvmt
<T>::
lol_ame
() {

49  
lol_ame_
;

52 
	gme
 <
tyme
 
	gT
>

53 
bo
 
	gEnvmt
<
	gT
>::
has_lol
(cڡ 
d
::
rg
& 
key
) const

54 {  
lol_ame_
.
fd
(
key
!lol_ame_.
d
(); }

56 
	gme
 <
tyme
 
	gT
>

57 
	gT
& 
	gEnvmt
<T>::
g_lol
(cڡ 
d
::
rg
& 
key
)

58 {  
lol_ame_
[
key
]; }

60 
	gme
 <
tyme
 
	gT
>

61 
	gEnvmt
<
	gT
>::
t_lol
(cڡ 
d
::
rg
& 
key
, 
T
 
v
)

63 
	glol_ame_
[
key
] = 
v
;

66 
	gme
 <
tyme
 
	gT
>

67 
	gEnvmt
<
	gT
>::
d_lol
(cڡ 
d
::
rg
& 
key
)

68 { 
lol_ame_
.
a
(
key
); }

70 
	gme
 <
tyme
 
	gT
>

71 
	gEnvmt
<
	gT
>* Envmt<T>::
glob_v
()

73 
Envmt
* 
cur
 = 
this
;

74 
	gcur
->
is_xil
()) {

75 
	gcur
 = 
cur
->
_
;

77  
	gcur
;

80 
	gme
 <
tyme
 
	gT
>

81 
bo
 
	gEnvmt
<
	gT
>::
has_glob
(cڡ 
d
::
rg
& 
key
)

82 {  
glob_v
()->
has
(
key
); }

84 
	gme
 <
tyme
 
	gT
>

85 
	gT
& 
	gEnvmt
<T>::
g_glob
(cڡ 
d
::
rg
& 
key
)

86 {  (*
glob_v
())[
key
]; }

88 
	gme
 <
tyme
 
	gT
>

89 
	gEnvmt
<
	gT
>::
t_glob
(cڡ 
d
::
rg
& 
key
, 
T
 
v
)

91 
glob_v
()->
	glol_ame_
[
key
] = 
v
;

94 
	gme
 <
tyme
 
	gT
>

95 
	gEnvmt
<
	gT
>::
d_glob
(cڡ 
d
::
rg
& 
key
)

96 { 
glob_v
()->
lol_ame_
.
a
(
key
); }

98 
	gme
 <
tyme
 
	gT
>

99 
	gEnvmt
<
	gT
>* Envmt<T>::
xil_v
(cڡ 
d
::
rg
& 
key
)

101 
Envmt
* 
cur
 = 
this
;

102 
	gcur
) {

103 i(
	gcur
->
has_lol
(
key
)) {

104  
	gcur
;

106 
	gcur
 = 
cur
->
_
;

108  
	gthis
;

114 
	gme
 <
tyme
 
	gT
>

115 
bo
 
	gEnvmt
<
	gT
>::
has_xil
(cڡ 
d
::
rg
& 
key
) const

117 aut
cur
 = 
this
;

118 
	gcur
->
is_xil
()) {

119 i(
	gcur
->
has_lol
(
key
) 
	gue
;

120 
	gcur
 = 
cur
->
_
;

122  
	gl
;

128 
	gme
 <
tyme
 
	gT
>

129 
	gEnvmt
<
	gT
>::
t_xil
(cڡ 
d
::
rg
& 
key
, 
T
 
v
)

131 aut
	gcur
 = 
this
; 
bo
 
	gshadow
 = 
l
;

132 
	gcur
->
is_xil
(|| 
	gshadow
) {

133 i(
	gcur
->
has_lol
(
key
)) {

134 
	gcur
->
t_lol
(
key
, 
v
);

137 
	gshadow
 = 
cur
->
is_shadow
();

138 
	gcur
 = 
cur
->
_
;

140 
t_lol
(
key
, 
v
);

145 
	gme
 <
tyme
 
	gT
>

146 
bo
 
	gEnvmt
<
	gT
>::
has
(cڡ 
d
::
rg
& 
key
) const

148 aut
cur
 = 
this
;

149 
	gcur
) {

150 i(
	gcur
->
has_lol
(
key
)) {

151  
	gue
;

153 
	gcur
 = 
cur
->
_
;

155  
	gl
;

159 
	gme
 <
tyme
 
	gT
>

160 
	gT
& 
	gEnvmt
<T>::
ݔ
[](cڡ 
d
::
rg
& 
key
)

162 aut
cur
 = 
this
;

163 
	gcur
) {

164 i(
	gcur
->
has_lol
(
key
)) {

165  
	gcur
->
g_lol
(
key
);

167 
	gcur
 = 
cur
->
_
;

169  
g_lol
(
key
);

172 #ifde
DEBUG


173 
	gme
 <
tyme
 
	gT
>

174 
size_t
 
	gEnvmt
<
	gT
>::
t
(
d
::
rg
 
efix
)

176 
size_t
 
dt
 = 0;

177 i(
	g_

	gdt
 = 
_
->
t
(
efix
) + 1;

178 
	gd
::

 << 
efix
 << 
d
::
rg
(
dt
, ' '<< "=" << 
	gthis
 << std::
dl
;

179 
tyme
 
	gd
::
m
<
d
::
rg
, 
	gT
>::

 
i
 = 
lol_ame_
.
beg
(); 
	gi
 !lol_ame_.
d
(); ++i) {

180 i(!
ds_wh
(
i
->
f
, "[f]") && !ends_with(i->first, "[f]4") && !ends_with(i->first, "[f]2")) {

181 
	gd
::

 << 
efix
 << 
d
::
rg
(
dt
, ' '<< 
	gi
->
	gf
 << " " << i->
	gcd
;

182 i(
Vue
* 
	gv
 = 
dymic_
<Vue*>(
i
->
cd
))

183 { 
d
::

 << " : " << 
v
->
to_rg
(); }

184 
	gd
::

 << 
d
::
dl
;

187  
	gdt
 ;

192 
me
 
ass
 
	gEnvmt
<
	gAST_Node
*>;

	@node_modules/node-sass/src/libsass/src/environment.hpp

1 #ide
SASS_ENVIRONMENT_H


2 
	#SASS_ENVIRONMENT_H


	)

4 
	~<rg
>

5 
	~<m
>

7 
	~"a_fwd_de.h
"

8 
	~"a_def_maos.h
"

9 
	~"memy_mag.h
"

11 
mea
 
	gSass
 {

13 
	gme
 <
tyme
 
	gT
>

14 as
	cEnvmt
 {

16 
	gd
::
m
<
d
::
rg
, 
	gT
> 
	glol_ame_
;

17 
ADD_PROPERTY
(
Envmt
*, 

)

18 
ADD_PROPERTY
(
bo
, 
is_shadow
)

20 
	gpublic
:

21 
Memy_Mag
 
mem
;

22 
Envmt
(
bo
 
is_shadow
 = 
l
);

23 
Envmt
(Envmt* 
v
, 
bo
 
is_shadow
 = 
l
);

24 
Envmt
(Envmt& 
v
, 
bo
 
is_shadow
 = 
l
);

27 
lk
(
Envmt
& 
v
);

28 
lk
(
Envmt
* 
v
);

32 
bo
 
is_xil
() const;

38 
bo
 
is_glob
() const;

42 
	gd
::
m
<
d
::
rg
, 
	gT
>& 
lol_ame
();

44 
bo
 
has_lol
(cڡ 
d
::
rg
& 
key
) const;

46 
	gT
& 
g_lol
(cڡ 
d
::
rg
& 
key
);

49 
t_lol
(cڡ 
d
::
rg
& 
key
, 
T
 
v
);

51 
d_lol
(cڡ 
d
::
rg
& 
key
);

55 
Envmt
* 
glob_v
();

58 
Envmt
* 
xil_v
(cڡ 
d
::
rg
& 
key
);

60 
bo
 
has_glob
(cڡ 
d
::
rg
& 
key
);

62 
	gT
& 
g_glob
(cڡ 
d
::
rg
& 
key
);

65 
t_glob
(cڡ 
d
::
rg
& 
key
, 
T
 
v
);

67 
d_glob
(cڡ 
d
::
rg
& 
key
);

72 
bo
 
has_xil
(cڡ 
d
::
rg
& 
key
) const;

77 
t_xil
(cڡ 
d
::
rg
& 
key
, 
T
 
v
);

81 
bo
 
has
(cڡ 
d
::
rg
& 
key
) const;

84 
	gT
& 
	gݔ
[](cڡ 
	gd
::
rg
& 
key
);

86 #ifde
DEBUG


87 
size_t
 
t
(
d
::
rg
 
efix
 = "");

	@node_modules/node-sass/src/libsass/src/error_handling.cpp

1 
	~"ss.h
"

2 
	~"a.h
"

3 
	~"ex.h
"

4 
	~"backa.h
"

5 
	~"r_hdlg.h
"

7 
	~<ioam
>

9 
mea
 
	gSass
 {

11 
mea
 
	gExi
 {

13 
	gBa
::
Ba
(
PrS
 
pe
, 
d
::
rg
 
msg
, std::
ve
<
Sass_Impt_Ery
>* 
impt_ack
)

14 : 
d
::
ruime_r
(
msg
), msg(msg),

15 
efix
("E"), 
pe
(pstate),

16 
impt_ack
(import_stack)

19 
	gInvidSass
::
InvidSass
(
PrS
 
pe
, 
d
::
rg
 
msg
)

20 : 
Ba
(
pe
, 
msg
)

24 
	gInvidPt
::
InvidPt
(
Se
* 

, Se* 

)

25 : 
Ba
(

->
pe
()), 

(parent), selector(selector)

27 
	gmsg
 = "Invalidarent selector for \"";

28 
	gmsg
 +

->
to_rg
(
Sass_Ine_Ois
());

29 
	gmsg
 += "\": \"";

30 
	gmsg
 +

->
to_rg
(
Sass_Ine_Ois
());

31 
	gmsg
 += "\"";

34 
	gInvidArgumtTy
::
InvidArgumtTy
(
PrS
 
pe
, 
d
::
rg
 

, std::rg 
g
, std::rg 
ty
, cڡ 
Vue
* 
vue
)

35 : 
Ba
(
pe
), 

(), 
g
rg), 
ty
y), 
vue
(value)

37 
	gmsg
 = 
g
 + ": \"";

38 
	gmsg
 +
vue
->
to_rg
(
Sass_Ine_Ois
());

39 
	gmsg
 +"\" inه " + 
ty
;

40 
	gmsg
 +" f `" + 

 + "'";

43 
	gInvidSyax
::
InvidSyax
(
PrS
 
pe
, 
d
::
rg
 
msg
, std::
ve
<
Sass_Impt_Ery
>* 
impt_ack
)

44 : 
Ba
(
pe
, 
msg
, 
impt_ack
)

47 
	gUndefedOti
::
UndefedOti
(cڡ 
Exessi
* 
lhs
, cڡ Exessi* 
rhs
, cڡ 
d
::
rg
& 

)

48 : 
lhs
hs), 
rhs
hs), 

(op)

50 
	gmsg
 = 
def__msg
 + ": \"";

51 
	gmsg
 +
lhs
->
to_rg
({ 
NESTED
, 5 });

52 
	gmsg
 +" " + 

 + " ";

53 
	gmsg
 +
rhs
->
to_rg
({ 
TO_SASS
, 5 });

54 
	gmsg
 += "\".";

57 
	gInvidNuOti
::
InvidNuOti
(cڡ 
Exessi
* 
lhs
, cڡ Exessi* 
rhs
, cڡ 
d
::
rg
& 

)

58 : 
UndefedOti
(
lhs
, 
rhs
, 

)

60 
	gmsg
 = 
def__nu_msg
 + ": \"";

61 
	gmsg
 +
lhs
->
e
();

62 
	gmsg
 +" " + 

 + " ";

63 
	gmsg
 +
rhs
->
e
();

64 
	gmsg
 += "\".";

67 
	gZoDivisiE
::
ZoDivisiE
(cڡ 
Exessi
& 
lhs
, cڡ Exessi& 
rhs
)

68 : 
lhs
hs), 
rhs
(rhs)

70 
	gmsg
 = "divided by 0";

73 
	gDuiKeyE
::
DuiKeyE
(cڡ 
M
& 
dup
, cڡ 
Exessi
& 
g
)

74 : 
Ba
(
g
.
pe
()), 
dup
(dup), org(org)

76 
	gmsg
 = "Duplicate key ";

77 
	gdup
.
g_dui_key
()->
is_dayed
(
l
);

78 
	gmsg
 +
dup
.
g_dui_key
()->
e
();

79 
	gmsg
 += " in map (";

80 
	gmsg
 +
g
.
e
();

81 
	gmsg
 += ").";

84 
	gTyMismch
::
TyMismch
(cڡ 
Exessi
& 
v
, cڡ 
d
::
rg
 
ty
)

85 : 
Ba
(
v
.
pe
()), v(v), 
ty
(type)

87 
	gmsg
 = 
v
.
to_rg
();

88 
	gmsg
 += " isotn ";

89 
	gmsg
 +
ty
;

90 
	gmsg
 += ".";

93 
	gInvidVue
::
InvidVue
(cڡ 
Exessi
& 
v
)

94 : 
Ba
(
v
.
pe
()), val(val)

96 
	gmsg
 = 
v
.
to_rg
();

97 
	gmsg
 += " isn't valid CSS value.";

100 
	gIncomtibUns
::
IncomtibUns
(cڡ 
Numb
& 
lhs
, cڡ Numb& 
rhs
)

101 : 
lhs
hs), 
rhs
(rhs)

103 
	gmsg
 = "Incompatible units: '";

104 
	gmsg
 +
rhs
.
un
();

105 
	gmsg
 += "'nd '";

106 
	gmsg
 +
lhs
.
un
();

107 
	gmsg
 += "'.";

110 
	gAhaChlsNEqu
::
AhaChlsNEqu
(cڡ 
Exessi
* 
lhs
, cڡ Exessi* 
rhs
, cڡ 
d
::
rg
& 

)

111 : 
lhs
hs), 
rhs
hs), 

(op)

113 
	gmsg
 = "Alpha channels must bequal: ";

114 
	gmsg
 +
lhs
->
to_rg
({ 
NESTED
, 5 });

115 
	gmsg
 +" " + 

 + " ";

116 
	gmsg
 +
rhs
->
to_rg
({ 
NESTED
, 5 });

117 
	gmsg
 += ".";

121 
	gSassVueE
::
SassVueE
(
PrS
 
pe
, 
OtiE
& 
r
)

122 : 
Ba
(
pe
, 
r
.
wh
())

124 
	gmsg
 = 
r
.
wh
();

125 
	gefix
 = 
r
.
y
();

131 
wn
(
d
::
rg
 
msg
, 
PrS
 
pe
)

133 
	gd
::

 << "Wng: " << 
msg
<< 
d
::
dl
;

136 
wn
(
d
::
rg
 
msg
, 
PrS
 
pe
, 
Backa
* 
bt
)

138 
Backa
 
t
(
bt
, 
pe
, "");

139 
	gmsg
 +
t
.
to_rg
();

140 
wn
(
msg
, 
pe
);

143 
dd_funi
(
d
::
rg
 
msg
, 
PrS
 
pe
)

145 
	gd
::
rg
 
cwd
(
Sass
::
Fe
::
g_cwd
());

146 
	gd
::
rg
 
abs_th
(
Sass
::
Fe
::
l2abs
(
pe
.
th
, 
cwd
, cwd));

147 
	gd
::
rg
 
l_th
(
Sass
::
Fe
::
abs2l
(
pe
.
th
, 
cwd
, cwd));

148 
	gd
::
rg
 
ouut_th
(
Sass
::
Fe
::
th_f_cse
(
l_th
, 
abs_th
, 
pe
.
th
));

150 
	gd
::

 << "DEPRECATION WARNING: " << 
msg
 << 
d
::
dl
;

151 
	gd
::

 << "wb ifutu vsiڠoSass." << 
d
::
dl
;

152 
	gd
::

 << " ol" << 
pe
.
le
+1 << " o" << 
ouut_th
 << 
d
::
dl
;

155 
dd
(
d
::
rg
 
msg
, std::rg 
msg2
, 
PrS
 
pe
)

157 
	gd
::
rg
 
cwd
(
Sass
::
Fe
::
g_cwd
());

158 
	gd
::
rg
 
abs_th
(
Sass
::
Fe
::
l2abs
(
pe
.
th
, 
cwd
, cwd));

159 
	gd
::
rg
 
l_th
(
Sass
::
Fe
::
abs2l
(
pe
.
th
, 
cwd
, cwd));

160 
	gd
::
rg
 
ouut_th
(
Sass
::
Fe
::
th_f_cse
(
l_th
, 
pe
.
th
,state.path));

162 
	gd
::

 << "DEPRECATION WARNING ol" << 
pe
.
le
 + 1;

163 i(
	gouut_th
.
ngth
()
	gd
::

 << " o" << 
ouut_th
;

164 
	gd
::

 << ":" << 
d
::
dl
;

165 
	gd
::

 << 
msg
 << "nd wb ifutu vsiڠoSass." << 
d
::
dl
;

166 i(
	gmsg2
.
ngth
()
	gd
::

 << 
msg2
 << 
d
::
dl
;

167 
	gd
::

 << 
d
::
dl
;

170 
dd_bd
(
d
::
rg
 
msg
, 
PrS
 
pe
)

172 
	gd
::
rg
 
cwd
(
Sass
::
Fe
::
g_cwd
());

173 
	gd
::
rg
 
abs_th
(
Sass
::
Fe
::
l2abs
(
pe
.
th
, 
cwd
, cwd));

174 
	gd
::
rg
 
l_th
(
Sass
::
Fe
::
abs2l
(
pe
.
th
, 
cwd
, cwd));

175 
	gd
::
rg
 
ouut_th
(
Sass
::
Fe
::
th_f_cse
(
l_th
, 
abs_th
, 
pe
.
th
));

177 
	gd
::

 << "WARNING: " << 
msg
 << 
d
::
dl
;

178 
	gd
::

 << " ol" << 
pe
.
le
+1 << " o" << 
ouut_th
 << 
d
::
dl
;

179 
	gd
::

 << "Thiwb ifutu vsiڠoSass." << 
d
::
dl
;

182 
r
(
d
::
rg
 
msg
, 
PrS
 
pe
)

184 
throw
 
	gExi
::
InvidSyax
(
pe
, 
msg
);

187 
r
(
d
::
rg
 
msg
, 
PrS
 
pe
, 
Backa
* 
bt
)

189 
Backa
 
t
(
bt
, 
pe
, "");

190 
	gmsg
 +"\n" + 
t
.
to_rg
();

191 
r
(
msg
, 
pe
);

	@node_modules/node-sass/src/libsass/src/error_handling.hpp

1 #ide
SASS_ERROR_HANDLING_H


2 
	#SASS_ERROR_HANDLING_H


	)

4 
	~<rg
>

5 
	~<sam
>

6 
	~<dex
>

7 
	~"posi.h
"

9 
mea
 
	gSass
 {

11 
	gBacka
;

13 
mea
 
	gExi
 {

15 cڡ 
	gd
::
rg
 
def_msg
 = "Invalid sass detected";

16 cڡ 
	gd
::
rg
 
def__msg
 = "Undefined operation";

17 cڡ 
	gd
::
rg
 
def__nu_msg
 = "Invalidull operation";

19 as
	cBa
 : 
public
 
d
::
ruime_r
 {

20 
eed
:

21 
d
::
rg
 
msg
;

22 
	gd
::
rg
 
efix
;

23 
	gpublic
:

24 
PrS
 
pe
;

25 
	gd
::
ve
<
Sass_Impt_Ery
>* 
impt_ack
;

26 
	gpublic
:

27 
Ba
(
PrS
 
pe
, 
d
::
rg
 
msg
 = 
def_msg
, std::
ve
<
Sass_Impt_Ery
>* 
impt_ack
 = 0);

28 
vtu
 cڡ * 
y
(cڡ {  
	gefix
.
c_r
(); }

29 
vtu
 cڡ * 
wh
(cڡ 
throw
({  
	gmsg
.
c_r
(); }

30 
	gvtu
 ~
Ba
(
throw
() {};

33 as
	cInvidSass
 : 
public
 
Ba
 {

34 
public
:

35 
InvidSass
(
PrS
 
pe
, 
d
::
rg
 
msg
);

36 
	gvtu
 ~
InvidSass
(
throw
() {};

39 as
	cInvidPt
 : 
public
 
Ba
 {

40 
eed
:

41 
Se
* 

;

42 
Se
* 
	g
;

43 
	gpublic
:

44 
InvidPt
(
Se
* 

, Se* 

);

45 
	gvtu
 ~
InvidPt
(
throw
() {};

48 as
	cInvidArgumtTy
 : 
public
 
Ba
 {

49 
eed
:

50 
d
::
rg
 

;

51 
	gd
::
rg
 
g
;

52 
	gd
::
rg
 
ty
;

53 cڡ 
Vue
* 
	gvue
;

54 
	gpublic
:

55 
InvidArgumtTy
(
PrS
 
pe
, 
d
::
rg
 

, std::rg 
g
, std::rg 
ty
, cڡ 
Vue
* 
vue
 = 0);

56 
	gvtu
 ~
InvidArgumtTy
(
throw
() {};

59 as
	cInvidSyax
 : 
public
 
Ba
 {

60 
public
:

61 
InvidSyax
(
PrS
 
pe
, 
d
::
rg
 
msg
, std::
ve
<
Sass_Impt_Ery
>* 
impt_ack
 = 0);

62 
	gvtu
 ~
InvidSyax
(
throw
() {};

66 as
	cOtiE
 : 
public
 
d
::
ruime_r
 {

67 
eed
:

68 
d
::
rg
 
msg
;

69 
	gpublic
:

70 
OtiE
(
d
::
rg
 
msg
 = 
def__msg
)

71 : 
d
::
ruime_r
(
msg
), msg(msg)

73 
	gpublic
:

74 
vtu
 cڡ * 
y
() const {  "Error"; }

75 
vtu
 cڡ * 
wh
(cڡ 
throw
({  
	gmsg
.
c_r
(); }

76 
	gvtu
 ~
OtiE
(
throw
() {};

79 as
	cZoDivisiE
 : 
public
 
OtiE
 {

80 
eed
:

81 cڡ 
Exessi
& 
lhs
;

82 cڡ 
	gExessi
& 
	grhs
;

83 
	gpublic
:

84 
ZoDivisiE
(cڡ 
Exessi
& 
lhs
, cڡ Exessi& 
rhs
);

85 
vtu
 cڡ * 
y
() const {  "ZeroDivisionError"; }

86 
	gvtu
 ~
ZoDivisiE
(
throw
() {};

89 as
	cDuiKeyE
 : 
public
 
Ba
 {

90 
eed
:

91 cڡ 
M
& 
dup
;

92 cڡ 
	gExessi
& 
	gg
;

93 
	gpublic
:

94 
DuiKeyE
(cڡ 
M
& 
dup
, cڡ 
Exessi
& 
g
);

95 
vtu
 cڡ * 
y
() const {  "Error"; }

96 
	gvtu
 ~
DuiKeyE
(
throw
() {};

99 as
	cTyMismch
 : 
public
 
Ba
 {

100 
eed
:

101 cڡ 
Exessi
& 
v
;

102 cڡ 
	gd
::
rg
 
ty
;

103 
	gpublic
:

104 
TyMismch
(cڡ 
Exessi
& 
v
, cڡ 
d
::
rg
 
ty
);

105 
vtu
 cڡ * 
y
() const {  "Error"; }

106 
	gvtu
 ~
TyMismch
(
throw
() {};

109 as
	cInvidVue
 : 
public
 
Ba
 {

110 
eed
:

111 cڡ 
Exessi
& 
v
;

112 
	gpublic
:

113 
InvidVue
(cڡ 
Exessi
& 
v
);

114 
vtu
 cڡ * 
y
() const {  "Error"; }

115 
	gvtu
 ~
InvidVue
(
throw
() {};

118 as
	cIncomtibUns
 : 
public
 
OtiE
 {

119 
eed
:

120 cڡ 
Numb
& 
lhs
;

121 cڡ 
	gNumb
& 
	grhs
;

122 
	gpublic
:

123 
IncomtibUns
(cڡ 
Numb
& 
lhs
, cڡ Numb& 
rhs
);

124 
	gvtu
 ~
IncomtibUns
(
throw
() {};

127 as
	cUndefedOti
 : 
public
 
OtiE
 {

128 
eed
:

129 cڡ 
Exessi
* 
lhs
;

130 cڡ 
Exessi
* 
	grhs
;

131 cڡ 
	gd
::
rg
 

;

132 
	gpublic
:

133 
UndefedOti
(cڡ 
Exessi
* 
lhs
, cڡ Exessi* 
rhs
, cڡ 
d
::
rg
& 

);

135 
	gvtu
 ~
UndefedOti
(
throw
() {};

138 as
	cInvidNuOti
 : 
public
 
UndefedOti
 {

139 
public
:

140 
InvidNuOti
(cڡ 
Exessi
* 
lhs
, cڡ Exessi* 
rhs
, cڡ 
d
::
rg
& 

);

141 
	gvtu
 ~
InvidNuOti
(
throw
() {};

144 as
	cAhaChlsNEqu
 : 
public
 
OtiE
 {

145 
eed
:

146 cڡ 
Exessi
* 
lhs
;

147 cڡ 
Exessi
* 
	grhs
;

148 cڡ 
	gd
::
rg
 

;

149 
	gpublic
:

150 
AhaChlsNEqu
(cڡ 
Exessi
* 
lhs
, cڡ Exessi* 
rhs
, cڡ 
d
::
rg
& 

);

152 
	gvtu
 ~
AhaChlsNEqu
(
throw
() {};

155 as
	cSassVueE
 : 
public
 
Ba
 {

156 
public
:

157 
SassVueE
(
PrS
 
pe
, 
OtiE
& 
r
);

158 
	gvtu
 ~
SassVueE
(
throw
() {};

163 
wn
(
d
::
rg
 
msg
, 
PrS
 
pe
);

164 
wn
(
d
::
rg
 
msg
, 
PrS
 
pe
, 
Backa
* 
bt
);

166 
dd_funi
(
d
::
rg
 
msg
, 
PrS
 
pe
);

167 
dd
(
d
::
rg
 
msg
, std::rg 
msg2
, 
PrS
 
pe
);

168 
dd_bd
(
d
::
rg
 
msg
, 
PrS
 
pe
);

171 
r
(
d
::
rg
 
msg
, 
PrS
 
pe
);

172 
r
(
d
::
rg
 
msg
, 
PrS
 
pe
, 
Backa
* 
bt
);

	@node_modules/node-sass/src/libsass/src/eval.cpp

1 
	~"ss.h
"

2 
	~<cdlib
>

3 
	~<cmh
>

4 
	~<ioam
>

5 
	~<sam
>

6 
	~<iom
>

7 
	~<tyfo
>

9 
	~"fe.h
"

10 
	~"ev.h
"

11 
	~"a.h
"

12 
	~"bd.h
"

13 
	~"ut.h
"

14 
	~"e.h
"

15 
	~"vmt.h
"

16 
	~"posi.h
"

17 
	~"ss/vues.h
"

18 
	~"to_vue.h
"

19 
	~"to_c.h
"

20 
	~"cڋxt.h
"

21 
	~"backa.h
"

22 
	~"x.h
"

23 
	~"ex.h
"

24 
	~"rr.h
"

25 
	~"exnd.h
"

26 
	~"c_ms.h
"

28 
mea
 
	gSass
 {

30 
le
 
add
(
x
, 
y
{  
	gx
 + 
	gy
; }

31 
le
 
sub
(
x
, 
y
{  
	gx
 - 
	gy
; }

32 
le
 
mul
(
x
, 
y
{  x * 
	gy
; }

33 
le
 
div
(
x
, 
y
{  
	gx
 / 
	gy
; }

34 
le
 
mod
(
x
, 
y
{  
	gd
::
abs
(
d
::
fmod
(x, y)); }

35 (*
	gb
)(, );

36 
b
 
	gs
[
Sass_OP
::
NUM_OPS
] = {

39 
add
, 
sub
, 
mul
, 
div
, 
mod


42 
	gEv
::
Ev
(
Exnd
& 
exp
)

43 : 
exp
(exp),

44 
x
(
exp
.ctx)

46 
	gEv
::~
Ev
() { }

48 
Cڋxt
& 
Ev
::
cڋxt
()

50  
x
;

53 
Env
* 
	gEv
::
vmt
()

55  
exp
.
vmt
();

58 
Se_Li
* 
	gEv
::

()

60  
exp
.

();

63 
Backa
* 
	gEv
::
backa
()

65  
exp
.
backa
();

68 
Exessi
* 
	gEv
::
ݔ
()(
Block
* 
b
)

70 
Exessi
* 
v
 = 0;

71 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

72 
	gv
 = (*
b
)[
i
]->
rfm
(
this
);

73 i(
	gv
)  val;

75  
	gv
;

78 
Exessi
* 
	gEv
::
ݔ
()(
Assignmt
* 
a
)

80 
Env
* 
v
 = 
exp
.
vmt
();

81 
	gd
::
rg
 
v
(
a
->
vb
());

82 i(
	ga
->
is_glob
()) {

83 i(
	ga
->
is_deu
()) {

84 i(
	gv
->
has_glob
(
v
)) {

85 
Exessi
* 
	ge
 = 
dymic_
<Exessi*>(
v
->
g_glob
(
v
));

86 i(!
	ge
 ||->
ce_ty
(=
Exessi
::
NULL_VAL
) {

87 
v
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(
this
));

91 
	gv
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(
this
));

95 
	gv
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(
this
));

98 i(
	ga
->
is_deu
()) {

99 i(
	gv
->
has_xil
(
v
)) {

100 aut
	gcur
 = 
v
;

101 
	gcur
 && cur->
is_xil
()) {

102 i(
	gcur
->
has_lol
(
v
)) {

103 i(
AST_Node
* 
	gnode
 = 
cur
->
g_lol
(
v
)) {

104 
Exessi
* 
e
 = 
dymic_
<Exessi*>(
node
);

105 i(!
	ge
 ||->
ce_ty
(=
Exessi
::
NULL_VAL
) {

106 
cur
->
t_lol
(
v
, 
a
->
vue
()->
rfm
(
this
));

110 
throw
 
	gd
::
ruime_r
("Envot in sync");

114 
	gcur
 = 
cur
->

();

116 
throw
 
	gd
::
ruime_r
("Envot in sync");

118 i(
	gv
->
has_glob
(
v
)) {

119 i(
AST_Node
* 
	gnode
 = 
v
->
g_glob
(
v
)) {

120 
Exessi
* 
e
 = 
dymic_
<Exessi*>(
node
);

121 i(!
	ge
 ||->
ce_ty
(=
Exessi
::
NULL_VAL
) {

122 
v
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(
this
));

126 i(
	gv
->
is_xil
()) {

127 
	gv
->
t_lol
(
v
, 
a
->
vue
()->
rfm
(
this
));

130 
	gv
->
t_lol
(
v
, 
a
->
vue
()->
rfm
(
this
));

134 
	gv
->
t_xil
(
v
, 
a
->
vue
()->
rfm
(
this
));

139 
Exessi
* 
	gEv
::
ݔ
()(
If
* 
i
)

141 
Exessi
* 
rv
 = 0;

142 
Env
 
v
(
exp
.
vmt
());

143 
	gexp
.
	gv_ack
.
push_back
(&
v
);

144 i(*
	gi
->
edi
()->
rfm
(
this
)) {

145 
	grv
 = 
i
->
block
()->
rfm
(
this
);

148 
Block
* 
	gt
 = 
i
->
ive
();

149 i(
	gt

	grv
 = 
t
->
rfm
(
this
);

151 
	gexp
.
	gv_ack
.
p_back
();

152  
	grv
;

157 
Exessi
* 
	gEv
::
ݔ
()(
F
* 
f
)

159 
d
::
rg
 
vb
(
f
->variable());

160 
Exessi
* 
	glow
 = 
f
->
low_bound
()->
rfm
(
this
);

161 i(
	glow
->
ce_ty
(!
Exessi
::
NUMBER
) {

162 
throw
 
Exi
::
TyMismch
(*
low
, "integer");

164 
Exessi
* 
	ghigh
 = 
f
->
u_bound
()->
rfm
(
this
);

165 i(
	ghigh
->
ce_ty
(!
Exessi
::
NUMBER
) {

166 
throw
 
Exi
::
TyMismch
(*
high
, "integer");

168 
Numb
* 
	gss_t
 = 
ic_
<Numb*>(
low
);

169 
Numb
* 
	gss_d
 = 
ic_
<Numb*>(
high
);

171 i(
	gss_t
->
un
(!
ss_d
->unit()) {

172 
d
::
rgam
 
msg
; 
	gmsg
 << "Incompatible units: '"

173 << 
	gss_t
->
un
() << "'nd '"

174 << 
	gss_d
->
un
() << "'.";

175 
r
(
msg
.
r
(), 
low
->
pe
(), 
backa
());

177 
	gt
 = 
ss_t
->
vue
();

178 
	gd
 = 
ss_d
->
vue
();

180 
Env
 
v
(
vmt
(), 
ue
);

181 
	gexp
.
	gv_ack
.
push_back
(&
v
);

182 
Numb
* 
	g
 = 
SASS_MEMORY_NEW
(
v
.
mem
, Numb, 
low
->
pe
(), 
t
, 
ss_d
->
un
());

183 
	gv
.
t_lol
(
vb
, 

);

184 
Block
* 
	gbody
 = 
f
->
block
();

185 
Exessi
* 
	gv
 = 0;

186 i(
	gt
 < 
	gd
) {

187 i(
	gf
->
is_usive
()++
	gd
;

188 
	gi
 = 
t
;

189 
	gi
 < 
	gd
;

190 ++
	gi
) {

191 
	g
->
vue
(
i
);

192 
	gv
.
t_lol
(
vb
, 

);

193 
	gv
 = 
body
->
rfm
(
this
);

194 i(
	gv
) ;

197 i(
	gf
->
is_usive
()--
	gd
;

198 
	gi
 = 
t
;

199 
	gi
 > 
	gd
;

200 --
	gi
) {

201 
	g
->
vue
(
i
);

202 
	gv
.
t_lol
(
vb
, 

);

203 
	gv
 = 
body
->
rfm
(
this
);

204 i(
	gv
) ;

207 
	gexp
.
	gv_ack
.
p_back
();

208  
	gv
;

213 
Exessi
* 
	gEv
::
ݔ
()(
Each
* 
e
)

215 
d
::
ve
<d::
rg
> 
vbs
(
e
->variables());

216 
Exessi
* 
	gex
 = 
e
->
li
()->
rfm
(
this
);

217 
Env
 
v
(
vmt
(), 
ue
);

218 
	gexp
.
	gv_ack
.
push_back
(&
v
);

219 
	gVeized
<
	gExessi
*>* 
	gli
 = 0;

220 
M
* 
	gm
 = 0;

221 i(
	gex
->
ce_ty
(=
Exessi
::
MAP
) {

222 
m
 = 
ic_
<
M
*>(
ex
);

224 i(
Se_Li
* 
	gls
 = 
dymic_
<Se_Li*>(
ex
)) {

225 
Liize
 
liize
(
x
.
mem
);

226 
	gli
 = 
dymic_
<
Li
*>(
ls
->
rfm
(&
liize
));

228 i(
	gex
->
ce_ty
(!
Exessi
::
LIST
) {

229 
li
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
ex
->
pe
(), 1, 
SASS_COMMA
);

230 *
	gli
 << 
	gex
;

233 
	gli
 = 
ic_
<
Li
*>(
ex
);

236 
Block
* 
	gbody
 = 
e
->
block
();

237 
Exessi
* 
	gv
 = 0;

239 i(
	gm
) {

240 aut
	gkey
 : 
m
->
keys
()) {

241 
Exessi
* 
vue
 = 
m
->

(
key
);

243 i(
	gvbs
.
size
() == 1) {

244 
Li
* 
vb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
m
->
pe
(), 2, 
SASS_SPACE
);

245 *
	gvb
 << 
	gkey
;

246 *
	gvb
 << 
	gvue
;

247 
	gv
.
t_lol
(
vbs
[0], 
vb
);

249 
	gv
.
t_lol
(
vbs
[0], 
key
);

250 
	gv
.
t_lol
(
vbs
[1], 
vue
);

253 
	gv
 = 
body
->
rfm
(
this
);

254 i(
	gv
) ;

258 i(
	gli
->
ngth
(=1 && 
dymic_
<
Se_Li
*>(
li
)) {

259 
li
 = 
dymic_
<
Veized
<
Exessi
*>*>(list);

261 
size_t
 
	gi
 = 0, 
	gL
 = 
li
->
ngth
(); i < L; ++i) {

262 
Exessi
* 
	ge
 = (*
li
)[
i
];

264 i(
Argumt
* 
	gg
 = 
dymic_
<Argumt*>(
e
)
g
->
vue
();

266 i(
Li
* 
	gsrs
 = 
dymic_
<Li*>(
e
)) {

267 i(
vbs
.
size
() == 1) {

268 
Exessi
* 
v
 = 
srs
;

269 
	gv
.
t_lol
(
vbs
[0], 
v
);

272 
size_t
 
	gj
 = 0, 
	gK
 = 
vbs
.
size
(); j < K; ++j) {

273 
Exessi
* 
	gs
 = 
j
 >
srs
->
ngth
()

274 ? 
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
ex
->
pe
())

275 : (*
srs
)[
j
];

276 
	gv
.
t_lol
(
vbs
[
j
], 
s
);

280 i(
	gvbs
.
size
() > 0) {

281 
	gv
.
t_lol
(
vbs
[0], 
e
);

282 
size_t
 
	gj
 = 1, 
	gK
 = 
vbs
.
size
(); j < K; ++j) {

284 
Exessi
* 
	gs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
ex
->
pe
());

285 
	gv
.
t_lol
(
vbs
[
j
], 
s
);

289 
	gv
 = 
body
->
rfm
(
this
);

290 i(
	gv
) ;

293 
	gexp
.
	gv_ack
.
p_back
();

294  
	gv
;

297 
Exessi
* 
	gEv
::
ݔ
()(
Whe
* 
w
)

299 
Exessi
* 
ed
 = 
w
->
edi
();

300 
Block
* 
	gbody
 = 
w
->
block
();

301 
Env
 
v
(
vmt
(), 
ue
);

302 
	gexp
.
	gv_ack
.
push_back
(&
v
);

303 *
	ged
->
rfm
(
this
)) {

304 
Exessi
* 
	gv
 = 
body
->
rfm
(
this
);

305 i(
	gv
) {

306 
	gexp
.
	gv_ack
.
p_back
();

307  
	gv
;

310 
	gexp
.
	gv_ack
.
p_back
();

314 
Exessi
* 
	gEv
::
ݔ
()(
Ru
* 
r
)

316  
r
->
vue
()->
rfm
(
this
);

319 
Exessi
* 
	gEv
::
ݔ
()(
Wng
* 
w
)

321 
Sass_Ouut_Sty
 
outy
 = 
x
.
c_tis
.
ouut_y
;

322 
	gx
.
	gc_tis
.
	gouut_y
 = 
NESTED
;

323 
Exessi
* 
	gmesge
 = 
w
->
mesge
()->
rfm
(
this
);

324 
Env
* 
	gv
 = 
exp
.
vmt
();

327 i(
	gv
->
has
("@warn[f]")) {

329 
Defi
* 
	gdef
 = 
ic_
<Defi*>((*
v
)["@warn[f]"]);

332 
Sass_Funi_Ery
 
	gc_funi
 = 
def
->
c_funi
();

333 
Sass_Funi_Fn
 
	gc_func
 = 
ss_funi_g_funi
(
c_funi
);

335 
To_C
 
	gto_c
;

336 
Sass_Vue
* 
	gc_gs
 = 
ss_make_li
(1, 
SASS_COMMA
);

337 
ss_li_t_vue
(
c_gs
, 0, 
mesge
->
rfm
(&
to_c
));

338 
Sass_Vue
* 
	gc_v
 = 
c_func
(
c_gs
, 
c_funi
, 
x
.
c_comp
);

339 
	gx
.
	gc_tis
.
	gouut_y
 = 
outy
;

340 
ss_de_vue
(
c_gs
);

341 
ss_de_vue
(
c_v
);

346 
	gd
::
rg
 
su
(
unque
(
mesge
->
to_ss
()));

347 
Backa
 
t
(
backa
(), 
w
->
pe
(), "");

348 
	gd
::

 << "WARNING: " << 
su
;

349 
	gd
::

 << 
t
.
to_rg
();

350 
	gd
::

 << 
d
::
dl
 << std::endl;

351 
	gx
.
	gc_tis
.
	gouut_y
 = 
outy
;

355 
Exessi
* 
	gEv
::
ݔ
()(
E
* 
e
)

357 
Sass_Ouut_Sty
 
outy
 = 
x
.
c_tis
.
ouut_y
;

358 
	gx
.
	gc_tis
.
	gouut_y
 = 
NESTED
;

359 
Exessi
* 
	gmesge
 = 
e
->
mesge
()->
rfm
(
this
);

360 
Env
* 
	gv
 = 
exp
.
vmt
();

363 i(
	gv
->
has
("@error[f]")) {

365 
Defi
* 
	gdef
 = 
ic_
<Defi*>((*
v
)["@error[f]"]);

368 
Sass_Funi_Ery
 
	gc_funi
 = 
def
->
c_funi
();

369 
Sass_Funi_Fn
 
	gc_func
 = 
ss_funi_g_funi
(
c_funi
);

371 
To_C
 
	gto_c
;

372 
Sass_Vue
* 
	gc_gs
 = 
ss_make_li
(1, 
SASS_COMMA
);

373 
ss_li_t_vue
(
c_gs
, 0, 
mesge
->
rfm
(&
to_c
));

374 
Sass_Vue
* 
	gc_v
 = 
c_func
(
c_gs
, 
c_funi
, 
x
.
c_comp
);

375 
	gx
.
	gc_tis
.
	gouut_y
 = 
outy
;

376 
ss_de_vue
(
c_gs
);

377 
ss_de_vue
(
c_v
);

382 
	gd
::
rg
 
su
(
unque
(
mesge
->
to_ss
()));

383 
	gx
.
	gc_tis
.
	gouut_y
 = 
outy
;

384 
r
(
su
, 
e
->
pe
());

388 
Exessi
* 
	gEv
::
ݔ
()(
Debug
* 
d
)

390 
Sass_Ouut_Sty
 
outy
 = 
x
.
c_tis
.
ouut_y
;

391 
	gx
.
	gc_tis
.
	gouut_y
 = 
NESTED
;

392 
Exessi
* 
	gmesge
 = 
d
->
vue
()->
rfm
(
this
);

393 
Env
* 
	gv
 = 
exp
.
vmt
();

396 i(
	gv
->
has
("@debug[f]")) {

398 
Defi
* 
	gdef
 = 
ic_
<Defi*>((*
v
)["@debug[f]"]);

401 
Sass_Funi_Ery
 
	gc_funi
 = 
def
->
c_funi
();

402 
Sass_Funi_Fn
 
	gc_func
 = 
ss_funi_g_funi
(
c_funi
);

404 
To_C
 
	gto_c
;

405 
Sass_Vue
* 
	gc_gs
 = 
ss_make_li
(1, 
SASS_COMMA
);

406 
ss_li_t_vue
(
c_gs
, 0, 
mesge
->
rfm
(&
to_c
));

407 
Sass_Vue
* 
	gc_v
 = 
c_func
(
c_gs
, 
c_funi
, 
x
.
c_comp
);

408 
	gx
.
	gc_tis
.
	gouut_y
 = 
outy
;

409 
ss_de_vue
(
c_gs
);

410 
ss_de_vue
(
c_v
);

415 
	gd
::
rg
 
cwd
(
x
.cwd());

416 
	gd
::
rg
 
su
(
unque
(
mesge
->
to_ss
()));

417 
	gd
::
rg
 
abs_th
(
Sass
::
Fe
::
l2abs
(
d
->
pe
().
th
, 
cwd
, cwd));

418 
	gd
::
rg
 
l_th
(
Sass
::
Fe
::
abs2l
(
d
->
pe
().
th
, 
cwd
, cwd));

419 
	gd
::
rg
 
ouut_th
(
Sass
::
Fe
::
th_f_cse
(
l_th
, 
abs_th
, 
d
->
pe
().
th
));

420 
	gx
.
	gc_tis
.
	gouut_y
 = 
outy
;

422 
	gd
::

 << 
ouut_th
 << ":" << 
d
->
pe
().
le
+1 << " DEBUG: " << 
su
;

423 
	gd
::

 << 
d
::
dl
;

427 
Exessi
* 
	gEv
::
ݔ
()(
Li
* 
l
)

430 i(
l
->
t
(=
SASS_HASH
) {

431 
M
* 
lm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Map,

432 
l
->
pe
(),

433 
l
->
ngth
() / 2);

434 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; i += 2)

436 
Exessi
* 
key
 = (*
l
)[
i
+0]->
rfm
(
this
);

437 
Exessi
* 
	gv
 = (*
l
)[
i
+1]->
rfm
(
this
);

439 
	gkey
->
is_dayed
(
ue
);

440 *
	glm
 << 
	gd
::
make_
(
key
, 
v
);

442 i(
	glm
->
has_dui_key
()) {

443 
throw
 
	gExi
::
DuiKeyE
(*
lm
, *
l
);

446 
	glm
->
is_ުt
(
l
->is_interpolant());

447  
	glm
->
rfm
(
this
);

450 i(
	gl
->
is_exnded
()) ;

452 
Li
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, List,

453 
l
->
pe
(),

454 
l
->
ngth
(),

455 
l
->
t
(),

456 
l
->
is_gli
());

457 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

458 *
	g
 << (*
	gl
)[
i
]->
rfm
(
this
);

460 
	g
->
is_ުt
(
l
->is_interpolant());

461 
	g
->
om_
(
l
->from_selector());

462 
	g
->
is_exnded
(
ue
);

463  
	g
;

466 
Exessi
* 
	gEv
::
ݔ
()(
M
* 
m
)

468 i(
m
->
is_exnded
())  m;

472 i(
	gm
->
has_dui_key
()) {

473 
throw
 
	gExi
::
DuiKeyE
(*
m
, *m);

476 
M
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Map,

477 
m
->
pe
(),

478 
m
->
ngth
());

479 aut
	gkey
 : 
m
->
keys
()) {

480 
Exessi
* 
ex_key
 = 
key
->
rfm
(
this
);

481 
Exessi
* 
	gex_v
 = 
m
->

(
key
)->
rfm
(
this
);

482 *
	gmm
 << 
	gd
::
make_
(
ex_key
, 
ex_v
);

486 i(
	gmm
->
has_dui_key
()) {

487 
throw
 
	gExi
::
DuiKeyE
(*
mm
, *
m
);

490 
	gmm
->
is_exnded
(
ue
);

491  
	gmm
;

494 
Exessi
* 
	gEv
::
ݔ
()(
By_Exessi
* 
b
)

497 
Sg_Schema
* 
t_schema
 = 0;

498 
Sass_OP
 
	g_ty
 = 
b
->
ty
();

501 i(
	g_ty
 =
Sass_OP
::
DIV
 && 
b
->
is_dayed
()) {

502 
b
->
right
(b->right()->
rfm
(
this
));

503 
	gb
->

(
b
->()->
rfm
(
this
));

504  
	gb
;

508 i(
Sg_Schema
* 
	gs_l
 = 
dymic_
<Sg_Schema*>(
b
->

())) {

509 i(!
s_l
->
has_ުt
(&& (!s_l->
is_right_ުt
())) {

510 
t_schema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Schema
, 
s_l
->
pe
());

511 
By_Exessi
* 
	gb_ex
 = 
SASS_MEMORY_NEW
(
x
.
mem
, By_Exessi, 
b
->
pe
(),

512 
b
->

(), 
s_l
->
ϡ
(), b->
right
());

513 
	gb_ex
->
is_dayed
(
b
->

()->is_dayed(|| b->
right
()->is_delayed());

515 
size_t
 
	gi
 = 0; i < 
	gs_l
->
ngth
() - 1; ++i) {

516 *
	gt_schema
 << 
	gs_l
->

(
i
)->
rfm
(
this
);

518 *
	gt_schema
 << 
	gb_ex
->
rfm
(
this
);

519  
	gt_schema
->
rfm
(
this
);

522 i(
Sg_Schema
* 
	gs_r
 = 
dymic_
<Sg_Schema*>(
b
->
right
())) {

523 i(!
s_r
->
has_ުt
(&& (!s_r->
is__ުt
(|| 
_ty
 =
Sass_OP
::
DIV
)) {

524 
t_schema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Schema
, 
s_r
->
pe
());

525 
By_Exessi
* 
	gb_ex
 = 
SASS_MEMORY_NEW
(
x
.
mem
, By_Exessi, 
b
->
pe
(),

526 
b
->

(), b->

(), 
s_r
->
f
());

527 
	gb_ex
->
is_dayed
(
b
->

()->is_dayed(|| b->
right
()->is_delayed());

529 *
	gt_schema
 << 
	gb_ex
->
rfm
(
this
);

530 
size_t
 
	gi
 = 1; i < 
	gs_r
->
ngth
(); ++i) {

531 *
	gt_schema
 << 
	gs_r
->

(
i
)->
rfm
(
this
);

533  
	gt_schema
->
rfm
(
this
);

539 i(
	g_ty
 =
Sass_OP
::
DIV
 && 
b
->
is_dayed
()) {

540 
b
->
right
(b->right()->
rfm
(
this
));

541 
	gb
->

(
b
->()->
rfm
(
this
));

542  
	gb
;

546 
Exessi
* 
	glhs
 = 
b
->

();

547 
Exessi
* 
	grhs
 = 
b
->
right
();

552 i(
Sg_Schema
* 
	gschema
 = 
dymic_
<Sg_Schema*>(
lhs
)) {

553 i(
schema
->
is_right_ުt
()) {

554 
b
->
is_dayed
(
ue
);

558 i(
Sg_Schema
* 
	gschema
 = 
dymic_
<Sg_Schema*>(
rhs
)) {

559 i(
schema
->
is__ުt
()) {

560 
b
->
is_dayed
(
ue
);

566 i(
	g_ty
 =
Sass_OP
::
EQ
 ||

567 
_ty
 =
Sass_OP
::
NEQ
 ||

568 
_ty
 =
Sass_OP
::
GT
 ||

569 
_ty
 =
Sass_OP
::
GTE
 ||

570 
_ty
 =
Sass_OP
::
LT
 ||

571 
_ty
 =
Sass_OP
::
LTE
)

574 i(
Sg_Schema
* 
schema
 = 
dymic_
<Sg_Schema*>(
lhs
)) {

575 i(
schema
->
has_ުts
()) {

576 
b
->
is_dayed
(
ue
);

579 i(
Sg_Schema
* 
	gschema
 = 
dymic_
<Sg_Schema*>(
rhs
)) {

580 i(
schema
->
has_ުts
()) {

581 
b
->
is_dayed
(
ue
);

584 
	glhs
->
is_exnded
(
l
);

585 
	glhs
->
t_dayed
(
l
);

586 
	glhs
 = 
lhs
->
rfm
(
this
);

587 
	glhs
->
is_exnded
(
l
);

588 
	glhs
->
t_dayed
(
l
);

589 
	glhs
 = 
lhs
->
rfm
(
this
);

590 
	grhs
->
is_exnded
(
l
);

591 
	grhs
->
t_dayed
(
l
);

592 
	grhs
 = 
rhs
->
rfm
(
this
);

593 
	grhs
->
is_exnded
(
l
);

594 
	grhs
->
t_dayed
(
l
);

595 
	grhs
 = 
rhs
->
rfm
(
this
);

604 
	glhs
 = 
lhs
->
rfm
(
this
);

605 
	glhs
->
is_dayed
(
l
);

606 
tyid
(*
lhs
=tyid(
By_Exessi
)) {

607 
By_Exessi
* 
lhs_ex
 = 
ic_
<By_Exessi*>(
lhs
);

608 i(
	glhs_ex
->
ty
(=
Sass_OP
::
DIV
 && 
lhs_ex
->
is_dayed
()) ;

609 
	glhs
 = 
Ev
::
ݔ
()(
lhs_ex
);

612 
	g_ty
) {

613 
	gSass_OP
::
AND
:

614  *
lhs
 ? 
b
->
right
()->
rfm
(
this
) :hs;

617 
	gSass_OP
::
OR
:

618  *
lhs
 ?h: 
b
->
right
()->
rfm
(
this
);

625 
	grhs
 = 
rhs
->
rfm
(
this
);

628 i(
	g_ty
 =
Sass_OP
::
DIV
 || 
_ty
 =Sass_OP::
MUL
) {

629 i(
Sg_Cڡt
* 
r
 = 
dymic_
<Sg_Cڡt*>(
rhs
)) {

630 
d
::
rg
 
vue
(
r
->value());

631 cڡ * 
	gt
 = 
vue
.
c_r
();

632 i(
	gPx
::
qu
 < 
Px
::
numb
 >(
t
) != 0) {

633 
rhs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
,hs->
pe
(), Textu::
DIMENSION
, 
r
->
vue
());

634 
	grhs
->
is_dayed
(
l
);h
rhs
->
rfm
(
this
);

640 
	gExessi
::
Ce_Ty
 
l_ty
 = 
lhs
->
ce_ty
();

641 
	gExessi
::
Ce_Ty
 
r_ty
 = 
rhs
->
ce_ty
();

644 
Sg_Schema
* 
	gs1
 = 
dymic_
<Sg_Schema*>(
b
->

());

645 
Sg_Schema
* 
	gs2
 = 
dymic_
<Sg_Schema*>(
b
->
right
());

646 
By_Exessi
* 
	gb1
 = 
dymic_
<By_Exessi*>(
b
->

());

647 
By_Exessi
* 
	gb2
 = 
dymic_
<By_Exessi*>(
b
->
right
());

649 
bo
 
	gschema_
 = 
l
;

651 
bo
 
	gf_day
 = (
s2
 && s2->
is__ުt
()) ||

652 (
s1
 && s1->
is_right_ުt
()) ||

653 (
b1
 && b1->
is_right_ުt
()) ||

654 (
b2
 && b2->
is__ުt
());

656 i((
	gs1
 && s1->
has_ުts
()|| (
	gs2
 && s2->has_ުts()|| 
	gf_day
)

659 i(
	g_ty
 =
Sass_OP
::
DIV
 || 
_ty
 =Sass_OP::
MUL
 || op_ty =Sass_OP::
MOD
 || op_ty =Sass_OP::
ADD
 || op_ty =Sass_OP::
SUB
 ||

660 
_ty
 =
Sass_OP
::
EQ
) {

661 i(
Sg_Cڡt
* 
r
 = 
dymic_
<Sg_Cڡt*>(
lhs
)) {

662 
d
::
rg
 
vue
(
r
->value());

663 cڡ * 
	gt
 = 
vue
.
c_r
();

664 i(
	gPx
::
qu
 < 
Px
::
dimsi
, Px::
d_of_fe
 >(
t
) != 0) {

665 
lhs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
,hs->
pe
(), Textu::
DIMENSION
, 
r
->
vue
());

666 
	glhs
->
is_dayed
(
l
);h
lhs
->
rfm
(
this
);

669 i(
Sg_Cڡt
* 
	gr
 = 
dymic_
<Sg_Cڡt*>(
rhs
)) {

670 
d
::
rg
 
vue
(
r
->value());

671 cڡ * 
	gt
 = 
vue
.
c_r
();

672 i(
	gPx
::
qu
 < 
Px
::
numb
 >(
t
) != 0) {

673 
rhs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
,hs->
pe
(), Textu::
DIMENSION
, 
r
->
vue
());

674 
	grhs
->
is_dayed
(
l
);h
rhs
->
rfm
(
this
);

679 
To_Vue
 
to_vue
(
x
, ctx.
mem
);

680 
Vue
* 
	gv_l
 = 
dymic_
<Vue*>(
lhs
->
rfm
(&
to_vue
));

681 
Vue
* 
	gv_r
 = 
dymic_
<Vue*>(
rhs
->
rfm
(&
to_vue
));

682 
	gl_ty
 = 
lhs
->
ce_ty
();

683 
	gr_ty
 = 
rhs
->
ce_ty
();

685 i(
	gs2
 && s2->
has_ުts
(&& s2->
ngth
()) {

686 
Textu
* 
	gt
 = 
dymic_
<Textu*>(
s2
->
emts
().
t
());

687 i(
	gt
 && !t->
is_ުt
())

690 
	gschema_
 = 
ue
;

691 
	grhs
 = 
t
->
rfm
(
this
);

695 i(
	gf_day
) {

696 
	gd
::
rg
 
r
("");

697 
	gr
 +
v_l
->
to_rg
(
x
.
c_tis
);

698 i(
	gb
->

().
	gws_befe

	gr
 += " ";

699 
	gr
 +
b
->
t
();

700 i(
	gb
->

().
	gws_a

	gr
 += " ";

701 
	gr
 +
v_r
->
to_rg
(
x
.
c_tis
);

702 
Sg_Cڡt
* 
	gv
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Cڡt, 
lhs
->
pe
(), 
r
);

703 
	gv
->
is_ުt
(
b
->

()->
has_ުt
());

704  
	gv
;

709 
	gy
 {

710 
	g_ty
) {

711 
	gSass_OP
::
EQ
:  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
b
->
pe
(), 
eq
(
lhs
, 
rhs
));

712 
	gSass_OP
::
NEQ
:  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
b
->
pe
(), !
eq
(
lhs
, 
rhs
));

713 
	gSass_OP
::
GT
:  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
b
->
pe
(), !

(
lhs
, 
rhs
, "gt"&& !
eq
(lhs,hs));

714 
	gSass_OP
::
GTE
:  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
b
->
pe
(), !

(
lhs
, 
rhs
, "gte"));

715 
	gSass_OP
::
LT
:  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
b
->
pe
(), 

(
lhs
, 
rhs
, "lt"));

716 
	gSass_OP
::
LTE
:  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
b
->
pe
(), 

(
lhs
, 
rhs
, "e"|| 
eq
(lhs,hs));

720 
tch
 (
Exi
::
OtiE
& 
r
)

723 
throw
 
Exi
::
SassVueE
(
b
->
pe
(), 
r
);

726 
	gl_ty
 = 
lhs
->
ce_ty
();

727 
	gr_ty
 = 
rhs
->
ce_ty
();

731 
Exessi
* 
	grv
 = 0;

732 
	gy
 {

733 
PrS
 
pe
(
b
->pstate());

734 i(
	gl_ty
 =
Exessi
::
NUMBER
 && 
r_ty
 == Expression::NUMBER) {

735 cڡ 
Numb
* 
l_n
 = 
dymic_
<cڡ Numb*>(
lhs
);

736 cڡ 
Numb
* 
	gr_n
 = 
dymic_
<cڡ Numb*>(
rhs
);

737 
	grv
 = 
_numbs
(
x
.
mem
, 
_ty
, *
l_n
, *
r_n
, ctx.
c_tis
, &
pe
);

739 i(
	gl_ty
 =
Exessi
::
NUMBER
 && 
r_ty
 =Exessi::
COLOR
) {

740 cڡ 
Numb
* 
l_n
 = 
dymic_
<cڡ Numb*>(
lhs
);

741 cڡ 
C
* 
	gr_c
 = 
dymic_
<cڡ C*>(
rhs
);

742 
	grv
 = 
_numb_c
(
x
.
mem
, 
_ty
, *
l_n
, *
r_c
, ctx.
c_tis
, &
pe
);

744 i(
	gl_ty
 =
Exessi
::
COLOR
 && 
r_ty
 =Exessi::
NUMBER
) {

745 cڡ 
C
* 
l_c
 = 
dymic_
<cڡ C*>(
lhs
);

746 cڡ 
Numb
* 
	gr_n
 = 
dymic_
<cڡ Numb*>(
rhs
);

747 
	grv
 = 
_c_numb
(
x
.
mem
, 
_ty
, *
l_c
, *
r_n
, ctx.
c_tis
, &
pe
);

749 i(
	gl_ty
 =
Exessi
::
COLOR
 && 
r_ty
 == Expression::COLOR) {

750 cڡ 
C
* 
l_c
 = 
dymic_
<cڡ C*>(
lhs
);

751 cڡ 
C
* 
	gr_c
 = 
dymic_
<cڡ C*>(
rhs
);

752 
	grv
 = 
_cs
(
x
.
mem
, 
_ty
, *
l_c
, *
r_c
, ctx.
c_tis
, &
pe
);

755 
To_Vue
 
to_vue
(
x
, ctx.
mem
);

756 
Vue
* 
	gv_l
 = 
dymic_
<Vue*>(
lhs
->
rfm
(&
to_vue
));

757 
Vue
* 
	gv_r
 = 
dymic_
<Vue*>(
rhs
->
rfm
(&
to_vue
));

758 
bo
 
	gުt
 = 
b
->
is_right_ުt
() ||

759 
b
->
is__ުt
() ||

760 
b
->
is_ުt
();

761 i(
	g_ty
 =
Sass_OP
::
SUB

ުt
 = 
l
;

763 
Vue
* 
	gex
 = 
_rgs
(
x
.
mem
, 
b
->

(), *
v_l
, *
v_r
, ctx.
c_tis
, &
pe
, !
ުt
);

764 i(
Sg_Cڡt
* 
	gr
 = 
dymic_
<Sg_Cڡt*>(
ex
))

766 i(
r
->
ce_ty
(=
Exessi
::
STRING
)

768 
Sg_Cڡt
* 
lr
 = 
dymic_
<Sg_Cڡt*>(
lhs
);

769 
Sg_Cڡt
* 
	grr
 = 
dymic_
<Sg_Cڡt*>(
rhs
);

770 i(
	g_ty
 !
Sass_OP
::
SUB
) {

771 i(
Sg_Cڡt
* 
g
 = 
lr
 ?: 
rr
)

772 { 
r
->
que_mk
(
g
->quote_mark()); }

776 
	gex
->
is_ުt
(
b
->is_interpolant());

777 
	grv
 = 
ex
;

780 
tch
 (
Exi
::
OtiE
& 
r
)

783 
throw
 
Exi
::
SassVueE
(
b
->
pe
(), 
r
);

786 i(
	grv
) {

787 i(
	gschema_
) {

789 (*
	gs2
)[0] = 
rv
;

790 
	grv
 = 
s2
->
rfm
(
this
);

793  
	grv
;

797 
Exessi
* 
	gEv
::
ݔ
()(
Ury_Exessi
* 
u
)

799 
Exessi
* 
ݔd
 = 
u
->ݔd()->
rfm
(
this
);

800 i(
	gu
->
ty
(=
Ury_Exessi
::
NOT
) {

801 
Boޗn
* 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Boޗn, 
u
->
pe
(), (
bo
)*
ݔd
);

802 
	gsu
->
vue
(!
su
->value());

803  
	gsu
;

805 i(
	gݔd
->
ce_ty
(=
Exessi
::
NUMBER
) {

806 
Numb
* 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Numb, *
ic_
<Numb*>(
ݔd
));

807 
	gsu
->
vue
(
u
->
ty
(=
Ury_Exessi
::
MINUS


808 ? -
su
->
vue
()

809 : 
su
->
vue
());

810  
	gsu
;

815 i(
	gݔd
->
ce_ty
(=
Exessi
::
NULL_VAL
 && 
dymic_
<
Vb
*>(
u
->
ݔd
())) {

816 
u
->
ݔd
(
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, u->
pe
(), ""));

818 
	gu
->
ݔd
(operand);

819 
Sg_Cڡt
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
,

820 
u
->
pe
(),

821 
u
->
e
());

822  
	gsu
;

825  
	gu
;

828 
Exessi
* 
	gEv
::
ݔ
()(
Funi_Cl
* 
c
)

830 i(
backa
()->

 !
NULL
 && backa()->
dth
(> 
Cڡts
::
MaxClSck
) {

832 
d
::
orgam
 
m
;

833 
	gm
 << "Sck dthxeded max o" << 
	gCڡts
::
MaxClSck
;

834 
r
(
m
.
r
(), 
c
->
pe
(), 
backa
());

836 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
c
->name()));

837 
	gd
::
rg
 
fu_me
(
me
 + "[f]");

838 
Argumts
* 
	ggs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumts, *
c
->
gumts
());

842 i(
	gme
 ="" && 
gs
->
ngth
() > 0) {

843 
Exessi
* 
de
 = 
gs
->

(0)->
rfm
(
this
);

844 
	ggs
->
a
(
gs
->
beg
());

845 
Funi_Cl
* 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Function_Call,

846 
c
->
pe
(),

847 
unque
(
de
->
to_rg
()),

848 
gs
);

849  
ݔ
()(
	gl
);

852 
Env
* 
	gv
 = 
vmt
();

853 i(!
	gv
->
has
(
fu_me
)) {

854 i(!
	gv
->
has
("*[f]")) {

856 
Argumt
* 
	gg
 : *
gs
) {

857 i(
By_Exessi
* 
b
 = 
dymic_
<By_Exessi*>(
g
->
vue
())) {

858 
b
->
t_whea
();

859 
	gg
->
is_dayed
(
b
->
n_day
());

862 
	ggs
 = 
ic_
<
Argumts
*>(
gs
->
rfm
(
this
));

863 
Funi_Cl
* 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Function_Call,

864 
c
->
pe
(),

865 
c
->
me
(),

866 
gs
);

867 i(
	ggs
->
has_med_gumts
()) {

868 
r
("Funi " + 
c
->
me
(+ " dۢ'su܈keywdrgumts", c->
pe
());

870 
Sg_Qued
* 
	gr
 = 
SASS_MEMORY_NEW
(
x
.
mem
, String_Quoted,

871 
c
->
pe
(),

872 
l
->
to_rg
(
x
.
c_tis
));

873 
	gr
->
is_ުt
(
c
->is_interpolant());

874  
	gr
;

877 
	gfu_me
 = "*[f]";

881 i(
	gfu_me
 != "if[f]") {

882 
gs
 = 
ic_
<
Argumts
*>rgs->
rfm
(
this
));

885 
Defi
* 
	gdef
 = 
ic_
<Defi*>((*
v
)[
fu_me
]);

887 i(
	gdef
->
is_ovld_ub
()) {

888 
	gd
::
rgam
 
ss
;

889 
	gss
 << 
	gfu_me


890 << 
	ggs
->
ngth
();

891 
	gfu_me
 = 
ss
.
r
();

892 
	gd
::
rg
 
sved_me
(
fu_me
);

893 i(!
	gv
->
has
(
sved_me
)
r
("ovlded funi `" + 
d
::
rg
(
c
->
me
()+ "` giv wrgumb ogumts", c->
pe
());

894 
	gdef
 = 
ic_
<
Defi
*>((*
v
)[
sved_me
]);

897 
Exessi
* 
	gsu
 = 
c
;

898 
Block
* 
	gbody
 = 
def
->
block
();

899 
Nive_Funi
 
	gfunc
 = 
def
->
tive_funi
();

900 
Sass_Funi_Ery
 
	gc_funi
 = 
def
->
c_funi
();

902 
Pams
* 
	gms
 = 
def
->
ms
();

903 
Env
 
_v
(
def
->
vmt
());

904 
	gexp
.
	gv_ack
.
push_back
(&
_v
);

906 i(
	gfunc
 || 
	gbody
) {

907 
bd
(
d
::
rg
("Funi"), 
c
->
me
(), 
ms
, 
gs
, &
x
, &
_v
, 
this
);

908 
Backa
 
he
(
backa
(), 
c
->
pe
(), ", ifuni `" + c->
me
() + "`");

909 
	gexp
.
	gbacka_ack
.
push_back
(&
he
);

911 i(
	gbody
 && !
	gPx
::
_ecl_fun
(
c
->
me
().
c_r
()){ 
su
 = 
body
->
rfm
(
this
); }

912 i(
	gfunc
{ 
	gsu
 = 
func
(
_v
, *
v
, 
x
, 
def
->
sigtu
(), 
c
->
pe
(), 
backa
()); }

913 i(!
	gsu

r
(
d
::
rg
("Funi "+ 
c
->
me
(+ " didلu vue", c->
pe
());

914 
	gexp
.
	gbacka_ack
.
p_back
();

919 i(
	gc_funi
) {

920 
Sass_Funi_Fn
 
	gc_func
 = 
ss_funi_g_funi
(
c_funi
);

921 i(
	gfu_me
 == "*[f]") {

922 
Sg_Qued
 *
r
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, 
c
->
pe
(), c->
me
());

923 
Argumts
* 
	gw_gs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumts, 
c
->
pe
());

924 *
	gw_gs
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
c
->
pe
(), 
r
);

925 *
	gw_gs
 +
gs
;

926 
	ggs
 = 
w_gs
;

930 
	gd
::
rg
 
ff
(
c
->
me
());

931 
bd
(
d
::
rg
("Funi"), 
c
->
me
(), 
ms
, 
gs
, &
x
, &
_v
, 
this
);

933 
Backa
 
he
(
backa
(), 
c
->
pe
(), ", ifuni `" + c->
me
() + "`");

934 
	gexp
.
	gbacka_ack
.
push_back
(&
he
);

936 
To_C
 
	gto_c
;

937 
Sass_Vue
* 
	gc_gs
 = 
ss_make_li
(
ms
[0].
ngth
(), 
SASS_COMMA
);

938 
size_t
 
	gi
 = 0; i < 
	gms
[0].
ngth
(); i++) {

939 
	gd
::
rg
 
key
 = 
ms
[0][
i
]->
me
();

940 
AST_Node
* 
	gnode
 = 
_v
.
g_lol
(
key
);

941 
Exessi
* 
	gg
 = 
ic_
<Exessi*>(
node
);

942 
ss_li_t_vue
(
c_gs
, 
i
, 
g
->
rfm
(&
to_c
));

944 
Sass_Vue
* 
	gc_v
 = 
c_func
(
c_gs
, 
c_funi
, 
x
.
c_comp
);

945 i(
ss_vue_g_g
(
c_v
=
SASS_ERROR
) {

946 
r
("r iC funi " + 
c
->
me
(+ ": " + 
ss_r_g_mesge
(
c_v
), c->
pe
(), 
backa
());

947 } i(
ss_vue_g_g
(
c_v
=
SASS_WARNING
) {

948 
r
("wng iC funi " + 
c
->
me
(+ ": " + 
ss_wng_g_mesge
(
c_v
), c->
pe
(), 
backa
());

950 
	gsu
 = 
cv_to_anode
(
x
.
mem
, 
c_v
, ctx, 
backa
(), 
c
->
pe
());

952 
	gexp
.
	gbacka_ack
.
p_back
();

953 
ss_de_vue
(
c_gs
);

954 i(
	gc_v
 !
c_gs
)

955 
ss_de_vue
(
c_v
);

960 i(
	gsu
->
pe
().
	gfe
 =
d
::
rg
::
os
)

961 
su
->
pe
(
c
->pstate());

963 
	gsu
->
is_dayed
(
su
->
ce_ty
(=
Exessi
::
STRING
);

964 i(!
	gsu
->
is_dayed
()su = 
su
->
rfm
(
this
);

965 
	gsu
->
is_ުt
(
c
->is_interpolant());

966 
	gexp
.
	gv_ack
.
p_back
();

967  
	gsu
;

970 
Exessi
* 
	gEv
::
ݔ
()(
Funi_Cl_Schema
* 
s
)

972 
Exessi
* 
evued_me
 = 
s
->
me
()->
rfm
(
this
);

973 
Exessi
* 
	gevued_gs
 = 
s
->
gumts
()->
rfm
(
this
);

974 
Sg_Schema
* 
	gss
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
s
->
pe
(), 2);

975 (*
	gss
<< 
	gevued_me
 << 
	gevued_gs
;

976  
	gss
->
rfm
(
this
);

979 
Exessi
* 
	gEv
::
ݔ
()(
Vb
* 
v
)

981 
d
::
rg
 
me
(
v
->name());

982 
Exessi
* 
	gvue
 = 0;

983 
Env
* 
	gv
 = 
vmt
();

984 i(
	gv
->
has
(
me
)
	gvue
 = 
ic_
<
Exessi
*>((*
v
)[name]);

985 
r
("Undefed vb: \"" + 
v
->
me
(+ "\".", v->
pe
());

986 i(
tyid
(*
vue
=tyid(
Argumt
)vu
ic_
<Argument*>(value)->value();

989 i(
	gvue
->
ce_ty
(=
Exessi
::
NUMBER
) {

990 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, *
ic_
<Number*>(value));

991 
	gic_
<
	gNumb
*>(
	gvue
)->
zo
(
ue
);

993 i(
	gvue
->
ce_ty
(=
Exessi
::
STRING
) {

994 iut
r
 = 
dymic_
<
Sg_Qued
*>(
vue
)) {

995 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, *
r
);

996 } iut
	gr
 = 
dymic_
<
Sg_Cڡt
*>(
vue
)) {

997 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
r
->
pe
(), str->value());

1000 i(
	gvue
->
ce_ty
(=
Exessi
::
LIST
) {

1001 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, *
ic_
<List*>(value));

1003 i(
	gvue
->
ce_ty
(=
Exessi
::
MAP
) {

1004 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
M
, *
ic_
<Map*>(value));

1006 i(
	gvue
->
ce_ty
(=
Exessi
::
BOOLEAN
) {

1007 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, *
ic_
<Boolean*>(value));

1009 i(
	gvue
->
ce_ty
(=
Exessi
::
COLOR
) {

1010 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
C
, *
ic_
<Color*>(value));

1012 i(
	gvue
->
ce_ty
(=
Exessi
::
NULL_VAL
) {

1013 
vue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, vue->
pe
());

1015 i(
	gvue
->
ce_ty
(=
Exessi
::
SELECTOR
) {

1016 
vue
 = vue->
rfm
(
this
);

1019 
	gvue
->
is_ުt
(
v
->is_interpolant());

1020 
	gvue
->
is_exnded
(
l
);

1021  
	gvue
->
rfm
(
this
);

1024 
Exessi
* 
	gEv
::
ݔ
()(
Textu
* 
t
)

1026 
usg
 
Px
::
numb
;

1027 
Exessi
* 
	gsu
 = 0;

1028 
size_t
 
	gL
 = 
t
->
vue
().
ngth
();

1029 
bo
 
	gzo
 = !(
L
 > 0 && 
t
->
vue
().
subr
(0, 1) == ".") ||

1030 (
L
 > 1 && 
t
->
vue
().
subr
(0, 2) == "0.") ||

1031 (
L
 > 1 && 
t
->
vue
().
subr
(0, 2) == "-.") ||

1032 (
L
 > 2 && 
t
->
vue
().
subr
(0, 3) == "-0.")

1035 cڡ 
	gd
::
rg
& 
xt
 = 
t
->
vue
();

1036 
size_t
 
	gnum_pos
 = 
xt
.
fd_f_n_of
(" \n\r\t");

1037 i(
	gnum_pos
 =
d
::
rg
::
os

num_pos
 = 
xt
.
ngth
();

1038 
size_t
 
	gun_pos
 = 
xt
.
fd_f_n_of
("-+0123456789.", 
num_pos
);

1039 i(
	gun_pos
 =
d
::
rg
::
os

un_pos
 = 
xt
.
ngth
();

1040 cڡ 
	gd
::
rg
& 
num
 = 
xt
.
subr
(
num_pos
, 
un_pos
 -um_pos);

1042 
	gt
->
ty
())

1044 
	gTextu
::
NUMBER
:

1045 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
,

1046 
t
->
pe
(),

1047 
ss_of
(
num
.
c_r
()),

1049 
zo
);

1051 
	gTextu
::
PERCENTAGE
:

1052 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
,

1053 
t
->
pe
(),

1054 
ss_of
(
num
.
c_r
()),

1056 
ue
);

1058 
	gTextu
::
DIMENSION
:

1059 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
,

1060 
t
->
pe
(),

1061 
ss_of
(
num
.
c_r
()),

1062 
Tok
(
numb
(
xt
.
c_r
())),

1063 
zo
);

1065 
	gTextu
::
HEX
: {

1066 i(
t
->
vue
().
subr
(0, 1) != "#") {

1067 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
t
->
pe
(),->
vue
());

1070 
	gd
::
rg
 
hext
(
t
->
vue
().
subr
(1));

1071 i(
	ghext
.
ngth
() == 6) {

1072 
d
::
rg
 
r
(
hext
.
subr
(0,2));

1073 
	gd
::
rg
 
g
(
hext
.
subr
(2,2));

1074 
	gd
::
rg
 
b
(
hext
.
subr
(4,2));

1075 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

1076 
t
->
pe
(),

1077 
ic_
<>(

(
r
.
c_r
(), 
NULL
, 16)),

1078 
ic_
<>(

(
g
.
c_r
(), 
NULL
, 16)),

1079 
ic_
<>(

(
b
.
c_r
(), 
NULL
, 16)),

1081 
t
->
vue
());

1084 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

1085 
t
->
pe
(),

1086 
ic_
<>(

(
d
::
rg
(2,
hext
[0]).
c_r
(), 
NULL
, 16)),

1087 
ic_
<>(

(
d
::
rg
(2,
hext
[1]).
c_r
(), 
NULL
, 16)),

1088 
ic_
<>(

(
d
::
rg
(2,
hext
[2]).
c_r
(), 
NULL
, 16)),

1090 
t
->
vue
());

1094 
	gsu
->
is_ުt
(
t
->is_interpolant());

1095  
	gsu
;

1098 
Exessi
* 
	gEv
::
ݔ
()(
Numb
* 
n
)

1100  
n
;

1103 
Exessi
* 
	gEv
::
ݔ
()(
Boޗn
* 
b
)

1105  
b
;

1108 
	gEv
::
ީi
(
Cڋxt
& 
x
, 
d
::
rg
& 
s
, 
Exessi
* 
ex
, 
bo
 
to_ques
, bo 
was_
) {

1110 
bo
 
	geds_osg_b
 = 
l
;

1112 i(
Argumts
* 
	ggs
 = 
dymic_
<Argumts*>(
ex
)) {

1113 
Li
* 

 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
gs
->
pe
(), 0, 
SASS_COMMA
);

1114 aut
	gg
 : *
gs
) {

1115 *

 << 
g
->
vue
();

1117 
	g
->
is_ުt
(
gs
->is_interpolant());

1118 
	geds_osg_b
 = 
ue
;

1119 
	gs
 += "(";

1120 
	gex
 = 

;

1122 i(
Numb
* 
	g
 = 
dymic_
<Numb*>(
ex
)) {

1123 i(!

->
is_vid_css_un
()) {

1124 
throw
 
Exi
::
InvidVue
(*

);

1127 i(
Argumt
* 
	gg
 = 
dymic_
<Argumt*>(
ex
)) {

1128 
ex
 = 
g
->
vue
();

1130 i(
Sg_Qued
* 
	gsq
 = 
dymic_
<Sg_Qued*>(
ex
)) {

1131 i(
was_
) {

1132 
bo
 
was_ުt
 = 
ex
->
is_ުt
();

1133 
	gex
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
sq
->
pe
(), sq->
vue
());

1134 
	gex
->
is_ުt
(
was_ުt
);

1138 i(
	gdymic_
<
	gNu
*>(
	gex
)) { ; }

1141 i(
	gdymic_
<
	gPt_Se
*>(
	gex
)) {

1143 
	gex
 = 
ex
->
rfm
(
this
);

1146 i(
Li
* 
	gl
 = 
dymic_
<Li*>(
ex
)) {

1147 
Li
* 

 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
l
->
pe
(), 0,->
t
());

1150 aut
	gem
 : *
l
) {

1151 
em
->
is_ުt
(
l
->is_interpolant());

1152 
	gd
::
rg
 

(""); 
ީi
(
x
,l, 
em
, 
to_ques
, 
l
->
is_ުt
());

1153 
bo
 
	gis_nu
 = 
dymic_
<
Nu
*>(
em
) != 0;

1154 i(!
	gis_nu
*
	g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
em
->
pe
(), 

);

1156 
	gs
 +(

->
to_rg
(
x
.
c_tis
));

1157 
	g
->
is_ުt
(
l
->is_interpolant());

1170 i(
	gto_ques
 && 
	gex
->
is_ުt
()) {

1171 
	gs
 +
evacue_ess
(
ex
 ?x->
to_rg
(
x
.
c_tis
) : "");

1173 
	gs
 +
ex
 ?x->
to_rg
(
x
.
c_tis
) : "";

1177 i(
	geds_osg_b

	gs
 += ")";

1181 
Exessi
* 
	gEv
::
ݔ
()(
Sg_Schema
* 
s
)

1183 
size_t
 
L
 = 
s
->
ngth
();

1184 
bo
 
	gto_ques
 = 
l
;

1185 i(
	gL
 > 1) {

1186 i(!
	gdymic_
<
	gSg_Qued
*>((*
	gs
)[0]&& !dymic_<Sg_Qued*>((*s)[
L
 - 1])) {

1187 i(
Sg_Cڡt
* 
	gl
 = 
dymic_
<Sg_Cڡt*>((*
s
)[0])) {

1188 i(
Sg_Cڡt
* 
r
 = 
dymic_
<Sg_Cڡt*>((*
s
)[
L
 - 1])) {

1189 i(
r
->
vue
().
size
() > 0) {

1190 i(
l
->
vue
()[0] ='"' && 
r
->vue()[r->vue().
size
(- 1] ='"'
to_ques
 = 
ue
;

1191 i(
	gl
->
vue
()[0] ='\'' && 
r
->vue()[r->vue().
size
(- 1] ='\''
to_ques
 = 
ue
;

1197 
bo
 
	gwas_qued
 = 
l
;

1198 
bo
 
	gwas_ުt
 = 
l
;

1199 
	gd
::
rg
 
s
("");

1200 
size_t
 
	gi
 = 0; i < 
	gL
; ++i) {

1201 
bo
 
	gis_qued
 = 
dymic_
<
Sg_Qued
*>((*
s
)[
i
]!
NULL
;

1202 i(
	gwas_qued
 && !(*
	gs
)[
i
]->
is_ުt
(&& !
	gwas_ުt
{ 
	gs
 += " "; }

1203 i(
	gi
 > 0 && 
	gis_qued
 && !(*
	gs
)[
i
]->
is_ުt
(&& !
	gwas_ުt
{ 
	gs
 += " "; }

1204 
Exessi
* 
	gex
 = (*
s
)[
i
]->
is_dayed
(? (*s)[i] : (*s)[i]->
rfm
(
this
);

1205 
ީi
(
x
, 
s
, 
ex
, 
to_ques
,x->
is_ުt
());

1206 
	gwas_qued
 = 
dymic_
<
Sg_Qued
*>((*
s
)[
i
]!
NULL
;

1207 
	gwas_ުt
 = (*
s
)[
i
]->
is_ުt
();

1210 i(!
	gs
->
is_ުt
()) {

1211 i(
	gs
->
ngth
(> 1 && 
	gs
 ="" 
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
s
->
pe
());

1212  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
s
->
pe
(), 
s
);

1214 
Sg_Qued
* 
	gr
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, 
s
->
pe
(), 
s
);

1217 i(
	gr
->
que_mk
()) str->quote_mark('*');

1218 i(!
	gis__commt

	gr
->
vue
(
rg_to_ouut
(
r
->value()));

1219 
	gr
->
is_ުt
(
s
->is_interpolant());

1220  
	gr
;

1224 
Exessi
* 
	gEv
::
ݔ
()(
Sg_Cڡt
* 
s
)

1226 i(!
s
->
is_dayed
(&& 
me_to_c
(s->
vue
())) {

1227 
C
* 
c
 = 
SASS_MEMORY_NEW
(
x
.
mem
, C, *
me_to_c
(
s
->
vue
()));

1228 
	gc
->
pe
(
s
->pstate());

1229 
	gc
->
di
(
s
->
vue
());

1230  
	gc
;

1232  
	gs
;

1235 
Exessi
* 
	gEv
::
ݔ
()(
Sg_Qued
* 
s
)

1237 
Sg_Qued
* 
r
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, 
s
->
pe
(), "");

1238 
	gr
->
vue
(
s
->value());

1239 
	gr
->
que_mk
(
s
->quote_mark());

1240 
	gr
->
is_ުt
(
s
->is_interpolant());

1241  
	gr
;

1244 
Exessi
* 
	gEv
::
ݔ
()(
Suts_Ot
* 
c
)

1246 
Exessi
* 

 = 
c
->()->
rfm
(
this
);

1247 
Exessi
* 
	gright
 = 
c
->
right
()->
rfm
(
this
);

1248 
Suts_Ot
* 
	gcc
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Supports_Operator,

1249 
c
->
pe
(),

1250 
ic_
<
Suts_Cdi
*>(

),

1251 
ic_
<
Suts_Cdi
*>(
right
),

1252 
c
->
ݔd
());

1253  
	gcc
;

1256 
Exessi
* 
	gEv
::
ݔ
()(
Suts_Negi
* 
c
)

1258 
Exessi
* 
cdi
 = 
c
->cdi()->
rfm
(
this
);

1259 
Suts_Negi
* 
	gcc
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Supports_Negation,

1260 
c
->
pe
(),

1261 
ic_
<
Suts_Cdi
*>(
cdi
));

1262  
	gcc
;

1265 
Exessi
* 
	gEv
::
ݔ
()(
Suts_Dei
* 
c
)

1267 
Exessi
* 
u
 = 
c
->u()->
rfm
(
this
);

1268 
Exessi
* 
	gvue
 = 
c
->
vue
()->
rfm
(
this
);

1269 
Suts_Dei
* 
	gcc
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Supports_Declaration,

1270 
c
->
pe
(),

1271 
u
,

1272 
vue
);

1273  
	gcc
;

1276 
Exessi
* 
	gEv
::
ݔ
()(
Suts_Ipީi
* 
c
)

1278 
Exessi
* 
vue
 = 
c
->vue()->
rfm
(
this
);

1279 
Suts_Ipީi
* 
	gcc
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Supports_Interpolation,

1280 
c
->
pe
(),

1281 
vue
);

1282  
	gcc
;

1285 
Exessi
* 
	gEv
::
ݔ
()(
At_Ro_Quy
* 
e
)

1287 
Exessi
* 
u
 = 
e
->feature();

1288 
	gu
 = (
u
 ? ftu->
rfm
(
this
) : 0);

1289 
Exessi
* 
	gvue
 = 
e
->
vue
();

1290 
	gvue
 = (
vue
 ? vue->
rfm
(
this
) : 0);

1291 
Exessi
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
At_Ro_Quy
,

1292 
e
->
pe
(),

1293 
ic_
<
Sg
*>(
u
),

1294 
vue
);

1295  
	g
;

1298 
Exessi
* 
	gEv
::
ݔ
()(
Med_Quy
* 
q
)

1300 
Sg
* 
t
 = 
q
->
med_ty
();

1301 
	gt
 = 
ic_
<
Sg
*>(
t
 ?->
rfm
(
this
) : 0);

1302 
Med_Quy
* 
	gqq
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Media_Query,

1303 
q
->
pe
(),

1304 
t
,

1305 
q
->
ngth
(),

1306 
q
->
is_ged
(),

1307 
q
->
is_ried
());

1308 
size_t
 
	gi
 = 0, 
	gL
 = 
q
->
ngth
(); i < L; ++i) {

1309 *
	gqq
 << 
	gic_
<
	gMed_Quy_Exessi
*>((*
	gq
)[
i
]->
rfm
(
this
));

1311  
	gqq
;

1314 
Exessi
* 
	gEv
::
ݔ
()(
Med_Quy_Exessi
* 
e
)

1316 
Exessi
* 
u
 = 
e
->feature();

1317 
	gu
 = (
u
 ? ftu->
rfm
(
this
) : 0);

1318 i(
	gu
 && 
	gdymic_
<
	gSg_Qued
*>(feature)) {

1319 
	gu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
,

1320 
u
->
pe
(),

1321 
dymic_
<
Sg_Qued
*>(
u
)->
vue
());

1323 
Exessi
* 
	gvue
 = 
e
->
vue
();

1324 
	gvue
 = (
vue
 ? vue->
rfm
(
this
) : 0);

1325 i(
	gvue
 && 
	gdymic_
<
	gSg_Qued
*>(value)) {

1327 
	gvue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
,

1328 
vue
->
pe
(),

1329 
dymic_
<
Sg_Qued
*>(
vue
)->value());

1331  
SASS_MEMORY_NEW
(
x
.
mem
, 
Med_Quy_Exessi
,

1332 
e
->
pe
(),

1333 
u
,

1334 
vue
,

1335 
e
->
is_ީed
());

1338 
Exessi
* 
	gEv
::
ݔ
()(
Nu
* 
n
)

1340  
n
;

1343 
Exessi
* 
	gEv
::
ݔ
()(
Argumt
* 
a
)

1345 
Exessi
* 
v
 = 
a
->
vue
();

1347 
	gv
->
is_dayed
(
a
->is_delayed());

1348 
	gv
 = 
v
->
rfm
(
this
);

1349 
	gv
->
is_dayed
(
l
);

1351 
bo
 
	gis__gumt
 = 
a
->
is__gumt
();

1352 
bo
 
	gis_keywd_gumt
 = 
a
->
is_keywd_gumt
();

1354 i(
	ga
->
is__gumt
()) {

1355 i(
	gv
->
ce_ty
(=
Exessi
::
MAP
) {

1356 
is__gumt
 = 
l
;

1357 
	gis_keywd_gumt
 = 
ue
;

1359 if(
	gv
->
ce_ty
(!
Exessi
::
LIST
) {

1360 
Li
* 
w
 = 
SASS_MEMORY_NEW
(
x
.
mem
, List,

1361 
v
->
pe
(),

1363 
SASS_COMMA
,

1364 
ue
);

1365 *
	gw
 << 
	gv
;

1366 
	gv
 = 
w
;

1369  
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
,

1370 
a
->
pe
(),

1371 
v
,

1372 
a
->
me
(),

1373 
is__gumt
,

1374 
is_keywd_gumt
);

1377 
Exessi
* 
	gEv
::
ݔ
()(
Argumts
* 
a
)

1379 
Argumts
* 

 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumts, 
a
->
pe
());

1380 i(
	ga
->
ngth
(=0 

;

1381 
size_t
 
	gi
 = 0, 
	gL
 = 
a
->
ngth
(); i < L; ++i) {

1382 
Argumt
* 
	gg
 = 
ic_
<Argumt*>((*
a
)[
i
]->
rfm
(
this
));

1383 i(!(
	gg
->
is__gumt
(||rg->
is_keywd_gumt
())) {

1384 *
	g
 << 
	gg
;

1388 i(
	ga
->
has__gumt
()) {

1389 
Exessi
* 
	gt
 = 
ic_
<
Argumt
*>(

1390 
a
->
g__gumt
()->
rfm
(
this
)

1391 )->
vue
()->
rfm
(
this
);

1393 
Sass_S
 
	gt
 = 
SASS_COMMA
;

1394 
Li
* 
	gls
 = 
dymic_
<Li*>(
t
);

1395 
M
* 
	gms
 = 
dymic_
<M*>(
t
);

1397 
Li
* 
	ggli
 = 
SASS_MEMORY_NEW
(
x
.
mem
, List,

1398 
t
->
pe
(),

1400 
ls
 ?s->
t
() : separator,

1401 
ue
);

1403 i(
	gls
 &&s->
is_gli
()) {

1404 aut
	gas
 : *
ls
*
gli
 << 
as
;

1405 } i(
	gms
) {

1406 *
	g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
t
->
pe
(), 
ms
, "", 
l
, 
ue
);

1407 } i(
	gls
) {

1408 aut
	gas
 : *
ls
*
gli
 << 
as
;

1410 *
	ggli
 << 
	gt
;

1412 i(
	ggli
->
ngth
()) {

1413 *
	g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
t
->
pe
(), 
gli
, "", 
ue
);

1417 i(
	ga
->
has_keywd_gumt
()) {

1418 
Exessi
* 
	gkwg
 = 
ic_
<
Argumt
*>(

1419 
a
->
g_keywd_gumt
()->
rfm
(
this
)

1420 )->
vue
()->
rfm
(
this
);

1422 *
	g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
kwg
->
pe
(), kwg, "", 
l
, 
ue
);

1425  
	g
;

1428 
Exessi
* 
	gEv
::
ݔ
()(
Commt
* 
c
)

1433 
le
 
Exessi
* 
	gEv
::
back_im
(
AST_Node
* 
n
)

1435  
ic_
<
Exessi
*>(
n
);

1440 
bo
 
	gEv
::
eq
(
Exessi
* 
lhs
, Exessi* 
rhs
)

1443  
	glhs
 && 
	grhs
 && *lh=*
rhs
;

1446 
bo
 
	gEv
::

(
Exessi
* 
lhs
, Exessi* 
rhs
, 
d
::
rg
 

)

1448 
Numb
* 
l
 = 
dymic_
<Numb*>(
lhs
);

1449 
Numb
* 
	gr
 = 
dymic_
<Numb*>(
rhs
);

1451 i(!
	gl
 || !
	gr

throw
 
	gExi
::
UndefedOti
(
lhs
, 
rhs
, 

);

1453  *
	gl
 < *
	gr
;

1456 
Vue
* 
	gEv
::
_numbs
(
Memy_Mag
& 
mem
, 
Sass_OP
 

, cڡ 
Numb
& 
l
, cڡ Numb& 
r
, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
)

1458 
	glv
 = 
l
.
vue
();

1459 
	grv
 = 
r
.
vue
();

1460 i(
	g
 =
Sass_OP
::
DIV
 && 
rv
 == 0) {

1462  
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
pe
 ? *p: 
l
.pe(), 
lv
 ? "Infinity" : "NaN");

1464 i(
	g
 =
Sass_OP
::
MOD
 && !
rv
) {

1466 
throw
 
Exi
::
ZoDivisiE
(
l
, 
r
);

1469 
Numb
 
tmp
(
r
);

1470 
bo
 
	gri
 = 

 !
Sass_OP
::
MUL
 && o!Sass_OP::
DIV
;

1471 
	gtmp
.
nmize
(
l
.
fd_cvtib_un
(), 
ri
);

1472 
	gd
::
rg
 
l_un
(
l
.
un
());

1473 
	gd
::
rg
 
r_un
(
tmp
.
un
());

1474 
Numb
* 
	gv
 = 
SASS_MEMORY_NEW
(
mem
, Numb, 
l
);

1475 
	gv
->
pe
ա? *p: 
l
.pstate());

1476 i(
	gl_un
.
emy
(&& (
	g
 =
Sass_OP
::
ADD
 || 

 =Sass_OP::
SUB
 || o=Sass_OP::
MOD
)) {

1477 
v
->
num_uns
(
r
.numerator_units();

1478 
	gv
->
dom_uns
(
r
.denominator_units();

1481 i(
	g
 =
Sass_OP
::
MUL
) {

1482 
v
->
vue
(
s
[

](
lv
, 
rv
));

1483 
size_t
 
	gi
 = 0, 
	gS
 = 
r
.
num_uns
().
size
(); i < S; ++i) {

1484 
	gv
->
num_uns
().
push_back
(
r
.num_uns()[
i
]);

1486 
size_t
 
	gi
 = 0, 
	gS
 = 
r
.
dom_uns
().
size
(); i < S; ++i) {

1487 
	gv
->
dom_uns
().
push_back
(
r
.dom_uns()[
i
]);

1490 i(
	g
 =
Sass_OP
::
DIV
) {

1491 
v
->
vue
(
s
[

](
lv
, 
rv
));

1492 
size_t
 
	gi
 = 0, 
	gS
 = 
r
.
num_uns
().
size
(); i < S; ++i) {

1493 
	gv
->
dom_uns
().
push_back
(
r
.
num_uns
()[
i
]);

1495 
size_t
 
	gi
 = 0, 
	gS
 = 
r
.
dom_uns
().
size
(); i < S; ++i) {

1496 
	gv
->
num_uns
().
push_back
(
r
.
dom_uns
()[
i
]);

1499 
Numb
 
rh
(
r
);

1500 
	gv
->
vue
(
s
[

](
lv
, 
rh
.vue(* 
r
.
cvt_
(
l
)));

1502  
	gv
;

1504 
	gv
->
vue
(
s
[

](
lv
, 
tmp
.value()));

1506 
	gv
->
nmize
();

1507  
	gv
;

1510 
Vue
* 
	gEv
::
_numb_c
(
Memy_Mag
& 
mem
, 
Sass_OP
 

, cڡ 
Numb
& 
l
, cڡ 
C
& 
rh
, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
)

1512 
C
 
r
(
rh
);

1513 
	glv
 = 
l
.
vue
();

1514 
	g
) {

1515 
	gSass_OP
::
ADD
:

1516 
Sass_OP
::
MUL
: {

1517  
SASS_MEMORY_NEW
(
mem
, 
C
,

1518 
pe
 ? *p: 
l
.pstate(),

1519 
s
[

](
lv
, 
r
.r()),

1520 
s
[

](
lv
, 
r
.
g
()),

1521 
s
[

](
lv
, 
r
.
b
()),

1522 
r
.
a
());

1524 
	gSass_OP
::
SUB
:

1525 
Sass_OP
::
DIV
: {

1526 
d
::
rg
 
p
(

 =
Sass_OP
::
SUB
 ? "-" : "/");

1527 
	gd
::
rg
 
c
(
r
.
to_rg
(
t
));

1528  
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
,

1529 
pe
 ? *p: 
l
.pstate(),

1530 
l
.
to_rg
(
t
)

1531 + 
p


1532 + 
c
);

1534 
	gSass_OP
::
MOD
: {

1535 
throw
 
Exi
::
UndefedOti
(&
l
, &
r
, 
ss__to_me
(

));

1540  
SASS_MEMORY_NEW
(
mem
, 
C
, 
rh
);

1543 
Vue
* 
	gEv
::
_c_numb
(
Memy_Mag
& 
mem
, 
Sass_OP
 

, cڡ 
C
& 
l
, cڡ 
Numb
& 
r
, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
)

1545 
	grv
 = 
r
.
vue
();

1546 i(
	g
 =
Sass_OP
::
DIV
 && !
rv
) {

1548 
throw
 
Exi
::
ZoDivisiE
(
l
, 
r
);

1550  
SASS_MEMORY_NEW
(
mem
, 
C
,

1551 
pe
 ? *p: 
l
.pstate(),

1552 
s
[

](
l
.
r
(), 
rv
),

1553 
s
[

](
l
.
g
(), 
rv
),

1554 
s
[

](
l
.
b
(), 
rv
),

1555 
l
.
a
());

1558 
Vue
* 
	gEv
::
_cs
(
Memy_Mag
& 
mem
, 
Sass_OP
 

, cڡ 
C
& 
l
, cڡ C& 
r
, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
)

1560 i(
	gl
.
a
(!
r
.a()) {

1561 
throw
 
Exi
::
AhaChlsNEqu
(&
l
, &
r
, "+");

1563 i(
	g
 =
Sass_OP
::
DIV
 && (!
r
.r(|| !r.
g
(||!r.
b
())) {

1565 
throw
 
Exi
::
ZoDivisiE
(
l
, 
r
);

1567  
SASS_MEMORY_NEW
(
mem
, 
C
,

1568 
pe
 ? *p: 
l
.pstate(),

1569 
s
[

](
l
.
r
(),.r()),

1570 
s
[

](
l
.
g
(), 
r
.g()),

1571 
s
[

](
l
.
b
(), 
r
.b()),

1572 
l
.
a
());

1575 
Vue
* 
	gEv
::
_rgs
(
Memy_Mag
& 
mem
, 
Sass
::
Ond
 
ݔd
, Vue& 
lhs
, Vue& 
rhs
, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
, 
bo
 
dayed
)

1577 
	gExessi
::
Ce_Ty
 
y
 = 
lhs
.
ce_ty
();

1578 
	gExessi
::
Ce_Ty
 
y
 = 
rhs
.
ce_ty
();

1579 
Sass_OP
 
	g
 = 
ݔd
.operand;

1581 
Sg_Qued
* 
	glqr
 = 
dymic_
<Sg_Qued*>(&
lhs
);

1582 
Sg_Qued
* 
	grqr
 = 
dymic_
<Sg_Qued*>(&
rhs
);

1584 
	gd
::
rg
 
lr
(
lqr
 ?qr->
vue
(: 
lhs
.
to_rg
(
t
));

1585 
	gd
::
rg
 
rr
(
rqr
 ?qr->
vue
(: 
rhs
.
to_rg
(
t
));

1587 i(
	gy
 =
Exessi
::
NULL_VAL

throw
 
Exi
::
InvidNuOti
(&
lhs
, &
rhs
, 
ss__to_me
(

));

1588 i(
	gy
 =
Exessi
::
NULL_VAL

throw
 
Exi
::
InvidNuOti
(&
lhs
, &
rhs
, 
ss__to_me
(

));

1589 i(
	g
 =
Sass_OP
::
MOD

throw
 
Exi
::
UndefedOti
(&
lhs
, &
rhs
, 
ss__to_me
(

));

1590 i(
	g
 =
Sass_OP
::
MUL

throw
 
Exi
::
UndefedOti
(&
lhs
, &
rhs
, 
ss__to_me
(

));

1591 
	gd
::
rg
 
p
;

1592 
	g
) {

1593 
	gSass_OP
::
SUB
: 
p
 = "-"; ;

1594 
	gSass_OP
::
DIV
: 
p
 = "/"; ;

1595 
	gSass_OP
::
MUL
: 
p
 = "*"; ;

1596 
	gSass_OP
::
MOD
: 
p
 = "%"; ;

1597 
	gSass_OP
::
EQ
: 
p
 = "=="; ;

1598 
	gSass_OP
::
NEQ
: 
p
 = "!="; ;

1599 
	gSass_OP
::
LT
: 
p
 = "<"; ;

1600 
	gSass_OP
::
GT
: 
p
 = ">"; ;

1601 
	gSass_OP
::
LTE
: 
p
 = "<="; ;

1602 
	gSass_OP
::
GTE
: 
p
 = ">="; ;

1606 i(
	gp
 == "")

1609 
que_mk
 = 0;

1610 
	gd
::
rg
 
unq
(
unque
(
lr
 + 
p
 + 
rr
, &
que_mk
, 
ue
));

1611 i(
	gque_mk
 && quote_mark != '*') {

1612  
SASS_MEMORY_NEW
(
mem
, 
Sg_Cڡt
, 
lhs
.
pe
(), 
que_mk
 + 
unq
 + quote_mark);

1614  
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
lhs
.
pe
(), 
lr
 + 
p
 + 
rr
);

1617 i(
	gp
 !"" && !
dayed
) {

1618 i(
ݔd
.
ws_befe

p
 = " " + sep;

1619 i(
	gݔd
.
	gws_a

	gp
 = 
p
 + " ";

1622 i(
	g
 =
Sass_OP
::
SUB
 || 

 =Sass_OP::
DIV
) {

1623 i(
lqr
 &&qr->
que_mk
()
lr
 = 
que
(lstr);

1624 i(
	grqr
 &&qr->
que_mk
()
	grr
 = 
que
(
rr
);

1625  
SASS_MEMORY_NEW
(
mem
, 
Sg_Cڡt
, 
lhs
.
pe
(), 
lr
 + 
p
 + 
rr
);

1628  
SASS_MEMORY_NEW
(
mem
, 
Sg_Cڡt
, 
lhs
.
pe
(), (
lr
+ 
p
 + (
rr
));

1631 
Exessi
* 
cv_to_anode
(
Memy_Mag
& 
mem
, 
Sass_Vue
* 
v
, 
Cڋxt
& 
x
, 
Backa
* 
backa
, 
PrS
 
pe
)

1633 
usg
 
	gd
::

;

1634 
usg
 
	gd
::
ry
;

1635 
Exessi
* 
	ge
 = 0;

1636 
ss_vue_g_g
(
v
)) {

1637 
	gSASS_BOOLEAN
: {

1638 
e
 = 
SASS_MEMORY_NEW
(
mem
, 
Boޗn
, 
pe
, !!
ss_boޗn_g_vue
(
v
));

1640 
	gSASS_NUMBER
: {

1641 
e
 = 
SASS_MEMORY_NEW
(
mem
, 
Numb
, 
pe
, 
ss_numb_g_vue
(
v
), 
ss_numb_g_un
(v));

1643 
	gSASS_COLOR
: {

1644 
e
 = 
SASS_MEMORY_NEW
(
mem
, 
C
, 
pe
, 
ss_c_g_r
(
v
), 
ss_c_g_g
(v), 
ss_c_g_b
(v), 
ss_c_g_a
(v));

1646 
	gSASS_STRING
: {

1647 i(
ss_rg_is_qued
(
v
))

1648 
e
 = 
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
pe
, 
ss_rg_g_vue
(
v
));

1650 
	ge
 = 
SASS_MEMORY_NEW
(
mem
, 
Sg_Cڡt
, 
pe
, 
ss_rg_g_vue
(
v
));

1653 
	gSASS_LIST
: {

1654 
Li
* 
l
 = 
SASS_MEMORY_NEW
(
mem
, Li, 
pe
, 
ss_li_g_ngth
(
v
), 
ss_li_g_t
(v));

1655 
size_t
 
	gi
 = 0, 
	gL
 = 
ss_li_g_ngth
(
v
); i < L; ++i) {

1656 *
	gl
 << 
cv_to_anode
(
mem
, 
ss_li_g_vue
(
v
, 
i
), 
x
, 
backa
, 
pe
);

1658 
	ge
 = 
l
;

1660 
	gSASS_MAP
: {

1661 
M
* 
m
 = 
SASS_MEMORY_NEW
(
mem
, M, 
pe
);

1662 
size_t
 
	gi
 = 0, 
	gL
 = 
ss_m_g_ngth
(
v
); i < L; ++i) {

1663 *
	gm
 << 
	gd
::
make_
(

1664 
cv_to_anode
(
mem
, 
ss_m_g_key
(
v
, 
i
), 
x
, 
backa
, 
pe
),

1665 
cv_to_anode
(
mem
, 
ss_m_g_vue
(
v
, 
i
), 
x
, 
backa
, 
pe
));

1667 
	ge
 = 
m
;

1669 
	gSASS_NULL
: {

1670 
e
 = 
SASS_MEMORY_NEW
(
mem
, 
Nu
, 
pe
);

1672 
	gSASS_ERROR
: {

1673 
r
("E iC funi: " + 
d
::
rg
(
ss_r_g_mesge
(
v
)), 
pe
, 
backa
);

1675 
	gSASS_WARNING
: {

1676 
r
("Wng iC funi: " + 
d
::
rg
(
ss_wng_g_mesge
(
v
)), 
pe
, 
backa
);

1679  
	ge
;

1682 
Se_Li
* 
	gEv
::
ݔ
()(Se_Li* 
s
)

1684 
d
::
ve
<
Se_Li
*> 
rv
;

1685 
Se_Li
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
s
->
pe
());

1686 
	g
->
is_tiڮ
(
s
->is_optional());

1687 
	g
->
med_block
(
s
->media_block());

1688 
	g
->
is_tiڮ
(
s
->is_optional());

1689 
size_t
 
	gi
 = 0, 
	giL
 = 
s
->
ngth
(); i < iL; ++i) {

1690 
	grv
.
push_back
(
ݔ
()((*
s
)[
i
]));

1695 
size_t
 
	ground
 = 0;

1696 
	ground
 !
d
::
rg
::
os
) {

1697 
bo
 
abt
 = 
ue
;

1698 
size_t
 
	gi
 = 0, 
	giL
 = 
rv
.
size
(); i < iL; ++i) {

1699 i(
	grv
[
i
]->
ngth
(> 
	ground
) {

1700 *
	g
 << (*
	grv
[
i
])[
round
];

1701 
	gabt
 = 
l
;

1704 i(
	gabt
) {

1705 
	ground
 = 
d
::
rg
::
os
;

1707 ++ 
	ground
;

1711  
	g
;

1715 
Se_Li
* 
	gEv
::
ݔ
()(
Comex_Se
* 
s
)

1717  
s
->
ize
(

(), 
x
);

1722 
Aribu_Se
* 
	gEv
::
ݔ
()(Aribu_Se* 
s
)

1724 
Sg
* 

 = 
s
->
vue
();

1725 i(
	g
{
ic_
<
Sg
*>(

->
rfm
(
this
)); }

1726 
Aribu_Se
* 
	gss
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Aribu_Se, *
s
);

1727 
	gss
->
vue
(

);

1728  
	gss
;

1731 
Se_Li
* 
	gEv
::
ݔ
()(
Se_Schema
* 
s
)

1734 
d
::
rg
 
su_r
(
s
->
cڋs
()->
rfm
(
this
)->
to_rg
(
x
.
c_tis
));

1735 
	gsu_r
 = 
unque
(
Ut
::
rim
(
su_r
)) + "\n{";

1736 
Pr
 
	gp
 = Pr::
om_c_r
(
su_r
.
c_r
(), 
x
, 
s
->
pe
());

1737 
	gp
.
	gϡ_med_block
 = 
s
->
med_block
();

1738 
Se_Li
* 
	g
 = 
p
.
r__li
(
exp
.
block_ack
.
back
()->
is_ro
());

1739 i(
	gs
->
has__f
()
	g
->
move__s
();

1740  
ݔ
()(
	g
);

1743 
Exessi
* 
	gEv
::
ݔ
()(
Pt_Se
* 
p
)

1745 
Se_Li
* 

 = 

();

1746 i(
	g
) {

1747 
	gexp
.
	g_ack
.
p_back
();

1748 
	g
 = 
ݔ
()(

);

1749 
	gexp
.
	g_ack
.
push_back
(

);

1750  
	g
;

1752  
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
p
->
pe
());

	@node_modules/node-sass/src/libsass/src/eval.hpp

1 #ide
SASS_EVAL_H


2 
	#SASS_EVAL_H


	)

4 
	~"a.h
"

5 
	~"cڋxt.h
"

6 
	~"ݔi.h
"

7 
	~"vmt.h
"

9 
mea
 
	gSass
 {

11 
ass
 
	gExnd
;

12 
ass
 
	gCڋxt
;

14 
ass
 
	gEv
 : 
public
 
Oti_CRTP
<
Exessi
*, Eval> {

16 
	give
:

17 
Exessi
* 
back_im
(
AST_Node
* 
n
);

19 
	gpublic
:

20 
Exnd
& 
exp
;

21 
	gCڋxt
& 
	gx
;

22 
Ev
(
Exnd
& 
exp
);

23 ~
Ev
();

25 
bo
 
	gis__commt
;

27 
Env
* 
vmt
();

28 
	gCڋxt
& 
cڋxt
();

29 
Se_Li
* 

();

30 
Backa
* 
backa
();

33 
Exessi
* 
ݔ
()(
	gBlock
*);

34 
Exessi
* 
ݔ
()(
	gAssignmt
*);

35 
Exessi
* 
ݔ
()(
	gIf
*);

36 
Exessi
* 
ݔ
()(
	gF
*);

37 
Exessi
* 
ݔ
()(
	gEach
*);

38 
Exessi
* 
ݔ
()(
	gWhe
*);

39 
Exessi
* 
ݔ
()(
	gRu
*);

40 
Exessi
* 
ݔ
()(
	gWng
*);

41 
Exessi
* 
ݔ
()(
	gE
*);

42 
Exessi
* 
ݔ
()(
	gDebug
*);

44 
Exessi
* 
ݔ
()(
	gLi
*);

45 
Exessi
* 
ݔ
()(
	gM
*);

46 
Exessi
* 
ݔ
()(
	gBy_Exessi
*);

47 
Exessi
* 
ݔ
()(
	gUry_Exessi
*);

48 
Exessi
* 
ݔ
()(
	gFuni_Cl
*);

49 
Exessi
* 
ݔ
()(
	gFuni_Cl_Schema
*);

50 
Exessi
* 
ݔ
()(
	gVb
*);

51 
Exessi
* 
ݔ
()(
	gTextu
*);

52 
Exessi
* 
ݔ
()(
	gNumb
*);

53 
Exessi
* 
ݔ
()(
	gBoޗn
*);

54 
Exessi
* 
ݔ
()(
	gSg_Schema
*);

55 
Exessi
* 
ݔ
()(
	gSg_Qued
*);

56 
Exessi
* 
ݔ
()(
	gSg_Cڡt
*);

58 
Exessi
* 
ݔ
()(
	gMed_Quy
*);

59 
Exessi
* 
ݔ
()(
	gMed_Quy_Exessi
*);

60 
Exessi
* 
ݔ
()(
	gAt_Ro_Quy
*);

61 
Exessi
* 
ݔ
()(
	gSuts_Ot
*);

62 
Exessi
* 
ݔ
()(
	gSuts_Negi
*);

63 
Exessi
* 
ݔ
()(
	gSuts_Dei
*);

64 
Exessi
* 
ݔ
()(
	gSuts_Ipީi
*);

65 
Exessi
* 
ݔ
()(
	gNu
*);

66 
Exessi
* 
ݔ
()(
	gArgumt
*);

67 
Exessi
* 
ݔ
()(
	gArgumts
*);

68 
Exessi
* 
ݔ
()(
	gCommt
*);

71 
Se_Li
* 
ݔ
()(
	gSe_Li
*);

72 
Se_Li
* 
ݔ
()(
	gComex_Se
*);

73 
Aribu_Se
* 
ݔ
()(
	gAribu_Se
*);

75 
Ty_Se
* 
ݔ
()(Ty_Se* 
	gs
) {  s; };

76 
Pudo_Se
* 
ݔ
()(Pudo_Se* 
	gs
) {  s; };

77 
Wed_Se
* 
ݔ
()(Wed_Se* 
	gs
) {  s; };

78 
Se_Quifr
* 
ݔ
()(Se_Quifr* 
	gs
) {  s; };

79 
Se_Phd
* 
ݔ
()(Se_Phd* 
	gs
) {  s; };

81 
Se_Li
* 
ݔ
()(
	gSe_Schema
*);

82 
Exessi
* 
ݔ
()(
	gPt_Se
*);

84 
	gme
 <
tyme
 
	gU
>

85 
Exessi
* 
back
(
U
 
x
{  
back_im
(x); }

88 
bo
 
eq
(
Exessi
*, Expression*);

89 
bo
 

(
Exessi
*, Exessi*, 
d
::
rg
 

);

91 
Vue
* 
_numbs
(
Memy_Mag
&, 
Sass_OP
, cڡ 
Numb
&, cڡ Numb&, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
 = 0);

92 
Vue
* 
_numb_c
(
Memy_Mag
&, 
Sass_OP
, cڡ 
Numb
&, cڡ 
C
&, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
 = 0);

93 
Vue
* 
_c_numb
(
Memy_Mag
&, 
Sass_OP
, cڡ 
C
&, cڡ 
Numb
&, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
 = 0);

94 
Vue
* 
_cs
(
Memy_Mag
&, 
Sass_OP
, cڡ 
C
&, cڡ C&, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
 = 0);

95 
Vue
* 
_rgs
(
Memy_Mag
&, 
Sass
::
Ond
, Vue&, Vue&, 
Sass_Ine_Ois
 
t
, 
PrS
* 
pe
 = 0, 
bo
 
ުt
 = 
l
);

97 
	give
:

98 
ީi
(
Cڋxt
& 
x
, 
d
::
rg
& 
s
, 
Exessi
* 
ex
, 
bo
 
to_ques
, bo 
was_
 = 
l
);

102 
Exessi
* 
cv_to_anode
(
Memy_Mag
& 
mem
, 
Sass_Vue
* 
v
, 
Cڋxt
& 
x
, 
Backa
* 
backa
, 
PrS
 
pe
 = ParserState("[AST]"));

	@node_modules/node-sass/src/libsass/src/expand.cpp

1 
	~"ss.h
"

2 
	~<ioam
>

3 
	~<tyfo
>

5 
	~"exnd.h
"

6 
	~"bd.h
"

7 
	~"ev.h
"

8 
	~"backa.h
"

9 
	~"cڋxt.h
"

10 
	~"rr.h
"

12 
mea
 
	gSass
 {

14 
	gExnd
::
Exnd
(
Cڋxt
& 
x
, 
Env
* 
v
, 
Backa
* 
bt
)

15 : 
x
(ctx),

16 
ev
(
Ev
(*
this
)),

17 
v_ack
(
d
::
ve
<
Env
*>()),

18 
block_ack
(
d
::
ve
<
Block
*>()),

19 
_ack
(
d
::
ve
<
AST_Node
*>()),

20 
ݔty_ack
(
d
::
ve
<
Sg
*>()),

21 
_ack
(
d
::
ve
<
Se_Li
*>()),

22 
med_block_ack
(
d
::
ve
<
Med_Block
*>()),

23 
backa_ack
(
d
::
ve
<
Backa
*>()),

24 
_keyames
(
l
)

26 
	gv_ack
.
push_back
(0);

27 
	gv_ack
.
push_back
(
v
);

28 
	gblock_ack
.
push_back
(0);

29 
	g_ack
.
push_back
(0);

31 
	gݔty_ack
.
push_back
(0);

32 
	g_ack
.
push_back
(0);

33 
	gmed_block_ack
.
push_back
(0);

34 
	gbacka_ack
.
push_back
(0);

35 
	gbacka_ack
.
push_back
(
bt
);

38 
	gCڋxt
& 
	gExnd
::
cڋxt
()

40  
x
;

43 
Env
* 
	gExnd
::
vmt
()

45 i(
v_ack
.
size
() > 0)

46  
v_ack
.
back
();

50 
Se_Li
* 
	gExnd
::

()

52 i(
_ack
.
size
() > 0)

53  
_ack
.
back
();

57 
Backa
* 
	gExnd
::
backa
()

59 i(
backa_ack
.
size
() > 0)

60  
backa_ack
.
back
();

65 
Smt
* 
	gExnd
::
ݔ
()(
Block
* 
b
)

69 
Env
 
v
(
vmt
());

71 
Block
* 
	gbb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block,

72 
b
->
pe
(),

73 
b
->
ngth
(),

74 
b
->
is_ro
());

76 
	gthis
->
	gblock_ack
.
push_back
(
bb
);

77 
	gthis
->
	gv_ack
.
push_back
(&
v
);

79 
	gthis
->
nd_block
(
b
);

81 
	gthis
->
	gblock_ack
.
p_back
();

82 
	gthis
->
	gv_ack
.
p_back
();

84  
	gbb
;

87 
Smt
* 
	gExnd
::
ݔ
()(
Ruˣt
* 
r
)

91 i(
_keyames
) {

92 
Keyame_Ru
* 
k
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Keyame_Ru, 
r
->
pe
(),->
block
()->
rfm
(
this
)->block());

93 i(
	gr
->

()) {

94 
	g_ack
.
push_back
(0);

95 
	gk
->

(
ic_
<
Se_Li
*>(
r
->()->
rfm
(&
ev
)));

96 
	g_ack
.
p_back
();

98  
	gk
;

102 i(
	gr
->
is_ro
()) {

103 i(
Se_Li
* 
	g_li
 = 
dymic_
<Se_Li*>(
r
->

())) {

104 
Comex_Se
* 
comex_
 : 
_li
->
emts
()) {

105 
Comex_Se
* 

 = 
comex_
;

106 
	g
) {

107 i(
	g
->
hd
()
Sime_Se
* 
	ghd
 : 

->hd()->
emts
()) {

108 i(
dymic_
<
Pt_Se
*>(
hd
=
NULL
) ;

109 
	gd
::
rg
 
l_r
(
comex_
->
to_rg
(
x
.
c_tis
));

110 
r
("Ba-vuˠ cڏh--ncg cha '&'.", 
hd
->
pe
(), 
backa
());

112 
	g
 = 

->tail();

118 
Exessi
* 
	gex
 = 
r
->

()->
rfm
(&
ev
);

119 
Se_Li
* 
	gl
 = 
dymic_
<Se_Li*>(
ex
);

120 i(
	gl
 =0
throw
 
d
::
ruime_r
("Expandedull selector");

122 i(
	gl
->
ngth
(=0 || 
l
->
has__f
()) {

123 
bo
 
has__
 = 
l
;

124 
size_t
 
	gi
 = 0, 
	gL
 = 
_ack
.
size
(); i < L && !
	ghas__
; i++) {

125 
Se_Li
* 
	g
 = 
_ack
.

(
i
);

126 
	ghas__
 = 

 !0 &&l->
ngth
() > 0;

128 i(!
	ghas__
) {

129 
r
("Ba-vuˠ cڏh--ncg cha '&'.", 
l
->
pe
(), 
backa
());

133 
	g_ack
.
push_back
(
l
);

134 
Env
* 
	gv
 = 0;

135 i(
	gblock_ack
.
back
()->
is_ro
()) {

136 
	gv
 = 
w
 
Env
(
vmt
());

137 
	gv_ack
.
push_back
(
v
);

139 
	gl
->
t_med_block
(
med_block_ack
.
back
());

140 
Block
* 
	gblk
 = 
r
->
block
()->
rfm
(
this
)->block();

141 
Ruˣt
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Ruleset,

142 
r
->
pe
(),

143 
l
,

144 
blk
);

145 
	g_ack
.
p_back
();

146 i(
	gblock_ack
.
back
()->
is_ro
()) {

147 
	gv_ack
.
p_back
();

148 
de
 
	gv
;

150 
	g
->
is_ro
(
r
->is_root());

151 
	g
->
bs
(
r
->tabs());

153  
	g
;

156 
Smt
* 
	gExnd
::
ݔ
()(
Prݣt
* 
p
)

158 
ݔty_ack
.
push_back
(
p
->
ݔty_agmt
());

159 
Block
* 
	gexnded_block
 = 
p
->
block
()->
rfm
(
this
)->block();

161 
size_t
 
	gi
 = 0, 
	gL
 = 
exnded_block
->
ngth
(); i < L; ++i) {

162 
Smt
* 
	gm
 = (*
exnded_block
)[
i
];

163 i(
Dei
* 
	gdec
 = 
ic_
<Dei*>(
m
)) {

164 
Sg_Schema
* 
combed_
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
p
->
pe
());

165 i(!
	gݔty_ack
.
emy
()) {

166 *
	gcombed_
 << 
	gݔty_ack
.
back
()->
rfm
(&
ev
)

167 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
,

168 
p
->
pe
(), "-")

169 << 
	gdec
->
ݔty
();

172 *
	gcombed_
 << 
	gdec
->
ݔty
();

174 
	gdec
->
ݔty
(
combed_
);

175 *
	gblock_ack
.
back
(<< 
	gdec
;

177 i(
tyid
(*
m
=tyid(
Commt
)) {

181 
r
("cڋomeadrݔtmuesu iy deiڠly", 
m
->
pe
(), 
backa
());

185 
	gݔty_ack
.
p_back
();

190 
Smt
* 
	gExnd
::
ݔ
()(
Suts_Block
* 
f
)

192 
Exessi
* 
cdi
 = 
f
->cdi()->
rfm
(&
ev
);

193 
Suts_Block
* 
	gff
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Supports_Block,

194 
f
->
pe
(),

195 
ic_
<
Suts_Cdi
*>(
cdi
),

196 
f
->
block
()->
rfm
(
this
)->block());

197  
	gff
;

200 
Smt
* 
	gExnd
::
ݔ
()(
Med_Block
* 
m
)

202 
med_block_ack
.
push_back
(
m
);

203 
Exessi
* 
	gmq
 = 
m
->
med_qus
()->
rfm
(&
ev
);

204 
	gd
::
rg
 
r_mq
(
mq
->
to_rg
(
x
.
c_tis
));

205 * 
	gr
 = 
ss_cy_c_rg
(
r_mq
.
c_r
());

206 
	gx
.
	grgs
.
push_back
(
r
);

207 
Pr
 
p
(Pr::
om_c_r
(
r
, 
x
, 
mq
->
pe
()));

208 
	gmq
 = 
p
.
r_med_qus
();

209 
Med_Block
* 
	gmm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Media_Block,

210 
m
->
pe
(),

211 
ic_
<
Li
*>(
mq
->
rfm
(&
ev
)),

212 
m
->
block
()->
rfm
(
this
)->block(),

214 
	gmed_block_ack
.
p_back
();

215 
	gmm
->
bs
(
m
->tabs());

216  
	gmm
;

219 
Smt
* 
	gExnd
::
ݔ
()(
At_Ro_Block
* 
a
)

221 
Block
* 
ab
 = 
a
->
block
();

223 
Exessi
* 
	g
 = 
a
->
exessi
();

224 i(
	g
 = 

->
rfm
(&
ev
);

225 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
At_Ro_Quy
, 
a
->
pe
());

226 
Block
* 
	gbb
 = 
ab
 ?b->
rfm
(
this
)->
block
() : 0;

227 
At_Ro_Block
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, At_Root_Block,

228 
a
->
pe
(),

229 
bb
,

230 
ic_
<
At_Ro_Quy
*>(

));

232  
	g
;

235 
Smt
* 
	gExnd
::
ݔ
()(
Deive
* 
a
)

237 
LOCAL_FLAG
(
_keyames
, 
a
->
is_keyames
());

238 
Block
* 
	gab
 = 
a
->
block
();

239 
Se
* 
	gas
 = 
a
->

();

240 
Exessi
* 
	gav
 = 
a
->
vue
();

241 
	g_ack
.
push_back
(0);

242 i(
	gav
av = 
av
->
rfm
(&
ev
);

243 i(
	gas
a
dymic_
<
Se
*>(
as
->
rfm
(&
ev
));

244 
	g_ack
.
p_back
();

245 
Block
* 
	gbb
 = 
ab
 ?b->
rfm
(
this
)->
block
() : 0;

246 
Deive
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Directive,

247 
a
->
pe
(),

248 
a
->
keywd
(),

249 
as
,

250 
bb
,

251 
av
);

252  
	g
;

255 
Smt
* 
	gExnd
::
ݔ
()(
Dei
* 
d
)

257 
Sg
* 
d_p
 = 
d
->
ݔty
();

258 
Sg
* 
	gw_p
 = 
ic_
<Sg*>(
d_p
->
rfm
(&
ev
));

259 
Exessi
* 
	gvue
 = 
d
->
vue
()->
rfm
(&
ev
);

260 i(!
	gvue
 || (vue->
is_visib
(&& !
	gd
->
is_imp܏
()))  0;

261 
Dei
* 
	gde
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Declaration,

262 
d
->
pe
(),

263 
w_p
,

264 
vue
,

265 
d
->
is_imp܏
());

266 
	gde
->
bs
(
d
->tabs());

267  
	gde
;

270 
Smt
* 
	gExnd
::
ݔ
()(
Assignmt
* 
a
)

272 
Env
* 
v
 = 
vmt
();

273 
	gd
::
rg
 
v
(
a
->
vb
());

274 i(
	ga
->
is_glob
()) {

275 i(
	ga
->
is_deu
()) {

276 i(
	gv
->
has_glob
(
v
)) {

277 
Exessi
* 
	ge
 = 
dymic_
<Exessi*>(
v
->
g_glob
(
v
));

278 i(!
	ge
 ||->
ce_ty
(=
Exessi
::
NULL_VAL
) {

279 
v
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

283 
	gv
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

287 
	gv
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

290 i(
	ga
->
is_deu
()) {

291 i(
	gv
->
has_xil
(
v
)) {

292 aut
	gcur
 = 
v
;

293 
	gcur
 && cur->
is_xil
()) {

294 i(
	gcur
->
has_lol
(
v
)) {

295 i(
AST_Node
* 
	gnode
 = 
cur
->
g_lol
(
v
)) {

296 
Exessi
* 
e
 = 
dymic_
<Exessi*>(
node
);

297 i(!
	ge
 ||->
ce_ty
(=
Exessi
::
NULL_VAL
) {

298 
cur
->
t_lol
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

302 
throw
 
	gd
::
ruime_r
("Envot in sync");

306 
	gcur
 = 
cur
->

();

308 
throw
 
	gd
::
ruime_r
("Envot in sync");

310 i(
	gv
->
has_glob
(
v
)) {

311 i(
AST_Node
* 
	gnode
 = 
v
->
g_glob
(
v
)) {

312 
Exessi
* 
e
 = 
dymic_
<Exessi*>(
node
);

313 i(!
	ge
 ||->
ce_ty
(=
Exessi
::
NULL_VAL
) {

314 
v
->
t_glob
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

318 i(
	gv
->
is_xil
()) {

319 
	gv
->
t_lol
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

322 
	gv
->
t_lol
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

326 
	gv
->
t_xil
(
v
, 
a
->
vue
()->
rfm
(&
ev
));

331 
Smt
* 
	gExnd
::
ݔ
()(
Impt
* 
imp
)

333 
Impt
* 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Impt, 
imp
->
pe
());

334 i(
	gimp
->
med_qus
(&& imp->med_qus()->
size
()) {

335 
Exessi
* 
	gex
 = 
imp
->
med_qus
()->
rfm
(&
ev
);

336 
	gsu
->
med_qus
(
dymic_
<
Li
*>(
ex
));

338  
size_t
 
	gi
 = 0, 
	gS
 = 
imp
->
us
().
size
(); i < S; ++i) {

339 
	gsu
->
us
().
push_back
(
imp
->us()[
i
]->
rfm
(&
ev
));

343  
	gsu
;

346 
Smt
* 
	gExnd
::
ݔ
()(
Impt_Stub
* 
i
)

349 
AST_Node
* 

 = 
_ack
.
back
();

350 i(
	g
 && 
	gdymic_
<
	gBlock
*>լt=
NULL
) {

351 
r
("Imp܈deivemay bud wh cڌ deive mixs.", 
i
->
pe
());

354 
Sass_Impt_Ery
 
	gimpt
 = 
ss_make_impt
(

355 
i
->
imp_th
().
c_r
(),

356 
i
->
abs_th
().
c_r
(),

359 
	gx
.
	gimpt_ack
.
push_back
(
impt
);

360 cڡ 
	gd
::
rg
& 
abs_th
(
i
->
sour
().abs_path);

361 
nd_block
(
x
.
shts
.

(
abs_th
).
ro
);

362 
ss_de_impt
(
x
.
impt_ack
.
back
());

363 
	gx
.
	gimpt_ack
.
p_back
();

367 
Smt
* 
	gExnd
::
ݔ
()(
Wng
* 
w
)

370 
w
->
rfm
(&
ev
);

374 
Smt
* 
	gExnd
::
ݔ
()(
E
* 
e
)

377 
e
->
rfm
(&
ev
);

381 
Smt
* 
	gExnd
::
ݔ
()(
Debug
* 
d
)

384 
d
->
rfm
(&
ev
);

388 
Smt
* 
	gExnd
::
ݔ
()(
Commt
* 
c
)

390 
ev
.
is__commt
 = 
ue
;

391 aut
	grv
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Commt
, 
c
->
pe
(), 
ic_
<
Sg
*>(c->
xt
()->
rfm
(&
ev
)), c->
is_imp܏
());

392 
	gev
.
	gis__commt
 = 
l
;

394  
	grv
;

397 
Smt
* 
	gExnd
::
ݔ
()(
If
* 
i
)

399 
Env
 
v
(
vmt
(), 
ue
);

400 
	gv_ack
.
push_back
(&
v
);

401 
	g_ack
.
push_back
(
i
);

402 i(*
	gi
->
edi
()->
rfm
(&
ev
)) {

403 
nd_block
(
i
->
block
());

406 
Block
* 
	gt
 = 
i
->
ive
();

407 i(
	gt

nd_block
(
t
);

409 
	g_ack
.
p_back
();

410 
	gv_ack
.
p_back
();

416 
Smt
* 
	gExnd
::
ݔ
()(
F
* 
f
)

418 
d
::
rg
 
vb
(
f
->variable());

419 
Exessi
* 
	glow
 = 
f
->
low_bound
()->
rfm
(&
ev
);

420 i(
	glow
->
ce_ty
(!
Exessi
::
NUMBER
) {

421 
throw
 
Exi
::
TyMismch
(*
low
, "integer");

423 
Exessi
* 
	ghigh
 = 
f
->
u_bound
()->
rfm
(&
ev
);

424 i(
	ghigh
->
ce_ty
(!
Exessi
::
NUMBER
) {

425 
throw
 
Exi
::
TyMismch
(*
high
, "integer");

427 
Numb
* 
	gss_t
 = 
ic_
<Numb*>(
low
);

428 
Numb
* 
	gss_d
 = 
ic_
<Numb*>(
high
);

430 i(
	gss_t
->
un
(!
ss_d
->unit()) {

431 
d
::
rgam
 
msg
; 
	gmsg
 << "Incompatible units: '"

432 << 
	gss_t
->
un
() << "'nd '"

433 << 
	gss_d
->
un
() << "'.";

434 
r
(
msg
.
r
(), 
low
->
pe
(), 
backa
());

436 
	gt
 = 
ss_t
->
vue
();

437 
	gd
 = 
ss_d
->
vue
();

439 
Env
 
v
(
vmt
(), 
ue
);

440 
	gv_ack
.
push_back
(&
v
);

441 
	g_ack
.
push_back
(
f
);

442 
Numb
* 
	g
 = 
SASS_MEMORY_NEW
(
v
.
mem
, Numb, 
low
->
pe
(), 
t
, 
ss_d
->
un
());

443 
	gv
.
t_lol
(
vb
, 

);

444 
Block
* 
	gbody
 = 
f
->
block
();

445 i(
	gt
 < 
	gd
) {

446 i(
	gf
->
is_usive
()++
	gd
;

447 
	gi
 = 
t
;

448 
	gi
 < 
	gd
;

449 ++
	gi
) {

450 
	g
->
vue
(
i
);

451 
	gv
.
t_lol
(
vb
, 

);

452 
nd_block
(
body
);

455 i(
	gf
->
is_usive
()--
	gd
;

456 
	gi
 = 
t
;

457 
	gi
 > 
	gd
;

458 --
	gi
) {

459 
	g
->
vue
(
i
);

460 
	gv
.
t_lol
(
vb
, 

);

461 
nd_block
(
body
);

464 
	g_ack
.
p_back
();

465 
	gv_ack
.
p_back
();

471 
Smt
* 
	gExnd
::
ݔ
()(
Each
* 
e
)

473 
d
::
ve
<d::
rg
> 
vbs
(
e
->variables());

474 
Exessi
* 
	gex
 = 
e
->
li
()->
rfm
(&
ev
);

475 
	gVeized
<
	gExessi
*>* 
	gli
 = 0;

476 
M
* 
	gm
 = 0;

477 i(
	gex
->
ce_ty
(=
Exessi
::
MAP
) {

478 
m
 = 
ic_
<
M
*>(
ex
);

480 i(
Se_Li
* 
	gls
 = 
dymic_
<Se_Li*>(
ex
)) {

481 
Liize
 
liize
(
x
.
mem
);

482 
	gli
 = 
dymic_
<
Li
*>(
ls
->
rfm
(&
liize
));

484 i(
	gex
->
ce_ty
(!
Exessi
::
LIST
) {

485 
li
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
ex
->
pe
(), 1, 
SASS_COMMA
);

486 *
	gli
 << 
	gex
;

489 
	gli
 = 
ic_
<
Li
*>(
ex
);

492 
Env
 
v
(
vmt
(), 
ue
);

493 
	gv_ack
.
push_back
(&
v
);

494 
	g_ack
.
push_back
(
e
);

495 
Block
* 
	gbody
 = 
e
->
block
();

497 i(
	gm
) {

498 aut
	gkey
 : 
m
->
keys
()) {

499 
Exessi
* 
k
 = 
key
->
rfm
(&
ev
);

500 
Exessi
* 
	gv
 = 
m
->

(
key
)->
rfm
(&
ev
);

502 i(
	gvbs
.
size
() == 1) {

503 
Li
* 
vb
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
m
->
pe
(), 2, 
SASS_SPACE
);

504 *
	gvb
 << 
	gk
;

505 *
	gvb
 << 
	gv
;

506 
	gv
.
t_lol
(
vbs
[0], 
vb
);

508 
	gv
.
t_lol
(
vbs
[0], 
k
);

509 
	gv
.
t_lol
(
vbs
[1], 
v
);

511 
nd_block
(
body
);

516 i(
	gli
->
ngth
(=1 && 
dymic_
<
Se_Li
*>(
li
)) {

517 
li
 = 
dymic_
<
Veized
<
Exessi
*>*>(list);

519 
size_t
 
	gi
 = 0, 
	gL
 = 
li
->
ngth
(); i < L; ++i) {

520 
Exessi
* 
	ge
 = (*
li
)[
i
];

522 i(
Argumt
* 
	gg
 = 
dymic_
<Argumt*>(
e
)
g
->
vue
();

524 i(
Li
* 
	gsrs
 = 
dymic_
<Li*>(
e
)) {

525 i(
vbs
.
size
() == 1) {

526 
Exessi
* 
v
 = 
srs
;

528 
	gv
.
t_lol
(
vbs
[0], 
v
);

530 
size_t
 
	gj
 = 0, 
	gK
 = 
vbs
.
size
(); j < K; ++j) {

531 
Exessi
* 
	gs
 = 
j
 >
srs
->
ngth
()

532 ? 
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
ex
->
pe
())

533 : (*
srs
)[
j
]->
rfm
(&
ev
);

534 
	gv
.
t_lol
(
vbs
[
j
], 
s
);

538 i(
	gvbs
.
size
() > 0) {

539 
	gv
.
t_lol
(
vbs
[0], 
e
);

540 
size_t
 
	gj
 = 1, 
	gK
 = 
vbs
.
size
(); j < K; ++j) {

541 
Exessi
* 
	gs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
ex
->
pe
());

542 
	gv
.
t_lol
(
vbs
[
j
], 
s
);

546 
nd_block
(
body
);

549 
	g_ack
.
p_back
();

550 
	gv_ack
.
p_back
();

554 
Smt
* 
	gExnd
::
ݔ
()(
Whe
* 
w
)

556 
Exessi
* 
ed
 = 
w
->
edi
();

557 
Block
* 
	gbody
 = 
w
->
block
();

558 
Env
 
v
(
vmt
(), 
ue
);

559 
	gv_ack
.
push_back
(&
v
);

560 
	g_ack
.
push_back
(
w
);

561 *
	ged
->
rfm
(&
ev
)) {

562 
nd_block
(
body
);

564 
	g_ack
.
p_back
();

565 
	gv_ack
.
p_back
();

569 
Smt
* 
	gExnd
::
ݔ
()(
Ru
* 
r
)

571 
r
("@tu may oy bud wh funi", 
r
->
pe
(), 
backa
());

576 
	gExnd
::
exnd__li
(
Se
* 
s
, 
Se_Li
* 
exnd
) {

578 i(
Se_Li
* 
	g
 = 
dymic_
<Se_Li*>(
s
)) {

579 
Comex_Se
* 
comex_
 : 

->
emts
()) {

580 
Comex_Se
* 

 = 
comex_
;

581 
	g
) {

582 i(
	g
->
hd
()
Sime_Se
* 
	ghd
 : 

->hd()->
emts
()) {

583 i(
dymic_
<
Pt_Se
*>(
hd
=
NULL
) ;

584 
	gd
::
rg
 
l_r
(
comex_
->
to_rg
(
x
.
c_tis
));

585 
r
("C'exnd " + 
l_r
 + ": c'exnds", 
hd
->
pe
(), 
backa
());

587 
	g
 = 

->tail();

593 
Se_Li
* 
	gcڋxtuized
 = 
dymic_
<Se_Li*>(
s
->
rfm
(&
ev
));

594 i(
	gcڋxtuized
 =
NULL
) ;

595 aut
	gcomex_l
 : 
cڋxtuized
->
emts
()) {

596 
Comex_Se
* 
c
 = 
comex_l
;

597 i(!
	gc
->
hd
(|| c->

()) {

598 
	gd
::
rg
 
l_r
(
cڋxtuized
->
to_rg
(
x
.
c_tis
));

599 
r
("C'exnd " + 
l_r
 + ": c'exndeed ses", 
c
->
pe
(), 
backa
());

601 
Compound_Se
* 
	gahd
 = 
c
->
hd
();

602 i(
	gcڋxtuized
->
is_tiڮ
()
	gahd
->is_tiڮ(
ue
);

603 
size_t
 
	gi
 = 0, 
	gL
 = 
exnd
->
ngth
(); i < L; ++i) {

604 
Comex_Se
* 
	gl
 = (*
exnd
)[
i
];

605 i(!(
	gl
->
hd
(&& s->hd()->
ngth
() > 0 &&

606 
	gdymic_
<
	gPt_Se
*>((*
	gl
->
hd
())[0])))

608 
Compound_Se
* 
	ghh
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, (*
exnd
)[
i
]->
pe
());

609 
	ghh
->
med_block
((*
exnd
)[
i
]->media_block());

610 
Comex_Se
* 
	gsl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, (*
exnd
)[
i
]->
pe
());

611 
	gsl
->
med_block
((*
exnd
)[
i
]->media_block());

612 i(
	gl
->
has_le_ed
()
	gsl
->has_le_ed(
ue
);

613 
Pt_Se
* 
	gps
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Pt_Se, (*
exnd
)[
i
]->
pe
());

614 
	gps
->
med_block
((*
exnd
)[
i
]->media_block());

615 *
	ghh
 << 
	gps
;

616 
	gsl
->

(
l
);

617 
	gsl
->
hd
(
hh
);

618 
	gl
 = 
sl
;

621 
	gx
.
	gsubt_m
.
put
(
ahd
->
to_r_vec
(), 
d
::
make_
(
l
,laceholder));

627 
Smt
* 
	gExnd
::
ݔ
()(
Exnsi
* 
e
)

629 i(
Se_Li
* 
exnd
 = 
dymic_
<Se_Li*>(

())) {

630 
Se
* 
s
 = 
e
->

();

631 i(
Se_Schema
* 
	gschema
 = 
dymic_
<Se_Schema*>(
s
)) {

632 i(
schema
->
has__f
()
s
 = 
ev
(schema);

634 i(
Se_Li
* 
	g
 = 
dymic_
<Se_Li*>(
s
)) {

635 
Comex_Se
* 
cs
 : *

) {

636 i(
cs
 !
NULL
 && cs->
hd
() != NULL) {

637 
cs
->
hd
()->
med_block
(
med_block_ack
.
back
());

641 
	g_ack
.
push_back
(0);

642 
exnd__li
(
s
, 
exnd
);

643 
	g_ack
.
p_back
();

648 
Smt
* 
	gExnd
::
ݔ
()(
Defi
* 
d
)

650 
Env
* 
v
 = 
vmt
();

651 
Defi
* 
	gdd
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Defi, *
d
);

652 
	gv
->
lol_ame
()[
d
->
me
() +

653 (
d
->
ty
(=
Defi
::
MIXIN
 ? "[m]" : "[f]")] = 
dd
;

655 i(
	gd
->
ty
(=
Defi
::
FUNCTION
 && (

656 
Px
::
lc__
(
d
->
me
().
c_r
()) ||

657 
d
->
me
() == "element" ||

658 
d
->
me
() == "expression" ||

659 
d
->
me
() == "url"

661 
dd
(

662 "Namg funi \"" + 
d
->
me
() + "\" is disallowed",

664 
d
->
pe
()

670 
	gdd
->
vmt
(
v
);

674 
Smt
* 
	gExnd
::
ݔ
()(
Mix_Cl
* 
c
)

676 
Env
* 
v
 = 
vmt
();

677 
	gd
::
rg
 
fu_me
(
c
->
me
() + "[m]");

678 i(!
	gv
->
has
(
fu_me
)) {

679 
r
("nmixamed " + 
c
->
me
(), c->
pe
(), 
backa
());

681 
Defi
* 
	gdef
 = 
ic_
<Defi*>((*
v
)[
fu_me
]);

682 
Block
* 
	gbody
 = 
def
->
block
();

683 
Pams
* 
	gms
 = 
def
->
ms
();

685 i(
	gc
->
block
(&& c->
me
(!"@cڋ" && !
body
->
has_cڋ
()) {

686 
r
("Mix \"" + 
c
->
me
(+ "\" d۠nهc cڋ block.", c->
pe
(), 
backa
());

688 
Argumts
* 
	ggs
 = 
ic_
<Argumts*>(
c
->
gumts
()

689 ->
rfm
(&
ev
));

690 
Backa
 
w_bt
(
backa
(), 
c
->
pe
(), ", imix `" + c->
me
() + "`");

691 
	gbacka_ack
.
push_back
(&
w_bt
);

692 
Env
 
w_v
(
def
->
vmt
());

693 
	gv_ack
.
push_back
(&
w_v
);

694 i(
	gc
->
block
()) {

696 
Defi
* 
	gthunk
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Definition,

697 
c
->
pe
(),

699 
SASS_MEMORY_NEW
(
x
.
mem
, 
Pams
, 
c
->
pe
()),

700 
c
->
block
(),

701 
Defi
::
MIXIN
);

702 
	gthunk
->
vmt
(
v
);

703 
	gw_v
.
lol_ame
()["@cڋ[m]"] = 
thunk
;

706 
bd
(
d
::
rg
("Mix"), 
c
->
me
(), 
ms
, 
gs
, &
x
, &
w_v
, &
ev
);

707 
nd_block
(
body
);

708 
	gbacka_ack
.
p_back
();

709 
	gv_ack
.
p_back
();

713 
Smt
* 
	gExnd
::
ݔ
()(
Cڋ
* 
c
)

715 
Env
* 
v
 = 
vmt
();

717 i(!
	gv
->
has
("@content[m]"))  0;

718 i(
	gblock_ack
.
back
()->
is_ro
()) {

719 
	g_ack
.
push_back
(0);

721 
Mix_Cl
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Mixin_Call,

722 
c
->
pe
(),

724 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumts
, 
c
->
pe
()));

725 
Smt
* 
	gm
 = 

->
rfm
(
this
);

726 i(
	gblock_ack
.
back
()->
is_ro
()) {

727 
	g_ack
.
p_back
();

729  
	gm
;

733 
le
 
Smt
* 
	gExnd
::
back_im
(
AST_Node
* 
n
)

735 
d
::
rg
 
r
 =d:: sg("`Exnd` dۢ'hd "+ 
tyid
(*
n
).
me
();

736 
Sg_Qued
* 
	gmsg
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, 
PrS
("[WARN]"), 
r
);

737 
r
("unknow;a cڏhLibSasmas", 
n
->
pe
(), 
backa
());

738  
SASS_MEMORY_NEW
(
x
.
mem
, 
Wng
, 
PrS
("[WARN]"), 
msg
);

742 
le
 
	gExnd
::
nd_block
(
Block
* 
b
)

744 i(
b
->
is_ro
()
_ack
.
push_back
(b);

745 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

746 
Smt
* 
	gh
 = (*
b
)[
i
]->
rfm
(
this
);

747 i(
	gh
*
	gblock_ack
.
back
() << ith;

749 i(
	gb
->
is_ro
()
	g_ack
.
p_back
();

	@node_modules/node-sass/src/libsass/src/expand.hpp

1 #ide
SASS_EXPAND_H


2 
	#SASS_EXPAND_H


	)

4 
	~<ve
>

6 
	~"a.h
"

7 
	~"ev.h
"

8 
	~"ݔi.h
"

9 
	~"vmt.h
"

11 
mea
 
	gSass
 {

13 
ass
 
	gLiize
;

14 
ass
 
	gCڋxt
;

15 
ass
 
	gEv
;

16 
	gEnvmt
<
	tAST_Node
*> 
	tEnv
;

17 
	gBacka
;

19 
ass
 
	gExnd
 : 
public
 
Oti_CRTP
<
Smt
*, Expand> {

20 
	gpublic
:

22 
Env
* 
vmt
();

23 
	gCڋxt
& 
cڋxt
();

24 
Se_Li
* 

();

25 
Backa
* 
backa
();

27 
	gCڋxt
& 
	gx
;

28 
Ev
 
	gev
;

31 
	gd
::
ve
<
Env
*> 
v_ack
;

32 
	gd
::
ve
<
Block
*> 
block_ack
;

33 
	gd
::
ve
<
AST_Node
*> 
_ack
;

34 
	gd
::
ve
<
Sg
*> 
ݔty_ack
;

35 
	gd
::
ve
<
Se_Li
*> 
_ack
;

36 
	gd
::
ve
<
Med_Block
*> 
med_block_ack
;

37 
	gd
::
ve
<
Backa
*>
backa_ack
;

38 
bo
 
	g_keyames
;

40 
Smt
* 
back_im
(
AST_Node
* 
n
);

42 
	give
:

43 
exnd__li
(
Se
*, 
Se_Li
* 
exnd
);

45 
	gpublic
:

46 
Exnd
(
Cڋxt
&, 
Env
*, 
Backa
*);

47 ~
Exnd
() { }

49 
Smt
* 
ݔ
()(
	gBlock
*);

50 
Smt
* 
ݔ
()(
	gRuˣt
*);

51 
Smt
* 
ݔ
()(
	gPrݣt
*);

52 
Smt
* 
ݔ
()(
	gMed_Block
*);

53 
Smt
* 
ݔ
()(
	gSuts_Block
*);

54 
Smt
* 
ݔ
()(
	gAt_Ro_Block
*);

55 
Smt
* 
ݔ
()(
	gDeive
*);

56 
Smt
* 
ݔ
()(
	gDei
*);

57 
Smt
* 
ݔ
()(
	gAssignmt
*);

58 
Smt
* 
ݔ
()(
	gImpt
*);

59 
Smt
* 
ݔ
()(
	gImpt_Stub
*);

60 
Smt
* 
ݔ
()(
	gWng
*);

61 
Smt
* 
ݔ
()(
	gE
*);

62 
Smt
* 
ݔ
()(
	gDebug
*);

63 
Smt
* 
ݔ
()(
	gCommt
*);

64 
Smt
* 
ݔ
()(
	gIf
*);

65 
Smt
* 
ݔ
()(
	gF
*);

66 
Smt
* 
ݔ
()(
	gEach
*);

67 
Smt
* 
ݔ
()(
	gWhe
*);

68 
Smt
* 
ݔ
()(
	gRu
*);

69 
Smt
* 
ݔ
()(
	gExnsi
*);

70 
Smt
* 
ݔ
()(
	gDefi
*);

71 
Smt
* 
ݔ
()(
	gMix_Cl
*);

72 
Smt
* 
ݔ
()(
	gCڋ
*);

74 
	gme
 <
tyme
 
	gU
>

75 
Smt
* 
back
(
U
 
x
{  
back_im
(x); }

77 
nd_block
(
Block
*);

	@node_modules/node-sass/src/libsass/src/extend.cpp

1 
	~"ss.h
"

2 
	~"exnd.h
"

3 
	~"cڋxt.h
"

4 
	~"backa.h
"

5 
	~"ths.h
"

6 
	~"rr.h
"

7 
	~"node.h
"

8 
	~"ss_ut.h
"

9 
	~"move_ahds.h
"

10 
	~"debug.h
"

11 
	~<ioam
>

12 
	~<deque
>

13 
	~<t
>

62 
mea
 
	gSass
 {

65 
	gd
::
	t
<
	tComex_Se
*, 
	tCompound_Se
*> 
	tExnsiPa
;

66 
	gd
::
	tve
<
	tExnsiPa
> 
	tSubtMErs
;

68 #ifde
DEBUG


71 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, cڡ 
	gComex_Se
::
Comb
 
comb
) {

72 
comb
) {

73 
Comex_Se
::
ANCESTOR_OF
: 
os
 << "\" \""; ;

74 
	gComex_Se
::
PARENT_OF
: 
os
 << "\">\""; ;

75 
	gComex_Se
::
PRECEDES
: 
os
 << "\"~\""; ;

76 
	gComex_Se
::
ADJACENT_TO
: 
os
 << "\"+\""; ;

77 
	gComex_Se
::
REFERENCE
: 
os
 << "\"/\""; ;

80  
	gos
;

84 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, 
	gCompound_Se
& 
	gcompoundSe
) {

85 
size_t
 
	gi
 = 0, 
	gL
 = 
compoundSe
.
ngth
(); i < L; ++i) {

86 i(
	gi
 > 0
	gos
 << ", ";

87 
	gos
 << 
	gcompoundSe
[
i
]->
to_rg
();

89  
	gos
;

92 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, 
	gSime_Se
& 
	gsimeSe
) {

93 
	gos
 << 
	gsimeSe
.
to_rg
();

94  
	gos
;

98 
tSimeSe
(
Sime_Se
* 
pSimeSe
, cڡ * 
mesge
=
NULL
, 
bo
 
wle
=
ue
) {

100 i(
mesge
) {

101 
d
::

 << 
mesge
;

104 i(
	gpSimeSe
) {

105 
	gd
::

 << "[" << *
pSimeSe
 << "]";

107 
	gd
::

 << "NULL";

110 i(
	gwle
) {

111 
	gd
::

 << 
d
::
dl
;

116 
	gd
::
	t
<
	tCompound_Se
*, 
	tComex_Se
*> 
	tSsNewSeqPa
;

117 
	gd
::
	tve
<
	tSsNewSeqPa
> 
	tSsNewSeqPaCi
;

121 
tCompoundSe
(
Compound_Se
* 
pCompoundSe
, cڡ * 
mesge
=
NULL
, 
bo
 
wle
=
ue
) {

123 i(
mesge
) {

124 
d
::

 << 
mesge
;

127 i(
	gpCompoundSe
) {

128 
	gd
::

 << "[" << *
pCompoundSe
 << "]";

130 
	gd
::

 << "NULL";

133 i(
	gwle
) {

134 
	gd
::

 << 
d
::
dl
;

139 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, 
	gComex_Se
& 
	gcomexSe
) {

141 
	gos
 << "[";

142 
Comex_Se
* 
	gpIr
 = &
comexSe
;

143 
bo
 
	gf
 = 
ue
;

144 
	gpIr
) {

145 i(
	gpIr
->
comb
(!
Comex_Se
::
ANCESTOR_OF
) {

146 i(!
f
) {

147 
os
 << ", ";

149 
	gf
 = 
l
;

150 
	gos
 << 
	gpIr
->
comb
();

153 i(!
	gf
) {

154 
	gos
 << ", ";

156 
	gf
 = 
l
;

158 i(
	gpIr
->
hd
()) {

159 
	gos
 << 
	gpIr
->
hd
()->
to_rg
();

161 
	gos
 << "NULL_HEAD";

164 
	gpIr
 = 
pIr
->

();

166 
	gos
 << "]";

168  
	gos
;

173 
tComexSe
(
Comex_Se
* 
pComexSe
, cڡ * 
mesge
=
NULL
, 
bo
 
wle
=
ue
) {

175 i(
mesge
) {

176 
d
::

 << 
mesge
;

179 i(
	gpComexSe
) {

180 
	gd
::

 << *
pComexSe
;

182 
	gd
::

 << "NULL";

185 i(
	gwle
) {

186 
	gd
::

 << 
d
::
dl
;

190 
tSsNewSeqPaCi
(
SsNewSeqPaCi
& 
ci
, cڡ * 
mesge
=
NULL
, 
bo
 
wle
=
ue
) {

192 i(
mesge
) {

193 
d
::

 << 
mesge
;

195 
bo
 
	gf
 = 
ue
;

196 
	gd
::

 << "[";

197 
	gSsNewSeqPa
& 
	g
 : 
ci
) {

198 i(
f
) {

199 
f
 = 
l
;

201 
	gd
::

 << ", ";

203 
	gd
::

 << "[";

204 
Compound_Se
* 
	gpSs
 = 

.
f
;

205 
Comex_Se
* 
	gpNewSe
 = 

.
cd
;

206 
	gd
::

 << "[" << *
pSs
 << "], ";

207 
tComexSe
(
pNewSe
, 
NULL
, 
l
);

209 
	gd
::

 << "]";

211 i(
	gwle
) {

212 
	gd
::

 << 
d
::
dl
;

217 
tSoursS
(
SoursS
& 
sours
, 
Cڋxt
& 
x
, cڡ * 
mesge
=
NULL
, 
bo
 
wle
=
ue
) {

219 i(
mesge
) {

220 
d
::

 << 
mesge
;

225 
	gd
::
	tdeque
<
	td
::
	trg
> 
	tSourSgs
;

226 
SourSgs
 
	gsourSgs
;

227 
	gSoursS
::

 it = 
sours
.
beg
(), 
	gEnd
 = sours.
d
(); 
	g
 !
End
; ++iterator) {

228 
Comex_Se
* 
	gpSour
 = *

;

229 
	gd
::
rgam
 
sam
;

230 
	gsam
 << 
comexSeToNode
(
pSour
, 
x
);

231 
	gsourSgs
.
push_back
(
sam
.
r
());

235 
	gd
::
st
(
sourSgs
.
beg
(), sourSgs.
d
());

237 
	gd
::

 << "SourcesSet[";

238 
	gSourSgs
::

 it = 
sourSgs
.
beg
(), 
	gEnd
 = sourSgs.
d
(); 
	g
 !
End
; ++iterator) {

239 
	gd
::
rg
 
sour
 = *

;

240 i(
	g
 !
sourSgs
.
beg
()) {

241 
d
::

 << ", ";

243 
	gd
::

 << 
sour
;

245 
	gd
::

 << "]";

247 i(
	gwle
) {

248 
	gd
::

 << 
d
::
dl
;

253 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, 
	gSubtMErs
& 
	gs
) {

254 
	gos
 << "SUBSET_MAP_ENTRIES[";

256 
	gSubtMErs
::

 it = 
s
.
beg
(), 
	gdIt
 =rs.
d
(); 
	g
 !
dIt
; ++iterator) {

257 
Comex_Se
* 
	gpExtComexSe
 = 

->
f
;

258 
Compound_Se
* 
	gpExtCompoundSe
 = 

->
cd
;

260 i(
	g
 !
s
.
beg
()) {

261 
os
 << ", ";

264 
	gos
 << "(";

266 i(
	gpExtComexSe
) {

267 
	gd
::

 << *
pExtComexSe
;

269 
	gd
::

 << "NULL";

272 
	gos
 << " -> ";

274 i(
	gpExtCompoundSe
) {

275 
	gd
::

 << *
pExtCompoundSe
;

277 
	gd
::

 << "NULL";

280 
	gos
 << ")";

284 
	gos
 << "]";

286  
	gos
;

290 
bo
 
Sur
(
Comex_Se
* 
pO
, Comex_Se* 
pTwo
, 
Cڋxt
& 
x
) {

293 
Posi
 
noPosi
(-1, -1, -1);

294 
Ty_Se
 
kePt
(
PrS
("[FAKE]"), "temp");

295 
Compound_Se
 
keHd
(
PrS
("[FAKE]"), 1 );

296 
	gkeHd
.
emts
().
push_back
(&
kePt
);

297 
Comex_Se
 
kePtCڏ
(
PrS
("[FAKE]"), Comex_Se::
ANCESTOR_OF
, &
keHd
 , 
NULL
 );

299 
	gpO
->
t_rmo
(&
kePtCڏ
, 
Comex_Se
::
ANCESTOR_OF
);

300 
	gpTwo
->
t_rmo
(&
kePtCڏ
, 
Comex_Se
::
ANCESTOR_OF
);

302 
bo
 
	gisSur
 = 
pO
->
is_sur_of
(
pTwo
);

304 
	gpO
->
r_rmo
();

305 
	gpTwo
->
r_rmo
();

307  
	gisSur
;

310 
nodeToComexSeDeque
(cڡ 
Node
& 
node
, 
ComexSeDeque
& 
out
, 
Cڋxt
& 
x
) {

311 
	gNodeDeque
::

 

 = 
node
.
ci
()->
beg
(), 
	gEnd
 =ode.ci()->
d
(); 
	g
 !
End
; iter++) {

312 
	gNode
& 
	gchd
 = *

;

313 
	gout
.
push_back
(
nodeToComexSe
(
chd
, 
x
));

317 
Node
 
comexSeDequeToNode
(cڡ 
ComexSeDeque
& 
deque
, 
Cڋxt
& 
x
) {

318 
Node
 
	gsu
 = Node::
Ci
();

320 
	gComexSeDeque
::
cڡ_
 

 = 
deque
.
beg
(), 
	gEnd
 = deque.
d
(); 
	g
 !
End
; iter++) {

321 
Comex_Se
* 
	gpChd
 = *

;

322 
	gsu
.
ci
()->
push_back
(
comexSeToNode
(
pChd
, 
x
));

325  
	gsu
;

328 as
	cLcsCiComt
 {

329 
	gpublic
:

330 
LcsCiComt
(
Cڋxt
& 
x
: 
mCtx
(ctx) {}

332 
Cڋxt
& 
mCtx
;

334 
bo
 
ݔ
()(
Comex_Se
* 
	gpO
, Comex_Se* 
	gpTwo
, 
	gComex_Se
*& 
	gpOut
) const {

345 i(
s_equ
(*
pO
, *
pTwo
, 
ue
 )) {

346 
	gpOut
 = 
pO
;

347  
	gue
;

350 i(
	gpO
->
comb
(!
Comex_Se
::
ANCESTOR_OF
 || 
pTwo
->combinator() != Complex_Selector::ANCESTOR_OF) {

351  
l
;

354 i(
Sur
(
pO
, 
pTwo
, 
mCtx
)) {

355 
	gpOut
 = 
pTwo
;

356  
	gue
;

359 i(
Sur
(
pTwo
, 
pO
, 
mCtx
)) {

360 
	gpOut
 = 
pO
;

361  
	gue
;

364  
	gl
;

375 
	$lcs_backa
(cڡ 
LCSTab
& 
c
, 
ComexSeDeque
& 
x
, ComexSeDeque& 
y
, 
i
, 
j
, cڡ 
LcsCiComt
& 
comt
, ComexSeDeque& 
out
) {

379 i(
i
 =0 || 
j
 == 0) {

380 
	`DEBUG_PRINTLN
(
LCS
, "RETURNING EMPTY")

385 
Comex_Se
* 
pComOut
 = 
NULL
;

386 i(
	`comt
(
x
[
i
], 
y
[
j
], 
pComOut
)) {

387 
	`DEBUG_PRINTLN
(
LCS
, "RETURNING AFTER ELEM COMPARE")

388 
	`lcs_backa
(
c
, 
x
, 
y
, 
i
 - 1, 
j
 - 1, 
comt
, 
out
);

389 
out
.
	`push_back
(
pComOut
);

393 i(
c
[
i
][
j
 - 1] > c[i - 1][j]) {

394 
	`DEBUG_PRINTLN
(
LCS
, "RETURNING AFTER TABLE COMPARE")

395 
	`lcs_backa
(
c
, 
x
, 
y
, 
i
, 
j
 - 1, 
comt
, 
out
);

399 
	`DEBUG_PRINTLN
(
LCS
, "FINAL RETURN")

400 
	`lcs_backa
(
c
, 
x
, 
y
, 
i
 - 1, 
j
, 
comt
, 
out
);

402 
	}
}

410 
	$lcs_b
(cڡ 
ComexSeDeque
& 
x
, cڡ ComexSeDeque& 
y
, cڡ 
LcsCiComt
& 
comt
, 
LCSTab
& 
out
) {

414 
LCSTab
 
	`c
(
x
.
	`size
(), 
d
::
ve
<>(
y
.size()));

420 
size_t
 
i
 = 1; i < 
x
.
	`size
(); i++) {

421 
size_t
 
j
 = 1; j < 
y
.
	`size
(); j++) {

422 
Comex_Se
* 
pComOut
 = 
NULL
;

424 i(
	`comt
(
x
[
i
], 
y
[
j
], 
pComOut
)) {

425 
c
[
i
][
j
] = c[i - 1][j - 1] + 1;

427 
c
[
i
][
j
] = 
d
::
	`max
(c[i][j - 1], c[i - 1][j]);

432 
out
 = 
c
;

433 
	}
}

449 
	$lcs
(
ComexSeDeque
& 
x
, ComexSeDeque& 
y
, cڡ 
LcsCiComt
& 
comt
, 
Cڋxt
& 
x
, ComexSeDeque& 
out
) {

453 
x
.
	`push_t
(
NULL
);

454 
y
.
	`push_t
(
NULL
);

456 
LCSTab
 
b
;

457 
	`lcs_b
(
x
, 
y
, 
comt
, 
b
);

459  
	`lcs_backa
(
b
, 
x
, 
y
, 
ic_
<>(x.
	`size
()- 1, stic_<>(y.size()- 1, 
comt
, 
out
);

460 
	}
}

529 
Node
 
	$im
(
Node
& 
qs
, 
Cڋxt
& 
x
, 
bo
 
isR
) {

533 i(
qs
.
	`ci
()->
	`size
() > 100) {

534  
qs
;

538 
	`DEBUG_PRINTLN
(
TRIM
, "TRIM: " << 
qs
)

541 
Node
 
su
 = Node::
	`Ci
();

542 
su
.
	`us
(
qs
);

544 
	`DEBUG_PRINTLN
(
TRIM
, "RESULT INITIAL: " << 
su
)

549 
toTrimIndex
 = 0;

551 
NodeDeque
::

 
qsIr
 = 
qs
.
	`ci
()->
	`beg
(), 
qsIrEnd
 = seqs.ci()->
	`d
(); seqsesIter != seqsesIterEnd; ++seqsesIter) {

552 
Node
& 
qs1
 = *
qsIr
;

554 
	`DEBUG_PRINTLN
(
TRIM
, "SEQS1: " << 
qs1
 << " " << 
toTrimIndex
)

556 
Node
 
mpResu
 = Node::
	`Ci
();

557 
mpResu
.
g_le_ed
 = 
qs1
.got_line_feed;

559 
NodeDeque
::

 
qs1Ir
 = 
qs1
.
	`ci
()->
	`beg
(), 
qs1EndIr
 = seqs1.ci()->
	`d
(); seqs1Iter != seqs1EndIter; ++seqs1Iter) {

560 
Node
& 
q1
 = *
qs1Ir
;

562 
Comex_Se
* 
pSeq1
 = 
	`nodeToComexSe
(
q1
, 
x
);

572 
maxScificy
 = 
isR
 ? 
pSeq1
->
	`ecificy
() : 0;

573 
SoursS
 
sours
 = 
pSeq1
->
	`sours
();

575 
	`DEBUG_PRINTLN
(
TRIM
, "TRIM SEQ1: " << 
q1
)

576 
	`DEBUG_EXEC
(
TRIM
, 
	`tSoursS
(
sours
, 
x
, "TRIM SOURCES: "))

578 
SoursS
::

 
soursSIt
 = 
sours
.
	`beg
(), 
soursSItEnd
 = sours.
	`d
(); sourcesSetIterator != sourcesSetIteratorEnd; ++sourcesSetIterator) {

579 cڡ 
Comex_Se
* cڡ 
pCutSe
 = *
soursSIt
;

580 
maxScificy
 = 
d
::
	`max
(maxScificy, 
pCutSe
->
	`ecificy
());

583 
	`DEBUG_PRINTLN
(
TRIM
, "MAX SPECIFICITY: " << 
maxScificy
)

585 
bo
 
isMeScificOur
 = 
l
;

587 
suIndex
 = 0;

589 
NodeDeque
::

 
suIr
 = 
su
.
	`ci
()->
	`beg
(), 
suIrEnd
 =esu.ci()->
	`d
();esultIter !=esultIterEnd; ++resultIter) {

590 
Node
& 
qs2
 = *
suIr
;

592 
	`DEBUG_PRINTLN
(
TRIM
, "SEQS1: " << 
qs1
)

593 
	`DEBUG_PRINTLN
(
TRIM
, "SEQS2: " << 
qs2
)

599 i(
qs1
.
	`ci
(=
qs2
.collection()) {

600 
	`DEBUG_PRINTLN
(
TRIM
, "CONTINUE")

604 
bo
 
isMeScificI
 = 
l
;

606 
NodeDeque
::

 
qs2Ir
 = 
qs2
.
	`ci
()->
	`beg
(), 
qs2IrEnd
 = seqs2.ci()->
	`d
(); seqs2Iter != seqs2IterEnd; ++seqs2Iter) {

607 
Node
& 
q2
 = *
qs2Ir
;

609 
Comex_Se
* 
pSeq2
 = 
	`nodeToComexSe
(
q2
, 
x
);

611 
	`DEBUG_PRINTLN
(
TRIM
, "SEQ2 SPEC: " << 
pSeq2
->
	`ecificy
())

612 
	`DEBUG_PRINTLN
(
TRIM
, "IS SPEC: " << 
pSeq2
->
	`ecificy
(<< " >" << 
maxScificy
 << " " << (pSeq2->specificity() >= maxSpecificity ? "true" : "false"))

613 
	`DEBUG_PRINTLN
(
TRIM
, "IS SUPER: " << (
pSeq2
->
	`is_sur_of
(
pSeq1
) ? "true" : "false"))

615 
isMeScificI
 = 
pSeq2
->
	`ecificy
(>
maxScificy
 &&Seq2->
	`is_sur_of
(
pSeq1
);

617 i(
isMeScificI
) {

618 
	`DEBUG_PRINTLN
(
TRIM
, "FOUND MORE SPECIFIC")

624 i(
isMeScificI
) {

625 
isMeScificOur
 = 
ue
;

629 
suIndex
++;

632 i(!
isMeScificOur
) {

633 
	`DEBUG_PRINTLN
(
TRIM
, "PUSHING: " << 
q1
)

634 
mpResu
.
	`ci
()->
	`push_back
(
q1
);

639 
	`DEBUG_PRINTLN
(
TRIM
, "RESULT BEFORE ASSIGN: " << 
su
)

640 
	`DEBUG_PRINTLN
(
TRIM
, "TEMP RESULT: " << 
toTrimIndex
 << " " << 
mpResu
)

641 (*
su
.
	`ci
())[
toTrimIndex
] = 
mpResu
;

643 
toTrimIndex
++;

645 
	`DEBUG_PRINTLN
(
TRIM
, "RESULT: " << 
su
)

648  
su
;

649 
	}
}

653 
bo
 
	$Sur
(cڡ 
Node
& 
e
, cڡ Node& 
two
, 
Cڋxt
& 
x
) {

656 
Posi
 
	`noPosi
(-1, -1, -1);

657 
Ty_Se
 
	`kePt
(
	`PrS
("[FAKE]"), "temp");

658 
Compound_Se
 
	`keHd
(
	`PrS
("[FAKE]"), 1 );

659 
keHd
.
	`emts
().
	`push_back
(&
kePt
);

660 
Comex_Se
 
	`kePtCڏ
(
	`PrS
("[FAKE]"), Comex_Se::
ANCESTOR_OF
, &
keHd
 , 
NULL
 );

662 
Comex_Se
* 
pOWhFakePt
 = 
	`nodeToComexSe
(
e
, 
x
);

663 
pOWhFakePt
->
	`t_rmo
(&
kePtCڏ
, 
Comex_Se
::
ANCESTOR_OF
);

664 
Comex_Se
* 
pTwoWhFakePt
 = 
	`nodeToComexSe
(
two
, 
x
);

665 
pTwoWhFakePt
->
	`t_rmo
(&
kePtCڏ
, 
Comex_Se
::
ANCESTOR_OF
);

667  
pOWhFakePt
->
	`is_sur_of
(
pTwoWhFakePt
);

668 
	}
}

671 as
	cPtSurChunk
 {

672 
	gpublic
:

673 
PtSurChunk
(
Node
& 
lcs
, 
Cڋxt
& 
x
: 
mLcs
cs), 
mCtx
(ctx) {}

674 
	gNode
& 
	gmLcs
;

675 
	gCڋxt
& 
	gmCtx
;

677 
bo
 
ݔ
()(cڡ 
	gNode
& 
	gq
) const {

679 i(
	gq
.
ci
()->
size
(=0 
l
;

680  
Sur
(
q
.
ci
()->
t
(), 
mLcs
.ci()->t(), 
mCtx
);

684 as
	cSubwveEmyChunk
 {

685 
	gpublic
:

686 
bo
 
ݔ
()(cڡ 
Node
& 
q
) const {

689  
q
.
ci
()->
emy
();

725 
	gme
<
tyme
 
	gChunkTy
>

726 
Node
 
	$chunks
(
Node
& 
q1
, Node& 
q2
, cڡ 
ChunkTy
& 
chunk
) {

727 
Node
 
chunk1
 = Node::
	`Ci
();

728 
q1
.
	`ci
()->
	`size
(&& !
	`chunk
(seq1)) {

729 
chunk1
.
	`ci
()->
	`push_back
(
q1
.ci()->
	`t
());

730 
q1
.
	`ci
()->
	`p_t
();

733 
Node
 
chunk2
 = Node::
	`Ci
();

734 !
	`chunk
(
q2
)) {

735 
chunk2
.
	`ci
()->
	`push_back
(
q2
.ci()->
	`t
());

736 
q2
.
	`ci
()->
	`p_t
();

739 i(
chunk1
.
	`ci
()->
	`emy
(&& 
chunk2
.collection()->empty()) {

740 
	`DEBUG_PRINTLN
(
CHUNKS
, "RETURNING BOTH EMPTY")

741  
Node
::
	`Ci
();

744 i(
chunk1
.
	`ci
()->
	`emy
()) {

745 
Node
 
chunk2W
 = Node::
	`Ci
();

746 
chunk2W
.
	`ci
()->
	`push_back
(
chunk2
);

747 
	`DEBUG_PRINTLN
(
CHUNKS
, "RETURNING ONE EMPTY")

748  
chunk2W
;

751 i(
chunk2
.
	`ci
()->
	`emy
()) {

752 
Node
 
chunk1W
 = Node::
	`Ci
();

753 
chunk1W
.
	`ci
()->
	`push_back
(
chunk1
);

754 
	`DEBUG_PRINTLN
(
CHUNKS
, "RETURNING TWO EMPTY")

755  
chunk1W
;

758 
Node
 
rms
 = Node::
	`Ci
();

760 
Node
 
fPmuti
 = Node::
	`Ci
();

761 
fPmuti
.
	`ci
()->
	`
(fPmuti.ci()->
	`d
(), 
chunk1
.ci()->
	`beg
(), chunk1.collection()->end());

762 
fPmuti
.
	`ci
()->
	`
(fPmuti.ci()->
	`d
(), 
chunk2
.ci()->
	`beg
(), chunk2.collection()->end());

763 
rms
.
	`ci
()->
	`push_back
(
fPmuti
);

765 
Node
 
cdPmuti
 = Node::
	`Ci
();

766 
cdPmuti
.
	`ci
()->
	`
(cdPmuti.ci()->
	`d
(), 
chunk2
.ci()->
	`beg
(), chunk2.collection()->end());

767 
cdPmuti
.
	`ci
()->
	`
(cdPmuti.ci()->
	`d
(), 
chunk1
.ci()->
	`beg
(), chunk1.collection()->end());

768 
rms
.
	`ci
()->
	`push_back
(
cdPmuti
);

770 
	`DEBUG_PRINTLN
(
CHUNKS
, "RETURNING PERM")

772  
rms
;

773 
	}
}

776 
Node
 
	$groupSes
(
Node
& 
q
, 
Cڋxt
& 
x
) {

777 
Node
 
wSeq
 = Node::
	`Ci
();

779 
Node
 

 = Node::
	`Ci
();

780 

.
	`us
(
q
);

782 !

.
	`ci
()->
	`emy
()) {

783 
Node
 
hd
 = Node::
	`Ci
();

786 
hd
.
	`ci
()->
	`push_back
(

.ci()->
	`t
());

787 

.
	`ci
()->
	`p_t
();

788 } !

.
	`ci
()->
	`emy
(&& (
hd
.ci()->
	`back
().
	`isComb
(||a.ci()->
	`t
().isCombinator()));

790 
wSeq
.
	`ci
()->
	`push_back
(
hd
);

793  
wSeq
;

794 
	}
}

797 
	$gAndRemoveInlOps
(
Node
& 
q
, Node& 
s
) {

798 
NodeDeque
& 
qCi
 = *(
q
.
	`ci
());

799 
NodeDeque
& 
sCi
 = *(
s
.
	`ci
());

801 
qCi
.
	`size
(> 0 && seqCi.
	`t
().
	`isComb
()) {

802 
sCi
.
	`push_back
(
qCi
.
	`t
());

803 
qCi
.
	`p_t
();

805 
	}
}

808 
	$gAndRemoveFOps
(
Node
& 
q
, Node& 
s
) {

809 
NodeDeque
& 
qCi
 = *(
q
.
	`ci
());

810 
NodeDeque
& 
sCi
 = *(
s
.
	`ci
());

812 
qCi
.
	`size
(> 0 && seqCi.
	`back
().
	`isComb
()) {

813 
sCi
.
	`push_back
(
qCi
.
	`back
());

814 
qCi
.
	`p_back
();

816 
	}
}

836 
Node
 
	$mgeInlOps
(
Node
& 
q1
, Node& 
q2
, 
Cڋxt
& 
x
) {

837 
Node
 
s1
 = Node::
	`Ci
();

838 
Node
 
s2
 = Node::
	`Ci
();

840 
	`gAndRemoveInlOps
(
q1
, 
s1
);

841 
	`gAndRemoveInlOps
(
q2
, 
s2
);

849 
DeuLcsComt
 
lcsDeuComt
;

850 
Node
 
sLcs
 = 
	`lcs
(
s1
, 
s2
, 
lcsDeuComt
, 
x
);

852 i(!(
sLcs
 =
s1
 || opsLc=
s2
)) {

853  
Node
::
	`N
();

859  (
s1
.
	`ci
()->
	`size
(> 
s2
.collection()->size() ? ops1 : ops2);

860 
	}
}

927 
Node
 
	$mgeFOps
(
Node
& 
q1
, Node& 
q2
, 
Cڋxt
& 
x
, Node& 
s
) {

929 
Node
 
s1
 = Node::
	`Ci
();

930 
Node
 
s2
 = Node::
	`Ci
();

932 
	`gAndRemoveFOps
(
q1
, 
s1
);

933 
	`gAndRemoveFOps
(
q2
, 
s2
);

939 i(
s1
.
	`ci
()->
	`emy
(&& 
s2
.collection()->empty()) {

940  
s
;

943 i(
s1
.
	`ci
()->
	`size
(> 1 || 
s2
.collection()->size() > 1) {

944 
DeuLcsComt
 
lcsDeuComt
;

945 
Node
 
sLcs
 = 
	`lcs
(
s1
, 
s2
, 
lcsDeuComt
, 
x
);

949 i(!(
sLcs
 =
s1
 || opsLc=
s2
)) {

950  
Node
::
	`N
();

953 i(
s1
.
	`ci
()->
	`size
(> 
s2
.collection()->size()) {

954 
s
.
	`ci
()->
	`
es.ci()->
	`beg
(), 
s1
.ci()->
	`rbeg
(), ops1.ci()->
	`nd
());

956 
s
.
	`ci
()->
	`
es.ci()->
	`beg
(), 
s2
.ci()->
	`rbeg
(), ops2.ci()->
	`nd
());

959  
s
;

962 i(!
s1
.
	`ci
()->
	`emy
(&& !
s2
.collection()->empty()) {

964 
Node
 
1
 = 
s1
.
	`ci
()->
	`t
();

965 
Node
 
2
 = 
s2
.
	`ci
()->
	`t
();

967 
Node
 
l1
 = 
q1
.
	`ci
()->
	`back
();

968 
q1
.
	`ci
()->
	`p_back
();

970 
Node
 
l2
 = 
q2
.
	`ci
()->
	`back
();

971 
q2
.
	`ci
()->
	`p_back
();

973 i(
1
.
	`comb
(=
Comex_Se
::
PRECEDES
 && 
2
.combinator() == Complex_Selector::PRECEDES) {

975 i(
l1
.
	`
()->
	`is_sur_of
(
l2
.selector())) {

977 
s
.
	`ci
()->
	`push_t
(
1
 );

978 
s
.
	`ci
()->
	`push_t
(
l2
);

980 } i(
l2
.
	`
()->
	`is_sur_of
(
l1
.selector())) {

982 
s
.
	`ci
()->
	`push_t
(
1
 );

983 
s
.
	`ci
()->
	`push_t
(
l1
);

987 
	`DEBUG_PRINTLN
(
ALL
, "l1: " << 
l1
)

988 
	`DEBUG_PRINTLN
(
ALL
, "l2: " << 
l2
)

990 
Comex_Se
* 
pMgedW
 = 
l1
.
	`
()->
	`e
(
x
);

992 
Compound_Se
* 
pMged
 = 
l1
.
	`
()->
	`hd
()->
	`unify_wh
(
l2
.()->hd(), 
x
);

993 
pMgedW
->
	`hd
(
pMged
);

995 
	`DEBUG_EXEC
(
ALL
, 
	`tCompoundSe
(
pMged
, "MERGED: "))

997 
Node
 
wRes
 = Node::
	`Ci
();

999 
Node
 
fPm
 = Node::
	`Ci
();

1000 
fPm
.
	`ci
()->
	`push_back
(
l1
);

1001 
fPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
PRECEDES
));

1002 
fPm
.
	`ci
()->
	`push_back
(
l2
);

1003 
fPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
PRECEDES
));

1004 
wRes
.
	`ci
()->
	`push_back
(
fPm
);

1006 
Node
 
cdPm
 = Node::
	`Ci
();

1007 
cdPm
.
	`ci
()->
	`push_back
(
l2
);

1008 
cdPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
PRECEDES
));

1009 
cdPm
.
	`ci
()->
	`push_back
(
l1
);

1010 
cdPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
PRECEDES
));

1011 
wRes
.
	`ci
()->
	`push_back
(
cdPm
);

1013 i(
pMged
) {

1014 
Node
 
mgedPm
 = Node::
	`Ci
();

1015 
mgedPm
.
	`ci
()->
	`push_back
(
Node
::
	`Se
(
pMgedW
, 
x
));

1016 
mgedPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
PRECEDES
));

1017 
wRes
.
	`ci
()->
	`push_back
(
mgedPm
);

1020 
s
.
	`ci
()->
	`push_t
(
wRes
);

1022 
	`DEBUG_PRINTLN
(
ALL
, "RESULT: " << 
s
)

1026 } i(((
1
.
	`comb
(=
Comex_Se
::
PRECEDES
 && 
2
.comb(=Comex_Se::
ADJACENT_TO
)) || ((op1.combinator() == Complex_Selector::ADJACENT_TO && op2.combinator() == Complex_Selector::PRECEDES))) {

1028 
Node
 
tdeS
 = 
l1
;

1029 
Node
 
tdeOp
 = 
1
;

1030 
Node
 
usS
 = 
l2
;

1031 
Node
 
usOp
 = 
2
;

1032 i(
1
.
	`comb
(!
Comex_Se
::
PRECEDES
) {

1033 
tdeS
 = 
l2
;

1034 
tdeOp
 = 
2
;

1035 
usS
 = 
l1
;

1036 
usOp
 = 
1
;

1039 i(
tdeS
.
	`
()->
	`is_sur_of
(
usS
.selector())) {

1041 
s
.
	`ci
()->
	`push_t
(
usOp
);

1042 
s
.
	`ci
()->
	`push_t
(
usS
);

1046 
	`DEBUG_PRINTLN
(
ALL
, "PLUS SEL: " << 
usS
)

1047 
	`DEBUG_PRINTLN
(
ALL
, "TILDE SEL: " << 
tdeS
)

1049 
Comex_Se
* 
pMgedW
 = 
usS
.
	`
()->
	`e
(
x
);

1051 
Compound_Se
* 
pMged
 = 
usS
.
	`
()->
	`hd
()->
	`unify_wh
(
tdeS
.()->hd(), 
x
);

1052 
pMgedW
->
	`hd
(
pMged
);

1054 
	`DEBUG_EXEC
(
ALL
, 
	`tCompoundSe
(
pMged
, "MERGED: "))

1056 
Node
 
wRes
 = Node::
	`Ci
();

1058 
Node
 
fPm
 = Node::
	`Ci
();

1059 
fPm
.
	`ci
()->
	`push_back
(
tdeS
);

1060 
fPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
PRECEDES
));

1061 
fPm
.
	`ci
()->
	`push_back
(
usS
);

1062 
fPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
ADJACENT_TO
));

1063 
wRes
.
	`ci
()->
	`push_back
(
fPm
);

1065 i(
pMged
) {

1066 
Node
 
mgedPm
 = Node::
	`Ci
();

1067 
mgedPm
.
	`ci
()->
	`push_back
(
Node
::
	`Se
(
pMgedW
, 
x
));

1068 
mgedPm
.
	`ci
()->
	`push_back
(
Node
::
	`Comb
(
Comex_Se
::
ADJACENT_TO
));

1069 
wRes
.
	`ci
()->
	`push_back
(
mgedPm
);

1072 
s
.
	`ci
()->
	`push_t
(
wRes
);

1074 
	`DEBUG_PRINTLN
(
ALL
, "RESULT: " << 
s
)

1077 } i(
1
.
	`comb
(=
Comex_Se
::
PARENT_OF
 && (
2
.comb(=Comex_Se::
PRECEDES
 || op2.comb(=Comex_Se::
ADJACENT_TO
)) {

1079 
s
.
	`ci
()->
	`push_t
(
2
);

1080 
s
.
	`ci
()->
	`push_t
(
l2
);

1082 
q1
.
	`ci
()->
	`push_back
(
l1
);

1083 
q1
.
	`ci
()->
	`push_back
(
1
);

1085 } i(
2
.
	`comb
(=
Comex_Se
::
PARENT_OF
 && (
1
.comb(=Comex_Se::
PRECEDES
 || op1.comb(=Comex_Se::
ADJACENT_TO
)) {

1087 
s
.
	`ci
()->
	`push_t
(
1
);

1088 
s
.
	`ci
()->
	`push_t
(
l1
);

1090 
q2
.
	`ci
()->
	`push_back
(
l2
);

1091 
q2
.
	`ci
()->
	`push_back
(
2
);

1093 } i(
1
.
	`comb
(=
2
.combinator()) {

1095 
	`DEBUG_PRINTLN
(
ALL
, "l1: " << 
l1
)

1096 
	`DEBUG_PRINTLN
(
ALL
, "l2: " << 
l2
)

1098 
Comex_Se
* 
pMgedW
 = 
l1
.
	`
()->
	`e
(
x
);

1100 
Compound_Se
* 
pMged
 = 
l1
.
	`
()->
	`hd
()->
	`unify_wh
(
l2
.()->hd(), 
x
);

1101 
pMgedW
->
	`hd
(
pMged
);

1103 
	`DEBUG_EXEC
(
ALL
, 
	`tCompoundSe
(
pMged
, "MERGED: "))

1105 i(!
pMged
) {

1106  
Node
::
	`N
();

1109 
s
.
	`ci
()->
	`push_t
(
1
);

1110 
s
.
	`ci
()->
	`push_t
(
Node
::
	`Se
(
pMgedW
, 
x
));

1112 
	`DEBUG_PRINTLN
(
ALL
, "RESULT: " << 
s
)

1115  
Node
::
	`N
();

1118  
	`mgeFOps
(
q1
, 
q2
, 
x
, 
s
);

1120 } i(!
s1
.
	`ci
()->
	`emy
()) {

1122 
Node
 
1
 = 
s1
.
	`ci
()->
	`t
();

1124 i(
1
.
	`comb
(=
Comex_Se
::
PARENT_OF
 && !
q2
.
	`ci
()->
	`emy
(&& seq2.ci()->
	`back
().
	`
()->
	`is_sur_of
(
q1
.collection()->back().selector())) {

1125 
q2
.
	`ci
()->
	`p_back
();

1129 
s
.
	`ci
()->
	`push_t
(
1
);

1130 
s
.
	`ci
()->
	`push_t
(
q1
.ci()->
	`back
());

1131 
q1
.
	`ci
()->
	`p_back
();

1133  
	`mgeFOps
(
q1
, 
q2
, 
x
, 
s
);

1137 
Node
 
2
 = 
s2
.
	`ci
()->
	`t
();

1139 i(
2
.
	`comb
(=
Comex_Se
::
PARENT_OF
 && !
q1
.
	`ci
()->
	`emy
(&& seq1.ci()->
	`back
().
	`
()->
	`is_sur_of
(
q2
.collection()->back().selector())) {

1140 
q1
.
	`ci
()->
	`p_back
();

1143 
s
.
	`ci
()->
	`push_t
(
2
);

1144 
s
.
	`ci
()->
	`push_t
(
q2
.ci()->
	`back
());

1145 
q2
.
	`ci
()->
	`p_back
();

1147  
	`mgeFOps
(
q1
, 
q2
, 
x
, 
s
);

1151 
	}
}

1190 
Node
 
	gExnd
::
	$subwve
(
Node
& 
e
, Node& 
two
, 
Cڋxt
& 
x
) {

1192 i(
e
.
	`ci
()->
	`size
() == 0) {

1193 
Node
 
out
 = Node::
	`Ci
();

1194 
out
.
	`ci
()->
	`push_back
(
two
);

1195  
out
;

1197 i(
two
.
	`ci
()->
	`size
() == 0) {

1198 
Node
 
out
 = Node::
	`Ci
();

1199 
out
.
	`ci
()->
	`push_back
(
e
);

1200  
out
;

1205 
Node
 
q1
 = Node::
	`Ci
();

1206 
q1
.
	`us
(
e
);

1207 
Node
 
q2
 = Node::
	`Ci
();

1208 
q2
.
	`us
(
two
);

1210 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "SUBWEAVE ONE: " << 
q1
)

1211 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "SUBWEAVE TWO: " << 
q2
)

1213 
Node
 

 = 
	`mgeInlOps
(
q1
, 
q2
, 
x
);

1214 i(

.
	`isN
()) {

1215  
Node
::
	`N
();

1218 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "INIT: " << 

)

1220 
Node
 
s
 = Node::
	`Ci
();

1221 
Node
 
f
 = 
	`mgeFOps
(
q1
, 
q2
, 
x
, 
s
);

1222 i(
f
.
	`isN
()) {

1223  
Node
::
	`N
();

1226 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "FIN: " << 
f
)

1232 
NodeDeque
::

 
fIr
 = 
f
.
	`ci
()->
	`beg
(), 
fEndIr
 = f.ci()->
	`d
();

1233 
fIr
 !
fEndIr
; ++finIter) {

1235 
Node
& 
chdNode
 = *
fIr
;

1237 i(!
chdNode
.
	`isCi
()) {

1238 
Node
 
w
 = Node::
	`Ci
();

1239 
w
.
	`ci
()->
	`push_back
(
chdNode
);

1240 
chdNode
 = 
w
;

1245 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "FIN MAPPED: " << 
f
)

1249 
Node
 
groupSeq1
 = 
	`groupSes
(
q1
, 
x
);

1250 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "SEQ1: " << 
groupSeq1
)

1252 
Node
 
groupSeq2
 = 
	`groupSes
(
q2
, 
x
);

1253 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "SEQ2: " << 
groupSeq2
)

1256 
ComexSeDeque
 
groupSeq1Cvd
;

1257 
	`nodeToComexSeDeque
(
groupSeq1
, 
groupSeq1Cvd
, 
x
);

1259 
ComexSeDeque
 
groupSeq2Cvd
;

1260 
	`nodeToComexSeDeque
(
groupSeq2
, 
groupSeq2Cvd
, 
x
);

1262 
ComexSeDeque
 
out
;

1263 
LcsCiComt
 
	`ciComt
(
x
);

1264 
	`lcs
(
groupSeq2Cvd
, 
groupSeq1Cvd
, 
ciComt
, 
x
, 
out
);

1265 
Node
 
qLcs
 = 
	`comexSeDequeToNode
(
out
, 
x
);

1267 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "SEQLCS: " << 
qLcs
)

1270 
Node
 
W
 = Node::
	`Ci
();

1271 
W
.
	`ci
()->
	`push_back
(

);

1272 
Node
 
diff
 = Node::
	`Ci
();

1273 
diff
.
	`ci
()->
	`push_back
(
W
);

1275 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "DIFF INIT: " << 
diff
)

1278 !
qLcs
.
	`ci
()->
	`emy
()) {

1279 
PtSurChunk
 
	`surChunk
(
qLcs
, 
x
);

1280 
Node
 
chunksResu
 = 
	`chunks
(
groupSeq1
, 
groupSeq2
, 
surChunk
);

1281 
diff
.
	`ci
()->
	`push_back
(
chunksResu
);

1283 
Node
 
lcsW
 = Node::
	`Ci
();

1284 
lcsW
.
	`ci
()->
	`push_back
(
qLcs
.ci()->
	`t
());

1285 
qLcs
.
	`ci
()->
	`p_t
();

1286 
diff
.
	`ci
()->
	`push_back
(
lcsW
);

1288 i(
groupSeq1
.
	`ci
()->
	`size
()groupSeq1.ci()->
	`p_t
();

1289 i(
groupSeq2
.
	`ci
()->
	`size
()groupSeq2.ci()->
	`p_t
();

1292 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "DIFF POST LCS: " << 
diff
)

1295 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "CHUNKS: ONE=" << 
groupSeq1
 << " TWO=" << 
groupSeq2
)

1298 
SubwveEmyChunk
 
emyChunk
;

1299 
Node
 
chunksResu
 = 
	`chunks
(
groupSeq1
, 
groupSeq2
, 
emyChunk
);

1300 
diff
.
	`ci
()->
	`push_back
(
chunksResu
);

1303 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "DIFF POST CHUNKS: " << 
diff
)

1306 
diff
.
	`ci
()->
	`
(diff.ci()->
	`d
(), 
f
.ci()->
	`beg
(), fin.collection()->end());

1308 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "DIFF POST FIN MAPPED: " << 
diff
)

1311 
Node
 
diffFd
 = Node::
	`Ci
();

1312 
NodeDeque
::

 
diffIr
 = 
diff
.
	`ci
()->
	`beg
(), 
diffEndIr
 = diff.ci()->
	`d
();

1313 
diffIr
 !
diffEndIr
; ++diffIter) {

1314 
Node
& 
node
 = *
diffIr
;

1315 i(
node
.
	`ci
(&& !node.ci()->
	`emy
()) {

1316 
diffFd
.
	`ci
()->
	`push_back
(
node
);

1319 
diff
 = 
diffFd
;

1321 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "DIFF POST REJECT: " << 
diff
)

1324 
Node
 
thsResu
 = 
	`ths
(
diff
, 
x
);

1326 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "PATHS: " << 
thsResu
)

1330 
NodeDeque
::

 
thsIr
 = 
thsResu
.
	`ci
()->
	`beg
(), 
thsEndIr
 =hsResu.ci()->
	`d
();

1331 
thsIr
 !
thsEndIr
; ++pathsIter) {

1333 
Node
& 
chd
 = *
thsIr
;

1334 
chd
 = 
	`橋n
(chd, 
x
);

1337 
	`DEBUG_PRINTLN
(
SUBWEAVE
, "FLATTENED: " << 
thsResu
)

1347  
thsResu
;

1349 
	}
}

1453 
Node
 
	$wve
(
Node
& 
th
, 
Cڋxt
& 
x
) {

1455 
	`DEBUG_PRINTLN
(
WEAVE
, "WEAVE: " << 
th
)

1457 
Node
 
befes
 = Node::
	`Ci
();

1458 
befes
.
	`ci
()->
	`push_back
(
Node
::
	`Ci
());

1460 
Node
 
as
 = Node::
	`Ci
();

1461 
as
.
	`us
(
th
);

1463 !
as
.
	`ci
()->
	`emy
()) {

1464 
Node
 
cut
 = 
as
.
	`ci
()->
	`t
().
	`e
(
x
);

1465 
as
.
	`ci
()->
	`p_t
();

1466 
	`DEBUG_PRINTLN
(
WEAVE
, "CURRENT: " << 
cut
)

1467 i(
cut
.
	`ci
()->
	`size
() == 0) ;

1469 
Node
 
ϡ_cut
 = Node::
	`Ci
();

1470 
ϡ_cut
.
	`ci
()->
	`push_back
(
cut
.ci()->
	`back
());

1471 
cut
.
	`ci
()->
	`p_back
();

1472 
	`DEBUG_PRINTLN
(
WEAVE
, "CURRENT POST POP: " << 
cut
)

1473 
	`DEBUG_PRINTLN
(
WEAVE
, "LAST CURRENT: " << 
ϡ_cut
)

1475 
Node
 
mpResu
 = Node::
	`Ci
();

1477 
NodeDeque
::

 
befesIr
 = 
befes
.
	`ci
()->
	`beg
(), 
befesEndIr
 = befes.ci()->
	`d
(); beforesIter != beforesEndIter; beforesIter++) {

1478 
Node
& 
befe
 = *
befesIr
;

1480 
Node
 
sub
 = 
Exnd
::
	`subwve
(
befe
, 
cut
, 
x
);

1482 
	`DEBUG_PRINTLN
(
WEAVE
, "SUB: " << 
sub
)

1484 i(
sub
.
	`isN
()) {

1485  
Node
::
	`Ci
();

1488 
NodeDeque
::

 
subIr
 = 
sub
.
	`ci
()->
	`beg
(), 
subEndIr
 = sub.ci()->
	`d
(); subIter != subEndIter; subIter++) {

1489 
Node
& 
qs
 = *
subIr
;

1491 
Node
 
toPush
 = Node::
	`Ci
();

1492 
toPush
.
	`us
(
qs
);

1493 
toPush
.
	`us
(
ϡ_cut
);

1495 
mpResu
.
	`ci
()->
	`push_back
(
toPush
);

1500 
befes
 = 
mpResu
;

1504  
befes
;

1505 
	}
}

1511 
Node
 
exndComexSe
(

1512 
Comex_Se
* 
pComexSe
,

1513 
Cڋxt
& 
x
,

1514 
ExnsiSubtM
& 
subt_m
,

1515 
d
::
t
<
Compound_Se
> 

, 
bo
 
isR
, bo 
isOrig
);

1531 
	gme
<
tyme
 
	gKeyTy
>

1532 as
	cGroupByToAFun
 {

1533 
	gpublic
:

1534 
KeyTy
 
ݔ
()(
ExnsiPa
& 
extPa
) const {

1535 
Comex_Se
* 
pSe
 = 
extPa
.
f
;

1536  *
	gpSe
;

1539 
Node
 
exndCompoundSe
(

1540 
Compound_Se
* 
pSe
,

1541 
Cڋxt
& 
x
,

1542 
ExnsiSubtM
& 
subt_m
,

1543 
d
::
t
<
Compound_Se
> 

, 
bo
 
isR
) {

1545 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pSe
, "EXTEND COMPOUND: "))

1548 
Node
 
	gexndedSes
 = Node::
Ci
();

1551 
SubtMErs
 
	gs
 = 
subt_m
.
g_v
(
pSe
->
to_r_vec
());

1553 
	gd
::
	tve
<
	td
::
	t
<
	tComex_Se
, std::ve<
	tExnsiPa
> > > 
	tGroudByToAResu
;

1555 
	gGroupByToAFun
<
	gComex_Se
> 
	gextPaKeyFun
;

1556 
GroudByToAResu
 
	gr
;

1557 
group_by_to_a
(
s
, 
extPaKeyFun
, 
r
);

1559 
	gd
::
	t
<
	tCompound_Se
*, 
	tComex_Se
*> 
	tSsNewSeqPa
;

1560 
	gd
::
	tve
<
	tSsNewSeqPa
> 
	tSsNewSeqPaCi
;

1563 
SsNewSeqPaCi
 
	ghd
;

1566 
	gGroudByToAResu
::

 
groudIr
 = 
r
.
beg
(), 
	ggroudIrEnd
 =.
d
(); 
	ggroudIr
 !
groudIrEnd
; groupedIter++) {

1567 
	gd
::

<
Comex_Se
, std::
ve
<
ExnsiPa
> >& 
groudPa
 = *
groudIr
;

1569 
	gComex_Se
& 
	gq
 = 
groudPa
.
f
;

1570 
	gd
::
ve
<
ExnsiPa
>& 
group
 = 
groudPa
.
cd
;

1572 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tComexSe
(&
q
, "SEQ: "))

1575 
Compound_Se
* 
	gpSs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
pSe
->
pe
());

1576 
	gd
::
ve
<
ExnsiPa
>::

 
groupIr
 = 
group
.
beg
(), 
	ggroupIrEnd
 = group.
d
(); 
	ggroupIr
 !
groupIrEnd
; groupIter++) {

1577 
	gExnsiPa
& 
	g
 = *
groupIr
;

1578 
Compound_Se
* 
	gpCompound
 = 

.
cd
;

1579 
size_t
 
	gdex
 = 0; index < 
	gpCompound
->
ngth
(); index++) {

1580 
Sime_Se
* 
	gpSimeSe
 = (*
pCompound
)[
dex
];

1581 (*
	gpSs
<< 
	gpSimeSe
;

1582 
	gpCompound
->
exnded
(
ue
);

1586 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pSs
, "SELS: "))

1588 
Comex_Se
* 
	gpExtComexSe
 = &
q
;

1589 
Compound_Se
* 
	gpExtCompoundSe
 = 
pSs
;

1593 
Compound_Se
* 
	gpSeWhoutExndSes
 = 
pSe
->
mus
(
pExtCompoundSe
, 
x
);

1595 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pSe
, "MEMBERS: "))

1596 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pSeWhoutExndSes
, "SELF_WO_SEL: "))

1598 
Compound_Se
* 
	gpImoCompoundSe
 = 
pExtComexSe
->
ϡ
()->
hd
();

1599 
Compound_Se
* 
	gpUnifdSe
 = 
NULL
;

1601 i(!
	gpImoCompoundSe
) {

1602 
	gpImoCompoundSe
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Compound_Se
, 
pSe
->
pe
());

1605 
	gpUnifdSe
 = 
pImoCompoundSe
->
unify_wh
(
pSeWhoutExndSes
, 
x
);

1608 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pImoCompoundSe
, "LHS: "))

1609 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pSeWhoutExndSes
, "RHS: "))

1610 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pUnifdSe
, "UNIFIED: "))

1613 i(!
	gpUnifdSe
 ||UnifdSe->
ngth
() == 0) {

1624 
Comex_Se
* 
	gpNewSe
 = 
pExtComexSe
->
eFuy
(
x
);

1626 
Comex_Se
* 
	gpNewIMo
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, 
pSe
->
pe
(), Comex_Se::
ANCESTOR_OF
, 
pUnifdSe
, 
NULL
);

1628 
	gComex_Se
::
Comb
 
comb
 = 
pNewSe
->
r_rmo
();

1629 
	gpNewSe
->
t_rmo
(
pNewIMo
, 
comb
);

1631 #ifde
DEBUG


1632 
SoursS
 
	gdebugS
;

1633 
	gdebugS
 = 
pNewSe
->
sours
();

1634 i(
	gdebugS
.
size
() > 0) {

1635 
	gthrow
 "Theew selector should start witho sources. Somethingeedso be clonedo fixhis.";

1637 
	gdebugS
 = 
pExtComexSe
->
sours
();

1638 i(
	gdebugS
.
size
() > 0) {

1639 
	gthrow
 "Thextension selector from our subset map shouldot have sources. These will bleedoheew selector. Somethingeedso be clonedo fixhis.";

1646 
DEBUG_PRINTLN
(
EXTEND_COMPOUND
, "SOURCES SETTING ON NEW SEQ: " << 
comexSeToNode
(
pNewSe
, 
x
))

1648 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
SoursS
 
dS
 = 
pNewSe
->
sours
(); 
tSoursS
(dS, 
x
, "SOURCES NEW SEQ BEGIN: "))

1650 
SoursS
 
	gwSoursS
 = 
pSe
->
sours
();

1651 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tSoursS
(
wSoursS
, 
x
, "SOURCES THIS EXTEND: "))

1653 
	gwSoursS
.

(
pExtComexSe
);

1654 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tSoursS
(
wSoursS
, 
x
, "SOURCES WITH NEW SOURCE: "))

1657 
	gpNewSe
->
addSours
(
wSoursS
, 
x
);

1659 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
SoursS
 
wS
 = 
pNewSe
->
sours
(); 
tSoursS
ewS, 
x
, "SOURCES ON NEW SELECTOR AFTER ADD: "))

1660 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tSoursS
(
pSe
->
sours
(), 
x
, "SOURCES THIS EXTEND WHICH SHOULD BE SAME STILL: "))

1663 i(
	gpSs
->
has_le_ed
()
	gpNewSe
->has_le_ed(
ue
);;

1665 
	ghd
.
push_back
(
d
::
make_
(
pSs
, 
pNewSe
));

1669 
	gSsNewSeqPaCi
::

 
hdIr
 = 
hd
.
beg
(), 
	ghdIrEnd
 = hd.
d
(); 
	ghdIr
 !
hdIrEnd
; holderIter++) {

1670 
	gSsNewSeqPa
& 
	g
 = *
hdIr
;

1672 
Compound_Se
* 
	gpSs
 = 

.
f
;

1673 
Comex_Se
* 
	gpNewSe
 = 

.
cd
;

1677 i(
	g
.
fd
(*
pSs
!

.
d
()) {

1682 
	gd
::
t
<
Compound_Se
> 
curSn
(

);

1683 
	gcurSn
.

(*
pSs
);

1686 
DEBUG_PRINTLN
(
EXTEND_COMPOUND
, "RECURSING DO EXTEND: " << 
comexSeToNode
(
pNewSe
, 
x
))

1687 
Node
 
	gcurExndedSes
 = 
exndComexSe
(
pNewSe
, 
x
, 
subt_m
, 
curSn
, 
isR
, 
l
);

1689 
DEBUG_PRINTLN
(
EXTEND_COMPOUND
, "RECURSING DO EXTEND RETURN: " << 
curExndedSes
)

1691 
	gNodeDeque
::

 it = 
curExndedSes
.
ci
()->
beg
(), 
	gdIt
 =ecurExndedSes.ci()->
d
();

1692 
	g
 !
dIt
; ++iterator) {

1693 
	gNode
& 
	gwSe
 = *

;

1698 i(!
	gexndedSes
.
cڏs
(
wSe
, 
l
 )) {

1700 
	gexndedSes
.
ci
()->
push_back
(
wSe
);

1705 
DEBUG_EXEC
(
EXTEND_COMPOUND
, 
tCompoundSe
(
pSe
, "EXTEND COMPOUND END: "))

1707  
	gexndedSes
;

1711 
bo
 
	$comexSeHasExnsi
(

1712 
Comex_Se
* 
pComexSe
,

1713 
Cڋxt
& 
x
,

1714 
ExnsiSubtM
& 
subt_m
) {

1716 
bo
 
hasExnsi
 = 
l
;

1718 
Comex_Se
* 
pIr
 = 
pComexSe
;

1720 !
hasExnsi
 && 
pIr
) {

1721 
Compound_Se
* 
pHd
 = 
pIr
->
	`hd
();

1723 i(
pHd
) {

1724 
Sime_Se
* 
pSime
 : *
pHd
) {

1725 i(
Wed_Se
* 
ws
 = 
dymic_
<Wed_Se*>(
pSime
)) {

1726 i(
Se_Li
* 

 = 
dymic_
<Se_Li*>(
ws
->
	`
())) {

1727 
Comex_Se
* 
cs
 : 

->
	`emts
()) {

1728 
cs
) {

1729 i(
	`comexSeHasExnsi
(
cs
, 
x
, 
subt_m
)) {

1730 
hasExnsi
 = 
ue
;

1733 
cs
 = cs->
	`
();

1739 
SubtMErs
 
s
 = 
subt_m
.
	`g_v
(
pHd
->
	`to_r_vec
());

1740 
ExnsiPa
 
ext
 : 
s
) {

1743 i(
ext
.
cd
->
	`med_block
() == 0) ;

1744 i(
pHd
->
	`med_block
() &&

1745 
ext
.
cd
->
	`med_block
()->
	`med_qus
() &&

1746 
pHd
->
	`med_block
()->
	`med_qus
()

1748 
d
::
rg
 
	`quy_
(
ext
.
cd
->
	`med_block
()->
	`med_qus
()->
	`to_rg
(
x
.
c_tis
));

1749 
d
::
rg
 
	`quy_right
(
pHd
->
	`med_block
()->
	`med_qus
()->
	`to_rg
(
x
.
c_tis
));

1750 i(
quy_
 =
quy_right
) ;

1754 
d
::
rgam
 
r
;

1755 
d
::
rg
 
	`cwd
(
Sass
::
Fe
::
	`g_cwd
());

1756 
PrS
 
	`pe
(
ext
.
cd
->pstate());

1757 
d
::
rg
 
	`l_th
(
Sass
::
Fe
::
	`abs2l
(
pe
.
th
, 
cwd
, cwd));

1758 
r
 << "You mayot @extendn outer selector from within @media.\n";

1759 
r
 << "You may only @extend selectors withinhe same directive.\n";

1760 
r
 << "From \"@exnd " << 
ext
.
cd
->
	`to_rg
(
x
.
c_tis
) << "\"";

1761 
r
 << " ol" << 
pe
.
le
+1 << " o" << 
l_th
 << "\n";

1762 
	`r
(
r
.
	`r
(), 
pComexSe
->
	`pe
());

1764 i(
s
.
	`size
(> 0
hasExnsi
 = 
ue
;

1767 
pIr
 =Ir->
	`
();

1770  
hasExnsi
;

1771 
	}
}

1785 
Node
 
exndComexSe
(

1786 
Comex_Se
* 
pComexSe
,

1787 
Cڋxt
& 
x
,

1788 
ExnsiSubtM
& 
subt_m
,

1789 
d
::
t
<
Compound_Se
> 

, 
bo
 
isR
, bo 
isOrig
) {

1791 
Node
 
	gcomexSe
 = 
comexSeToNode
(
pComexSe
, 
x
);

1792 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "EXTEND COMPLEX: " << 
comexSe
)

1794 
Node
 
	gexndedNExnded
 = Node::
Ci
();

1796 
	gNodeDeque
::

 
comexSIr
 = 
comexSe
.
ci
()->
beg
(),

1797 
	gcomexSIrEnd
 = 
comexSe
.
ci
()->
d
();

1798 
	gcomexSIr
 !
comexSIrEnd
; ++complexSelIter)

1801 
	gNode
& 
	gsqOrOp
 = *
comexSIr
;

1803 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "LOOP: " << 
sqOrOp
)

1807 i(!
	gsqOrOp
.
isSe
()) {

1810 
Node
 
	gour
 = Node::
Ci
();

1811 
Node
 
	gr
 = Node::
Ci
();

1812 
	gour
.
ci
()->
push_back
(
r
);

1813 
	gr
.
ci
()->
push_back
(
sqOrOp
);

1814 
	gexndedNExnded
.
ci
()->
push_back
(
our
);

1818 
Compound_Se
* 
	gpCompoundSe
 = 
sqOrOp
.

()->
hd
();

1821 
Node
 
	gexnded
 = 
exndCompoundSe
(
pCompoundSe
, 
x
, 
subt_m
, 

, 
isR
);

1822 i(
	gsqOrOp
.
	gg_le_ed

	gexnded
.g_le_ed = 
ue
;

1823 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "EXTENDED: " << 
exnded
)

1828 
Comex_Se
* 
	gpJuCutCompoundSe
 = 
sqOrOp
.

();

1831 i(
	gisOrig
 && !
	gpComexSe
->
has_ahd
()) {

1832 
SoursS
 
	gct
;

1833 
	gct
.

(
pComexSe
);

1834 
	gpJuCutCompoundSe
->
addSours
(
ct
, 
x
);

1835 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "ADD SOURCES: " << *
pComexSe
)

1838 
bo
 
	gisSur
 = 
l
;

1839 
	gNodeDeque
::

 it = 
exnded
.
ci
()->
beg
(), 
	gdIt
 =xnded.ci()->
d
();

1840 
	g
 !
dIt
; ++iterator) {

1841 
	gNode
& 
	gchdNode
 = *

;

1842 
Comex_Se
* 
	gpExnsiSe
 = 
nodeToComexSe
(
chdNode
, 
x
);

1843 i(
	gpExnsiSe
->
is_sur_of
(
pJuCutCompoundSe
)) {

1844 
	gisSur
 = 
ue
;

1849 i(!
	gisSur
) {

1850 i(
	gsqOrOp
.
	gg_le_ed

	gpJuCutCompoundSe
->
has_le_ed
(
sqOrOp
.
g_le_ed
);

1851 
	gexnded
.
ci
()->
push_t
(
comexSeToNode
(
pJuCutCompoundSe
, 
x
));

1854 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "CHOICES UNSHIFTED: " << 
exnded
)

1857 
	gexndedNExnded
.
ci
()->
push_back
(
exnded
);

1861 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "EXTENDED NOT EXPANDED: " << 
exndedNExnded
)

1866 
Node
 
	gths
 = 
Sass
::
ths
(
exndedNExnded
, 
x
);

1868 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "PATHS: " << 
ths
)

1873 
Node
 
	gwves
 = Node::
Ci
();

1875 
	gNodeDeque
::

 
thsIr
 = 
ths
.
ci
()->
beg
(), 
	gthsEndIr
 =hs.ci()->
d
(); 
	gthsIr
 !
thsEndIr
; ++pathsIter) {

1876 
	gNode
& 
	gth
 = *
thsIr
;

1877 
Node
 
	gwved
 = 
wve
(
th
, 
x
);

1878 
	gwved
.
	gg_le_ed
 = 
th
.
g_le_ed
;

1879 
	gwves
.
ci
()->
push_back
(
wved
);

1882 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "WEAVES: " << 
wves
)

1887 
Node
 
	gimmed
 = 
im
(
wves
, 
x
, 
isR
);

1889 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "TRIMMED: " << 
immed
)

1893 
Node
 
	gexndedSes
 = 
橋n
(
immed
, 
x
, 1);

1895 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, ">>>>> EXTENDED: " << 
exndedSes
)

1898 
DEBUG_PRINTLN
(
EXTEND_COMPLEX
, "EXTEND COMPLEX END: " << 
comexSe
)

1901  
	gexndedSes
;

1909 
Se_Li
* 
	gExnd
::
	$exndSeLi
(
Se_Li
* 
pSeLi
, 
Cڋxt
& 
x
, 
ExnsiSubtM
& 
subt_m
, 
bo
 
isR
, bo& 
exndedSomhg
) {

1911 
Se_Li
* 
pNewSes
 = 
	`SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pSeLi
->
	`pe
(),SeLi->
	`ngth
());

1913 
exndedSomhg
 = 
l
;

1915 
size_t
 
dex
 = 0, 
ngth
 = 
pSeLi
->
	`ngth
(); index <ength; index++) {

1916 
Comex_Se
* 
pSe
 = (*
pSeLi
)[
dex
];

1923 i(!
	`comexSeHasExnsi
(
pSe
, 
x
, 
subt_m
)) {

1924 *
pNewSes
 << 
pSe
;

1928 
exndedSomhg
 = 
ue
;

1930 
d
::
t
<
Compound_Se
> 

;

1932 
Node
 
exndedSes
 = 
	`exndComexSe
(
pSe
, 
x
, 
subt_m
, 

, 
isR
, 
ue
);

1933 i(!
pSe
->
	`has_ahd
()) {

1934 i(!
exndedSes
.
	`cڏs
(
	`comexSeToNode
(
pSe
, 
x
), 
ue
 )) {

1935 *
pNewSes
 << 
pSe
;

1939 
NodeDeque
::

 it = 
exndedSes
.
	`ci
()->
	`beg
(), 
Beg
 =xndedSes.ci()->beg(), 
End
 =xndedSes.ci()->
	`d
(); iterator != iteratorEnd; ++iterator) {

1941 if(
isR
 && 

 =
Beg
 && 
exndedSes
.
	`ci
()->
	`size
() > 1 ) ;

1943 
Node
& 
chdNode
 = *

;

1944 *
pNewSes
 << 
	`nodeToComexSe
(
chdNode
, 
x
);

1948 
Remove_Phds
 
	`move_ahds
(
x
);

1951 
pNewSes
 = 
move_ahds
.
	`move_ahds
(pNewSelectors);

1954 
Comex_Se
* 
cur
 : *
pNewSes
) {

1956 
cur
) {

1958 i(
cur
->
	`hd
()) {

1960 
Compound_Se
* 
y_hd
 = 
	`SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
cur
->
	`pe
());

1961 
Sime_Se
* 
hs
 : *
cur
->
	`hd
()) {

1962 i(
Wed_Se
* 
ws
 = 
dymic_
<Wed_Se*>(
hs
)) {

1963 i(
Se_Li
* 

 = 
dymic_
<Se_Li*>(
ws
->
	`
())) {

1965 i(

->
	`emy
()) {

1967 *
y_hd
 << 
	`SASS_MEMORY_NEW
(
x
.
mem
, 
Ty_Se
, 
hs
->
	`pe
(), 
ws
->
	`me
());

1972 
Se_Li
* 
ext_
 = 
	`exndSeLi
(

, 
x
, 
subt_m
);

1973 
size_t
 
i
 = 0; i < 
ext_
->
	`ngth
(); i += 1) {

1974 i(
Comex_Se
* 
ext_cs
 = 
ext_
->
	`
(
i
)) {

1976 
Wed_Se
* 
y_ws
 = 
	`SASS_MEMORY_NEW
(
x
.
mem
, Wed_Se, *
ws
);

1977 
Se_Li
* 
y_ws_
 = 
	`SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 

->
	`pe
());

1979 i(
ext_cs
->
	`f
()*
y_ws_
 <<xt_cs->first();

1981 
y_ws
->
	`
(
y_ws_
);

1983 *
y_hd
 << 
y_ws
;

1988 *
y_hd
 << 
hs
;

1991 *
y_hd
 << 
hs
;

1995 
cur
->
	`hd
(
y_hd
);

1998 
cur
 = cur->
	`
();

2001  
pNewSes
;

2003 
	}
}

2006 
bo
 
	$shouldExndBlock
(
Block
* 
b
) {

2021 
size_t
 
i
 = 0, 
L
 = 
b
->
	`ngth
(); i < L; ++i) {

2022 
Smt
* 
m
 = (*
b
)[
i
];

2024 i(
	`tyid
(*
m
=tyid(
Ruˣt
)) {

2028  
ue
;

2032  
l
;

2034 
	}
}

2038 
	gme
 <
tyme
 
	gObjeTy
>

2039 
	$exndObjeWhSeAndBlock
(
ObjeTy
* 
pObje
, 
Cڋxt
& 
x
, 
ExnsiSubtM
& 
subt_m
) {

2041 
	`DEBUG_PRINTLN
(
EXTEND_OBJECT
, "FOUND SELECTOR: " << 
ic_
<
Se_Li
*>(
pObje
->
	`
())->
	`to_rg
(
x
.
c_tis
))

2045 i(!
	`shouldExndBlock
(
pObje
->
	`block
())) {

2046 
	`DEBUG_PRINTLN
(
EXTEND_OBJECT
, "RETURNING WITHOUT EXTEND ATTEMPT")

2050 
bo
 
exndedSomhg
 = 
l
;

2051 
Se_Li
* 
pNewSeLi
 = 
Exnd
::
	`exndSeLi
(
ic_
<Se_Li*>(
pObje
->
	`
()), 
x
, 
subt_m
, 
l
, 
exndedSomhg
);

2053 i(
exndedSomhg
 && 
pNewSeLi
) {

2054 
	`DEBUG_PRINTLN
(
EXTEND_OBJECT
, "EXTEND ORIGINAL SELECTORS: " << 
ic_
<
Se_Li
*>(
pObje
->
	`
())->
	`to_rg
(
x
.
c_tis
))

2055 
	`DEBUG_PRINTLN
(
EXTEND_OBJECT
, "EXTEND SETTING NEW SELECTORS: " << 
pNewSeLi
->
	`to_rg
(
x
.
c_tis
))

2056 
pNewSeLi
->
	`move__s
();

2057 
pObje
->
	`
(
pNewSeLi
);

2059 
	`DEBUG_PRINTLN
(
EXTEND_OBJECT
, "EXTEND DID NOT TRY TO EXTEND ANYTHING")

2061 
	}
}

2065 
	gExnd
::
	$Exnd
(
Cڋxt
& 
x
, 
ExnsiSubtM
& 
ssm
)

2066 : 
	`x
(
x
), 
	$subt_m
(
ssm
)

2067 { 
	}
}

2069 
	gExnd
::
	$ݔ
()(
Block
* 
b
)

2071 
size_t
 
i
 = 0, 
L
 = 
b
->
	`ngth
(); i < L; ++i) {

2072 (*
b
)[
i
]->
	`rfm
(
this
);

2076 i(
b
->
	`is_ro
()) {

2078 autcڡ &

 : 
subt_m
.
	`vues
()) {

2079 
Comex_Se
* 
l
 = 

.
f
 ? it.f->
	`f
(: 
NULL
;

2080 
Compound_Se
* 
ext
 = 

.
cd
 ? it.cd : 
NULL
;

2081 i(
ext
 && (ext->
	`exnded
(||xt->
	`is_tiڮ
())) ;

2082 
d
::
rg
 
	`r_l
(
l
->
	`to_rg
({ 
NESTED
, 5 }));

2083 
d
::
rg
 
	`r_ext
(
ext
->
	`to_rg
({ 
NESTED
, 5 }));

2086 
	`r
("\"" + 
r_l
 + "\" faed@exnd \"" + 
r_ext
 + "\".\n"

2087 "Th \"" + 
r_ext
 + "\" wasot found.\n"

2088 "U \"@exnd " + 
r_ext
 + " !optional\" ifhe"

2089 "xnd should babˁ.", 
ext
->
	`pe
());

2093 
	}
}

2095 
	gExnd
::
	$ݔ
()(
Ruˣt
* 
pRuˣt
)

2097 
	`exndObjeWhSeAndBlock
(
pRuˣt
, 
x
, 
subt_m
);

2098 
pRuˣt
->
	`block
()->
	`rfm
(
this
);

2099 
	}
}

2101 
	gExnd
::
	$ݔ
()(
Suts_Block
* 
pFtuBlock
)

2103 
pFtuBlock
->
	`block
()->
	`rfm
(
this
);

2104 
	}
}

2106 
	gExnd
::
	$ݔ
()(
Med_Block
* 
pMedBlock
)

2108 
pMedBlock
->
	`block
()->
	`rfm
(
this
);

2109 
	}
}

2111 
	gExnd
::
	$ݔ
()(
Deive
* 
a
)

2115 i(
a
->
	`block
()a->block()->
	`rfm
(
this
);

2117 
	}
}

	@node_modules/node-sass/src/libsass/src/extend.hpp

1 #ide
SASS_EXTEND_H


2 
	#SASS_EXTEND_H


	)

4 
	~<rg
>

6 
	~"a.h
"

7 
	~"ݔi.h
"

8 
	~"subt_m.h
"

10 
mea
 
	gSass
 {

12 
ass
 
	gCڋxt
;

13 
ass
 
	gNode
;

15 
	gSubt_M
<
	td
::
	trg
, std::
	t
<
	tComex_Se
*, 
	tCompound_Se
*> > 
	tExnsiSubtM
;

17 
ass
 
	gExnd
 : 
public
 
Oti_CRTP
<, Extend> {

19 
	gCڋxt
& 
	gx
;

20 
	gExnsiSubtM
& 
	gsubt_m
;

22 
back_im
(
AST_Node
* 
n
) { }

24 
	gpublic
:

25 
Node
 
subwve
(Node& 
e
, Node& 
two
, 
Cڋxt
& 
x
);

26 
Se_Li
* 
exndSeLi
(Se_Li* 
pSeLi
, 
Cڋxt
& 
x
, 
ExnsiSubtM
& 
subt_m
, 
bo
 
isR
, bo& 
exndedSomhg
);

27 
Se_Li
* 
exndSeLi
(Se_Li* 
pSeLi
, 
Cڋxt
& 
x
, 
ExnsiSubtM
& 
subt_m
, 
bo
 
isR
 = 
l
) {

28 
bo
 
exndedSomhg
 = 
l
;

29  
exndSeLi
(
pSeLi
, 
x
, 
subt_m
, 
isR
, 
exndedSomhg
);

31 
Exnd
(
Cڋxt
&, 
ExnsiSubtM
&);

32 ~
Exnd
() { }

34 
ݔ
()(
	gBlock
*);

35 
ݔ
()(
	gRuˣt
*);

36 
ݔ
()(
	gSuts_Block
*);

37 
ݔ
()(
	gMed_Block
*);

38 
ݔ
()(
	gDeive
*);

40 
	gme
 <
tyme
 
	gU
>

41 
back
(
U
 
x
{  
back_im
(x); }

	@node_modules/node-sass/src/libsass/src/file.cpp

1 #ifde
_WIN32


2 #ifde
__MINGW32__


3 #ide
off64_t


4 
	#off64_t
 
_off64_t


	)

7 
	~<de.h
>

8 
	#S_ISDIR
(
mode
(((mode& 
S_IFMT
=
S_IFDIR
)

	)

10 
	~<unid.h
>

12 
	~"ss.h
"

13 
	~<ioam
>

14 
	~<fam
>

15 
	~<cy
>

16 
	~<ve
>

17 
	~<gܙhm
>

18 
	~<sys/.h
>

19 
	~"fe.h
"

20 
	~"cڋxt.h
"

21 
	~"ex.h
"

22 
	~"utf8_rg.h
"

23 
	~"ss2scss.h
"

25 #ifde
_WIN32


26 
	~<wdows.h
>

28 #ifde
_MSC_VER


29 
	~<codecvt
>

30 
le
 
	gd
::
rg
 
	$wrg_to_rg
(cڡ 
d
::
wrg
& 
wr
)

32 
d
::
wrg_cvt
<d::
codecvt_utf8
<
wch_t
>, wch_t> 
wch_cvr
;

33  
wch_cvr
.
	`to_bys
(
wr
);

34 
	}
}

36 
le
 
	gd
::
rg
 
	$wrg_to_rg
(cڡ 
d
::
wrg
 &
wr
)

38 
size_eded
 = 
	`WideChToMuiBy
(
CP_UTF8
, 0, &
wr
[0], ()wr.
	`size
(), 
NULL
, 0, NULL, NULL);

39 
d
::
rg
 
	`rTo
(
size_eded
, 0);

40 
	`WideChToMuiBy
(
CP_UTF8
, 0, &
wr
[0], ()wr.
	`size
(), &
rTo
[0], 
size_eded
, 
NULL
, NULL);

41  
rTo
;

42 
	}
}

46 
mea
 
	gSass
 {

47 
mea
 
	gFe
 {

51 
	gd
::
rg
 
g_cwd
()

53 cڡ 
size_t
 
wd_n
 = 1024;

54 #ide
_WIN32


55 
	gwd
[
wd_n
];

56 
	gd
::
rg
 
cwd
 = 
gcwd
(
wd
, 
wd_n
);

58 
wch_t
 
	gwd
[
wd_n
];

59 
	gd
::
rg
 
cwd
 = 
wrg_to_rg
(
_wgcwd
(
wd
, 
wd_n
));

61 
a
(
cwd
.
beg
(), cwd.
d
(), '\\', '/');

63 i(
	gcwd
[
cwd
.
ngth
() - 1] != '/') cwd += '/';

64  
	gcwd
;

68 
bo
 
fe_exis
(cڡ 
d
::
rg
& 
th
)

70 #ifde
_WIN32


71 
d
::
wrg
 
wth
 = 
UTF_8
::
cvt_to_utf16
(
th
);

72 
DWORD
 
	gdwArib
 = 
GFeAribusW
(
wth
.
c_r
());

73  (
	gdwArib
 !
INVALID_FILE_ATTRIBUTES
 &&

74 (!(
dwArib
 & 
FILE_ATTRIBUTE_DIRECTORY
)));

76 

 
	g_buf
;

77  (

 (
th
.
c_r
(), &
_buf
) == 0) &&

78 (!
S_ISDIR
 (
_buf
.
_mode
));

84 
bo
 
is_absu_th
(cڡ 
d
::
rg
& 
th
)

86 #ifde
_WIN32


87 i(
th
.
ngth
(>2 && 
iha
թh[0]&&h[1] =':' 
ue
;

89 
size_t
 
	gi
 = 0;

91 i(
	gth
[
i
] && 
	gPx
::
is_pha
(
th
[i])) {

93 
th
[
i
] && 
Px
::
is_num
(path[i])) ++i;

94 
	gi
 = 
i
 && 
th
[i] == ':' ? i + 1 : 0;

96  
	gth
[
i
] == '/';

100 
le
 
size_t
 
fd_ϡ_fd_t
(cڡ 
d
::
rg
& 
th
, size_
lim
 = std::rg::
os
)

102 
size_t
 
pos
 = 
d
::
rg
::
os
;

103 
size_t
 
	gpos_p
 = 
th
.
fd_ϡ_of
('/', 
lim
);

104 #ifde
_WIN32


105 
size_t
 
	gpos_w
 = 
th
.
fd_ϡ_of
('\\', 
lim
);

107 
size_t
 
	gpos_w
 = 
d
::
rg
::
os
;

109 i(
	gpos_p
 !
d
::
rg
::
os
 && 
pos_w
 != std::string::npos) {

110 
pos
 = 
d
::
max
(
pos_p
, 
pos_w
);

112 i(
	gpos_p
 !
d
::
rg
::
os
) {

113 
pos
 = 
pos_p
;

116 
	gpos
 = 
pos_w
;

118  
	gpos
;

122 
	gd
::
rg
 
d_me
(cڡ 
d
::rg& 
th
)

124 
size_t
 
pos
 = 
fd_ϡ_fd_t
(
th
);

125 i(
	gpos
 =
d
::
rg
::
os
)  "";

126  
	gth
.
subr
(0, 
pos
+1);

130 
	gd
::
rg
 
ba_me
(cڡ 
d
::rg& 
th
)

132 
size_t
 
pos
 = 
fd_ϡ_fd_t
(
th
);

133 i(
	gpos
 =
d
::
rg
::
os
 
th
;

134  
	gth
.
subr
(
pos
+1);

139 
	gd
::
rg
 
make_nil_th
 (
d
::rg 
th
)

143 
size_t
 
pos
;

145 #ifde
_WIN32


147 
a
(
th
.
beg
(),h.
d
(), '\\', '/');

150 
	gpos
 = 0;

151 (
	gpos
 = 
th
.
fd
("/./", 
pos
)!
d
::
rg
::
os
th.
a
(pos, 2);

153 
	gpos
 = 0;

154 
	gth
.
ngth
(> 1 &&h.
subr
(0, 2="./"
th
.
a
(0, 2);

155 (
	gpos
 = 
th
.
ngth
()> 1 &&h.
subr
(
pos
 - 2="/."th.
a
(pos - 2);

158 
size_t
 
	go
 = 0;

160 i(
	gth
[
o
] && 
	gPx
::
is_pha
(
th
[proto])) {

162 
th
[
o
] && 
Px
::
is_num
(path[proto++])) {}

164 i(
o
 && 
th
[proto] == ':') ++roto;

168 
	gth
[
o
++] == '/') {}

170 
pos
 = 
o
;

171 (
	gpos
 = 
th
.
fd
("//", 
pos
)!
d
::
rg
::
os
th.
a
(pos, 1);

173  
	gth
;

179 
	gd
::
rg
 
jo_ths
(
d
::rg 
l
, std::rg 
r
)

182 #ifde
_WIN32


184 
a
(
l
.
beg
(),.
d
(), '\\', '/');

185 
a
(
r
.
beg
(),.
d
(), '\\', '/');

188 i(
	gl
.
emy
() 
	gr
;

189 i(
	gr
.
emy
() 
	gl
;

191 i(
is_absu_th
(
r
) 
	gr
;

192 i(
	gl
[
l
.
ngth
()-1] != '/') += '/';

194 (
	gr
.
ngth
(> 3&& (.
subr
(0, 3="../"|| (
r
.substr(0, 3)) == "..\\")) {

195 
size_t
 
L
 = 
l
.
ngth
(), 
	gpos
 = 
fd_ϡ_fd_t
(l, L - 2);

196 
bo
 
	gis_ash
 = 
pos
 + 2 =
L
 && (
l
[pos+1] == '/' ||[pos+1] == '\\');

197 
bo
 
	gis_lf
 = 
pos
 + 3 =
L
 && (
l
[pos+1] == '.');

198 i(!
	gis_lf
 && !
	gis_ash

	gr
 = 
r
.
subr
(3);

199 
	gl
 = 
l
.
subr
(0, 
pos
 =
d
::
rg
::
os
 ?os :os + 1);

202  
	gl
 + 
	gr
;

205 
	gd
::
rg
 
th_f_cse
(cڡ 
d
::rg& 
l_th
, cڡ std::rg& 
abs_th
, cڡ std::rg& 
ig_th
)

210 i(
l_th
.
subr
(0, 3) == "../") {

211  
ig_th
;

214  
	gabs_th
 =
ig_th
 ? 
abs_th
 : 
l_th
;

218 
	gd
::
rg
 
l2abs
(cڡ 
d
::rg& 
th
, cڡ std::rg& 
ba
, cڡ std::rg& 
cwd
)

220  
make_nil_th
(
jo_ths
(jo_ths(
cwd
, 
ba
), 
th
));

225 
	gd
::
rg
 
abs2l
(cڡ 
d
::rg& 
th
, cڡ std::rg& 
ba
, cڡ std::rg& 
cwd
)

228 
d
::
rg
 
abs_th
 = 
l2abs
(
th
, 
cwd
);

229 
	gd
::
rg
 
abs_ba
 = 
l2abs
(
ba
, 
cwd
);

231 
size_t
 
	go
 = 0;

233 i(
	gth
[
o
] && 
	gPx
::
is_pha
(
th
[proto])) {

235 
th
[
o
] && 
Px
::
is_num
(path[proto++])) {}

237 i(
o
 && 
th
[proto] == ':') ++roto;

242 i(
	go
 && 
	gth
[
o
++] ='/' &&r> 3 
th
;

244 #ifde
_WIN32


247 i(
	gabs_ba
[0] !
abs_th
[0]) bs_path;

250 
	gd
::
rg
 
rd_uri
 = "";

251 
	gd
::
rg
 
rd_ba
 = "";

253 
size_t
 
	gdex
 = 0;

254 
size_t
 
	gmSize
 = 
d
::
m
(
abs_th
.
size
(), 
abs_ba
.size());

255 
size_t
 
	gi
 = 0; i < 
	gmSize
; ++i) {

256 #ifde
FS_CASE_SENSITIVE


257 i(
	gabs_th
[
i
] !
abs_ba
[i]) ;

261 i(
tow
(
abs_th
[
i
]!tow(
abs_ba
[i])) ;

263 i(
	gabs_th
[
i
] ='/'
dex
 = i + 1;

265 
size_t
 
	gi
 = 
dex
; i < 
	gabs_th
.
size
(); ++i) {

266 
	grd_uri
 +
abs_th
[
i
];

268 
size_t
 
	gi
 = 
dex
; i < 
	gabs_ba
.
size
(); ++i) {

269 
	grd_ba
 +
abs_ba
[
i
];

272 
size_t
 
	g
 = 0;

273 
size_t
 
	gdeܛs
 = 0;

274 
size_t
 
	gright
 = 0;igh< 
	grd_ba
.
size
(); ++right) {

275 i(
	grd_ba
[
right
] == '/') {

276 i(
rd_ba
.
subr
(

, 2) != "..") {

277 ++
deܛs
;

279 i(
	gdeܛs
 > 1) {

280 --
	gdeܛs
;

283 
	gdeܛs
 = 0;

285 
	g
 = 
right
 + 1;

289 
	gd
::
rg
 
su
 = "";

290 
size_t
 
	gi
 = 0; i < 
	gdeܛs
; ++i) {

291 
	gsu
 += "../";

293 
	gsu
 +
rd_uri
;

295  
	gsu
;

303 
	gd
::
ve
<
Inude
> 
sve_udes
(cڡ 
d
::
rg
& 
ro
, cڡ std::rg& 
fe
)

305 
d
::
rg
 
fame
 = 
jo_ths
(
ro
, 
fe
);

307 cڡ 
	gd
::
ve
<
d
::
rg
> 
exts
 = {

311 
	gd
::
rg
 
ba
(
d_me
(
fe
));

312 
	gd
::
rg
 
me
(
ba_me
(
fe
));

313 
	gd
::
ve
<
Inude
> 
udes
;

315 
	gd
::
rg
 
l_th
(
jo_ths
(
ba
, 
me
));

316 
	gd
::
rg
 
abs_th
(
jo_ths
(
ro
, 
l_th
));

317 i(
fe_exis
(
abs_th
)
	gudes
.
push_back
({{ 
l_th
, 
ro
 },bs_path });

319 
	gl_th
 = 
jo_ths
(
ba
, "_" + 
me
);

320 
	gabs_th
 = 
jo_ths
(
ro
, 
l_th
);

321 i(
fe_exis
(
abs_th
)
	gudes
.
push_back
({{ 
l_th
, 
ro
 },bs_path });

323 aut
	gext
 : 
exts
) {

324 
l_th
 = 
jo_ths
(
ba
, "_" + 
me
 + 
ext
);

325 
	gabs_th
 = 
jo_ths
(
ro
, 
l_th
);

326 i(
fe_exis
(
abs_th
)
	gudes
.
push_back
({{ 
l_th
, 
ro
 },bs_path });

329 aut
	gext
 : 
exts
) {

330 
l_th
 = 
jo_ths
(
ba
, 
me
 + 
ext
);

331 
	gabs_th
 = 
jo_ths
(
ro
, 
l_th
);

332 i(
fe_exis
(
abs_th
)
	gudes
.
push_back
({{ 
l_th
, 
ro
 },bs_path });

335  
	gudes
;

339 
	gd
::
rg
 
fd_fe
(cڡ 
d
::rg& 
fe
, cڡ std::
ve
<d::rg> 
ths
)

342 
size_t
 
i
 = 0, 
	gS
 = 
ths
.
size
(); 
	gi
 < S; ++i)

344 
	gd
::
ve
<
Inude
> 
sved
(
sve_udes
(
ths
[
i
], 
fe
));

345 i(
	gsved
.
size
()esved[0].
	gabs_th
;

348  
	gd
::
rg
("");

352 
	gd
::
rg
 
fd_fe
(cڡ 
d
::rg& 
fe
, cڡ * 
ths
[])

354 i(
	gths
 =0 
d
::
rg
("");

355 
	gd
::
ve
<
d
::
rg
> 
udes
(0);

357 cڡ ** 
	g
 = 
ths
;

358 
	g
 && *it) {

359 
	gudes
.
push_back
(*

);

360 ++
	g
;

362  
fd_fe
(
fe
, 
udes
);

368 * 
ad_fe
(cڡ 
d
::
rg
& 
th
)

370 #ifde
_WIN32


371 
BYTE
* 
pBufr
;

372 
DWORD
 
	gdwBys
;

374 
	gd
::
wrg
 
wth
 = 
UTF_8
::
cvt_to_utf16
(
th
);

375 
HANDLE
 
	ghFe
 = 
CeFeW
(
wth
.
c_r
(), 
GENERIC_READ
, 
FILE_SHARE_READ
, 
NULL
, 
OPEN_EXISTING
, 0, NULL);

376 i(
	ghFe
 =
INVALID_HANDLE_VALUE
)  0;

377 
DWORD
 
	gdwFeLgth
 = 
GFeSize
(
hFe
, 
NULL
);

378 i(
	gdwFeLgth
 =
INVALID_FILE_SIZE
)  0;

380 
	gpBufr
 = (
BYTE
*)
mloc
((
dwFeLgth
+1)*(BYTE));

381 
RdFe
(
hFe
, 
pBufr
, 
dwFeLgth
, &
dwBys
, 
NULL
);

382 
	gpBufr
[
dwFeLgth
] = '\0';

383 
CloHd
(
hFe
);

385 * 
	gcڋs
 = (*
pBufr
;

387 

 
	g
;

388 i(

(
th
.
c_r
(), &

=-1 || 
S_ISDIR
(.
_mode
))  0;

389 
	gd
::
ifam
 
fe
(
th
.
c_r
(), 
d
::
ios
::

 | std::ios::
by
 | std::ios::
e
);

390 * 
	gcڋs
 = 0;

391 i(
	gfe
.
is_ݒ
()) {

392 
size_t
 
	gsize
 = 
fe
.
g
();

394 
	gcڋs
 = (*
mloc
((
size
+1)*());

395 
	gfe
.
ekg
(0, 
d
::
ios
::
beg
);

396 
	gfe
.
ad
(
cڋs
, 
size
);

397 
	gcڋs
[
size
] = '\0';

398 
	gfe
.
o
();

401 
	gd
::
rg
 
exnsi
;

402 i(
	gth
.
ngth
() > 5) {

403 
	gexnsi
 = 
th
.
subr
թh.
ngth
() - 5, 5);

405 
size_t
 
	gi
=0; i<
	gexnsi
.
size
();++i)

406 
	gexnsi
[
i
] = 
tow
(
exnsi
[i]);

407 i(
	gexnsi
 =".ss" && 
cڋs
 != 0) {

408 * 
cvd
 = 
ss2scss
(
cڋs
, 
SASS2SCSS_PRETTIFY_1
 | 
SASS2SCSS_KEEP_COMMENT
);

409 

(
cڋs
);

410  
	gcvd
;

412  
	gcڋs
;

	@node_modules/node-sass/src/libsass/src/file.hpp

1 #ide
SASS_FILE_H


2 
	#SASS_FILE_H


	)

4 
	~<rg
>

5 
	~<ve
>

7 
mea
 
	gSass
 {

9 
ass
 
	gBlock
;

10 
ass
 
	gCڋxt
;

12 
mea
 
	gFe
 {

16 
	gd
::
rg
 
g_cwd
();

19 
bo
 
fe_exis
(cڡ 
d
::
rg
& 
fe
);

23 
bo
 
is_absu_th
(cڡ 
d
::
rg
& 
th
);

26 
	gd
::
rg
 
d_me
(cڡ 
d
::rg& 
th
);

29 
	gd
::
rg
 
ba_me
(cڡ 
d
::string&);

33 
	gd
::
rg
 
make_nil_th
 (
d
::rg 
th
);

37 
	gd
::
rg
 
jo_ths
(
d
::rg 
ro
, std::rg 
me
);

41 
	gd
::
rg
 
th_f_cse
(cڡ 
d
::rg& 
l_th
, cڡ std::rg& 
abs_th
, cڡ std::rg& 
ig_th
);

44 
	gd
::
rg
 
l2abs
(cڡ 
d
::rg& 
th
, cڡ std::rg& 
ba
 = ".", cڡ std::rg& 
cwd
 = 
g_cwd
());

48 
	gd
::
rg
 
abs2l
(cڡ 
d
::rg& 
th
, cڡ std::rg& 
ba
 = ".", cڡ std::rg& 
cwd
 = 
g_cwd
());

51 
	gd
::
rg
 
fd_fe
(cڡ 
d
::rg& 
fe
, cڡ std::
ve
<d::rg> 
ths
);

53 
	gd
::
rg
 
fd_fe
(cڡ 
d
::rg& 
fe
, cڡ ** 
ths
);

58 * 
ad_fe
(cڡ 
d
::
rg
& 
fe
);

63 as
	cImp܋r
 {

64 
	gpublic
:

66 
d
::
rg
 
imp_th
;

68 
	gd
::
rg
 
x_th
;

71 
	gd
::
rg
 
ba_th
;

72 
	gpublic
:

73 
Imp܋r
(
d
::
rg
 
imp_th
, std::rg 
x_th
)

74 : 
imp_th
(
Fe
::
make_nil_th
(imp_path)),

75 
x_th
(
Fe
::
make_nil_th
(ctx_path)),

76 
ba_th
(
Fe
::
d_me
(
x_th
))

81 as
	cInude
 : 
public
 
Imp܋r
 {

82 
public
:

84 
d
::
rg
 
abs_th
;

85 
	gpublic
:

86 
Inude
(cڡ 
Imp܋r
& 
imp
, 
d
::
rg
 
abs_th
)

87 : 
Imp܋r
(
imp
), 
abs_th
(abs_path)

92 as
	cResour
 {

93 
	gpublic
:

95 * 
cڋs
;

97 * 
	gcm
;

98 
	gpublic
:

99 
Resour
(* 
cڋs
, * 
cm
)

100 : 
cڋs
(cڋs), 
cm
(srcmap)

105 as
	cStySht
 : 
public
 
Resour
 {

106 
public
:

108 
Block
* 
ro
;

109 
	gpublic
:

110 
StySht
(cڡ 
Resour
& 
s
, 
Block
* 
ro
)

111 : 
Resour
(
s
), 
ro
(root)

115 
mea
 
	gFe
 {

117 
	gd
::
ve
<
Inude
> 
sve_udes
(cڡ 
d
::
rg
& 
ro
, cڡ std::rg& 
fe
);

	@node_modules/node-sass/src/libsass/src/functions.cpp

1 
	~"ss.h
"

2 
	~"funis.h
"

3 
	~"a.h
"

4 
	~"cڋxt.h
"

5 
	~"backa.h
"

6 
	~"rr.h
"

7 
	~"cڡts.h
"

8 
	~"e.h
"

9 
	~"exnd.h
"

10 
	~"ev.h
"

11 
	~"ut.h
"

12 
	~"exnd.h
"

13 
	~"utf8_rg.h
"

14 
	~"ss/ba.h
"

15 
	~"utf8.h
"

17 
	~<cdt
>

18 
	~<cdlib
>

19 
	~<cmh
>

20 
	~<cy
>

21 
	~<sam
>

22 
	~<rg
>

23 
	~<iom
>

24 
	~<ioam
>

25 
	~<ndom
>

26 
	~<t
>

28 #ifde
__MINGW32__


29 
	~"wdows.h
"

30 
	~"wy.h
"

33 
	#ARG
(
gme
, 
gty

g_g
<gty>rgme, 
v
, 
sig
, 
pe
, 
backa
)

	)

34 
	#ARGR
(
gme
, 
gty
, 
lo
, 
hi

	`g_g_r
rgme, 
v
, 
sig
, 
pe
,o, hi, 
backa
)

	)

35 
	#ARGM
(
gme
, 
gty
, 
x

	`g_g_m
rgme, 
v
, 
sig
, 
pe
, 
backa
, ctx)

	)

37 
mea
 
	gSass
 {

38 
usg
 
	gd
::
rgam
;

39 
usg
 
	gd
::
dl
;

41 
Defi
* 
make_tive_funi
(
Sigtu
 
sig
, 
Nive_Funi
 
func
, 
Cڋxt
& 
x
)

43 
Pr
 
	gsig_rr
 = Pr::
om_c_r
(
sig
, 
x
, 
PrS
("[built-in function]"));

44 
	gsig_rr
.
	gx
<
	gPx
::
idtifr
>();

45 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
sig_rr
.
xed
));

46 
Pams
* 
	gms
 = 
sig_rr
.
r_ms
();

47  
SASS_MEMORY_NEW
(
x
.
mem
, 
Defi
,

48 
PrS
("[built-in function]"),

49 
sig
,

50 
me
,

51 
ms
,

52 
func
,

53 
l
);

56 
Defi
* 
make_c_funi
(
Sass_Funi_Ery
 
c_func
, 
Cڋxt
& 
x
)

58 
usg
 
mea
 
	gPx
;

60 cڡ * 
	gsig
 = 
ss_funi_g_sigtu
(
c_func
);

61 
Pr
 
	gsig_rr
 = Pr::
om_c_r
(
sig
, 
x
, 
PrS
("[c function]"));

63 
	gsig_rr
.
	gx
 < 
	gives
 < 
	gidtifr
, 
	gexaly
 <'*'>,

64 
	gexaly
 < 
	gCڡts
::
wn_kwd
 >,

65 
	gexaly
 < 
	gCڡts
::
r_kwd
 >,

66 
	gexaly
 < 
	gCڡts
::
debug_kwd
 >

68 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
sig_rr
.
xed
));

69 
Pams
* 
	gms
 = 
sig_rr
.
r_ms
();

70  
SASS_MEMORY_NEW
(
x
.
mem
, 
Defi
,

71 
PrS
("[c function]"),

72 
sig
,

73 
me
,

74 
ms
,

75 
c_func
,

76 
l
, 
ue
);

79 
	gd
::
rg
 
funi_me
(
Sigtu
 
sig
)

81 
d
::
rg
 
r
(
sig
);

82  
	gr
.
subr
(0, 
r
.
fd
('('));

85 
mea
 
	gFunis
 {

87 
le
 
hd_utf8_r
 (cڡ 
PrS
& 
pe
, 
Backa
* 
backa
)

89 
	gy
 {

90 
	gthrow
;

92 
tch
 (
utf8
::
vid_code_pot
) {

93 
d
::
rg
 
msg
("utf8::invalid_code_point");

94 
r
(
msg
, 
pe
, 
backa
);

96 
tch
 (
utf8
::
n_ough_room
) {

97 
d
::
rg
 
msg
("utf8::not_enough_room");

98 
r
(
msg
, 
pe
, 
backa
);

100 
tch
 (
utf8
::
vid_utf8
) {

101 
d
::
rg
 
msg
("utf8::invalid_utf8");

102 
r
(
msg
, 
pe
, 
backa
);

104 
tch
 (...{ 
	gthrow
; }

107 
	gme
 <
tyme
 
	gT
>

108 
T
* 
g_g
(cڡ 
d
::
rg
& 
gme
, 
Env
& 
v
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
Backa
* 
backa
)

111 
T
* 
	gv
 = 
dymic_
<T*>(
v
[
gme
]);

112 i(!
	gv
) {

113 
	gd
::
rg
 
msg
("argument `");

114 
	gmsg
 +
gme
;

115 
	gmsg
 += "` of `";

116 
	gmsg
 +
sig
;

117 
	gmsg
 += "` must be ";

118 
	gmsg
 +
T
::
ty_me
();

119 
r
(
msg
, 
pe
, 
backa
);

121  
	gv
;

124 
M
* 
g_g_m
(cڡ 
d
::
rg
& 
gme
, 
Env
& 
v
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
Backa
* 
backa
, 
Cڋxt
& 
x
)

127 
M
* 
	gv
 = 
dymic_
<M*>(
v
[
gme
]);

128 i(
	gv
)  val;

130 
Li
* 
	glv
 = 
dymic_
<Li*>(
v
[
gme
]);

131 i(
	glv
 &&v->
ngth
(=0 
SASS_MEMORY_NEW
(
x
.
mem
, 
M
, 
pe
, 0);

134 
	gv
 = 
g_g
<
M
>(
gme
, 
	gv
, 
	gsig
, 
	gpe
, 
	gbacka
);

135  
	gv
;

138 
Numb
* 
g_g_r
(cڡ 
d
::
rg
& 
gme
, 
Env
& 
v
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
lo
, 
hi
, 
Backa
* 
backa
)

141 
Numb
* 
	gv
 = 
g_g
<Numb>(
gme
, 
	gv
, 
	gsig
, 
	gpe
, 
	gbacka
);

142 
	gv
 = 
v
->
vue
();

143 i(!(
	glo
 <
v
 && v <
hi
)) {

144 
d
::
rgam
 
msg
;

145 
	gmsg
 << "gum`" << 
	ggme
 << "` o`" << 
	gsig
 << "` must be between ";

146 
	gmsg
 << 
	glo
 << "nd " << 
	ghi
;

147 
r
(
msg
.
r
(), 
pe
, 
backa
);

149  
	gv
;

152 
	#ARGSEL
(
gme
, 
y
, 
cڋxtuize

g_g_l
<y>rgme, 
v
, 
sig
, 
pe
, 
backa
, 
x
)

	)

154 
	gme
 <
tyme
 
	gT
>

155 
T
* 
g_g_l
(cڡ 
d
::
rg
& 
gme
, 
Env
& 
v
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
Backa
* 
backa
, 
Cڋxt
& 
x
);

157 
	gme
 <>

158 
Se_Li
* 
g_g_l
(cڡ 
d
::
rg
& 
gme
, 
Env
& 
v
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
Backa
* 
backa
, 
Cڋxt
& 
x
) {

159 
Exessi
* 
	gexp
 = 
ARG
(
gme
, Expression);

160 i(
	gexp
->
ce_ty
(=
Exessi
::
NULL_VAL
) {

161 
d
::
rgam
 
msg
;

162 
	gmsg
 << 
	ggme
 << ":ull isot valid selector: it must be string,\n";

163 
	gmsg
 << "li orgs, oli oliorgf `" << 
funi_me
(
sig
) << "'";

164 
r
(
msg
.
r
(), 
pe
);

166 i(
Sg_Cڡt
* 
	gr
 =
dymic_
<Sg_Cڡt*>(
exp
)) {

167 
r
->
que_mk
(0);

169 
	gd
::
rg
 
exp_c
 = 
exp
->
to_rg
(
x
.
c_tis
) + "{";

170  
	gPr
::
r_
(
exp_c
.
c_r
(), 
x
);

173 
	gme
 <>

174 
Comex_Se
* 
g_g_l
(cڡ 
d
::
rg
& 
gme
, 
Env
& 
v
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
Backa
* 
backa
, 
Cڋxt
& 
x
) {

175 
Exessi
* 
	gexp
 = 
ARG
(
gme
, Expression);

176 i(
	gexp
->
ce_ty
(=
Exessi
::
NULL_VAL
) {

177 
d
::
rgam
 
msg
;

178 
	gmsg
 << 
	ggme
 << ":ull isot valid selector: it must be string,\n";

179 
	gmsg
 << "li orgs, oli oliorgf `" << 
funi_me
(
sig
) << "'";

180 
r
(
msg
.
r
(), 
pe
);

182 i(
Sg_Cڡt
* 
	gr
 =
dymic_
<Sg_Cڡt*>(
exp
)) {

183 
r
->
que_mk
(0);

185 
	gd
::
rg
 
exp_c
 = 
exp
->
to_rg
(
x
.
c_tis
) + "{";

186 
Se_Li
* 
	gl_li
 = 
Pr
::
r_
(
exp_c
.
c_r
(), 
x
);

187  (
	gl_li
->
ngth
(> 0? s_li->
f
() : 0;

190 
	gme
 <>

191 
Compound_Se
* 
g_g_l
(cڡ 
d
::
rg
& 
gme
, 
Env
& 
v
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
Backa
* 
backa
, 
Cڋxt
& 
x
) {

192 
Exessi
* 
	gexp
 = 
ARG
(
gme
, Expression);

193 i(
	gexp
->
ce_ty
(=
Exessi
::
NULL_VAL
) {

194 
d
::
rgam
 
msg
;

195 
	gmsg
 << 
	ggme
 << ":u inه sg f `" << 
funi_me
(
sig
) << "'";

196 
r
(
msg
.
r
(), 
pe
);

198 i(
Sg_Cڡt
* 
	gr
 =
dymic_
<Sg_Cڡt*>(
exp
)) {

199 
r
->
que_mk
(0);

201 
	gd
::
rg
 
exp_c
 = 
exp
->
to_rg
(
x
.
c_tis
) + "{";

202 
Se_Li
* 
	gl_li
 = 
Pr
::
r_
(
exp_c
.
c_r
(), 
x
);

203  (
	gl_li
->
ngth
(> 0? s_li->
f
()->

()->
hd
() : 0;

206 #ifde
__MINGW32__


207 
ut64_t
 
GSd
()

209 
HCRYPTPROV
 
	ghp
 = 0;

210 
BYTE
 
	grb
[8];

211 
CryAcqueCڋxt
(&
hp
, 0, 0, 
PROV_RSA_FULL
, 
CRYPT_VERIFYCONTEXT
);

212 
CryGRdom
(
hp
, (
rb
),b);

213 
CryRCڋxt
(
hp
, 0);

215 
ut64_t
 
	ged
;

216 
memy
(&
ed
, &
rb
[0], (seed));

218  
	ged
;

221 
ut64_t
 
GSd
()

223 
	gd
::
ndom_devi
 
rd
;

224  
rd
();

232 
	gd
::
mt19937
 
nd
(
ic_
<>(
GSd
()));

235 
	gd
::
t
<
d
::
rg
> 
us
 {

246 
le
 
c_num
(
Numb
* 
n
) {

247 i(
	gn
->
un
() == "%") {

248  
d
::
m
(d::
max
(
n
->
vue
() * 255 / 100.0, 0.0), 255.0);

250  
	gd
::
m
(
d
::
max
(
n
->
vue
(), 0.0), 255.0);

254 
le
 
pha_num
(
Numb
* 
n
) {

255 i(
	gn
->
un
() == "%") {

256  
d
::
m
(d::
max
(
n
->
vue
(), 0.0), 100.0);

258  
	gd
::
m
(
d
::
max
(
n
->
vue
(), 0.0), 1.0);

262 
Sigtu
 
	grgb_sig
 = "rgb($red, $green, $blue)";

263 
BUILT_IN
(
rgb
)

265  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

266 
pe
,

267 
c_num
(
ARG
("$d", 
Numb
)),

268 
c_num
(
ARG
("$g", 
Numb
)),

269 
c_num
(
ARG
("$blue", 
Numb
)));

272 
Sigtu
 
	grgba_4_sig
 = "rgba($red, $green, $blue, $alpha)";

273 
BUILT_IN
(
rgba_4
)

275  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

276 
pe
,

277 
c_num
(
ARG
("$d", 
Numb
)),

278 
c_num
(
ARG
("$g", 
Numb
)),

279 
c_num
(
ARG
("$blue", 
Numb
)),

280 
pha_num
(
ARG
("$pha", 
Numb
)));

283 
Sigtu
 
	grgba_2_sig
 = "rgba($color, $alpha)";

284 
BUILT_IN
(
rgba_2
)

286 
C
* 
	gc_g
 = 
ARG
("$color", Color);

287 
C
* 
	gw_c
 = 
SASS_MEMORY_NEW
(
x
.
mem
, C, *
c_g
);

288 
	gw_c
->
a
(
pha_num
(
ARG
("$pha", 
Numb
)));

289 
	gw_c
->
di
("");

290  
	gw_c
;

293 
Sigtu
 
	gd_sig
 = "red($color)";

294 
BUILT_IN
(
d
)

295 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
ARG
("$c", 
C
)->
r
()); }

297 
Sigtu
 
	gg_sig
 = "green($color)";

298 
BUILT_IN
(
g
)

299 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
ARG
("$c", 
C
)->
g
()); }

301 
Sigtu
 
	gblue_sig
 = "blue($color)";

302 
BUILT_IN
(
blue
)

303 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
ARG
("$c", 
C
)->
b
()); }

305 
Sigtu
 
	gmix_sig
 = "mix($color-1, $color-2, $weight: 50%)";

306 
BUILT_IN
(
mix
)

308 
C
* 
	gc1
 = 
ARG
("$color-1", Color);

309 
C
* 
	gc2
 = 
ARG
("$color-2", Color);

310 
Numb
* 
	gweight
 = 
ARGR
("$weight", Number, 0, 100);

312 
	gp
 = 
weight
->
vue
()/100;

313 
	gw
 = 2*
p
 - 1;

314 
	ga
 = 
c1
->
a
(- 
c2
->a();

316 
	gw1
 = (((
w
 * 
a
 == -1) ? w : (w +)/(1 + w*a)) + 1)/2.0;

317 
	gw2
 = 1 - 
w1
;

319  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

320 
pe
,

321 
Sass
::
round
(
w1
*
c1
->
r
(+ 
w2
*
c2
->r(), 
x
.
c_tis
.
ecisi
),

322 
Sass
::
round
(
w1
*
c1
->
g
(+ 
w2
*
c2
->g(), 
x
.
c_tis
.
ecisi
),

323 
Sass
::
round
(
w1
*
c1
->
b
(+ 
w2
*
c2
->b(), 
x
.
c_tis
.
ecisi
),

324 
c1
->
a
()*
p
 + 
c2
->a()*(1-p));

332 
	sHSL
 { 
	gh
; 
	gs
; 
	gl
; };

333 
HSL
 
rgb_to_h
(
r
, 
g
, 
b
)

337 
	gr
 /255.0; 
	gg
 /255.0; 
	gb
 /= 255.0;

339 
	gmax
 = 
d
::
max
(
r
, std::max(
g
, 
b
));

340 
	gm
 = 
d
::
m
(
r
, std::m(
g
, 
b
));

341 
	gd
 = 
max
 - 
m
;

343 
	gh
 = 0, 
	gs
 = 0, 
	gl
 = (
max
 + 
m
) / 2.0;

345 i(
	gmax
 =
m
) {

346 
h
 = 
s
 = 0;

349 i(
	gl
 < 0.5
	gs
 = 
d
 / (
max
 + 
m
);

350 
	gs
 = 
d
 / (2.0 - 
max
 - 
m
);

352 i(
	gr
 =
max

h
 = (
g
 - 
b
/ 
d
 + (g < b ? 6 : 0);

353 i(
	gg
 =
max

h
 = (
b
 - 
r
/ 
d
 + 2;

354 i(
	gb
 =
max

h
 = (
r
 - 
g
/ 
d
 + 4;

357 
HSL
 
	gh_ru
;

358 
	gh_ru
.
	gh
 = 
h
 / 6 * 360;

359 
	gh_ru
.
	gs
 = 
s
 * 100;

360 
	gh_ru
.
	gl
 = 
l
 * 100;

362  
	gh_ru
;

366 
h_to_rgb
(
m1
, 
m2
, 
h
) {

367 
	gh
 < 0) h += 1;

368 
	gh
 > 1) h -= 1;

369 i(
	gh
*6.0 < 1 
	gm1
 + (
	gm2
 - m1)*h*6;

370 i(
	gh
*2.0 < 1 
	gm2
;

371 i(
	gh
*3.0 < 2 
	gm1
 + (
	gm2
 - m1) * (2.0/3.0 - h)*6;

372  
	gm1
;

375 
C
* 
ha_im
(
h
, 
s
, 
l
, 
a
, 
Cڋxt
& 
x
, 
PrS
 
pe
)

377 
	gh
 /= 360.0;

378 
	gs
 /= 100.0;

379 
	gl
 /= 100.0;

381 i(
	gl
 < 0) = 0;

382 i(
	gs
 < 0) s = 0;

383 i(
	gl
 > 1) = 1;

384 i(
	gs
 > 1) s = 1;

385 
	gh
 < 0) h += 1;

386 
	gh
 > 1) h -= 1;

389 
	gm2
;

390 i(
	gl
 <0.5
m2
 = 
l
*(
s
+1.0);

391 
	gm2
 = (
l
+
s
)-(l*s);

392 
	gm1
 = (
l
*2.0)-
m2
;

394 
	gr
 = (
h_to_rgb
(
m1
, 
m2
, 
h
 + 1.0/3.0) * 255.0);

395 
	gg
 = (
h_to_rgb
(
m1
, 
m2
, 
h
) * 255.0);

396 
	gb
 = (
h_to_rgb
(
m1
, 
m2
, 
h
 - 1.0/3.0) * 255.0);

398  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
, 
pe
, 
r
, 
g
, 
b
, 
a
);

401 
Sigtu
 
	gh_sig
 = "hsl($hue, $saturation, $lightness)";

402 
BUILT_IN
(
h
)

404  
ha_im
(
ARG
("$hue", 
Numb
)->
vue
(),

405 
ARG
("$tuti", 
Numb
)->
vue
(),

406 
ARG
("$lighess", 
Numb
)->
vue
(),

408 
x
,

409 
pe
);

412 
Sigtu
 
	gha_sig
 = "hsla($hue, $saturation, $lightness, $alpha)";

413 
BUILT_IN
(
ha
)

415  
ha_im
(
ARG
("$hue", 
Numb
)->
vue
(),

416 
ARG
("$tuti", 
Numb
)->
vue
(),

417 
ARG
("$lighess", 
Numb
)->
vue
(),

418 
ARG
("$pha", 
Numb
)->
vue
(),

419 
x
,

420 
pe
);

423 
Sigtu
 
	ghue_sig
 = "hue($color)";

424 
BUILT_IN
(
hue
)

426 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

427 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

428 
rgb_c
->
g
(),

429 
rgb_c
->
b
());

430  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
h_c
.
h
, "deg");

433 
Sigtu
 
	gtuti_sig
 = "saturation($color)";

434 
BUILT_IN
(
tuti
)

436 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

437 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

438 
rgb_c
->
g
(),

439 
rgb_c
->
b
());

440  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
h_c
.
s
, "%");

443 
Sigtu
 
	glighess_sig
 = "lightness($color)";

444 
BUILT_IN
(
lighess
)

446 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

447 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

448 
rgb_c
->
g
(),

449 
rgb_c
->
b
());

450  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
h_c
.
l
, "%");

453 
Sigtu
 
	gadju_hue_sig
 = "adjust-hue($color, $degrees)";

454 
BUILT_IN
(
adju_hue
)

456 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

457 
Numb
* 
	gdeges
 = 
ARG
("$degrees", Number);

458 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

459 
rgb_c
->
g
(),

460 
rgb_c
->
b
());

461  
ha_im
(
h_c
.
h
 + 
deges
->
vue
(),

462 
h_c
.
s
,

463 
h_c
.
l
,

464 
rgb_c
->
a
(),

465 
x
,

466 
pe
);

469 
Sigtu
 
	glighn_sig
 = "lighten($color, $amount)";

470 
BUILT_IN
(
lighn
)

472 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

473 
Numb
* 
	gamou
 = 
ARGR
("$amount", Number, 0, 100);

474 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

475 
rgb_c
->
g
(),

476 
rgb_c
->
b
());

478 
	ghcL
 = 
h_c
.
l
;

479 i(
	ghcL
 < 0) {

480 
	ghcL
 = 0;

483  
ha_im
(
h_c
.
h
,

484 
h_c
.
s
,

485 
hcL
 + 
amou
->
vue
(),

486 
rgb_c
->
a
(),

487 
x
,

488 
pe
);

491 
Sigtu
 
	gdk_sig
 = "darken($color, $amount)";

492 
BUILT_IN
(
dk
)

494 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

495 
Numb
* 
	gamou
 = 
ARGR
("$amount", Number, 0, 100);

496 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

497 
rgb_c
->
g
(),

498 
rgb_c
->
b
());

501 
	ghcL
 = 
h_c
.
l
;

502 i(
	ghcL
 > 100) {

503 
	ghcL
 = 100;

506  
ha_im
(
h_c
.
h
,

507 
h_c
.
s
,

508 
hcL
 - 
amou
->
vue
(),

509 
rgb_c
->
a
(),

510 
x
,

511 
pe
);

514 
Sigtu
 
	gtu_sig
 = "saturate($color, $amount: false)";

515 
BUILT_IN
(
tu
)

518 
Numb
* 
	gamou
 = 
dymic_
<Numb*>(
v
["$amount"]);

519 i(!
	gamou
) {

520  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, "tu(" + 
v
["$c"]->
to_rg
(x.
c_tis
) + ")");

523 
ARGR
("$amou", 
Numb
, 0, 100);

524 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

525 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

526 
rgb_c
->
g
(),

527 
rgb_c
->
b
());

529 
	ghcS
 = 
h_c
.
s
 + 
amou
->
vue
();

532 i(
	ghcS
 < 0) {

533 
	ghcS
 = 0;

535 i(
	ghcS
 > 100) {

536 
	ghcS
 = 100;

539  
ha_im
(
h_c
.
h
,

540 
hcS
,

541 
h_c
.
l
,

542 
rgb_c
->
a
(),

543 
x
,

544 
pe
);

547 
Sigtu
 
	gdetu_sig
 = "desaturate($color, $amount)";

548 
BUILT_IN
(
detu
)

550 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

551 
Numb
* 
	gamou
 = 
ARGR
("$amount", Number, 0, 100);

552 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

553 
rgb_c
->
g
(),

554 
rgb_c
->
b
());

556 
	ghcS
 = 
h_c
.
s
 - 
amou
->
vue
();

559 i(
	ghcS
 <= 0) {

560 
hcS
 = 0;

562 i(
	ghcS
 > 100) {

563 
	ghcS
 = 100;

566  
ha_im
(
h_c
.
h
,

567 
hcS
,

568 
h_c
.
l
,

569 
rgb_c
->
a
(),

570 
x
,

571 
pe
);

574 
Sigtu
 
	ggys_sig
 = "grayscale($color)";

575 
BUILT_IN
(
gys
)

578 
Numb
* 
	gamou
 = 
dymic_
<Numb*>(
v
["$color"]);

579 i(
	gamou
) {

580  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, "gys(" + 
amou
->
to_rg
(x.
c_tis
) + ")");

583 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

584 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

585 
rgb_c
->
g
(),

586 
rgb_c
->
b
());

587  
ha_im
(
h_c
.
h
,

589 
h_c
.
l
,

590 
rgb_c
->
a
(),

591 
x
,

592 
pe
);

595 
Sigtu
 
	gcomemt_sig
 = "complement($color)";

596 
BUILT_IN
(
comemt
)

598 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

599 
HSL
 
	gh_c
 = 
rgb_to_h
(
rgb_c
->
r
(),

600 
rgb_c
->
g
(),

601 
rgb_c
->
b
());

602  
ha_im
(
h_c
.
h
 - 180.0,

603 
h_c
.
s
,

604 
h_c
.
l
,

605 
rgb_c
->
a
(),

606 
x
,

607 
pe
);

610 
Sigtu
 
	gvt_sig
 = "invert($color)";

611 
BUILT_IN
(
vt
)

614 
Numb
* 
	gamou
 = 
dymic_
<Numb*>(
v
["$color"]);

615 i(
	gamou
) {

616  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, "vt(" + 
amou
->
to_rg
(x.
c_tis
) + ")");

619 
C
* 
	grgb_c
 = 
ARG
("$color", Color);

620  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

621 
pe
,

622 255 - 
rgb_c
->
r
(),

623 255 - 
rgb_c
->
g
(),

624 255 - 
rgb_c
->
b
(),

625 
rgb_c
->
a
());

631 
Sigtu
 
	gpha_sig
 = "alpha($color)";

632 
Sigtu
 
	gacy_sig
 = "opacity($color)";

633 
BUILT_IN
(
pha
)

635 
Sg_Cڡt
* 
	g_kwd
 = 
dymic_
<Sg_Cڡt*>(
v
["$color"]);

636 i(
	g_kwd
) {

637  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, "pha(" + 
_kwd
->
vue
() + ")");

641 
Numb
* 
	gamou
 = 
dymic_
<Numb*>(
v
["$color"]);

642 i(
	gamou
) {

643  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, "acy(" + 
amou
->
to_rg
(x.
c_tis
) + ")");

646  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
ARG
("$c", 
C
)->
a
());

649 
Sigtu
 
	gacify_sig
 = "opacify($color, $amount)";

650 
Sigtu
 
	gde__sig
 = "fade-in($color, $amount)";

651 
BUILT_IN
(
acify
)

653 
C
* 
	gc
 = 
ARG
("$color", Color);

654 
	gamou
 = 
ARGR
("$amou", 
Numb
, 0, 1)->
vue
();

655 
	gpha
 = 
d
::
m
(
c
->
a
(+ 
amou
, 1.0);

656  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

657 
pe
,

658 
c
->
r
(),

659 
c
->
g
(),

660 
c
->
b
(),

661 
pha
);

664 
Sigtu
 
	gtize_sig
 = "transparentize($color, $amount)";

665 
Sigtu
 
	gde_out_sig
 = "fade-out($color, $amount)";

666 
BUILT_IN
(
tize
)

668 
C
* 
	gc
 = 
ARG
("$color", Color);

669 
	gamou
 = 
ARGR
("$amou", 
Numb
, 0, 1)->
vue
();

670 
	gpha
 = 
d
::
max
(
c
->
a
(- 
amou
, 0.0);

671  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

672 
pe
,

673 
c
->
r
(),

674 
c
->
g
(),

675 
c
->
b
(),

676 
pha
);

683 
Sigtu
 
	gadju_c_sig
 = "adjust-color($color, $red: false, $green: false, $blue: false, $hue: false, $saturation: false, $lightness: false, $alpha: false)";

684 
BUILT_IN
(
adju_c
)

686 
C
* 
	gc
 = 
ARG
("$color", Color);

687 
Numb
* 
	gr
 = 
dymic_
<Numb*>(
v
["$red"]);

688 
Numb
* 
	gg
 = 
dymic_
<Numb*>(
v
["$green"]);

689 
Numb
* 
	gb
 = 
dymic_
<Numb*>(
v
["$blue"]);

690 
Numb
* 
	gh
 = 
dymic_
<Numb*>(
v
["$hue"]);

691 
Numb
* 
	gs
 = 
dymic_
<Numb*>(
v
["$saturation"]);

692 
Numb
* 
	gl
 = 
dymic_
<Numb*>(
v
["$lightness"]);

693 
Numb
* 
	ga
 = 
dymic_
<Numb*>(
v
["$alpha"]);

695 
bo
 
	grgb
 = 
r
 || 
g
 || 
b
;

696 
bo
 
	gh
 = 
h
 || 
s
 || 
l
;

698 i(
	grgb
 && 
	gh
) {

699 
r
(" scify bh RGBnd HSL vuef `adju-c`", 
pe
);

701 i(
	grgb
) {

702 
	g
 = 
r
 ? 
ARGR
("$d", 
Numb
, -255, 255)->
vue
() : 0;

703 
	ggg
 = 
g
 ? 
ARGR
("$g", 
Numb
, -255, 255)->
vue
() : 0;

704 
	gbb
 = 
b
 ? 
ARGR
("$blue", 
Numb
, -255, 255)->
vue
() : 0;

705 
	g
 = 
a
 ? 
ARGR
("$pha", 
Numb
, -1, 1)->
vue
() : 0;

706  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

707 
pe
,

708 
c
->
r
(+ 

,

709 
c
->
g
(+ 
gg
,

710 
c
->
b
(+ 
bb
,

711 
c
->
a
(+ 

);

713 i(
	gh
) {

714 
HSL
 
	gh_ru
 = 
rgb_to_h
(
c
->
r
(), c->
g
(), c->
b
());

715 
	gss
 = 
s
 ? 
ARGR
("$tuti", 
Numb
, -100, 100)->
vue
() : 0;

716 
	g
 = 
l
 ? 
ARGR
("$lighess", 
Numb
, -100, 100)->
vue
() : 0;

717 
	g
 = 
a
 ? 
ARGR
("$pha", 
Numb
, -1, 1)->
vue
() : 0;

718  
ha_im
(
h_ru
.
h
 + (h ? h->
vue
() : 0),

719 
h_ru
.
s
 + 
ss
,

720 
h_ru
.
l
 + 

,

721 
c
->
a
(+ 

,

722 
x
,

723 
pe
);

725 i(
	ga
) {

726  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

727 
pe
,

728 
c
->
r
(),

729 
c
->
g
(),

730 
c
->
b
(),

731 
c
->
a
(+ (?->
vue
() : 0));

733 
r
("nكnoughrgumtf `adju-c`", 
pe
);

735  
	gc
;

738 
Sigtu
 
	gs_c_sig
 = "scale-color($color, $red: false, $green: false, $blue: false, $hue: false, $saturation: false, $lightness: false, $alpha: false)";

739 
BUILT_IN
(
s_c
)

741 
C
* 
	gc
 = 
ARG
("$color", Color);

742 
Numb
* 
	gr
 = 
dymic_
<Numb*>(
v
["$red"]);

743 
Numb
* 
	gg
 = 
dymic_
<Numb*>(
v
["$green"]);

744 
Numb
* 
	gb
 = 
dymic_
<Numb*>(
v
["$blue"]);

745 
Numb
* 
	gh
 = 
dymic_
<Numb*>(
v
["$hue"]);

746 
Numb
* 
	gs
 = 
dymic_
<Numb*>(
v
["$saturation"]);

747 
Numb
* 
	gl
 = 
dymic_
<Numb*>(
v
["$lightness"]);

748 
Numb
* 
	ga
 = 
dymic_
<Numb*>(
v
["$alpha"]);

750 
bo
 
	grgb
 = 
r
 || 
g
 || 
b
;

751 
bo
 
	gh
 = 
h
 || 
s
 || 
l
;

753 i(
	grgb
 && 
	gh
) {

754 
r
(" scify bh RGBnd HSL vuef `s-c`", 
pe
);

756 i(
	grgb
) {

757 
	grs
 = (
r
 ? 
ARGR
("$d", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

758 
	ggs
 = (
g
 ? 
ARGR
("$g", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

759 
	gbs
 = (
b
 ? 
ARGR
("$blue", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

760 
	gas
 = (
a
 ? 
ARGR
("$pha", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

761  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

762 
pe
,

763 
c
->
r
(+ 
rs
 * (rscale > 0.0 ? 255 - color->r() : color->r()),

764 
c
->
g
(+ 
gs
 * (gscale > 0.0 ? 255 - color->g() : color->g()),

765 
c
->
b
(+ 
bs
 * (bscale > 0.0 ? 255 - color->b() : color->b()),

766 
c
->
a
(+ 
as
 * (ascale > 0.0 ? 1.0 - color->a() : color->a()));

768 i(
	gh
) {

769 
	ghs
 = (
h
 ? 
ARGR
("$hue", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

770 
	gss
 = (
s
 ? 
ARGR
("$tuti", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

771 
	gls
 = (
l
 ? 
ARGR
("$lighess", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

772 
	gas
 = (
a
 ? 
ARGR
("$pha", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

773 
HSL
 
	gh_ru
 = 
rgb_to_h
(
c
->
r
(), c->
g
(), c->
b
());

774 
	gh_ru
.
	gh
 +
hs
 * (hs > 0.0 ? 360.0 - 
h_ru
.
h
 : hsl_struct.h);

775 
	gh_ru
.
	gs
 +
ss
 * (ss > 0.0 ? 100.0 - 
h_ru
.
s
 : hsl_struct.s);

776 
	gh_ru
.
	gl
 +
ls
 * (ls > 0.0 ? 100.0 - 
h_ru
.
l
 : hsl_struct.l);

777 
	gpha
 = 
c
->
a
(+ 
as
 * (ascale > 0.0 ? 1.0 - color->a() : color->a());

778  
ha_im
(
h_ru
.
h
, h_ru.
s
, h_ru.
l
, 
pha
, 
x
, 
pe
);

780 i(
	ga
) {

781 
	gas
 = (
a
 ? 
ARGR
("$pha", 
Numb
, -100.0, 100.0)->
vue
() : 0.0) / 100.0;

782  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

783 
pe
,

784 
c
->
r
(),

785 
c
->
g
(),

786 
c
->
b
(),

787 
c
->
a
(+ 
as
 * (ascale > 0.0 ? 1.0 - color->a() : color->a()));

789 
r
("nكnoughrgumtf `s-c`", 
pe
);

791  
	gc
;

794 
Sigtu
 
	gchge_c_sig
 = "change-color($color, $red: false, $green: false, $blue: false, $hue: false, $saturation: false, $lightness: false, $alpha: false)";

795 
BUILT_IN
(
chge_c
)

797 
C
* 
	gc
 = 
ARG
("$color", Color);

798 
Numb
* 
	gr
 = 
dymic_
<Numb*>(
v
["$red"]);

799 
Numb
* 
	gg
 = 
dymic_
<Numb*>(
v
["$green"]);

800 
Numb
* 
	gb
 = 
dymic_
<Numb*>(
v
["$blue"]);

801 
Numb
* 
	gh
 = 
dymic_
<Numb*>(
v
["$hue"]);

802 
Numb
* 
	gs
 = 
dymic_
<Numb*>(
v
["$saturation"]);

803 
Numb
* 
	gl
 = 
dymic_
<Numb*>(
v
["$lightness"]);

804 
Numb
* 
	ga
 = 
dymic_
<Numb*>(
v
["$alpha"]);

806 
bo
 
	grgb
 = 
r
 || 
g
 || 
b
;

807 
bo
 
	gh
 = 
h
 || 
s
 || 
l
;

809 i(
	grgb
 && 
	gh
) {

810 
r
(" scify bh RGBnd HSL vuef `chge-c`", 
pe
);

812 i(
	grgb
) {

813  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

814 
pe
,

815 
r
 ? 
ARGR
("$d", 
Numb
, 0, 255)->
vue
(: 
c
->r(),

816 
g
 ? 
ARGR
("$g", 
Numb
, 0, 255)->
vue
(: 
c
->g(),

817 
b
 ? 
ARGR
("$blue", 
Numb
, 0, 255)->
vue
(: 
c
->b(),

818 
a
 ? 
ARGR
("$pha", 
Numb
, 0, 255)->
vue
(: 
c
->a());

820 i(
	gh
) {

821 
HSL
 
	gh_ru
 = 
rgb_to_h
(
c
->
r
(), c->
g
(), c->
b
());

822 i(
	gh

	gh_ru
.h = 
ic_
<>(((ic_<>(
h
->
vue
()) % 360) + 360) % 360) / 360.0;

823 i(
	gs

	gh_ru
.
ARGR
("$tuti", 
Numb
, 0, 100)->
vue
();

824 i(
	gl

	gh_ru
.
ARGR
("$lighess", 
Numb
, 0, 100)->
vue
();

825 
	gpha
 = 
a
 ? 
ARGR
("$pha", 
Numb
, 0, 1.0)->
vue
(: 
c
->a();

826  
ha_im
(
h_ru
.
h
, h_ru.
s
, h_ru.
l
, 
pha
, 
x
, 
pe
);

828 i(
	ga
) {

829 
	gpha
 = 
a
 ? 
ARGR
("$pha", 
Numb
, 0, 1.0)->
vue
(: 
c
->a();

830  
SASS_MEMORY_NEW
(
x
.
mem
, 
C
,

831 
pe
,

832 
c
->
r
(),

833 
c
->
g
(),

834 
c
->
b
(),

835 
pha
);

837 
r
("nكnoughrgumtf `chge-c`", 
pe
);

839  
	gc
;

842 
	gme
 <
size_t
 
	gnge
>

843 
p_chl
(
c
) {

844 i(
	gc
 > 
	gnge
) ange;

845 i(
	gc
 < 0)  0;

846  
	gc
;

849 
Sigtu
 
	g_hex_r_sig
 = "ie-hex-str($color)";

850 
BUILT_IN
(
_hex_r
)

852 
C
* 
	gc
 = 
ARG
("$color", Color);

853 
	gr
 = 
p_chl
<0xff>(
c
->
r
());

854 
	gg
 = 
p_chl
<0xff>(
c
->
g
());

855 
	gb
 = 
p_chl
<0xff>(
c
->
b
());

856 
	ga
 = 
p_chl
<1> (
c
->
a
()) * 255;

858 
	gd
::
rgam
 
ss
;

859 
	gss
 << '#' << 
	gd
::
tw
(2<< 
d
::
tfl
('0');

860 
	gss
 << 
	gd
::
hex
 << 
d
::
tw
(2<< 
ic_
<>(
Sass
::
round
(
a
, 
x
.
c_tis
.
ecisi
));

861 
	gss
 << 
	gd
::
hex
 << 
d
::
tw
(2<< 
ic_
<>(
Sass
::
round
(
r
, 
x
.
c_tis
.
ecisi
));

862 
	gss
 << 
	gd
::
hex
 << 
d
::
tw
(2<< 
ic_
<>(
Sass
::
round
(
g
, 
x
.
c_tis
.
ecisi
));

863 
	gss
 << 
	gd
::
hex
 << 
d
::
tw
(2<< 
ic_
<>(
Sass
::
round
(
b
, 
x
.
c_tis
.
ecisi
));

865 
	gd
::
rg
 
su
(
ss
.
r
());

866 
size_t
 
	gi
 = 0, 
	gL
 = 
su
.
ngth
(); i < L; ++i) {

867 
	gsu
[
i
] = 
d
::
tou
(
su
[i]);

869  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
su
);

876 
Sigtu
 
	gunque_sig
 = "unquote($string)";

877 
BUILT_IN
(
ss_unque
)

879 
AST_Node
* 
	gg
 = 
v
["$string"];

880 i(
Sg_Qued
* 
	grg_qued
 = 
dymic_
<Sg_Qued*>(
g
)) {

881 
Sg_Cڡt
* 
su
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Cڡt, 
pe
, 
rg_qued
->
vue
());

883 
	gsu
->
ss_fix_1291
(
rg_qued
->
que_mk
() != 0);

884  
	gsu
;

886 i(
	gdymic_
<
	gSg_Cڡt
*>(
	gg
)) {

887  (
	gExessi
*
	gg
;

890 
Sass_Ouut_Sty
 
	gdy
 = 
x
.
c_tis
.
ouut_y
;

891 
	gx
.
	gc_tis
.
	gouut_y
 = 
SASS_STYLE_NESTED
;

892 
	gd
::
rg
 
v
(
g
->
to_rg
(
x
.
c_tis
));

893 
	gv
 = 
dymic_
<
Nu
*>(
g
? "nu" : 
v
;

894 
	gx
.
	gc_tis
.
	gouut_y
 = 
dy
;

896 
dd_funi
("Passg " + 
v
 + ",-rg vue,unque()", 
pe
);

897  (
	gExessi
*
	gg
;

901 
Sigtu
 
	gque_sig
 = "quote($string)";

902 
BUILT_IN
(
ss_que
)

904 
AST_Node
* 
	gg
 = 
v
["$string"];

906 i(
Sg_Qued
* 
	gqr
 = 
dymic_
<Sg_Qued*>(
g
)) {

907 
qr
->
que_mk
('*');

908  
	gqr
;

911 
	gd
::
rg
 
r
(
que
(
g
->
to_rg
(
x
.
c_tis
), 
Sg_Cڡt
::
doub_que
()));

912 
Sg_Qued
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, 
pe
, 
r
);

913 
	gsu
->
is_dayed
(
ue
);

914 
	gsu
->
que_mk
('*');

915  
	gsu
;

919 
Sigtu
 
	gr_ngth_sig
 = "str-length($string)";

920 
BUILT_IN
(
r_ngth
)

922 
size_t
 
	gn
 = 
d
::
rg
::
os
;

923 
	gy
 {

924 
Sg_Cڡt
* 
	gs
 = 
ARG
("$string", String_Constant);

925 
	gn
 = 
UTF_8
::
code_pot_cou
(
s
->
vue
(), 0, s->vue().
size
());

930 
tch
 (...{ 
hd_utf8_r
(
pe
, 
backa
); }

932  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()
n
);

935 
Sigtu
 
	gr__sig
 = "str-insert($string, $insert, $index)";

936 
BUILT_IN
(
r_
)

938 
	gd
::
rg
 
r
;

939 
	gy
 {

940 
Sg_Cڡt
* 
	gs
 = 
ARG
("$string", String_Constant);

941 
	gr
 = 
s
->
vue
();

942 
	gr
 = 
unque
(
r
);

943 
Sg_Cڡt
* 
	gi
 = 
ARG
("$insert", String_Constant);

944 
	gd
::
rg
 
s
 = 
i
->
vue
();

945 
	gs
 = 
unque
(
s
);

946 
Numb
* 
	gd
 = 
ARG
("$index", Number);

947 
	gdex
 = 
d
->
vue
();

948 
size_t
 
	gn
 = 
UTF_8
::
code_pot_cou
(
r
, 0, s.
size
());

950 i(
	gdex
 > 0 && index <
n
) {

952 
r
.

(
UTF_8
::
offt__posi
(r, 
ic_
<
size_t
>(
dex
- 1), 
s
);

954 i(
	gdex
 > 
	gn
) {

956 
	gr
 +
s
;

958 i(
	gdex
 == 0) {

959 
r
 = 
s
 + str;

961 i(
	gd
::
abs
(
dex
<
n
) {

963 
dex
 +
n
 + 1;

964 
	gr
.

(
UTF_8
::
offt__posi
(
r
, 
ic_
<
size_t
>(
dex
)), 
s
);

968 
	gr
 = 
s
 + 
r
;

971 i(
Sg_Qued
* 
	gss
 = 
dymic_
<Sg_Qued*>(
s
)) {

972 i(
ss
->
que_mk
()
r
 = 
que
(str);

977 
tch
 (...{ 
hd_utf8_r
(
pe
, 
backa
); }

978  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
r
);

981 
Sigtu
 
	gr_dex_sig
 = "str-index($string, $substring)";

982 
BUILT_IN
(
r_dex
)

984 
size_t
 
	gdex
 = 
d
::
rg
::
os
;

985 
	gy
 {

986 
Sg_Cڡt
* 
	gs
 = 
ARG
("$string", String_Constant);

987 
Sg_Cڡt
* 
	gt
 = 
ARG
("$substring", String_Constant);

988 
	gd
::
rg
 
r
 = 
s
->
vue
();

989 
	gr
 = 
unque
(
r
);

990 
	gd
::
rg
 
subr
 = 
t
->
vue
();

991 
	gsubr
 = 
unque
(
subr
);

993 
size_t
 
	gc_dex
 = 
r
.
fd
(
subr
);

994 if(
	gc_dex
 =
d
::
rg
::
os
) {

995  
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
pe
);

997 
	gdex
 = 
UTF_8
::
code_pot_cou
(
r
, 0, 
c_dex
) + 1;

1001 
tch
 (...{ 
hd_utf8_r
(
pe
, 
backa
); }

1003  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()
dex
);

1006 
Sigtu
 
	gr_i_sig
 = "str-slice($string, $start-at, $end-at:-1)";

1007 
BUILT_IN
(
r_i
)

1009 
	gd
::
rg
 
wr
;

1010 
	gy
 {

1011 
Sg_Cڡt
* 
	gs
 = 
ARG
("$string", String_Constant);

1012 
	gt_
 = 
ARG
("$t-", 
Numb
)->
vue
();

1013 
	gd_
 = 
ARG
("$d-", 
Numb
)->
vue
();

1015 
	gd
::
rg
 
r
 = 
unque
(
s
->
vue
());

1017 
size_t
 
	gsize
 = 
utf8
::
di
(
r
.
beg
(), s.
d
());

1018 i(
	gd_
 <
size
 * -1.0{ 
d_
 += size; }

1019 i(
	gd_
 < 0{nd_ +
size
 + 1; }

1020 i(
	gd_
 > 
	gsize
{nd_ = ()
size
; }

1021 i(
	gt_
 < 0{ s_ +
size
 + 1; }

1022 i(
	gt_
 =0{ ++ 
t_
; }

1024 i(
	gt_
 <
d_
)

1026 
d
::
rg
::

 
t
 = 
r
.
beg
();

1027 
	gutf8
::
adv
(
t
, 
t_
 - 1, 
r
.
d
());

1028 
	gd
::
rg
::

 
d
 = 
t
;

1029 
	gutf8
::
adv
(
d
, 
d_
 - 
t_
 + 1, 
r
.end());

1030 
	gwr
 = 
d
::
rg
(
t
, 
d
);

1032 i(
Sg_Qued
* 
	gss
 = 
dymic_
<Sg_Qued*>(
s
)) {

1033 if(
ss
->
que_mk
()
wr
 = 
que
(newstr);

1038 
tch
 (...{ 
hd_utf8_r
(
pe
, 
backa
); }

1039  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
wr
);

1042 
Sigtu
 
	gto_u__sig
 = "to-upper-case($string)";

1043 
BUILT_IN
(
to_u_
)

1045 
Sg_Cڡt
* 
	gs
 = 
ARG
("$string", String_Constant);

1046 
	gd
::
rg
 
r
 = 
s
->
vue
();

1048 
size_t
 
	gi
 = 0, 
	gL
 = 
r
.
ngth
(); i < L; ++i) {

1049 i(
	gSass
::
Ut
::
isAscii
(
r
[
i
])) {

1050 
r
[
i
] = 
d
::
tou
(str[i]);

1054 i(
Sg_Qued
* 
	gss
 = 
dymic_
<Sg_Qued*>(
s
)) {

1055 
Sg_Qued
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, *
ss
);

1056 
	gy
->
vue
(
r
);

1057  
	gy
;

1059  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
r
);

1063 
Sigtu
 
	gto_low__sig
 = "to-lower-case($string)";

1064 
BUILT_IN
(
to_low_
)

1066 
Sg_Cڡt
* 
	gs
 = 
ARG
("$string", String_Constant);

1067 
	gd
::
rg
 
r
 = 
s
->
vue
();

1069 
size_t
 
	gi
 = 0, 
	gL
 = 
r
.
ngth
(); i < L; ++i) {

1070 i(
	gSass
::
Ut
::
isAscii
(
r
[
i
])) {

1071 
r
[
i
] = 
d
::
tow
(str[i]);

1075 i(
Sg_Qued
* 
	gss
 = 
dymic_
<Sg_Qued*>(
s
)) {

1076 
Sg_Qued
* 
y
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, *
ss
);

1077 
	gy
->
vue
(
r
);

1078  
	gy
;

1080  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
r
);

1088 
Sigtu
 
	grage_sig
 = "percentage($number)";

1089 
BUILT_IN
(
rage
)

1091 
Numb
* 
	gn
 = 
ARG
("$number", Number);

1092 i(!
	gn
->
is_unss
()
r
("gum$numb o`" + 
d
::
rg
(
sig
+ "` mu bunss", 
pe
);

1093  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
n
->
vue
() * 100, "%");

1096 
Sigtu
 
	ground_sig
 = "round($number)";

1097 
BUILT_IN
(
round
)

1099 
Numb
* 
	gn
 = 
ARG
("$number", Number);

1100 
Numb
* 
	gr
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Numb, *
n
);

1101 
	gr
->
pe
(pstate);

1102 
	gr
->
vue
(
Sass
::
round
(
r
->vue(), 
x
.
c_tis
.
ecisi
));

1103  
	gr
;

1106 
Sigtu
 
	g_sig
 = "ceil($number)";

1107 
BUILT_IN
(

)

1109 
Numb
* 
	gn
 = 
ARG
("$number", Number);

1110 
Numb
* 
	gr
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Numb, *
n
);

1111 
	gr
->
pe
(pstate);

1112 
	gr
->
vue
(
d
::

(
r
->value()));

1113  
	gr
;

1116 
Sigtu
 
	go_sig
 = "floor($number)";

1117 
BUILT_IN
(
o
)

1119 
Numb
* 
	gn
 = 
ARG
("$number", Number);

1120 
Numb
* 
	gr
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Numb, *
n
);

1121 
	gr
->
pe
(pstate);

1122 
	gr
->
vue
(
d
::
o
(
r
->value()));

1123  
	gr
;

1126 
Sigtu
 
	gabs_sig
 = "abs($number)";

1127 
BUILT_IN
(
abs
)

1129 
Numb
* 
	gn
 = 
ARG
("$number", Number);

1130 
Numb
* 
	gr
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Numb, *
n
);

1131 
	gr
->
pe
(pstate);

1132 
	gr
->
vue
(
d
::
abs
(
r
->value()));

1133  
	gr
;

1136 
Sigtu
 
	gm_sig
 = "min($numbers...)";

1137 
BUILT_IN
(
m
)

1139 
Li
* 
	ggli
 = 
ARG
("$numbers", List);

1140 
Numb
* 
	ga
 = 0;

1141 
size_t
 
	gi
 = 0, 
	gL
 = 
gli
->
ngth
(); i < L; ++i) {

1142 
Exessi
* 
	gv
 = 
gli
->
vue__dex
(
i
);

1143 
Numb
* 
	gxi
 = 
dymic_
<Numb*>(
v
);

1144 i(!
	gxi
) {

1145 
r
("\"" + 
v
->
to_rg
(
x
.
c_tis
+ "\" inهumb f `m'", 
pe
);

1147 i(
	ga
) {

1148 i(*
	gxi
 < *
	ga
a = 
xi
;

1149 } 
	ga
 = 
xi
;

1151  
	ga
;

1154 
Sigtu
 
	gmax_sig
 = "max($numbers...)";

1155 
BUILT_IN
(
max
)

1157 
Li
* 
	ggli
 = 
ARG
("$numbers", List);

1158 
Numb
* 
	gge
 = 0;

1159 
size_t
 
	gi
 = 0, 
	gL
 = 
gli
->
ngth
(); i < L; ++i) {

1160 
Exessi
* 
	gv
 = 
gli
->
vue__dex
(
i
);

1161 
Numb
* 
	gxi
 = 
dymic_
<Numb*>(
v
);

1162 i(!
	gxi
) {

1163 
r
("\"" + 
v
->
to_rg
(
x
.
c_tis
+ "\" inهumb f `max'", 
pe
);

1165 i(
	gge
) {

1166 i(*
	gge
 < *
	gxi
ge = 
xi
;

1167 } 
	gge
 = 
xi
;

1169  
	gge
;

1172 
Sigtu
 
	gndom_sig
 = "random($limit:false)";

1173 
BUILT_IN
(
ndom
)

1175 
AST_Node
* 
	gg
 = 
v
["$limit"];

1176 
Vue
* 
	gv
 = 
dymic_
<Vue*>(
g
);

1177 
Numb
* 
	gl
 = 
dymic_
<Numb*>(
g
);

1178 
Boޗn
* 
	gb
 = 
dymic_
<Boޗn*>(
g
);

1179 i(
	gl
) {

1180 
	gv
 = 
l
->
vue
();

1181 i(
	gv
 < 1) {

1182 
rgam
 
	gr
;

1183 
	gr
 << "$lim " << 
	gv
 << " must be greaterhan orqualo 1 for `random`";

1184 
r
(
r
.
r
(), 
pe
);

1186 
bo
 
	geq_t
 = 
d
::
bs
(
unc
(
v
- v< 
NUMBER_EPSILON
;

1187 i(!
	geq_t
) {

1188 
rgam
 
	gr
;

1189 
	gr
 << "Exed $limb ieg bug `" << 
	gv
 << "` for `random`";

1190 
r
(
r
.
r
(), 
pe
);

1192 
	gd
::
unifm__diributi
<> 
diribut
(1, 
v
 + 1);

1193 
ut_32_t
 
	gdiribud
 = 
ic_
<ut_32_t>(
diribut
(
nd
));

1194  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()
diribud
);

1196 i(
	gb
) {

1197 
	gd
::
unifm__diributi
<> 
diribut
(0, 1);

1198 
	gdiribud
 = 
ic_
<>(
diribut
(
nd
));

1199  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 
diribud
);

1200 } i(
	gv
) {

1201 
throw
 
	gExi
::
InvidArgumtTy
(
pe
, "ndom", "$lim", "numb", 
v
);

1203 
throw
 
	gExi
::
InvidArgumtTy
(
pe
, "random", "$limit", "number");

1212 
Sigtu
 
	gngth_sig
 = "length($list)";

1213 
BUILT_IN
(
ngth
)

1215 i(
Se_Li
* 
	g
 = 
dymic_
<Se_Li*>(
v
["$list"])) {

1216  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()

->
ngth
());

1218 
Exessi
* 
	gv
 = 
ARG
("$list", Expression);

1219 i(
	gv
->
ce_ty
(=
Exessi
::
MAP
) {

1220 
M
* 
m
 = 
dymic_
<M*>(
v
["$list"]);

1221  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()(
m
 ? m->
ngth
() : 1));

1223 i(
	gv
->
ce_ty
(=
Exessi
::
SELECTOR
) {

1224 i(
Compound_Se
* 
h
 = 
dymic_
<Compound_Se*>(
v
)) {

1225  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()
h
->
ngth
());

1226 } i(
Se_Li
* 
	gls
 = 
dymic_
<Se_Li*>(
v
)) {

1227  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()
ls
->
ngth
());

1229  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, 1);

1233 
Li
* 
	gli
 = 
dymic_
<Li*>(
v
["$list"]);

1234  
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
,

1235 
pe
,

1236 ()(
li
 ?i->
size
() : 1));

1239 
Sigtu
 
	gh_sig
 = "nth($list, $n)";

1240 
BUILT_IN
(
h
)

1242 
Numb
* 
	gn
 = 
ARG
("$n", Number);

1243 
M
* 
	gm
 = 
dymic_
<M*>(
v
["$list"]);

1244 i(
Se_Li
* 
	g
 = 
dymic_
<Se_Li*>(
v
["$list"])) {

1245 
size_t
 
n
 = 
m
 ? m->
ngth
(: 

->length();

1246 
bo
 
	gemy
 = 
m
 ? m->
emy
(: 

->empty();

1247 i(
	gemy

r
("gum`$li` o`" + 
d
::
rg
(
sig
+ "` mu bemy", 
pe
);

1248 
	gdex
 = 
d
::
o
(
n
->
vue
(< 0 ? 
n
 +->value() :->value() - 1);

1249 i(
	gdex
 < 0 || index > 
	gn
 - 1
r
("dex ouoboundf `" + 
d
::
rg
(
sig
+ "`", 
pe
);

1251 
Liize
 
liize
(
x
.
mem
);

1252  (*
	g
)[
ic_
<>(
dex
)]->
rfm
(&
liize
);

1254 
Li
* 
	gl
 = 
dymic_
<Li*>(
v
["$list"]);

1255 i(
	gn
->
vue
(=0
r
("gum`$n` o`" + 
d
::
rg
(
sig
+ "` mu bn-zo", 
pe
);

1257 i(!
	gm
 && !
	gl
) {

1258 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1259 *
	gl
 << 
ARG
("$li", 
Exessi
);

1261 
size_t
 
	gn
 = 
m
 ? m->
ngth
(: 
l
->length();

1262 
bo
 
	gemy
 = 
m
 ? m->
emy
(: 
l
->empty();

1263 i(
	gemy

r
("gum`$li` o`" + 
d
::
rg
(
sig
+ "` mu bemy", 
pe
);

1264 
	gdex
 = 
d
::
o
(
n
->
vue
(< 0 ? 
n
 +->value() :->value() - 1);

1265 i(
	gdex
 < 0 || index > 
	gn
 - 1
r
("dex ouoboundf `" + 
d
::
rg
(
sig
+ "`", 
pe
);

1267 i(
	gm
) {

1268 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1269 *
	gl
 << 
	gm
->
keys
()[
ic_
<>(
dex
)];

1270 *
	gl
 << 
	gm
->

(
m
->
keys
()[
ic_
<>(
dex
)]);

1271  
	gl
;

1274  
	gl
->
vue__dex
(
ic_
<>(
dex
));

1278 
Sigtu
 
	gt_h_sig
 = "set-nth($list, $n, $value)";

1279 
BUILT_IN
(
t_h
)

1281 
Li
* 
	gl
 = 
dymic_
<Li*>(
v
["$list"]);

1282 
Numb
* 
	gn
 = 
ARG
("$n", Number);

1283 
Exessi
* 
	gv
 = 
ARG
("$value", Expression);

1284 i(!
	gl
) {

1285 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1286 *
	gl
 << 
ARG
("$li", 
Exessi
);

1288 i(
	gl
->
emy
()
r
("gum`$li` o`" + 
d
::
rg
(
sig
+ "` mu bemy", 
pe
);

1289 
	gdex
 = 
d
::
o
(
n
->
vue
(< 0 ? 
l
->
ngth
() +->value() :->value() - 1);

1290 i(
	gdex
 < 0 || index > 
	gl
->
ngth
(- 1
r
("dex ouoboundf `" + 
d
::
rg
(
sig
+ "`", 
pe
);

1291 
Li
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 
l
->
ngth
(),->
t
());

1292 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

1293 *
	gsu
 << ((
	gi
 =
dex
? 
v
 : (*
l
)[
i
]);

1295  
	gsu
;

1298 
Sigtu
 
	gdex_sig
 = "index($list, $value)";

1299 
BUILT_IN
(
dex
)

1301 
Li
* 
	gl
 = 
dymic_
<Li*>(
v
["$list"]);

1302 
Exessi
* 
	gv
 = 
ARG
("$value", Expression);

1303 i(!
	gl
) {

1304 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1305 *
	gl
 << 
ARG
("$li", 
Exessi
);

1307 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

1308 i(
	gEv
::
eq
(
l
->
vue__dex
(
i
), 
v
) 
SASS_MEMORY_NEW
(
x
.
mem
, 
Numb
, 
pe
, ()(i+1));

1310  
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
pe
);

1313 
Sigtu
 
	gjo_sig
 = "join($list1, $list2, $separator:uto)";

1314 
BUILT_IN
(
jo
)

1316 
Li
* 
	gl1
 = 
dymic_
<Li*>(
v
["$list1"]);

1317 
Li
* 
	gl2
 = 
dymic_
<Li*>(
v
["$list2"]);

1318 
Sg_Cڡt
* 
	gp
 = 
ARG
("$separator", String_Constant);

1319 
Sass_S
 
	gp_v
 = (
l1
 ?1->
t
(: 
SASS_SPACE
);

1320 i(!
	gl1
) {

1321 
	gl1
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1322 *
	gl1
 << 
ARG
("$li1", 
Exessi
);

1323 
	gp_v
 = (
l2
 ?2->
t
(: 
SASS_SPACE
);

1325 i(!
	gl2
) {

1326 
	gl2
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1327 *
	gl2
 << 
ARG
("$li2", 
Exessi
);

1329 
size_t
 
	gn
 = 
l1
->
ngth
(+ 
l2
->length();

1330 
	gd
::
rg
 
p_r
 = 
unque
(
p
->
vue
());

1331 i(
	gp_r
 ="a"
p_v
 = 
SASS_SPACE
;

1332 i(
	gp_r
 ="comma"
p_v
 = 
SASS_COMMA
;

1333 i(
	gp_r
 !"auto"
r
("gum`$t` o`" + 
d
::
rg
(
sig
+ "` mu b`a`, `comma`, o`auto`", 
pe
);

1334 
Li
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 
n
, 
p_v
);

1335 *
	gsu
 +
l1
;

1336 *
	gsu
 +
l2
;

1337  
	gsu
;

1340 
Sigtu
 
	gnd_sig
 = "append($list, $val, $separator:uto)";

1341 
BUILT_IN
(
nd
)

1343 
Li
* 
	gl
 = 
dymic_
<Li*>(
v
["$list"]);

1344 
Exessi
* 
	gv
 = 
ARG
("$val", Expression);

1345 i(
Se_Li
* 
	g
 = 
dymic_
<Se_Li*>(
v
["$list"])) {

1346 
Liize
 
liize
(
x
.
mem
);

1347 
	gl
 = 
dymic_
<
Li
*>(

->
rfm
(&
liize
));

1349 
Sg_Cڡt
* 
	gp
 = 
ARG
("$separator", String_Constant);

1350 i(!
	gl
) {

1351 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1352 *
	gl
 << 
ARG
("$li", 
Exessi
);

1354 
Li
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 
l
->
ngth
(+ 1,->
t
());

1355 
	gd
::
rg
 
p_r
(
unque
(
p
->
vue
()));

1356 i(
	gp_r
 ="a"
su
->
t
(
SASS_SPACE
);

1357 i(
	gp_r
 ="comma"
su
->
t
(
SASS_COMMA
);

1358 i(
	gp_r
 !"auto"
r
("gum`$t` o`" + 
d
::
rg
(
sig
+ "` mu b`a`, `comma`, o`auto`", 
pe
);

1359 *
	gsu
 +
l
;

1360 
bo
 
	gis_gli
 = 
l
->
is_gli
();

1361 
	gsu
->
is_gli
(is_arglist);

1362 i(
	gis_gli
) {

1363 *
	gsu
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
,

1364 
v
->
pe
(),

1365 
v
,

1367 
l
,

1368 
l
);

1371 *
	gsu
 << 
	gv
;

1373  
	gsu
;

1376 
Sigtu
 
	gz_sig
 = "zip($lists...)";

1377 
BUILT_IN
(
z
)

1379 
Li
* 
	ggli
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, *
ARG
("$lists", List));

1380 
size_t
 
	gsh܋
 = 0;

1381 
size_t
 
	gi
 = 0, 
	gL
 = 
gli
->
ngth
(); i < L; ++i) {

1382 
Li
* 
	gh
 = 
dymic_
<Li*>(
gli
->
vue__dex
(
i
));

1383 i(!
	gh
) {

1384 
	gh
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1385 *
	gh
 << 
	ggli
->
vue__dex
(
i
);

1386 i(
	ggli
->
is_gli
()) {

1387 ((
	gArgumt
*)(*
	ggli
)[
i
])->
vue
(
h
);

1389 (*
	ggli
)[
i
] = 
h
;

1392 
	gsh܋
 = (
i
 ? 
d
::
m
(
sh܋
, 
h
->
ngth
()) : ith->length());

1394 
Li
* 
	gzrs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 
sh܋
, 
SASS_COMMA
);

1395 
size_t
 
	gL
 = 
gli
->
ngth
();

1396 
size_t
 
	gi
 = 0; i < 
	gsh܋
; ++i) {

1397 
Li
* 
	gzr
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 
L
);

1398 
size_t
 
	gj
 = 0; j < 
	gL
; ++j) {

1399 *
	gzr
 << (*
	gic_
<
	gLi
*>(
	ggli
->
vue__dex
(
j
)))[
i
];

1401 *
	gzrs
 << 
	gzr
;

1403  
	gzrs
;

1406 
Sigtu
 
	gli_t_sig
 = "list_separator($list)";

1407 
BUILT_IN
(
li_t
)

1409 
Li
* 
	gl
 = 
dymic_
<Li*>(
v
["$list"]);

1410 i(!
	gl
) {

1411 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 1);

1412 *
	gl
 << 
ARG
("$li", 
Exessi
);

1414  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
,

1415 
pe
,

1416 
l
->
t
(=
SASS_COMMA
 ? "comma" : "space");

1423 
Sigtu
 
	gm_g_sig
 = "map-get($map, $key)";

1424 
BUILT_IN
(
m_g
)

1426 
M
* 
	gm
 = 
ARGM
("$m", M, 
x
);

1427 
Exessi
* 
	gv
 = 
ARG
("$key", Expression);

1428 
	gy
 {

1429  
	gm
->

(
v
);

1430 } 
tch
 (cڡ 
d
::
out_of_nge
&) {

1431  
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
pe
);

1433 
tch
 (...{ 
	gthrow
; }

1436 
Sigtu
 
	gm_has_key_sig
 = "map-has-key($map, $key)";

1437 
BUILT_IN
(
m_has_key
)

1439 
M
* 
	gm
 = 
ARGM
("$m", M, 
x
);

1440 
Exessi
* 
	gv
 = 
ARG
("$key", Expression);

1441  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
m
->
has
(
v
));

1444 
Sigtu
 
	gm_keys_sig
 = "map-keys($map)";

1445 
BUILT_IN
(
m_keys
)

1447 
M
* 
	gm
 = 
ARGM
("$m", M, 
x
);

1448 
Li
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 
m
->
ngth
(), 
SASS_COMMA
);

1449 ut
	gkey
 : 
m
->
keys
()) {

1450 *
su
 << 
key
;

1452  
	gsu
;

1455 
Sigtu
 
	gm_vues_sig
 = "map-values($map)";

1456 
BUILT_IN
(
m_vues
)

1458 
M
* 
	gm
 = 
ARGM
("$m", M, 
x
);

1459 
Li
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 
m
->
ngth
(), 
SASS_COMMA
);

1460 ut
	gkey
 : 
m
->
keys
()) {

1461 *
su
 << 
m
->

(
key
);

1463  
	gsu
;

1466 
Sigtu
 
	gm_mge_sig
 = "map-merge($map1, $map2)";

1467 
BUILT_IN
(
m_mge
)

1469 
M
* 
	gm1
 = 
ARGM
("$m1", M, 
x
);

1470 
M
* 
	gm2
 = 
ARGM
("$m2", M, 
x
);

1472 
size_t
 
	gn
 = 
m1
->
ngth
(+ 
m2
->length();

1473 
M
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, M, 
pe
, 
n
);

1474 *
	gsu
 +
m1
;

1475 *
	gsu
 +
m2
;

1476  
	gsu
;

1479 
Sigtu
 
	gm_move_sig
 = "map-remove($map, $keys...)";

1480 
BUILT_IN
(
m_move
)

1482 
bo
 
	gmove
;

1483 
M
* 
	gm
 = 
ARGM
("$m", M, 
x
);

1484 
Li
* 
	ggli
 = 
ARG
("$keys", List);

1485 
M
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, M, 
pe
, 1);

1486 aut
	gkey
 : 
m
->
keys
()) {

1487 
move
 = 
l
;

1488 
size_t
 
	gj
 = 0, 
	gK
 = 
gli
->
ngth
(); j < K && !
	gmove
; ++j) {

1489 
	gmove
 = 
Ev
::
eq
(
key
, 
gli
->
vue__dex
(
j
));

1491 i(!
	gmove
*
	gsu
 << 
	gd
::
make_
(
key
, 
m
->

(key));

1493  
	gsu
;

1496 
Sigtu
 
	gkeywds_sig
 = "keywords($args)";

1497 
BUILT_IN
(
keywds
)

1499 
Li
* 
	ggli
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, *
ARG
("$args", List));

1500 
M
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, M, 
pe
, 1);

1501 
size_t
 
	gi
 = 
gli
->
size
(), 
	gL
 =rgli->
ngth
(); i < L; ++i) {

1502 
	gd
::
rg
 
me
 = 
d
::rg(((
Argumt
*)(*
gli
)[
i
])->name());

1503 
	gme
 = 
me
.
a
(0, 1);

1504 *
	gsu
 << 
	gd
::
make_
(
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
,

1505 
pe
, 
me
),

1506 ((
Argumt
*)(*
gli
)[
i
])->
vue
());

1508  
	gsu
;

1515 
Sigtu
 
	gty_of_sig
 = "type-of($value)";

1516 
BUILT_IN
(
ty_of
)

1518 
Exessi
* 
	gv
 = 
ARG
("$value", Expression);

1519  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
v
->
ty
());

1522 
Sigtu
 
	gun_sig
 = "unit($number)";

1523 
BUILT_IN
(
un
)

1524 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
que
(
ARG
("$numb", 
Numb
)->
un
(), '"')); }

1526 
Sigtu
 
	gunss_sig
 = "unitless($number)";

1527 
BUILT_IN
(
unss
)

1528 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ARG
("$numb", 
Numb
)->
is_unss
()); }

1530 
Sigtu
 
	gcomb_sig
 = "comparable($number-1, $number-2)";

1531 
BUILT_IN
(
comb
)

1533 
Numb
* 
	gn1
 = 
ARG
("$number-1", Number);

1534 
Numb
* 
	gn2
 = 
ARG
("$number-2", Number);

1535 i(
	gn1
->
is_unss
(|| 
	gn2
->is_unitless()) {

1536  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ue
);

1538 
Numb
 
tmp_n2
(*
n2
);

1539 
	gtmp_n2
.
nmize
(
n1
->
fd_cvtib_un
());

1540  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
n1
->
un
(=
tmp_n2
.unit());

1543 
Sigtu
 
	gvb_exis_sig
 = "variable-exists($name)";

1544 
BUILT_IN
(
vb_exis
)

1546 
	gd
::
rg
 
s
 = 
Ut
::
nmize_undsces
(
unque
(
ARG
("$me", 
Sg_Cڡt
)->
vue
()));

1548 if(
	gd_v
.
has
("$"+
s
)) {

1549  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ue
);

1552  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
l
);

1556 
Sigtu
 
	gglob_vb_exis_sig
 = "global-variable-exists($name)";

1557 
BUILT_IN
(
glob_vb_exis
)

1559 
	gd
::
rg
 
s
 = 
Ut
::
nmize_undsces
(
unque
(
ARG
("$me", 
Sg_Cڡt
)->
vue
()));

1561 if(
	gd_v
.
has_glob
("$"+
s
)) {

1562  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ue
);

1565  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
l
);

1569 
Sigtu
 
	gfuni_exis_sig
 = "function-exists($name)";

1570 
BUILT_IN
(
funi_exis
)

1572 
	gd
::
rg
 
s
 = 
Ut
::
nmize_undsces
(
unque
(
ARG
("$me", 
Sg_Cڡt
)->
vue
()));

1574 if(
	gd_v
.
has_glob
(
s
+"[f]")) {

1575  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ue
);

1578  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
l
);

1582 
Sigtu
 
	gmix_exis_sig
 = "mixin-exists($name)";

1583 
BUILT_IN
(
mix_exis
)

1585 
	gd
::
rg
 
s
 = 
Ut
::
nmize_undsces
(
unque
(
ARG
("$me", 
Sg_Cڡt
)->
vue
()));

1587 if(
	gd_v
.
has_glob
(
s
+"[m]")) {

1588  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ue
);

1591  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
l
);

1595 
Sigtu
 
	gu_exis_sig
 = "feature-exists($name)";

1596 
BUILT_IN
(
u_exis
)

1598 
	gd
::
rg
 
s
 = 
unque
(
ARG
("$me", 
Sg_Cڡt
)->
vue
());

1600 if(
	gus
.
fd
(
s
=
us
.
d
()) {

1601  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
l
);

1604  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ue
);

1608 
Sigtu
 
	g_sig
 = "call($name, $args...)";

1609 
BUILT_IN
(

)

1611 
	gd
::
rg
 
me
 = 
Ut
::
nmize_undsces
(
unque
(
ARG
("$me", 
Sg_Cڡt
)->
vue
()));

1612 
Li
* 
	ggli
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, *
ARG
("$args", List));

1614 
Argumts
* 
	ggs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumts, 
pe
);

1619 
size_t
 
	gi
 = 0, 
	gL
 = 
gli
->
ngth
(); i < L; ++i) {

1620 
Exessi
* 
	gex
 = 
gli
->
vue__dex
(
i
);

1626 i(
	ggli
->
is_gli
()) {

1627 
Argumt
* 
	gg
 = 
dymic_
<Argumt*>((*
gli
)[
i
]);

1628 *
	ggs
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
,

1629 
pe
,

1630 
ex
,

1631 
g
 ?rg->
me
() : "",

1632 
g
 ?rg->
is__gumt
(: 
l
,

1633 
g
 ?rg->
is_keywd_gumt
(: 
l
);

1635 *
	ggs
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
pe
, 
ex
);

1638 
Funi_Cl
* 
	gfunc
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Funi_Cl, 
pe
, 
me
, 
gs
);

1639 
Exnd
 
exnd
(
x
, &
d_v
, 
backa
);

1640  
	gfunc
->
rfm
(&
exnd
.
ev
);

1648 
Sigtu
 
	gn_sig
 = "not($value)";

1649 
BUILT_IN
(
ss_n
)

1650 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ARG
("$vue", 
Exessi
)->
is_l
()); }

1652 
Sigtu
 
	gif_sig
 = "if($condition, $if-true, $if-false)";

1655 
BUILT_IN
(
ss_if
)

1657 
Exnd
 
exnd
(
x
, &
d_v
, 
backa
);

1658 
bo
 
	gis_ue
 = !
ARG
("$cdi", 
Exessi
)->
rfm
(&
exnd
.
ev
)->
is_l
();

1659 i(
	gis_ue
) {

1660  
ARG
("$if-ue", 
Exessi
)->
rfm
(&
exnd
.
ev
);

1663  
ARG
("$if-l", 
Exessi
)->
rfm
(&
exnd
.
ev
);

1671 
Sigtu
 
	gimage_u_sig
 = "image-url($path, $only-path: false, $cache-buster: false)";

1672 
BUILT_IN
(
image_u
)

1674 
r
("`image_u` habmoved fromibsbeu it'nمothSasec", 
pe
);

1685 
Sigtu
 
	ge_sig
 = "inspect($value)";

1686 
BUILT_IN
(
e
)

1688 
Exessi
* 
	gv
 = 
ARG
("$value", Expression);

1689 i(
	gv
->
ce_ty
(=
Exessi
::
NULL_VAL
) {

1690  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, "null");

1691 } i(
	gv
->
ce_ty
(=
Exessi
::
BOOLEAN
 && *
v
 == 0) {

1692  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, "false");

1693 } i(
	gv
->
ce_ty
(=
Exessi
::
STRING
) {

1694  
v
;

1697 
Sass_Ouut_Sty
 
	gd_y
;

1698 
	gd_y
 = 
x
.
c_tis
.
ouut_y
;

1699 
	gx
.
	gc_tis
.
	gouut_y
 = 
TO_SASS
;

1700 
Emr
 
emr
(
x
.
c_tis
);

1701 
Ine
 
i
(
emr
);

1702 
	gi
.
	g_dei
 = 
l
;

1703 
	gv
->
rfm
(&
i
);

1704 
	gx
.
	gc_tis
.
	gouut_y
 = 
d_y
;

1705  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
i
.
g_bufr
());

1709 
Sigtu
 
	g_á_sig
 = "selector-nest($selectors...)";

1710 
BUILT_IN
(
_á
)

1712 
Li
* 
	ggli
 = 
ARG
("$selectors", List);

1715 if
	ggli
->
ngth
() == 0 )

1716 
r
("$s: Aa o se mu bsd", 
pe
);

1719 
	gd
::
ve
<
Se_Li
*> 
rdSes
;

1720 
size_t
 
	gi
 = 0, 
	gL
 = 
gli
->
ngth
(); i < L; ++i) {

1721 
Exessi
* 
	gexp
 = 
dymic_
<Exessi*>(
gli
->
vue__dex
(
i
));

1722 i(
	gexp
->
ce_ty
(=
Exessi
::
NULL_VAL
) {

1723 
d
::
rgam
 
msg
;

1724 
	gmsg
 << "$selectors:ull isot valid selector: it must be string,\n";

1725 
	gmsg
 << "aist of strings, orist ofists of strings for 'selector-nest'";

1726 
r
(
msg
.
r
(), 
pe
);

1728 i(
Sg_Cڡt
* 
	gr
 =
dymic_
<Sg_Cڡt*>(
exp
)) {

1729 
r
->
que_mk
(0);

1731 
	gd
::
rg
 
exp_c
 = 
exp
->
to_rg
(
x
.
c_tis
) + "{";

1732 
Se_Li
* 
	gl
 = 
Pr
::
r_
(
exp_c
.
c_r
(), 
x
);

1733 
	grdSes
.
push_back
(
l
);

1737 if
	grdSes
.
emy
() ) {

1738  
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
pe
);

1742 
	gd
::
ve
<
Se_Li
*>::

 
r
 = 
rdSes
.
beg
();

1743 
Se_Li
* 
	gsu
 = *
r
;

1744 ++
	gr
;

1746 ;
	gr
 !
rdSes
.
d
(); ++itr) {

1747 
Se_Li
* 
	gchd
 = *
r
;

1748 
	gd
::
ve
<
Comex_Se
*> 
exoded
;

1749 
Se_Li
* 
	grv
 = 
chd
->
ize
(
su
, 
x
);

1750 
size_t
 
	gm
 = 0, 
	gmL
 = 
rv
->
ngth
(); m < mLen; ++m) {

1751 
	gexoded
.
push_back
((*
rv
)[
m
]);

1753 
	gsu
->
emts
(
exoded
);

1756 
Liize
 
liize
(
x
.
mem
);

1757  
	gsu
->
rfm
(&
liize
);

1760 
Sigtu
 
	g_nd_sig
 = "selector-append($selectors...)";

1761 
BUILT_IN
(
_nd
)

1763 
Li
* 
	ggli
 = 
ARG
("$selectors", List);

1766 if
	ggli
->
ngth
() == 0 )

1767 
r
("$s: Aa o se mu bsd", 
pe
);

1770 
	gd
::
ve
<
Se_Li
*> 
rdSes
;

1771 
size_t
 
	gi
 = 0, 
	gL
 = 
gli
->
ngth
(); i < L; ++i) {

1772 
Exessi
* 
	gexp
 = 
dymic_
<Exessi*>(
gli
->
vue__dex
(
i
));

1773 i(
	gexp
->
ce_ty
(=
Exessi
::
NULL_VAL
) {

1774 
d
::
rgam
 
msg
;

1775 
	gmsg
 << "$selectors:ull isot valid selector: it must be string,\n";

1776 
	gmsg
 << "aist of strings, orist ofists of strings for 'selector-append'";

1777 
r
(
msg
.
r
(), 
pe
);

1779 i(
Sg_Cڡt
* 
	gr
 =
dymic_
<Sg_Cڡt*>(
exp
)) {

1780 
r
->
que_mk
(0);

1782 
	gd
::
rg
 
exp_c
 = 
exp
->
to_rg
() + "{";

1783 
Se_Li
* 
	gl
 = 
Pr
::
r_
(
exp_c
.
c_r
(), 
x
);

1784 
	grdSes
.
push_back
(
l
);

1788 if
	grdSes
.
emy
() ) {

1789  
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
pe
);

1793 
	gd
::
ve
<
Se_Li
*>::

 
r
 = 
rdSes
.
beg
();

1794 
Se_Li
* 
	gsu
 = *
r
;

1795 ++
	gr
;

1797 ;
	gr
 !
rdSes
.
d
(); ++itr) {

1798 
Se_Li
* 
	gchd
 = *
r
;

1799 
	gd
::
ve
<
Comex_Se
*> 
wEmts
;

1808 
size_t
 
	gi
 = 0, 
	gsuL
 = 
su
->
ngth
(); i <esultLen; ++i) {

1809 
size_t
 
	gj
 = 0, 
	gchdL
 = 
chd
->
ngth
(); j < childLen; ++j) {

1810 
Comex_Se
* 
	gSeqCle
 = (*
su
)[
i
]->
eFuy
(
x
);

1811 
Comex_Se
* 
	gchdSeq
 = (*
chd
)[
j
];

1812 
Comex_Se
* 
	gba
 = 
chdSeq
->

();

1815 if
	gchdSeq
->
comb
(!
Comex_Se
::
Comb
::
ANCESTOR_OF
 ) {

1816 
d
::
rg
 
msg
("Can'tppend `");

1817 
	gmsg
 +
chdSeq
->
to_rg
();

1818 
	gmsg
 += "`o `";

1819 
	gmsg
 +
SeqCle
->
to_rg
();

1820 
	gmsg
 += "`";

1821 
r
(
msg
, 
pe
, 
backa
);

1825 
Ty_Se
* 
	gpTy
 = 
dymic_
<Ty_Se*>(
chdSeq
->
hd
()->
f
());

1826 if(
	gpTy
 &&Ty->
me
() == "*") {

1827 
d
::
rg
 
msg
("Can'tppend `");

1828 
	gmsg
 +
chdSeq
->
to_rg
();

1829 
	gmsg
 += "`o `";

1830 
	gmsg
 +
SeqCle
->
to_rg
();

1831 
	gmsg
 += "`";

1832 
r
(
msg
, 
pe
, 
backa
);

1838 *(
	gSeqCle
->
rmo
()->
hd
()+(
ba
->head());

1841 
	gSeqCle
->
rmo
()->


ba
->tail() );

1843 
	gwEmts
.
push_back
(
SeqCle
);

1847 
	gsu
->
emts
(
wEmts
);

1850 
Liize
 
liize
(
x
.
mem
);

1851  
	gsu
->
rfm
(&
liize
);

1854 
Sigtu
 
	g_unify_sig
 = "selector-unify($selector1, $selector2)";

1855 
BUILT_IN
(
_unify
)

1857 
Se_Li
* 
	g1
 = 
ARGSEL
("$1", Se_Li, 
p_cڋxtuize
);

1858 
Se_Li
* 
	g2
 = 
ARGSEL
("$2", Se_Li, 
p_cڋxtuize
);

1860 
Se_Li
* 
	gsu
 = 
1
->
unify_wh
(
2
, 
x
);

1861 
Liize
 
liize
(
x
.
mem
);

1862  
	gsu
->
rfm
(&
liize
);

1865 
Sigtu
 
	gsime_s_sig
 = "simple-selectors($selector)";

1866 
BUILT_IN
(
sime_s
)

1868 
Compound_Se
* 
	gl
 = 
ARGSEL
("$", Compound_Se, 
p_cڋxtuize
);

1870 
Li
* 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
l
->
pe
(), s->
ngth
(), 
SASS_COMMA
);

1872 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

1873 
Sime_Se
* 
	gss
 = (*
l
)[
i
];

1874 
	gd
::
rg
 
ss_rg
 = 
ss
->
to_rg
() ;

1876 *
	gl
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
ss
->
pe
(), 
ss_rg
);

1879  
	gl
;

1882 
Sigtu
 
	g_exnd_sig
 = "selector-extend($selector, $extendee, $extender)";

1883 
BUILT_IN
(
_exnd
)

1885 
Se_Li
* 
	g
 = 
ARGSEL
("$", Se_Li, 
p_cڋxtuize
);

1886 
Se_Li
* 
	gexnd
 = 
ARGSEL
("$exnd", Se_Li, 
p_cڋxtuize
);

1887 
Se_Li
* 
	gexnd
 = 
ARGSEL
("$exnd", Se_Li, 
p_cڋxtuize
);

1889 
ExnsiSubtM
 
	gsubt_m
;

1890 
	gexnd
->
puϋ_exnds
(
exnd
, 
x
, 
subt_m
);

1892 
Se_Li
* 
	gsu
 = 
Exnd
::
exndSeLi
(

, 
x
, 
subt_m
, 
l
);

1894 
Liize
 
liize
(
x
.
mem
);

1895  
	gsu
->
rfm
(&
liize
);

1898 
Sigtu
 
	g_a_sig
 = "selector-replace($selector, $original, $replacement)";

1899 
BUILT_IN
(
_a
)

1901 
Se_Li
* 
	g
 = 
ARGSEL
("$", Se_Li, 
p_cڋxtuize
);

1902 
Se_Li
* 
	gig
 = 
ARGSEL
("$ig", Se_Li, 
p_cڋxtuize
);

1903 
Se_Li
* 
	gamt
 = 
ARGSEL
("$amt", Se_Li, 
p_cڋxtuize
);

1905 
ExnsiSubtM
 
	gsubt_m
;

1906 
	gamt
->
puϋ_exnds
(
ig
, 
x
, 
subt_m
);

1908 
Se_Li
* 
	gsu
 = 
Exnd
::
exndSeLi
(

, 
x
, 
subt_m
, 
ue
);

1910 
Liize
 
liize
(
x
.
mem
);

1911  
	gsu
->
rfm
(&
liize
);

1914 
Sigtu
 
	g_r_sig
 = "selector-parse($selector)";

1915 
BUILT_IN
(
_r
)

1917 
Se_Li
* 
	gl
 = 
ARGSEL
("$", Se_Li, 
p_cڋxtuize
);

1919 
Liize
 
liize
(
x
.
mem
);

1920  
	gl
->
rfm
(&
liize
);

1923 
Sigtu
 
	gis_sur_sig
 = "is-superselector($super, $sub)";

1924 
BUILT_IN
(
is_sur
)

1926 
Se_Li
* 
	gl_sup
 = 
ARGSEL
("$sur", Se_Li, 
p_cڋxtuize
);

1927 
Se_Li
* 
	gl_sub
 = 
ARGSEL
("$sub", Se_Li, 
p_cڋxtuize
);

1928 
bo
 
	gsu
 = 
l_sup
->
is_sur_of
(
l_sub
);

1929  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
su
);

1932 
Sigtu
 
	gunique_id_sig
 = "unique-id()";

1933 
BUILT_IN
(
unique_id
)

1935 
	gd
::
rgam
 
ss
;

1936 
	gd
::
unifm__diributi
<> 
diribut
(0, 4294967296);

1937 
ut_32_t
 
	gdiribud
 = 
ic_
<ut_32_t>(
diribut
(
nd
));

1938 
	gss
 << "u" << 
	gd
::
tfl
('0'<< 
d
::
tw
(8<< std::
hex
 << 
diribud
;

1939  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
ss
.
r
());

	@node_modules/node-sass/src/libsass/src/functions.hpp

1 #ide
SASS_FUNCTIONS_H


2 
	#SASS_FUNCTIONS_H


	)

4 
	~"liize.h
"

5 
	~"posi.h
"

6 
	~"vmt.h
"

7 
	~"ss/funis.h
"

9 
	#BUILT_IN
(
me

Exessi
*\

10 
	`me
(
Env
& 
v
, Env& 
d_v
, 
Cڋxt
& 
x
, 
Sigtu
 
sig
, 
PrS
 
pe
, 
Backa
* 
backa
)

	)

12 
mea
 
	gSass
 {

13 
ass
 
	gCڋxt
;

14 
	gBacka
;

15 
ass
 
	gAST_Node
;

16 
ass
 
	gExessi
;

17 
ass
 
	gDefi
;

18 
	gEnvmt
<
	tAST_Node
*> 
	tEnv
;

19 cڡ * 
	tSigtu
;

20 
	gExessi
* (*
	tNive_Funi
)(
	tEnv
&, Env&, 
	tCڋxt
&, 
	tSigtu
, 
	tPrS
, 
	tBacka
*);

22 
Defi
* 
make_tive_funi
(
Sigtu
, 
Nive_Funi
, 
Cڋxt
& 
x
);

23 
Defi
* 
make_c_funi
(
Sass_Funi_Ery
 
c_func
, 
Cڋxt
& 
x
);

25 
	gd
::
rg
 
funi_me
(
Sigtu
);

27 
mea
 
	gFunis
 {

29 
Sigtu
 
rgb_sig
;

30 
Sigtu
 
rgba_4_sig
;

31 
Sigtu
 
rgba_2_sig
;

32 
Sigtu
 
d_sig
;

33 
Sigtu
 
g_sig
;

34 
Sigtu
 
blue_sig
;

35 
Sigtu
 
mix_sig
;

36 
Sigtu
 
h_sig
;

37 
Sigtu
 
ha_sig
;

38 
Sigtu
 
hue_sig
;

39 
Sigtu
 
tuti_sig
;

40 
Sigtu
 
lighess_sig
;

41 
Sigtu
 
adju_hue_sig
;

42 
Sigtu
 
lighn_sig
;

43 
Sigtu
 
dk_sig
;

44 
Sigtu
 
tu_sig
;

45 
Sigtu
 
detu_sig
;

46 
Sigtu
 
gys_sig
;

47 
Sigtu
 
comemt_sig
;

48 
Sigtu
 
vt_sig
;

49 
Sigtu
 
pha_sig
;

50 
Sigtu
 
acy_sig
;

51 
Sigtu
 
acify_sig
;

52 
Sigtu
 
de__sig
;

53 
Sigtu
 
tize_sig
;

54 
Sigtu
 
de_out_sig
;

55 
Sigtu
 
adju_c_sig
;

56 
Sigtu
 
s_c_sig
;

57 
Sigtu
 
chge_c_sig
;

58 
Sigtu
 
_hex_r_sig
;

59 
Sigtu
 
unque_sig
;

60 
Sigtu
 
que_sig
;

61 
Sigtu
 
r_ngth_sig
;

62 
Sigtu
 
r__sig
;

63 
Sigtu
 
r_dex_sig
;

64 
Sigtu
 
r_i_sig
;

65 
Sigtu
 
to_u__sig
;

66 
Sigtu
 
to_low__sig
;

67 
Sigtu
 
rage_sig
;

68 
Sigtu
 
round_sig
;

69 
Sigtu
 
_sig
;

70 
Sigtu
 
o_sig
;

71 
Sigtu
 
abs_sig
;

72 
Sigtu
 
m_sig
;

73 
Sigtu
 
max_sig
;

74 
Sigtu
 
e_sig
;

75 
Sigtu
 
ndom_sig
;

76 
Sigtu
 
ngth_sig
;

77 
Sigtu
 
h_sig
;

78 
Sigtu
 
dex_sig
;

79 
Sigtu
 
jo_sig
;

80 
Sigtu
 
nd_sig
;

81 
Sigtu
 
z_sig
;

82 
Sigtu
 
li_t_sig
;

83 
Sigtu
 
ty_of_sig
;

84 
Sigtu
 
un_sig
;

85 
Sigtu
 
unss_sig
;

86 
Sigtu
 
comb_sig
;

87 
Sigtu
 
vb_exis_sig
;

88 
Sigtu
 
glob_vb_exis_sig
;

89 
Sigtu
 
funi_exis_sig
;

90 
Sigtu
 
mix_exis_sig
;

91 
Sigtu
 
u_exis_sig
;

92 
Sigtu
 
_sig
;

93 
Sigtu
 
n_sig
;

94 
Sigtu
 
if_sig
;

95 
Sigtu
 
image_u_sig
;

96 
Sigtu
 
m_g_sig
;

97 
Sigtu
 
m_mge_sig
;

98 
Sigtu
 
m_move_sig
;

99 
Sigtu
 
m_keys_sig
;

100 
Sigtu
 
m_vues_sig
;

101 
Sigtu
 
m_has_key_sig
;

102 
Sigtu
 
keywds_sig
;

103 
Sigtu
 
t_h_sig
;

104 
Sigtu
 
unique_id_sig
;

105 
Sigtu
 
_á_sig
;

106 
Sigtu
 
_nd_sig
;

107 
Sigtu
 
_exnd_sig
;

108 
Sigtu
 
_a_sig
;

109 
Sigtu
 
_unify_sig
;

110 
Sigtu
 
is_sur_sig
;

111 
Sigtu
 
sime_s_sig
;

112 
Sigtu
 
_r_sig
;

114 
BUILT_IN
(
rgb
);

115 
BUILT_IN
(
rgba_4
);

116 
BUILT_IN
(
rgba_2
);

117 
BUILT_IN
(
d
);

118 
BUILT_IN
(
g
);

119 
BUILT_IN
(
blue
);

120 
BUILT_IN
(
mix
);

121 
BUILT_IN
(
h
);

122 
BUILT_IN
(
ha
);

123 
BUILT_IN
(
hue
);

124 
BUILT_IN
(
tuti
);

125 
BUILT_IN
(
lighess
);

126 
BUILT_IN
(
adju_hue
);

127 
BUILT_IN
(
lighn
);

128 
BUILT_IN
(
dk
);

129 
BUILT_IN
(
tu
);

130 
BUILT_IN
(
detu
);

131 
BUILT_IN
(
gys
);

132 
BUILT_IN
(
comemt
);

133 
BUILT_IN
(
vt
);

134 
BUILT_IN
(
pha
);

135 
BUILT_IN
(
acify
);

136 
BUILT_IN
(
tize
);

137 
BUILT_IN
(
adju_c
);

138 
BUILT_IN
(
s_c
);

139 
BUILT_IN
(
chge_c
);

140 
BUILT_IN
(
_hex_r
);

141 
BUILT_IN
(
ss_unque
);

142 
BUILT_IN
(
ss_que
);

143 
BUILT_IN
(
r_ngth
);

144 
BUILT_IN
(
r_
);

145 
BUILT_IN
(
r_dex
);

146 
BUILT_IN
(
r_i
);

147 
BUILT_IN
(
to_u_
);

148 
BUILT_IN
(
to_low_
);

149 
BUILT_IN
(
rage
);

150 
BUILT_IN
(
round
);

151 
BUILT_IN
(

);

152 
BUILT_IN
(
o
);

153 
BUILT_IN
(
abs
);

154 
BUILT_IN
(
m
);

155 
BUILT_IN
(
max
);

156 
BUILT_IN
(
e
);

157 
BUILT_IN
(
ndom
);

158 
BUILT_IN
(
ngth
);

159 
BUILT_IN
(
h
);

160 
BUILT_IN
(
dex
);

161 
BUILT_IN
(
jo
);

162 
BUILT_IN
(
nd
);

163 
BUILT_IN
(
z
);

164 
BUILT_IN
(
li_t
);

165 
BUILT_IN
(
ty_of
);

166 
BUILT_IN
(
un
);

167 
BUILT_IN
(
unss
);

168 
BUILT_IN
(
comb
);

169 
BUILT_IN
(
vb_exis
);

170 
BUILT_IN
(
glob_vb_exis
);

171 
BUILT_IN
(
funi_exis
);

172 
BUILT_IN
(
mix_exis
);

173 
BUILT_IN
(
u_exis
);

174 
BUILT_IN
(

);

175 
BUILT_IN
(
ss_n
);

176 
BUILT_IN
(
ss_if
);

177 
BUILT_IN
(
image_u
);

178 
BUILT_IN
(
m_g
);

179 
BUILT_IN
(
m_mge
);

180 
BUILT_IN
(
m_move
);

181 
BUILT_IN
(
m_keys
);

182 
BUILT_IN
(
m_vues
);

183 
BUILT_IN
(
m_has_key
);

184 
BUILT_IN
(
keywds
);

185 
BUILT_IN
(
t_h
);

186 
BUILT_IN
(
unique_id
);

187 
BUILT_IN
(
_á
);

188 
BUILT_IN
(
_nd
);

189 
BUILT_IN
(
_exnd
);

190 
BUILT_IN
(
_a
);

191 
BUILT_IN
(
_unify
);

192 
BUILT_IN
(
is_sur
);

193 
BUILT_IN
(
sime_s
);

194 
BUILT_IN
(
_r
);

	@node_modules/node-sass/src/libsass/src/inspect.cpp

1 
	~"ss.h
"

2 
	~<cmh
>

3 
	~<rg
>

4 
	~<ioam
>

5 
	~<iom
>

6 
	~<dt.h
>

7 
	~<dt.h
>

9 
	~"a.h
"

10 
	~"e.h
"

11 
	~"cڋxt.h
"

12 
	~"liize.h
"

13 
	~"c_ms.h
"

14 
	~"utf8/checked.h
"

16 
mea
 
	gSass
 {

18 
	gIne
::
Ine
(
Emr
 
emi
)

19 : 
Emr
(
emi
)

21 
Ine
::~Inspect() { }

24 
Ine
::
ݔ
()(
Block
* 
block
)

26 i(!
block
->
is_ro
()) {

27 
add_ݒ_mpg
(
block
);

28 
nd_sce_ݒ
();

30 i(
ouut_y
(=
NESTED

dti
 +
block
->
bs
();

31 
size_t
 
	gi
 = 0, 
	gL
 = 
block
->
ngth
(); i < L; ++i) {

32 (*
	gblock
)[
i
]->
rfm
(
this
);

34 i(
ouut_y
(=
NESTED

dti
 -
block
->
bs
();

35 i(!
	gblock
->
is_ro
()) {

36 
nd_sce_or
();

37 
add_o_mpg
(
block
);

42 
	gIne
::
ݔ
()(
Ruˣt
* 
ruˣt
)

44 
ruˣt
->

()->
rfm
(
this
);

45 
	gruˣt
->
block
()->
rfm
(
this
);

48 
	gIne
::
ݔ
()(
Keyame_Ru
* 
ru
)

50 i(
ru
->

()ru->()->
rfm
(
this
);

51 i(
	gru
->
block
()ru->block()->
rfm
(
this
);

54 
	gIne
::
ݔ
()(
Prݣt
* 
ݣt
)

56 
ݣt
->
ݔty_agmt
()->
rfm
(
this
);

57 
nd_c_t
();

58 
	gݣt
->
block
()->
rfm
(
this
);

61 
	gIne
::
ݔ
()(
Bubb
* 
bubb
)

63 
nd_dti
();

64 
nd_tok
("::BUBBLE", 
bubb
);

65 
nd_sce_ݒ
();

66 
	gbubb
->
node
()->
rfm
(
this
);

67 
nd_sce_or
();

70 
	gIne
::
ݔ
()(
Med_Block
* 
med_block
)

72 
nd_dti
();

73 
nd_tok
("@med", 
med_block
);

74 
nd_mdy_a
();

75 
	g_med_block
 = 
ue
;

76 
	gmed_block
->
med_qus
()->
rfm
(
this
);

77 
	g_med_block
 = 
l
;

78 
	gmed_block
->
block
()->
rfm
(
this
);

81 
	gIne
::
ݔ
()(
Suts_Block
* 
u_block
)

83 
nd_dti
();

84 
nd_tok
("@suts", 
u_block
);

85 
nd_mdy_a
();

86 
	gu_block
->
cdi
()->
rfm
(
this
);

87 
	gu_block
->
block
()->
rfm
(
this
);

90 
	gIne
::
ݔ
()(
At_Ro_Block
* 
_ro_block
)

92 
nd_dti
();

93 
nd_tok
("@-ro ", 
_ro_block
);

94 
nd_mdy_a
();

95 if(
	g_ro_block
->
exessi
()_ro_block->exessi()->
rfm
(
this
);

96 
	g_ro_block
->
block
()->
rfm
(
this
);

99 
	gIne
::
ݔ
()(
Deive
* 
_ru
)

101 
nd_dti
();

102 
nd_tok
(
_ru
->
keywd
(),t_rule);

103 i(
	g_ru
->

()) {

104 
nd_mdy_a
();

105 
bo
 
	gwas_wed
 = 
_wed
;

106 
	g_wed
 = 
ue
;

107 
	g_ru
->

()->
rfm
(
this
);

108 
	g_wed
 = 
was_wed
;

110 i(
	g_ru
->
vue
()) {

111 
nd_mdy_a
();

112 
	g_ru
->
vue
()->
rfm
(
this
);

114 i(
	g_ru
->
block
()) {

115 
	g_ru
->
block
()->
rfm
(
this
);

118 
nd_dim
();

122 
	gIne
::
ݔ
()(
Dei
* 
dec
)

124 i(
dec
->
vue
()->
ce_ty
(=
Exessi
::
NULL_VAL
) ;

125 
bo
 
	gwas_de
 = 
_dei
;

126 
	g_dei
 = 
ue
;

127 i(
ouut_y
(=
NESTED
)

128 
dti
 +
dec
->
bs
();

129 
nd_dti
();

130 
	gdec
->
ݔty
()->
rfm
(
this
);

131 
nd_c_t
();

133 i(
	gdec
->
vue
()->
ce_ty
(=
Exessi
::
SELECTOR
) {

134 
Memy_Mag
 
mem
;

135 
Liize
 
liize
(
mem
);

136 
	gdec
->
vue
()->
rfm
(&
liize
)->rfm(
this
);

138 
	gdec
->
vue
()->
rfm
(
this
);

141 i(
	gdec
->
is_imp܏
()) {

142 
nd_tiڮ_a
();

143 
nd_rg
("!important");

145 
nd_dim
();

146 i(
ouut_y
(=
NESTED
)

147 
dti
 -
dec
->
bs
();

148 
	g_dei
 = 
was_de
;

151 
	gIne
::
ݔ
()(
Assignmt
* 
as
)

153 
nd_tok
(
as
->
vb
(),ssn);

154 
nd_c_t
();

155 
	gas
->
vue
()->
rfm
(
this
);

156 i(
	gas
->
is_deu
()) {

157 
nd_tiڮ_a
();

158 
nd_rg
("!default");

160 
nd_dim
();

163 
	gIne
::
ݔ
()(
Impt
* 
impt
)

165 i(!
impt
->
us
().
emy
()) {

166 
nd_tok
("@impt", 
impt
);

167 
nd_mdy_a
();

169 i(
Sg_Qued
* 
	grq
 = 
dymic_
<Sg_Qued*>(
impt
->
us
().
t
())) {

170 
rq
->
is_dayed
(
l
);

173 
	gimpt
->
us
().
t
()->
rfm
(
this
);

174 i(
	gimpt
->
us
().
size
() == 1) {

175 i(
impt
->
med_qus
()) {

176 
nd_mdy_a
();

177 
	gimpt
->
med_qus
()->
rfm
(
this
);

180 
nd_dim
();

181 
size_t
 
	gi
 = 1, 
	gS
 = 
impt
->
us
().
size
(); i < S; ++i) {

182 
nd_mdy_leed
();

183 
nd_tok
("@impt", 
impt
);

184 
nd_mdy_a
();

186 i(
Sg_Qued
* 
	grq
 = 
dymic_
<Sg_Qued*>(
impt
->
us
()[
i
])) {

187 
rq
->
is_dayed
(
l
);

190 
	gimpt
->
us
()[
i
]->
rfm
(
this
);

191 i(
	gimpt
->
us
().
size
(- 1 =
i
) {

192 i(
impt
->
med_qus
()) {

193 
nd_mdy_a
();

194 
	gimpt
->
med_qus
()->
rfm
(
this
);

197 
nd_dim
();

202 
	gIne
::
ݔ
()(
Impt_Stub
* 
impt
)

204 
nd_dti
();

205 
nd_tok
("@impt", 
impt
);

206 
nd_mdy_a
();

207 
nd_rg
(
impt
->
imp_th
());

208 
nd_dim
();

211 
	gIne
::
ݔ
()(
Wng
* 
wng
)

213 
nd_dti
();

214 
nd_tok
("@wn", 
wng
);

215 
nd_mdy_a
();

216 
	gwng
->
mesge
()->
rfm
(
this
);

217 
nd_dim
();

220 
	gIne
::
ݔ
()(
E
* 
r
)

222 
nd_dti
();

223 
nd_tok
("@r", 
r
);

224 
nd_mdy_a
();

225 
	gr
->
mesge
()->
rfm
(
this
);

226 
nd_dim
();

229 
	gIne
::
ݔ
()(
Debug
* 
debug
)

231 
nd_dti
();

232 
nd_tok
("@debug", 
debug
);

233 
nd_mdy_a
();

234 
	gdebug
->
vue
()->
rfm
(
this
);

235 
nd_dim
();

238 
	gIne
::
ݔ
()(
Commt
* 
commt
)

240 
_commt
 = 
ue
;

241 
	gcommt
->
xt
()->
rfm
(
this
);

242 
	g_commt
 = 
l
;

245 
	gIne
::
ݔ
()(
If
* 
cd
)

247 
nd_dti
();

248 
nd_tok
("@if", 
cd
);

249 
nd_mdy_a
();

250 
	gcd
->
edi
()->
rfm
(
this
);

251 
	gcd
->
block
()->
rfm
(
this
);

252 i(
	gcd
->
ive
()) {

253 
nd_tiڮ_leed
();

254 
nd_dti
();

255 
nd_rg
("else");

256 
	gcd
->
ive
()->
rfm
(
this
);

260 
	gIne
::
ݔ
()(
F
* 
lo
)

262 
nd_dti
();

263 
nd_tok
("@f", 
lo
);

264 
nd_mdy_a
();

265 
nd_rg
(
lo
->
vb
());

266 
nd_rg
(" from ");

267 
	glo
->
low_bound
()->
rfm
(
this
);

268 
nd_rg
(
lo
->
is_usive
() ? "hrough " : "o ");

269 
	glo
->
u_bound
()->
rfm
(
this
);

270 
	glo
->
block
()->
rfm
(
this
);

273 
	gIne
::
ݔ
()(
Each
* 
lo
)

275 
nd_dti
();

276 
nd_tok
("@ch", 
lo
);

277 
nd_mdy_a
();

278 
nd_rg
(
lo
->
vbs
()[0]);

279 
size_t
 
	gi
 = 1, 
	gL
 = 
lo
->
vbs
().
size
(); i < L; ++i) {

280 
nd_comma_t
();

281 
nd_rg
(
lo
->
vbs
()[
i
]);

283 
nd_rg
(" in ");

284 
	glo
->
li
()->
rfm
(
this
);

285 
	glo
->
block
()->
rfm
(
this
);

288 
	gIne
::
ݔ
()(
Whe
* 
lo
)

290 
nd_dti
();

291 
nd_tok
("@whe", 
lo
);

292 
nd_mdy_a
();

293 
	glo
->
edi
()->
rfm
(
this
);

294 
	glo
->
block
()->
rfm
(
this
);

297 
	gIne
::
ݔ
()(
Ru
* 
t
)

299 
nd_dti
();

300 
nd_tok
("@tu", 
t
);

301 
nd_mdy_a
();

302 
	gt
->
vue
()->
rfm
(
this
);

303 
nd_dim
();

306 
	gIne
::
ݔ
()(
Exnsi
* 
exnd
)

308 
nd_dti
();

309 
nd_tok
("@exnd", 
exnd
);

310 
nd_mdy_a
();

311 
	gexnd
->

()->
rfm
(
this
);

312 
nd_dim
();

315 
	gIne
::
ݔ
()(
Defi
* 
def
)

317 
nd_dti
();

318 i(
	gdef
->
ty
(=
Defi
::
MIXIN
) {

319 
nd_tok
("@mix", 
def
);

320 
nd_mdy_a
();

322 
nd_tok
("@funi", 
def
);

323 
nd_mdy_a
();

325 
nd_rg
(
def
->
me
());

326 
	gdef
->
ms
()->
rfm
(
this
);

327 
	gdef
->
block
()->
rfm
(
this
);

330 
	gIne
::
ݔ
()(
Mix_Cl
* 

)

332 
nd_dti
();

333 
nd_tok
("@ude", 

);

334 
nd_mdy_a
();

335 
nd_rg
(

->
me
());

336 i(
	g
->
gumts
()) {

337 
	g
->
gumts
()->
rfm
(
this
);

339 i(
	g
->
block
()) {

340 
nd_tiڮ_a
();

341 
	g
->
block
()->
rfm
(
this
);

343 i(!
	g
->
block
()
nd_dim
();

346 
	gIne
::
ݔ
()(
Cڋ
* 
cڋ
)

348 
nd_dti
();

349 
nd_tok
("@cڋ", 
cڋ
);

350 
nd_dim
();

353 
	gIne
::
ݔ
()(
M
* 
m
)

355 i(
ouut_y
(=
TO_SASS
 && 
m
->
emy
()) {

356 
nd_rg
("()");

359 i(
	gm
->
emy
()) ;

360 i(
	gm
->
is_visib
()) ;

361 
bo
 
	gems_ouut
 = 
l
;

362 
nd_rg
("(");

363 aut
	gkey
 : 
m
->
keys
()) {

364 i(
ems_ouut

nd_comma_t
();

365 
	gkey
->
rfm
(
this
);

366 
nd_c_t
();

367 
	gm
->

(
key
)->
rfm
(
this
);

368 
	gems_ouut
 = 
ue
;

370 
nd_rg
(")");

373 
	gIne
::
ݔ
()(
Li
* 
li
)

375 i(
ouut_y
(=
TO_SASS
 && 
li
->
emy
()) {

376 
nd_rg
("()");

379 
	gd
::
rg
 
p
(
li
->
t
(=
SASS_SPACE
 ? " " : ",");

380 i((
ouut_y
(!
COMPRESSED
&& 
p
 == ",") sep += " ";

381 i(
	g_med_block
 && 
	gp
 !" "
p
 += " ";

382 i(
	gli
->
emy
()) ;

383 
bo
 
	gems_ouut
 = 
l
;

385 
bo
 
	gwas_a_y
 = 
_a_y
;

386 
bo
 
	gwas_comma_y
 = 
_comma_y
;

388 i(
ouut_y
(=
TO_SASS
 &&

389 
li
->
ngth
() == 1 &&

390 !
li
->
om_
() &&

391 !
dymic_
<
Li
*>((*
li
)[0]) &&

392 !
dymic_
<
Li
*>((*
li
)[0]) &&

393 !
dymic_
<
Se_Li
*>((*
li
)[0])) {

394 
nd_rg
("(");

396 i(!
	g_dei
 && (
	gli
->
t
(=
SASS_HASH
 ||

397 (
li
->
t
(=
SASS_SPACE
 && 
_a_y
) ||

398 (
li
->
t
(=
SASS_COMMA
 && 
_comma_y
)

400 
nd_rg
("(");

403 i(
	gli
->
t
(=
SASS_SPACE

_a_y
 = 
ue
;

404 i(
	gli
->
t
(=
SASS_COMMA

_comma_y
 = 
ue
;

406 
size_t
 
	gi
 = 0, 
	gL
 = 
li
->
size
(); i < L; ++i) {

407 i(
	gli
->
t
(=
SASS_HASH
)

408 { 
p
[0] = 
i
 % 2 ? ':' : ','; }

409 
Exessi
* 
	gli_em
 = (*
li
)[
i
];

410 i(
ouut_y
(!
TO_SASS
) {

411 i(
li_em
->
is_visib
()) {

413 i(!
dymic_
<
Sg_Cڡt
*>(
li_em
)) {

418 i(
	gems_ouut
) {

419 
nd_rg
(
p
);

421 i(
	gems_ouut
 && 
	gp
 != " ")

422 
nd_tiڮ_a
();

423 
	gli_em
->
rfm
(
this
);

424 
	gems_ouut
 = 
ue
;

427 
	g_comma_y
 = 
was_comma_y
;

428 
	g_a_y
 = 
was_a_y
;

430 i(
ouut_y
(=
TO_SASS
 &&

431 
li
->
ngth
() == 1 &&

432 !
li
->
om_
() &&

433 !
dymic_
<
Li
*>((*
li
)[0]) &&

434 !
dymic_
<
Li
*>((*
li
)[0]) &&

435 !
dymic_
<
Se_Li
*>((*
li
)[0])) {

436 
nd_rg
(",)");

438 i(!
	g_dei
 && (
	gli
->
t
(=
SASS_HASH
 ||

439 (
li
->
t
(=
SASS_SPACE
 && 
_a_y
) ||

440 (
li
->
t
(=
SASS_COMMA
 && 
_comma_y
)

442 
nd_rg
(")");

447 
	gIne
::
ݔ
()(
By_Exessi
* 
ex
)

449 
ex
->

()->
rfm
(
this
);

450 i
	g_med_block
 ||

451 (
ouut_y
(=
INSPECT
) || (

452 
ex
->

().
ws_befe


453 && (!
ex
->
is_ުt
())

454 && (!
ex
->
is_dayed
() ||

455 
ex
->
is__ުt
() ||

456 
ex
->
is_right_ުt
()

459 )
nd_rg
(" ");

460 
	gex
->
ty
()) {

461 
	gSass_OP
::
AND
: 
nd_rg
("&&"); ;

462 
	gSass_OP
::
OR
: 
nd_rg
("||"); ;

463 
	gSass_OP
::
EQ
: 
nd_rg
("=="); ;

464 
	gSass_OP
::
NEQ
: 
nd_rg
("!="); ;

465 
	gSass_OP
::
GT
: 
nd_rg
(">"); ;

466 
	gSass_OP
::
GTE
: 
nd_rg
(">="); ;

467 
	gSass_OP
::
LT
: 
nd_rg
("<"); ;

468 
	gSass_OP
::
LTE
: 
nd_rg
("<="); ;

469 
	gSass_OP
::
ADD
: 
nd_rg
("+"); ;

470 
	gSass_OP
::
SUB
: 
nd_rg
("-"); ;

471 
	gSass_OP
::
MUL
: 
nd_rg
("*"); ;

472 
	gSass_OP
::
DIV
: 
nd_rg
("/"); ;

473 
	gSass_OP
::
MOD
: 
nd_rg
("%"); ;

476 i
	g_med_block
 ||

477 (
ouut_y
(=
INSPECT
) || (

478 
ex
->

().
ws_a


479 && (!
ex
->
is_ުt
())

480 && (!
ex
->
is_dayed
()

481 || 
ex
->
is__ުt
()

482 || 
ex
->
is_right_ުt
()

484 )
nd_rg
(" ");

485 
	gex
->
right
()->
rfm
(
this
);

488 
	gIne
::
ݔ
()(
Ury_Exessi
* 
ex
)

490 i(
ex
->
ty
(=
Ury_Exessi
::
PLUS

nd_rg
("+");

491 
nd_rg
("-");

492 
	gex
->
ݔd
()->
rfm
(
this
);

495 
	gIne
::
ݔ
()(
Funi_Cl
* 

)

497 
nd_tok
(

->
me
(), call);

498 
	g
->
gumts
()->
rfm
(
this
);

501 
	gIne
::
ݔ
()(
Funi_Cl_Schema
* 

)

503 

->
me
()->
rfm
(
this
);

504 
	g
->
gumts
()->
rfm
(
this
);

507 
	gIne
::
ݔ
()(
Vb
* 
v
)

509 
nd_tok
(
v
->
me
(), var);

512 
	gIne
::
ݔ
()(
Textu
* 
txt
)

514 
nd_tok
(
txt
->
vue
(),xt);

517 
	gIne
::
ݔ
()(
Numb
* 
n
)

520 
d
::
rg
 
s
;

531 
	gd
::
rgam
 
ss
;

532 
	gss
.
ecisi
(12);

533 
	gss
 << 
	gn
->
vue
();

536 i(
	gss
.
r
().
fd_f_of
("e"!
d
::
rg
::
os
) {

537 
ss
.
r
(); 
	gss
.
r
(
d
::
rg
());

538 
	gss
.
ecisi
(
d
::
max
(12, 
t
.precision));

539 
	gss
 << 
	gd
::
fixed
 << 
n
->
vue
();

542 
	gd
::
rg
 
tmp
 = 
ss
.
r
();

543 
size_t
 
	gpos_pot
 = 
tmp
.
fd_f_of
(".,");

544 
size_t
 
	gpos_a
 = 
tmp
.
fd_ϡ_n_of
("0");

545 
bo
 
	gis_t
 = 
pos_pot
 =
pos_a
 ||

546 
pos_pot
 =
d
::
rg
::
os
;

549 
	gss
.
r
(); ss.
r
(
d
::
rg
());

552 i(
	gis_t
)

554 
	gss
.
ecisi
(0);

555 
	gss
 << 
	gd
::
fixed
 << 
n
->
vue
();

556 
	gs
 = 
d
::
rg
(
ss
.
r
());

562 i(
	gpos_a
 < 
	gt
.
	gecisi
 + 
	gpos_pot
)

563 { 
	gss
.
ecisi
(()(
pos_a
 - 
pos_pot
)); }

564 { 
	gss
.
ecisi
(
t
.precision); }

566 
	gss
 << 
	gd
::
fixed
 << 
n
->
vue
();

567 
	gs
 = 
d
::
rg
(
ss
.
r
());

569 
size_t
 
	gpos
 = 
s
.
fd_ϡ_n_of
("0");

571 i(
	gpos
 =
d
::
rg
::
os
) {

572 
s
 = "0.0";

574 
bo
 
	g_dec_pot
 = 
s
[
pos
] == '.' ||

575 
s
[
pos
] == ',';

577 i(
	g_dec_pot
++ 
	gpos
;

578 
	gs
.
size
 (
pos
 + 1);

583 i(
	gs
 ="0.0"
s
 = "0";

584 i(
	gs
 =""
s
 = "0";

585 i(
	gs
 ="-0"
s
 = "0";

586 i(
	gs
 ="-0.0"
s
 = "0";

587 i(
	gt
.
	gouut_y
 =
COMPRESSED
)

590 
size_t
 
off
 = 
s
[0] == '-' ? 1 : 0;

592 i(
	gn
->
zo
(&& 
	gs
[
off
] ='0' && 
s
[off+1] ='.'s.
a
(off, 1);

596 
	gs
 +
n
->
un
();

599 
nd_tok
(
s
, 
n
);

603 
	gme
 <
size_t
 
	gnge
>

604 
p_chl
(
c
) {

605 i(
	gc
 > 
	gnge
) ange;

606 i(
	gc
 < 0)  0;

607  
	gc
;

610 
	gIne
::
ݔ
()(
C
* 
c
)

613 
d
::
rgam
 
ss
;

617 
	gd
::
rg
 
me
 = 
c
->
di
();

620 
	gd
::
rg
 
s_me
 = 
me
;

622 
	gr
 = 
Sass
::
round
(
p_chl
<0xff>(
c
->
r
()), 
t
.
ecisi
);

623 
	gg
 = 
Sass
::
round
(
p_chl
<0xff>(
c
->
g
()), 
t
.
ecisi
);

624 
	gb
 = 
Sass
::
round
(
p_chl
<0xff>(
c
->
b
()), 
t
.
ecisi
);

625 
	ga
 = 
p_chl
<1> (
c
->
a
());

628 i(
	gme
 !"" && 
me_to_c
(
me
)) {

629 cڡ 
C
* 
n
 = 
me_to_c
(
me
);

630 
	gr
 = 
Sass
::
round
(
p_chl
<0xff>(
n
->
r
()), 
t
.
ecisi
);

631 
	gg
 = 
Sass
::
round
(
p_chl
<0xff>(
n
->
g
()), 
t
.
ecisi
);

632 
	gb
 = 
Sass
::
round
(
p_chl
<0xff>(
n
->
b
()), 
t
.
ecisi
);

633 
	ga
 = 
p_chl
<1> (
n
->
a
());

637 
	gnumv
 = 
r
 * 0x10000 + 
g
 * 0x100 + 
b
;

638 i(
c_to_me
(
numv
))

639 
	gs_me
 = 
c_to_me
(
numv
);

642 
	gd
::
rgam
 
hext
;

643 
bo
 
	gcomesd
 = 
t
.
ouut_y
 =
COMPRESSED
;

644 
	ghext
 << '#' << 
	gd
::
tw
(1<< 
d
::
tfl
('0');

646 i(
	gcomesd
 && 
is_c_doubt
(
r
, 
g
, 
b
&& 
	ga
 == 1) {

647 
hext
 << 
d
::
hex
 << std::
tw
(1<< (
ic_
<>(
r
) >> 4);

648 
	ghext
 << 
	gd
::
hex
 << 
d
::
tw
(1<< (
ic_
<>(
g
) >> 4);

649 
	ghext
 << 
	gd
::
hex
 << 
d
::
tw
(1<< (
ic_
<>(
b
) >> 4);

651 
	ghext
 << 
	gd
::
hex
 << 
d
::
tw
(2<< 
ic_
<>(
r
);

652 
	ghext
 << 
	gd
::
hex
 << 
d
::
tw
(2<< 
ic_
<>(
g
);

653 
	ghext
 << 
	gd
::
hex
 << 
d
::
tw
(2<< 
ic_
<>(
b
);

656 i(
	gcomesd
 && !
	gc
->
is_dayed
()
	gme
 = "";

657 i(
	gt
.
	gouut_y
 =
INSPECT
 && 
a
 >= 1) {

658 
nd_tok
(
hext
.
r
(), 
c
);

663 i(
	gme
 != "") {

664 
ss
 << 
me
;

666 i(
	gr
 =0 && 
g
 =0 && 
b
 =0 && 
a
 == 0) {

667 
ss
 << "transparent";

669 i(
	ga
 >= 1) {

670 i(
s_me
 != "") {

671 i(
comesd
 && 
hext
.
r
().
size
(< 
s_me
.size()) {

672 
ss
 << 
hext
.
r
();

674 
	gss
 << 
	gs_me
;

678 
	gss
 << 
	ghext
.
r
();

682 
	gss
 << "rgba(";

683 
	gss
 << 
	gic_
<>(
	gr
) << ",";

684 i(!
	gcomesd

	gss
 << " ";

685 
	gss
 << 
	gic_
<>(
	gg
) << ",";

686 i(!
	gcomesd

	gss
 << " ";

687 
	gss
 << 
	gic_
<>(
	gb
) << ",";

688 i(!
	gcomesd

	gss
 << " ";

689 
	gss
 << 
	ga
 << ')';

692 
nd_tok
(
ss
.
r
(), 
c
);

696 
	gIne
::
ݔ
()(
Boޗn
* 
b
)

699 
nd_tok
(
b
->
vue
() ? "true" : "false", b);

702 
	gIne
::
ݔ
()(
Sg_Schema
* 
ss
)

706 
size_t
 
i
 = 0, 
	gL
 = 
ss
->
ngth
(); 
	gi
 < L; ++i) {

707 i((*
	gss
)[
i
]->
is_ުt
()
nd_rg
("#{");

708 (*
	gss
)[
i
]->
rfm
(
this
);

709 i((*
	gss
)[
i
]->
is_ުt
()
nd_rg
("}");

713 
	gIne
::
ݔ
()(
Sg_Cڡt
* 
s
)

715 
nd_tok
(
s
->
vue
(), s);

718 
	gIne
::
ݔ
()(
Sg_Qued
* 
s
)

720 i(cڡ 
q
 = 
s
->
que_mk
()) {

721 
nd_tok
(
que
(
s
->
vue
(), 
q
), s);

723 
nd_tok
(
s
->
vue
(), s);

727 
	gIne
::
ݔ
()(
Cuom_E
* 
e
)

729 
nd_tok
(
e
->
mesge
(),);

732 
	gIne
::
ݔ
()(
Cuom_Wng
* 
w
)

734 
nd_tok
(
w
->
mesge
(), w);

737 
	gIne
::
ݔ
()(
Suts_Ot
* 
so
)

740 i(
so
->
eds_ns
(so->

())
nd_rg
("(");

741 
	gso
->

()->
rfm
(
this
);

742 i(
	gso
->
eds_ns
(
so
->

())
nd_rg
(")");

744 i(
	gso
->
ݔd
(=
Suts_Ot
::
AND
) {

745 
nd_mdy_a
();

746 
nd_tok
("d", 
so
);

747 
nd_mdy_a
();

748 } i(
	gso
->
ݔd
(=
Suts_Ot
::
OR
) {

749 
nd_mdy_a
();

750 
nd_tok
("", 
so
);

751 
nd_mdy_a
();

754 i(
	gso
->
eds_ns
(
so
->
right
())
nd_rg
("(");

755 
	gso
->
right
()->
rfm
(
this
);

756 i(
	gso
->
eds_ns
(
so
->
right
())
nd_rg
(")");

759 
	gIne
::
ݔ
()(
Suts_Negi
* 

)

761 
nd_tok
("n", 

);

762 
nd_mdy_a
();

763 i(
	g
->
eds_ns
(

->
cdi
())
nd_rg
("(");

764 
	g
->
cdi
()->
rfm
(
this
);

765 i(
	g
->
eds_ns
(

->
cdi
())
nd_rg
(")");

768 
	gIne
::
ݔ
()(
Suts_Dei
* 
sd
)

770 
nd_rg
("(");

771 
	gsd
->
u
()->
rfm
(
this
);

772 
nd_rg
(": ");

773 
	gsd
->
vue
()->
rfm
(
this
);

774 
nd_rg
(")");

777 
	gIne
::
ݔ
()(
Suts_Ipީi
* 
sd
)

779 
sd
->
vue
()->
rfm
(
this
);

782 
	gIne
::
ݔ
()(
Med_Quy
* 
mq
)

784 
size_t
 
i
 = 0;

785 i(
	gmq
->
med_ty
()) {

786 i(
	gmq
->
is_ged
()
nd_rg
("not ");

787 i(
	gmq
->
is_ried
()
nd_rg
("only ");

788 
	gmq
->
med_ty
()->
rfm
(
this
);

791 (*
	gmq
)[
i
++]->
rfm
(
this
);

793 
size_t
 
	gL
 = 
mq
->
ngth
(); 
	gi
 < L; ++i) {

794 
nd_rg
("nd ");

795 (*
	gmq
)[
i
]->
rfm
(
this
);

799 
	gIne
::
ݔ
()(
Med_Quy_Exessi
* 
mqe
)

801 i(
mqe
->
is_ީed
()) {

802 
mqe
->
u
()->
rfm
(
this
);

805 
nd_rg
("(");

806 
	gmqe
->
u
()->
rfm
(
this
);

807 i(
	gmqe
->
vue
()) {

808 
nd_rg
(": ");

809 
	gmqe
->
vue
()->
rfm
(
this
);

811 
nd_rg
(")");

815 
	gIne
::
ݔ
()(
At_Ro_Quy
* 

)

817 
nd_rg
("(");

818 
	g
->
u
()->
rfm
(
this
);

819 i(
	g
->
vue
()) {

820 
nd_c_t
();

821 
	g
->
vue
()->
rfm
(
this
);

823 
nd_rg
(")");

826 
	gIne
::
ݔ
()(
Nu
* 
n
)

829 
nd_tok
("nu", 
n
);

833 
	gIne
::
ݔ
()(
Pam
* 
p
)

835 
nd_tok
(
p
->
me
(),);

836 i(
	gp
->
deu_vue
()) {

837 
nd_c_t
();

838 
	gp
->
deu_vue
()->
rfm
(
this
);

840 i(
	gp
->
is__m
()) {

841 
nd_rg
("...");

845 
	gIne
::
ݔ
()(
Pams
* 
p
)

847 
nd_rg
("(");

848 i(!
	gp
->
emy
()) {

849 (*
	gp
)[0]->
rfm
(
this
);

850 
size_t
 
	gi
 = 1, 
	gL
 = 
p
->
ngth
(); i < L; ++i) {

851 
nd_comma_t
();

852 (*
	gp
)[
i
]->
rfm
(
this
);

855 
nd_rg
(")");

858 
	gIne
::
ݔ
()(
Argumt
* 
a
)

860 i(!
a
->
me
().
emy
()) {

861 
nd_tok
(
a
->
me
(),);

862 
nd_c_t
();

865 i(
	ga
->
vue
()->
ce_ty
(=
Exessi
::
NULL_VAL
) {

868 i(
	ga
->
vue
()->
ce_ty
(=
Exessi
::
STRING
) {

869 
Sg_Cڡt
* 
s
 = 
ic_
<Sg_Cڡt*>(
a
->
vue
());

870 
	gs
->
rfm
(
this
);

871 } 
	ga
->
vue
()->
rfm
(
this
);

872 i(
	ga
->
is__gumt
()) {

873 
nd_rg
("...");

877 
	gIne
::
ݔ
()(
Argumts
* 
a
)

879 
nd_rg
("(");

880 i(!
	ga
->
emy
()) {

881 (*
	ga
)[0]->
rfm
(
this
);

882 
size_t
 
	gi
 = 1, 
	gL
 = 
a
->
ngth
(); i < L; ++i) {

883 
nd_rg
(", ");

885 (*
	ga
)[
i
]->
rfm
(
this
);

888 
nd_rg
(")");

891 
	gIne
::
ݔ
()(
Se_Schema
* 
s
)

893 
s
->
cڋs
()->
rfm
(
this
);

896 
	gIne
::
ݔ
()(
Pt_Se
* 
p
)

898 
nd_rg
("&");

901 
	gIne
::
ݔ
()(
Se_Phd
* 
s
)

903 
nd_tok
(
s
->
me
(), s);

904 i(
	gs
->
has_le_bak
()
nd_tiڮ_leed
();

905 i(
	gs
->
has_le_bak
()
nd_dti
();

909 
	gIne
::
ݔ
()(
Ty_Se
* 
s
)

911 
nd_tok
(
s
->
ns_me
(), s);

914 
	gIne
::
ݔ
()(
Se_Quifr
* 
s
)

916 
nd_tok
(
s
->
ns_me
(), s);

917 i(
	gs
->
has_le_bak
()
nd_tiڮ_leed
();

918 i(
	gs
->
has_le_bak
()
nd_dti
();

921 
	gIne
::
ݔ
()(
Aribu_Se
* 
s
)

923 
nd_rg
("[");

924 
add_ݒ_mpg
(
s
);

925 
nd_tok
(
s
->
ns_me
(), s);

926 i(!
	gs
->
mch
().
emy
()) {

927 
nd_rg
(
s
->
mch
());

928 i(
	gs
->
vue
()) {

929 
	gs
->
vue
()->
rfm
(
this
);

932 
add_o_mpg
(
s
);

933 
nd_rg
("]");

936 
	gIne
::
ݔ
()(
Pudo_Se
* 
s
)

938 
nd_tok
(
s
->
ns_me
(), s);

939 i(
	gs
->
exessi
()) {

940 
nd_rg
("(");

941 
	gs
->
exessi
()->
rfm
(
this
);

942 
nd_rg
(")");

946 
	gIne
::
ݔ
()(
Wed_Se
* 
s
)

948 
bo
 
was
 = 
_wed
;

949 
	g_wed
 = 
ue
;

950 
nd_tok
(
s
->
me
(), s);

951 
nd_rg
("(");

952 
bo
 
	gwas_comma_y
 = 
_comma_y
;

953 
	g_comma_y
 = 
l
;

954 
	gs
->

()->
rfm
(
this
);

955 
	g_comma_y
 = 
was_comma_y
;

956 
nd_rg
(")");

957 
	g_wed
 = 
was
;

960 
	gIne
::
ݔ
()(
Compound_Se
* 
s
)

962 
size_t
 
i
 = 0, 
	gL
 = 
s
->
ngth
(); 
	gi
 < L; ++i) {

963 (*
	gs
)[
i
]->
rfm
(
this
);

965 i(
	gs
->
has_le_bak
()) {

966 i(
ouut_y
(!
COMPACT
) {

967 
nd_tiڮ_leed
();

972 
	gIne
::
ݔ
()(
Comex_Se
* 
c
)

974 
Compound_Se
* 
hd
 = 
c
->head();

975 
Comex_Se
* 
	g
 = 
c
->

();

976 
	gComex_Se
::
Comb
 
comb
 = 
c
->
comb
();

978 i(
	gcomb
 =
Comex_Se
::
ANCESTOR_OF
 && (!
hd
 || hd->
emy
())) {

979 i(

菞->
rfm
(
this
);

983 i(
	gc
->
has_le_ed
()) {

984 i(!(
	gc
->
has__f
())) {

985 
nd_tiڮ_leed
();

986 
nd_dti
();

990 i(
	ghd
 && hd->
ngth
(!0
hd
->
rfm
(
this
);

991 
bo
 
	gis_emy
 = !
hd
 || hd->
ngth
(=0 || hd->
is_emy_n
();

992 
bo
 
	gis_
 = 
hd
 && !hd->
is_emy_n
(&& 

;

993 i(
ouut_y
(=
COMPRESSED
 && 
comb
 !
Comex_Se
::
ANCESTOR_OF

schedud_a
 = 0;

995 
	gcomb
) {

996 
	gComex_Se
::
ANCESTOR_OF
:

997 i(
is_

nd_mdy_a
();

999 
	gComex_Se
::
PARENT_OF
:

1000 
nd_tiڮ_a
();

1001 
nd_rg
(">");

1002 
nd_tiڮ_a
();

1004 
	gComex_Se
::
ADJACENT_TO
:

1005 
nd_tiڮ_a
();

1006 
nd_rg
("+");

1007 
nd_tiڮ_a
();

1009 
	gComex_Se
::
REFERENCE
:

1010 
nd_mdy_a
();

1011 
nd_rg
("/");

1012 
	gc
->
n
()->
rfm
(
this
);

1013 
nd_rg
("/");

1014 
nd_mdy_a
();

1016 
	gComex_Se
::
PRECEDES
:

1017 i(
is_emy

nd_tiڮ_a
();

1018 
nd_mdy_a
();

1019 
nd_rg
("~");

1020 i(
	g

nd_mdy_a
();

1021 
nd_tiڮ_a
();

1024 i(
	g
 && 
	gcomb
 !
Comex_Se
::
ANCESTOR_OF
) {

1025 i(
c
->
has_le_bak
()
nd_tiڮ_leed
();

1027 i(
	g
菞->
rfm
(
this
);

1028 i(!
	g
 && 
	gc
->
has_le_bak
()) {

1029 i(
ouut_y
(=
COMPACT
) {

1030 
nd_mdy_a
();

1035 
	gIne
::
ݔ
()(
Se_Li
* 
g
)

1038 i(
g
->
emy
()) {

1039 i(
ouut_y
(=
TO_SASS
) {

1040 
nd_tok
("()", 
g
);

1046 
bo
 
	gwas_comma_y
 = 
_comma_y
;

1048 i(
ouut_y
(=
TO_SASS
 && 
g
->
ngth
() == 1 &&

1049 (!
dymic_
<
Li
*>((*
g
)[0]) &&

1050 !
dymic_
<
Se_Li
*>((*
g
)[0]))) {

1051 
nd_rg
("(");

1053 i(!
	g_dei
 && 
	g_comma_y
) {

1054 
nd_rg
("(");

1057 i(
	g_dei

	g_comma_y
 = 
ue
;

1059 
size_t
 
	gi
 = 0, 
	gL
 = 
g
->
ngth
(); i < L; ++i) {

1060 i(!
	g_wed
 && 
	gi
 =0
nd_dti
();

1061 i((*
	gg
)[
i
] == 0) ;

1062 
schedu_mpg
((*
g
)[
i
]->
ϡ
());

1064 (*
	gg
)[
i
]->
rfm
(
this
);

1066 i(
	gi
 < 
	gL
 - 1) {

1067 
	gschedud_a
 = 0;

1068 
nd_comma_t
();

1072 
	g_comma_y
 = 
was_comma_y
;

1074 i(
ouut_y
(=
TO_SASS
 && 
g
->
ngth
() == 1 &&

1075 (!
dymic_
<
Li
*>((*
g
)[0]) &&

1076 !
dymic_
<
Se_Li
*>((*
g
)[0]))) {

1077 
nd_rg
(",)");

1079 i(!
	g_dei
 && 
	g_comma_y
) {

1080 
nd_rg
(")");

1085 
	gIne
::
back_im
(
AST_Node
* 
n
)

	@node_modules/node-sass/src/libsass/src/inspect.hpp

1 #ide
SASS_INSPECT_H


2 
	#SASS_INSPECT_H


	)

4 
	~"posi.h
"

5 
	~"ݔi.h
"

6 
	~"emr.h
"

8 
mea
 
	gSass
 {

9 
ass
 
	gCڋxt
;

11 
ass
 
	gIne
 : 
public
 
Oti_CRTP
<, Ine>,ubli
	gEmr
 {

12 
	geed
:

14 
usg
 
Oti_CRTP
<, 
	gIne
>::
ݔ
();

16 
back_im
(
AST_Node
* 
n
);

18 
	gpublic
:

20 
Ine
(
Emr
 
emi
);

21 
	gvtu
 ~
Ine
();

24 
vtu
 
ݔ
()(
	gBlock
*);

25 
vtu
 
ݔ
()(
	gRuˣt
*);

26 
vtu
 
ݔ
()(
	gPrݣt
*);

27 
vtu
 
ݔ
()(
	gBubb
*);

28 
vtu
 
ݔ
()(
	gSuts_Block
*);

29 
vtu
 
ݔ
()(
	gMed_Block
*);

30 
vtu
 
ݔ
()(
	gAt_Ro_Block
*);

31 
vtu
 
ݔ
()(
	gDeive
*);

32 
vtu
 
ݔ
()(
	gKeyame_Ru
*);

33 
vtu
 
ݔ
()(
	gDei
*);

34 
vtu
 
ݔ
()(
	gAssignmt
*);

35 
vtu
 
ݔ
()(
	gImpt
*);

36 
vtu
 
ݔ
()(
	gImpt_Stub
*);

37 
vtu
 
ݔ
()(
	gWng
*);

38 
vtu
 
ݔ
()(
	gE
*);

39 
vtu
 
ݔ
()(
	gDebug
*);

40 
vtu
 
ݔ
()(
	gCommt
*);

41 
vtu
 
ݔ
()(
	gIf
*);

42 
vtu
 
ݔ
()(
	gF
*);

43 
vtu
 
ݔ
()(
	gEach
*);

44 
vtu
 
ݔ
()(
	gWhe
*);

45 
vtu
 
ݔ
()(
	gRu
*);

46 
vtu
 
ݔ
()(
	gExnsi
*);

47 
vtu
 
ݔ
()(
	gDefi
*);

48 
vtu
 
ݔ
()(
	gMix_Cl
*);

49 
vtu
 
ݔ
()(
	gCڋ
*);

51 
vtu
 
ݔ
()(
	gM
*);

52 
vtu
 
ݔ
()(
	gLi
*);

53 
vtu
 
ݔ
()(
	gBy_Exessi
*);

54 
vtu
 
ݔ
()(
	gUry_Exessi
*);

55 
vtu
 
ݔ
()(
	gFuni_Cl
*);

56 
vtu
 
ݔ
()(
	gFuni_Cl_Schema
*);

59 
vtu
 
ݔ
()(
	gVb
*);

60 
vtu
 
ݔ
()(
	gTextu
*);

61 
vtu
 
ݔ
()(
	gNumb
*);

62 
vtu
 
ݔ
()(
	gC
*);

63 
vtu
 
ݔ
()(
	gBoޗn
*);

64 
vtu
 
ݔ
()(
	gSg_Schema
*);

65 
vtu
 
ݔ
()(
	gSg_Cڡt
*);

66 
vtu
 
ݔ
()(
	gSg_Qued
*);

67 
vtu
 
ݔ
()(
	gCuom_E
*);

68 
vtu
 
ݔ
()(
	gCuom_Wng
*);

69 
vtu
 
ݔ
()(
	gSuts_Ot
*);

70 
vtu
 
ݔ
()(
	gSuts_Negi
*);

71 
vtu
 
ݔ
()(
	gSuts_Dei
*);

72 
vtu
 
ݔ
()(
	gSuts_Ipީi
*);

73 
vtu
 
ݔ
()(
	gMed_Quy
*);

74 
vtu
 
ݔ
()(
	gMed_Quy_Exessi
*);

75 
vtu
 
ݔ
()(
	gAt_Ro_Quy
*);

76 
vtu
 
ݔ
()(
	gNu
*);

77 
vtu
 
ݔ
()(
Pt_Se
* 
	gp
);

79 
vtu
 
ݔ
()(
	gPam
*);

80 
vtu
 
ݔ
()(
	gPams
*);

81 
vtu
 
ݔ
()(
	gArgumt
*);

82 
vtu
 
ݔ
()(
	gArgumts
*);

84 
vtu
 
ݔ
()(
	gSe_Schema
*);

85 
vtu
 
ݔ
()(
	gSe_Phd
*);

86 
vtu
 
ݔ
()(
	gTy_Se
*);

87 
vtu
 
ݔ
()(
	gSe_Quifr
*);

88 
vtu
 
ݔ
()(
	gAribu_Se
*);

89 
vtu
 
ݔ
()(
	gPudo_Se
*);

90 
vtu
 
ݔ
()(
	gWed_Se
*);

91 
vtu
 
ݔ
()(
	gCompound_Se
*);

92 
vtu
 
ݔ
()(
	gComex_Se
*);

93 
vtu
 
ݔ
()(
	gSe_Li
*);

	@node_modules/node-sass/src/libsass/src/json.cpp

24 #ifde
_MSC_VER


25 
	#_CRT_SECURE_NO_WARNINGS


	)

26 
	#_CRT_NONSTDC_NO_DEPRECATE


	)

29 
	~"js.h
"

33 
	~"utf8.h
"

35 
	~<as.h
>

36 
	~<dt.h
>

37 
	~<dio.h
>

38 
	~<dlib.h
>

39 
	~<rg.h
>

41 #i
defed
(
_MSC_VER
) && _MSC_VER < 1900

42 
	~<dg.h
>

43 #ifde
tf


44 #unde
tf


46 "C" 
tf
(*, 
size_t
, const *, ...);

49 
	#out_of_memy
() do { \

50 
	`rtf
(
dr
, "Out of memory.\n"); \

51 
	`ex
(
EXIT_FAILURE
); \

52 } 0)

	)

55 *
	$js_rdup
(cڡ *
r
)

57 *
t
 = (*
	`mloc
(
	`
(
r
) + 1);

58 i(
t
 =
NULL
)

59 
	`out_of_memy
();

60 
	`ry
(
t
, 
r
);

61  
t
;

62 
	}
}

68 *
	mcur
;

69 *
	md
;

70 *
	mt
;

71 } 
	tSB
;

73 
	$sb_
(
SB
 *
sb
)

75 
sb
->
t
 = (*
	`mloc
(17);

76 i(
sb
->
t
 =
NULL
)

77 
	`out_of_memy
();

78 
sb
->
cur
 = sb->
t
;

79 
sb
->
d
 = sb->
t
 + 16;

80 
	}
}

83 
	#sb_ed
(
sb
, 
ed
) do { \

84 i((
sb
)->
d
 - (sb)->
cur
 < (
ed
)) \

85 
	`sb_grow
(
sb
, 
ed
); \

86 } 0)

	)

88 
	$sb_grow
(
SB
 *
sb
, 
ed
)

90 
size_t
 
ngth
 = 
sb
->
cur
 - sb->
t
;

91 
size_t
 
loc
 = 
sb
->
d
 - sb->
t
;

94 
loc
 *= 2;

95 } 
loc
 < 
ngth
 + 
ed
);

97 
sb
->
t
 = (*
	`loc
(sb->t, 
loc
 + 1);

98 i(
sb
->
t
 =
NULL
)

99 
	`out_of_memy
();

100 
sb
->
cur
 = sb->
t
 + 
ngth
;

101 
sb
->
d
 = sb->
t
 + 
loc
;

102 
	}
}

104 
	$sb_put
(
SB
 *
sb
, cڡ *
bys
, 
cou
)

106 
	`sb_ed
(
sb
, 
cou
);

107 
	`memy
(
sb
->
cur
, 
bys
, 
cou
);

108 
sb
->
cur
 +
cou
;

109 
	}
}

111 
	#sb_putc
(
sb
, 
c
) do { \

112 i((
sb
)->
cur
 >(sb)->
d
) \

113 
	`sb_grow
(
sb
, 1); \

114 *(
sb
)->
cur
++ = (
c
); \

115 } 0)

	)

117 
	$sb_puts
(
SB
 *
sb
, cڡ *
r
)

119 
	`sb_put
(
sb
, 
r
, ()
	`
(str));

120 
	}
}

122 *
	$sb_fish
(
SB
 *
sb
)

124 *
sb
->
cur
 = 0;

125 
	`as
(
sb
->
t
 <sb->
cur
 && 
	`
(sb->t=(
size_t
)(sb->cur - sb->start));

126  
sb
->
t
;

127 
	}
}

129 
	$sb_
(
SB
 *
sb
)

131 
	`
(
sb
->
t
);

132 
	}
}

165 
	$utf8_vide_cz
(cڡ *
s
)

167 
c
 = *
s
++;

169 i(
c
 <= 0x7F) {

171 } i(
c
 <= 0xC1) {

174 } i(
c
 <= 0xDF) {

176 i((()*
s
++ & 0xC0) != 0x80)

180 } i(
c
 <= 0xEF) {

182 i(
c
 =0xE0 && ()*
s
 < 0xA0)

186 i(
c
 =0xED && ()*
s
 > 0x9F)

190 i((()*
s
++ & 0xC0) != 0x80)

192 i((()*
s
++ & 0xC0) != 0x80)

196 } i(
c
 <= 0xF4) {

198 i(
c
 =0xF0 && ()*
s
 < 0x90)

202 i(
c
 =0xF4 && ()*
s
 > 0x8F)

206 i((()*
s
++ & 0xC0) != 0x80)

208 i((()*
s
++ & 0xC0) != 0x80)

210 i((()*
s
++ & 0xC0) != 0x80)

217 
	}
}

220 
bo
 
	$utf8_vide
(cڡ *
s
)

222 
n
;

224 ; *
s
 !0; s +
n
) {

225 
n
 = 
	`utf8_vide_cz
(
s
);

226 i(
n
 == 0)

227  
l
;

230  
ue
;

231 
	}
}

240 
	$utf8_ad_ch
(cڡ *
s
, 
ut32_t
 *
out
)

242 cڡ *
c
 = (cڡ *
s
;

244 
	`as
(
	`utf8_vide_cz
(
s
));

246 i(
c
[0] <= 0x7F) {

248 *
out
 = 
c
[0];

250 } i(
c
[0] <= 0xDF) {

252 *
out
 = ((
ut32_t
)
c
[0] & 0x1F) << 6 |

253 ((
ut32_t
)
c
[1] & 0x3F);

255 } i(
c
[0] <= 0xEF) {

257 *
out
 = ((
ut32_t
)
c
[0] & 0xF) << 12 |

258 ((
ut32_t
)
c
[1] & 0x3F) << 6 |

259 ((
ut32_t
)
c
[2] & 0x3F);

263 *
out
 = ((
ut32_t
)
c
[0] & 0x7) << 18 |

264 ((
ut32_t
)
c
[1] & 0x3F) << 12 |

265 ((
ut32_t
)
c
[2] & 0x3F) << 6 |

266 ((
ut32_t
)
c
[3] & 0x3F);

269 
	}
}

279 
	$utf8_wre_ch
(
ut32_t
 
unicode
, *
out
)

281 *
o
 = (*
out
;

283 
	`as
(
unicode
 <= 0x10FFFF && !(unicode >= 0xD800 && unicode <= 0xDFFF));

285 i(
unicode
 <= 0x7F) {

287 *
o
++ = 
unicode
;

289 } i(
unicode
 <= 0x7FF) {

291 *
o
++ = 0xC0 | 
unicode
 >> 6;

292 *
o
++ = 0x80 | (
unicode
 & 0x3F);

294 } i(
unicode
 <= 0xFFFF) {

296 *
o
++ = 0xE0 | 
unicode
 >> 12;

297 *
o
++ = 0x80 | (
unicode
 >> 6 & 0x3F);

298 *
o
++ = 0x80 | (
unicode
 & 0x3F);

302 *
o
++ = 0xF0 | 
unicode
 >> 18;

303 *
o
++ = 0x80 | (
unicode
 >> 12 & 0x3F);

304 *
o
++ = 0x80 | (
unicode
 >> 6 & 0x3F);

305 *
o
++ = 0x80 | (
unicode
 & 0x3F);

308 
	}
}

316 
bo
 
	$om_suoge_
(
ut16_t
 
uc
, ut16_
lc
, 
ut32_t
 *
unicode
)

318 i(
uc
 >0xD800 && u<0xDBFF && 
lc
 >= 0xDC00 &&c <= 0xDFFF) {

319 *
unicode
 = 0x10000 + ((((
ut32_t
)
uc
 & 0x3FF<< 10| (
lc
 & 0x3FF));

320  
ue
;

322  
l
;

324 
	}
}

331 
	$to_suoge_
(
ut32_t
 
unicode
, 
ut16_t
 *
uc
, ut16_*
lc
)

333 
ut32_t
 
n
;

335 
	`as
(
unicode
 >= 0x10000 && unicode <= 0x10FFFF);

337 
n
 = 
unicode
 - 0x10000;

338 *
uc
 = ((
n
 >> 10) & 0x3FF) | 0xD800;

339 *
lc
 = (
n
 & 0x3FF) | 0xDC00;

340 
	}
}

342 
bo
 
is_a
 (cڡ *
c
);

343 
bo
 
is_dig
 (cڡ *
c
);

344 
bo
 
r_vue
 (cڡ **

, 
JsNode
 **
out
);

345 
bo
 
r_rg
 (cڡ **

, **
out
);

346 
bo
 
r_numb
 (cڡ **

, *
out
);

347 
bo
 
r_y
 (cڡ **

, 
JsNode
 **
out
);

348 
bo
 
r_obje
 (cڡ **

, 
JsNode
 **
out
);

349 
bo
 
r_hex16
 (cڡ **

, 
ut16_t
 *
out
);

351 
bo
 
ex_l
 (cڡ **

, cڡ *
r
);

352 
sk_a
 (cڡ **

);

354 
em_vue
 (
SB
 *
out
, cڡ 
JsNode
 *
node
);

355 
em_vue_dd
 (
SB
 *
out
, cڡ 
JsNode
 *
node
, cڡ *
a
, 
dt_v
);

356 
em_rg
 (
SB
 *
out
, cڡ *
r
);

357 
em_numb
 (
SB
 *
out
, 
num
);

358 
em_y
 (
SB
 *
out
, cڡ 
JsNode
 *
y
);

359 
em_y_dd
 (
SB
 *
out
, cڡ 
JsNode
 *
y
, cڡ *
a
, 
dt_v
);

360 
em_obje
 (
SB
 *
out
, cڡ 
JsNode
 *
obje
);

361 
em_obje_dd
 (
SB
 *
out
, cڡ 
JsNode
 *
obje
, cڡ *
a
, 
dt_v
);

363 
wre_hex16
(*
out
, 
ut16_t
 
v
);

365 
JsNode
 *
mknode
(
JsTag
 
g
);

366 
nd_node
(
JsNode
 *

, JsNod*
chd
);

367 
d_node
(
JsNode
 *

, JsNod*
chd
);

368 
nd_memb
(
JsNode
 *
obje
, *
key
, JsNod*
vue
);

371 
bo
 
g_is_vid
(
g
);

372 
bo
 
numb_is_vid
(cڡ *
num
);

374 
JsNode
 *
	$js_decode
(cڡ *
js
)

376 cڡ *
s
 = 
js
;

377 
JsNode
 *
t
;

379 
	`sk_a
(&
s
);

380 i(!
	`r_vue
(&
s
, &
t
))

381  
NULL
;

383 
	`sk_a
(&
s
);

384 i(*
s
 != 0) {

385 
	`js_de
(
t
);

386  
NULL
;

389  
t
;

390 
	}
}

392 *
	$js_code
(cڡ 
JsNode
 *
node
)

394  
	`js_rgify
(
node
, 
NULL
);

395 
	}
}

397 *
	$js_code_rg
(cڡ *
r
)

399 
SB
 
sb
;

400 
	`sb_
(&
sb
);

402 
	`em_rg
(&
sb
, 
r
);

404  
	`sb_fish
(&
sb
);

405 
	}
}

407 *
	$js_rgify
(cڡ 
JsNode
 *
node
, cڡ *
a
)

409 
SB
 
sb
;

410 
	`sb_
(&
sb
);

412 i(
a
 !
NULL
)

413 
	`em_vue_dd
(&
sb
, 
node
, 
a
, 0);

415 
	`em_vue
(&
sb
, 
node
);

417  
	`sb_fish
(&
sb
);

418 
	}
}

420 
	$js_de
(
JsNode
 *
node
)

422 i(
node
 !
NULL
) {

423 
	`js_move_om_
(
node
);

425 
node
->
g
) {

426 
JSON_STRING
:

427 
	`
(
node
->
rg_
);

429 
JSON_ARRAY
:

430 
JSON_OBJECT
:

432 
JsNode
 *
chd
, *
xt
;

433 
chd
 = 
node
->
chdn
.
hd
; chd !
NULL
; chd = 
xt
) {

434 
xt
 = 
chd
->next;

435 
	`js_de
(
chd
);

442 
	`
(
node
);

444 
	}
}

446 
bo
 
	$js_vide
(cڡ *
js
)

448 cڡ *
s
 = 
js
;

450 
	`sk_a
(&
s
);

451 i(!
	`r_vue
(&
s
, 
NULL
))

452  
l
;

454 
	`sk_a
(&
s
);

455 i(*
s
 != 0)

456  
l
;

458  
ue
;

459 
	}
}

461 
JsNode
 *
	$js_fd_emt
(
JsNode
 *
y
, 
dex
)

463 
JsNode
 *
emt
;

464 
i
 = 0;

466 i(
y
 =
NULL
 ||ay->
g
 !
JSON_ARRAY
)

467  
NULL
;

469 
	`js_fܗch
(
emt
, 
y
) {

470 i(
i
 =
dex
)

471  
emt
;

472 
i
++;

475  
NULL
;

476 
	}
}

478 
JsNode
 *
	$js_fd_memb
(
JsNode
 *
obje
, cڡ *
me
)

480 
JsNode
 *
memb
;

482 i(
obje
 =
NULL
 || obje->
g
 !
JSON_OBJECT
)

483  
NULL
;

485 
	`js_fܗch
(
memb
, 
obje
)

486 i(
	`rcmp
(
memb
->
key
, 
me
) == 0)

487  
memb
;

489  
NULL
;

490 
	}
}

492 
JsNode
 *
	$js_f_chd
(cڡ 
JsNode
 *
node
)

494 i(
node
 !
NULL
 && (node->
g
 =
JSON_ARRAY
 ||ode->g =
JSON_OBJECT
))

495  
node
->
chdn
.
hd
;

496  
NULL
;

497 
	}
}

499 
JsNode
 *
	$mknode
(
JsTag
 
g
)

501 
JsNode
 *
t
 = (JsNode*
	`oc
(1, (JsonNode));

502 i(
t
 =
NULL
)

503 
	`out_of_memy
();

504 
t
->
g
 =ag;

505  
t
;

506 
	}
}

508 
JsNode
 *
	$js_mknu
()

510  
	`mknode
(
JSON_NULL
);

511 
	}
}

513 
JsNode
 *
	$js_mkbo
(
bo
 
b
)

515 
JsNode
 *
t
 = 
	`mknode
(
JSON_BOOL
);

516 
t
->
bo_
 = 
b
;

517  
t
;

518 
	}
}

520 
JsNode
 *
	$mkrg
(*
s
)

522 
JsNode
 *
t
 = 
	`mknode
(
JSON_STRING
);

523 
t
->
rg_
 = 
s
;

524  
t
;

525 
	}
}

527 
JsNode
 *
	$js_mkrg
(cڡ *
s
)

529  
	`mkrg
(
	`js_rdup
(
s
));

530 
	}
}

532 
JsNode
 *
	$js_mknumb
(
n
)

534 
JsNode
 *
node
 = 
	`mknode
(
JSON_NUMBER
);

535 
node
->
numb_
 = 
n
;

536  
node
;

537 
	}
}

539 
JsNode
 *
	$js_mky
()

541  
	`mknode
(
JSON_ARRAY
);

542 
	}
}

544 
JsNode
 *
	$js_mkobje
()

546  
	`mknode
(
JSON_OBJECT
);

547 
	}
}

549 
	$nd_node
(
JsNode
 *

, JsNod*
chd
)

551 i(
chd
 !
NULL
 && 

 != NULL) {

552 
chd
->

 =arent;

553 
chd
->
ev
 = 

->
chdn
.

;

554 
chd
->
xt
 = 
NULL
;

556 i(

->
chdn
.

 !
NULL
)

557 

->
chdn
.

->
xt
 = 
chd
;

559 

->
chdn
.
hd
 = 
chd
;

560 

->
chdn
.

 = 
chd
;

562 
	}
}

564 
	$d_node
(
JsNode
 *

, JsNod*
chd
)

566 i(
chd
 !
NULL
 && 

 != NULL) {

567 
chd
->

 =arent;

568 
chd
->
ev
 = 
NULL
;

569 
chd
->
xt
 = 

->
chdn
.
hd
;

571 i(

->
chdn
.
hd
 !
NULL
)

572 

->
chdn
.
hd
->
ev
 = 
chd
;

574 

->
chdn
.

 = 
chd
;

575 

->
chdn
.
hd
 = 
chd
;

577 
	}
}

579 
	$nd_memb
(
JsNode
 *
obje
, *
key
, JsNod*
vue
)

581 i(
vue
 !
NULL
 && 
obje
 != NULL) {

582 
vue
->
key
 = key;

583 
	`nd_node
(
obje
, 
vue
);

585 
	}
}

587 
	$js_nd_emt
(
JsNode
 *
y
, JsNod*
emt
)

589 i(
y
 !
NULL
 && 
emt
 !=NULL) {

590 
	`as
(
y
->
g
 =
JSON_ARRAY
);

591 
	`as
(
emt
->

 =
NULL
);

593 
	`nd_node
(
y
, 
emt
);

595 
	}
}

597 
	$js_d_emt
(
JsNode
 *
y
, JsNod*
emt
)

599 
	`as
(
y
->
g
 =
JSON_ARRAY
);

600 
	`as
(
emt
->

 =
NULL
);

602 
	`d_node
(
y
, 
emt
);

603 
	}
}

605 
	$js_nd_memb
(
JsNode
 *
obje
, cڡ *
key
, JsNod*
vue
)

607 i(
obje
 !
NULL
 && 
key
 !NULL && 
vue
 != NULL) {

608 
	`as
(
obje
->
g
 =
JSON_OBJECT
);

609 
	`as
(
vue
->

 =
NULL
);

611 
	`nd_memb
(
obje
, 
	`js_rdup
(
key
), 
vue
);

613 
	}
}

615 
	$js_d_memb
(
JsNode
 *
obje
, cڡ *
key
, JsNod*
vue
)

617 i(
obje
 !
NULL
 && 
key
 !NULL && 
vue
 != NULL) {

618 
	`as
(
obje
->
g
 =
JSON_OBJECT
);

619 
	`as
(
vue
->

 =
NULL
);

621 
vue
->
key
 = 
	`js_rdup
(key);

622 
	`d_node
(
obje
, 
vue
);

624 
	}
}

626 
	$js_move_om_
(
JsNode
 *
node
)

628 i(
node
 !
NULL
) {

629 
JsNode
 *

 = 
node
->parent;

631 i(

 !
NULL
) {

632 i(
node
->
ev
 !
NULL
)

633 
node
->
ev
->
xt
 =ode->next;

635 

->
chdn
.
hd
 = 
node
->
xt
;

637 i(
node
->
xt
 !
NULL
)

638 
node
->
xt
->
ev
 =ode->prev;

640 

->
chdn
.

 = 
node
->
ev
;

642 
	`
(
node
->
key
);

644 
node
->

 = 
NULL
;

645 
node
->
ev
 =ode->
xt
 = 
NULL
;

646 
node
->
key
 = 
NULL
;

649 
	}
}

651 
bo
 
	$r_vue
(cڡ **

, 
JsNode
 **
out
)

653 cڡ *
s
 = *

;

655 *
s
) {

657 i(
	`ex_l
(&
s
, "null")) {

658 i(
out
)

659 *
out
 = 
	`js_mknu
();

660 *

 = 
s
;

661  
ue
;

663  
l
;

666 i(
	`ex_l
(&
s
, "false")) {

667 i(
out
)

668 *
out
 = 
	`js_mkbo
(
l
);

669 *

 = 
s
;

670  
ue
;

672  
l
;

675 i(
	`ex_l
(&
s
, "true")) {

676 i(
out
)

677 *
out
 = 
	`js_mkbo
(
ue
);

678 *

 = 
s
;

679  
ue
;

681  
l
;

684 *
r
 = 
NULL
;

685 i(
	`r_rg
(&
s
, 
out
 ? &
r
 : 
NULL
)) {

686 i(
out
)

687 *
out
 = 
	`mkrg
(
r
);

688 *

 = 
s
;

689  
ue
;

691  
l
;

695 i(
	`r_y
(&
s
, 
out
)) {

696 *

 = 
s
;

697  
ue
;

699  
l
;

702 i(
	`r_obje
(&
s
, 
out
)) {

703 *

 = 
s
;

704  
ue
;

706  
l
;

709 
num
;

710 i(
	`r_numb
(&
s
, 
out
 ? &
num
 : 
NULL
)) {

711 i(
out
)

712 *
out
 = 
	`js_mknumb
(
num
);

713 *

 = 
s
;

714  
ue
;

716  
l
;

719 
	}
}

721 
bo
 
	$r_y
(cڡ **

, 
JsNode
 **
out
)

723 cڡ *
s
 = *

;

724 
JsNode
 *
t
 = 
out
 ? 
	`js_mky
(: 
NULL
;

725 
JsNode
 *
emt
 = 
NULL
;

727 i(*
s
++ != '[')

728 
u
;

729 
	`sk_a
(&
s
);

731 i(*
s
 == ']') {

732 
s
++;

733 
sucss
;

737 i(!
	`r_vue
(&
s
, 
out
 ? &
emt
 : 
NULL
))

738 
u
;

739 
	`sk_a
(&
s
);

741 i(
out
)

742 
	`js_nd_emt
(
t
, 
emt
);

744 i(*
s
 == ']') {

745 
s
++;

746 
sucss
;

749 i(*
s
++ != ',')

750 
u
;

751 
	`sk_a
(&
s
);

754 
sucss
:

755 *

 = 
s
;

756 i(
out
)

757 *
out
 = 
t
;

758  
ue
;

760 
u
:

761 
	`js_de
(
t
);

762  
l
;

763 
	}
}

765 
bo
 
	$r_obje
(cڡ **

, 
JsNode
 **
out
)

767 cڡ *
s
 = *

;

768 
JsNode
 *
t
 = 
out
 ? 
	`js_mkobje
(: 
NULL
;

769 *
key
 = 
NULL
;

770 
JsNode
 *
vue
 = 
NULL
;

772 i(*
s
++ != '{')

773 
u
;

774 
	`sk_a
(&
s
);

776 i(*
s
 == '}') {

777 
s
++;

778 
sucss
;

782 i(!
	`r_rg
(&
s
, 
out
 ? &
key
 : 
NULL
))

783 
u
;

784 
	`sk_a
(&
s
);

786 i(*
s
++ != ':')

787 
u__key
;

788 
	`sk_a
(&
s
);

790 i(!
	`r_vue
(&
s
, 
out
 ? &
vue
 : 
NULL
))

791 
u__key
;

792 
	`sk_a
(&
s
);

794 i(
out
)

795 
	`nd_memb
(
t
, 
key
, 
vue
);

797 i(*
s
 == '}') {

798 
s
++;

799 
sucss
;

802 i(*
s
++ != ',')

803 
u
;

804 
	`sk_a
(&
s
);

807 
sucss
:

808 *

 = 
s
;

809 i(
out
)

810 *
out
 = 
t
;

811  
ue
;

813 
u__key
:

814 i(
out
)

815 
	`
(
key
);

816 
u
:

817 
	`js_de
(
t
);

818  
l
;

819 
	}
}

821 
bo
 
	$r_rg
(cڡ **

, **
out
)

823 cڡ *
s
 = *

;

824 
SB
 
sb
 = { 0, 0, 0 };

825 
throwaway_bufr
[4];

827 *
b
;

829 i(*
s
++ != '"')

830  
l
;

832 i(
out
) {

833 
	`sb_
(&
sb
);

834 
	`sb_ed
(&
sb
, 4);

835 
b
 = 
sb
.
cur
;

837 
b
 = 
throwaway_bufr
;

840 *
s
 != '"') {

841 
c
 = *
s
++;

844 i(
c
 == '\\') {

845 
c
 = *
s
++;

846 
c
) {

850 *
b
++ = 
c
;

853 *
b
++ = '\b';

856 *
b
++ = '\f';

859 *
b
++ = '\n';

862 *
b
++ = '\r';

865 *
b
++ = '\t';

869 
ut16_t
 
uc
, 
lc
;

870 
ut32_t
 
unicode
;

872 i(!
	`r_hex16
(&
s
, &
uc
))

873 
ed
;

875 i(
uc
 >= 0xD800 && uc <= 0xDFFF) {

877 i(*
s
++ !'\\' || *s++ !'u' || !
	`r_hex16
(&s, &
lc
))

878 
ed
;

879 i(!
	`om_suoge_
(
uc
, 
lc
, &
unicode
))

880 
ed
;

881 } i(
uc
 == 0) {

883 
ed
;

885 
unicode
 = 
uc
;

888 
b
 +
	`utf8_wre_ch
(
unicode
, b);

893 
ed
;

895 } i(
c
 <= 0x1F) {

897 
ed
;

900 
n
;

902 
s
--;

903 
n
 = 
	`utf8_vide_cz
(
s
);

904 i(
n
 == 0)

905 
ed
;

907 
n
--)

908 *
b
++ = *
s
++;

915 i(
out
) {

916 
sb
.
cur
 = 
b
;

917 
	`sb_ed
(&
sb
, 4);

918 
b
 = 
sb
.
cur
;

920 
b
 = 
throwaway_bufr
;

923 
s
++;

925 i(
out
)

926 *
out
 = 
	`sb_fish
(&
sb
);

927 *

 = 
s
;

928  
ue
;

930 
ed
:

931 i(
out
)

932 
	`sb_
(&
sb
);

933  
l
;

934 
	}
}

936 
bo
 
	$is_a
(cڡ *
c
) {

937  ((*
c
) == '\t' || (*c) == '\n' || (*c) == '\r' || (*c) == ' ');

938 
	}
}

940 
bo
 
	$is_dig
(cڡ *
c
){

941  ((*
c
) >= '0' && (*c) <= '9');

942 
	}
}

954 
bo
 
	$r_numb
(cڡ **

, *
out
)

956 cڡ *
s
 = *

;

959 i(*
s
 == '-')

960 
s
++;

963 i(*
s
 == '0') {

964 
s
++;

966 i(!
	`is_dig
(
s
))

967  
l
;

969 
s
++;

970 } 
	`is_dig
(
s
));

974 i(*
s
 == '.') {

975 
s
++;

976 i(!
	`is_dig
(
s
))

977  
l
;

979 
s
++;

980 } 
	`is_dig
(
s
));

984 i(*
s
 == 'E' || *s == 'e') {

985 
s
++;

986 i(*
s
 == '+' || *s == '-')

987 
s
++;

988 i(!
	`is_dig
(
s
))

989  
l
;

991 
s
++;

992 } 
	`is_dig
(
s
));

995 i(
out
)

996 *
out
 = 
	`od
(*

, 
NULL
);

998 *

 = 
s
;

999  
ue
;

1000 
	}
}

1002 
	$sk_a
(cڡ **

)

1004 cڡ *
s
 = *

;

1005 
	`is_a
(
s
))

1006 
s
++;

1007 *

 = 
s
;

1008 
	}
}

1010 
	$em_vue
(
SB
 *
out
, cڡ 
JsNode
 *
node
)

1012 
	`as
(
	`g_is_vid
(
node
->
g
));

1013 
node
->
g
) {

1014 
JSON_NULL
:

1015 
	`sb_puts
(
out
, "null");

1017 
JSON_BOOL
:

1018 
	`sb_puts
(
out
, 
node
->
bo_
 ? "true" : "false");

1020 
JSON_STRING
:

1021 
	`em_rg
(
out
, 
node
->
rg_
);

1023 
JSON_NUMBER
:

1024 
	`em_numb
(
out
, 
node
->
numb_
);

1026 
JSON_ARRAY
:

1027 
	`em_y
(
out
, 
node
);

1029 
JSON_OBJECT
:

1030 
	`em_obje
(
out
, 
node
);

1033 
	`as
(
l
);

1035 
	}
}

1037 
	$em_vue_dd
(
SB
 *
out
, cڡ 
JsNode
 *
node
, cڡ *
a
, 
dt_v
)

1039 
	`as
(
	`g_is_vid
(
node
->
g
));

1040 
node
->
g
) {

1041 
JSON_NULL
:

1042 
	`sb_puts
(
out
, "null");

1044 
JSON_BOOL
:

1045 
	`sb_puts
(
out
, 
node
->
bo_
 ? "true" : "false");

1047 
JSON_STRING
:

1048 
	`em_rg
(
out
, 
node
->
rg_
);

1050 
JSON_NUMBER
:

1051 
	`em_numb
(
out
, 
node
->
numb_
);

1053 
JSON_ARRAY
:

1054 
	`em_y_dd
(
out
, 
node
, 
a
, 
dt_v
);

1056 
JSON_OBJECT
:

1057 
	`em_obje_dd
(
out
, 
node
, 
a
, 
dt_v
);

1060 
	`as
(
l
);

1062 
	}
}

1064 
	$em_y
(
SB
 *
out
, cڡ 
JsNode
 *
y
)

1066 cڡ 
JsNode
 *
emt
;

1068 
	`sb_putc
(
out
, '[');

1069 
	`js_fܗch
(
emt
, 
y
) {

1070 
	`em_vue
(
out
, 
emt
);

1071 i(
emt
->
xt
 !
NULL
)

1072 
	`sb_putc
(
out
, ',');

1074 
	`sb_putc
(
out
, ']');

1075 
	}
}

1077 
	$em_y_dd
(
SB
 *
out
, cڡ 
JsNode
 *
y
, cڡ *
a
, 
dt_v
)

1079 cڡ 
JsNode
 *
emt
 = 
y
->
chdn
.
hd
;

1080 
i
;

1082 i(
emt
 =
NULL
) {

1083 
	`sb_puts
(
out
, "[]");

1087 
	`sb_puts
(
out
, "[\n");

1088 
emt
 !
NULL
) {

1089 
i
 = 0; i < 
dt_v
 + 1; i++)

1090 
	`sb_puts
(
out
, 
a
);

1091 
	`em_vue_dd
(
out
, 
emt
, 
a
, 
dt_v
 + 1);

1093 
emt
 =mt->
xt
;

1094 
	`sb_puts
(
out
, 
emt
 !
NULL
 ? ",\n" : "\n");

1096 
i
 = 0; i < 
dt_v
; i++)

1097 
	`sb_puts
(
out
, 
a
);

1098 
	`sb_putc
(
out
, ']');

1099 
	}
}

1101 
	$em_obje
(
SB
 *
out
, cڡ 
JsNode
 *
obje
)

1103 cڡ 
JsNode
 *
memb
;

1105 
	`sb_putc
(
out
, '{');

1106 
	`js_fܗch
(
memb
, 
obje
) {

1107 
	`em_rg
(
out
, 
memb
->
key
);

1108 
	`sb_putc
(
out
, ':');

1109 
	`em_vue
(
out
, 
memb
);

1110 i(
memb
->
xt
 !
NULL
)

1111 
	`sb_putc
(
out
, ',');

1113 
	`sb_putc
(
out
, '}');

1114 
	}
}

1116 
	$em_obje_dd
(
SB
 *
out
, cڡ 
JsNode
 *
obje
, cڡ *
a
, 
dt_v
)

1118 cڡ 
JsNode
 *
memb
 = 
obje
->
chdn
.
hd
;

1119 
i
;

1121 i(
memb
 =
NULL
) {

1122 
	`sb_puts
(
out
, "{}");

1126 
	`sb_puts
(
out
, "{\n");

1127 
memb
 !
NULL
) {

1128 
i
 = 0; i < 
dt_v
 + 1; i++)

1129 
	`sb_puts
(
out
, 
a
);

1130 
	`em_rg
(
out
, 
memb
->
key
);

1131 
	`sb_puts
(
out
, ": ");

1132 
	`em_vue_dd
(
out
, 
memb
, 
a
, 
dt_v
 + 1);

1134 
memb
 = memb->
xt
;

1135 
	`sb_puts
(
out
, 
memb
 !
NULL
 ? ",\n" : "\n");

1137 
i
 = 0; i < 
dt_v
; i++)

1138 
	`sb_puts
(
out
, 
a
);

1139 
	`sb_putc
(
out
, '}');

1140 
	}
}

1142 
	$em_rg
(
SB
 *
out
, cڡ *
r
)

1144 
bo
 
es_unicode
 = 
l
;

1145 cڡ *
s
 = 
r
;

1146 *
b
;

1149 #ide
NDEBUG


1150 i(!
	`utf8_vide
(
r
)) {

1151 
throw
 
utf8
::
	`vid_utf8
(0);

1155 
	`as
(
	`utf8_vide
(
r
));

1161 
	`sb_ed
(
out
, 14);

1162 
b
 = 
out
->
cur
;

1164 *
b
++ = '"';

1165 *
s
 != 0) {

1166 
c
 = *
s
++;

1169 
c
) {

1171 *
b
++ = '\\';

1172 *
b
++ = '"';

1175 *
b
++ = '\\';

1176 *
b
++ = '\\';

1179 *
b
++ = '\\';

1180 *
b
++ = 'b';

1183 *
b
++ = '\\';

1184 *
b
++ = 'f';

1187 *
b
++ = '\\';

1188 *
b
++ = 'n';

1191 *
b
++ = '\\';

1192 *
b
++ = 'r';

1195 *
b
++ = '\\';

1196 *
b
++ = 't';

1199 
n
;

1201 
s
--;

1202 
n
 = 
	`utf8_vide_cz
(
s
);

1204 i(
n
 == 0) {

1213 
	`as
(
l
);

1214 i(
es_unicode
) {

1215 
	`ry
(
b
, "\\uFFFD");

1216 
b
 += 6;

1218 *
b
++ = 0xEFu;

1219 *
b
++ = 0xBFu;

1220 *
b
++ = 0xBDu;

1222 
s
++;

1223 } i(
c
 < 0x1F || (>0x80 && 
es_unicode
)) {

1225 
ut32_t
 
unicode
;

1227 
s
 +
	`utf8_ad_ch
(s, &
unicode
);

1229 i(
unicode
 <= 0xFFFF) {

1230 *
b
++ = '\\';

1231 *
b
++ = 'u';

1232 
b
 +
	`wre_hex16
(b, 
unicode
);

1235 
ut16_t
 
uc
, 
lc
;

1236 
	`as
(
unicode
 <= 0x10FFFF);

1237 
	`to_suoge_
(
unicode
, &
uc
, &
lc
);

1238 *
b
++ = '\\';

1239 *
b
++ = 'u';

1240 
b
 +
	`wre_hex16
(b, 
uc
);

1241 *
b
++ = '\\';

1242 *
b
++ = 'u';

1243 
b
 +
	`wre_hex16
(b, 
lc
);

1247 
n
--)

1248 *
b
++ = *
s
++;

1259 
out
->
cur
 = 
b
;

1260 
	`sb_ed
(
out
, 14);

1261 
b
 = 
out
->
cur
;

1263 *
b
++ = '"';

1265 
out
->
cur
 = 
b
;

1266 
	}
}

1268 
	$em_numb
(
SB
 *
out
, 
num
)

1276 
buf
[64];

1277 
	`rtf
(
buf
, "%.16g", 
num
);

1279 i(
	`numb_is_vid
(
buf
))

1280 
	`sb_puts
(
out
, 
buf
);

1282 
	`sb_puts
(
out
, "null");

1283 
	}
}

1285 
bo
 
	$g_is_vid
(
g
)

1287  ( 
g
 <
JSON_OBJECT
);

1288 
	}
}

1290 
bo
 
	$numb_is_vid
(cڡ *
num
)

1292  (
	`r_numb
(&
num
, 
NULL
) && *num == '\0');

1293 
	}
}

1295 
bo
 
	$ex_l
(cڡ **

, cڡ *
r
)

1297 cڡ *
s
 = *

;

1299 *
r
 != '\0')

1300 i(*
s
++ !*
r
++)

1301  
l
;

1303 *

 = 
s
;

1304  
ue
;

1305 
	}
}

1311 
bo
 
	$r_hex16
(cڡ **

, 
ut16_t
 *
out
)

1313 cڡ *
s
 = *

;

1314 
ut16_t
 
t
 = 0;

1315 
ut16_t
 
i
;

1316 
ut16_t
 
tmp
;

1317 
c
;

1319 
i
 = 0; i < 4; i++) {

1320 
c
 = *
s
++;

1321 i(
c
 >= '0' && c <= '9')

1322 
tmp
 = 
c
 - '0';

1323 i(
c
 >= 'A' && c <= 'F')

1324 
tmp
 = 
c
 - 'A' + 10;

1325 i(
c
 >= 'a' && c <= 'f')

1326 
tmp
 = 
c
 - 'a' + 10;

1328  
l
;

1330 
t
 <<= 4;

1331 
t
 +
tmp
;

1334 i(
out
)

1335 *
out
 = 
t
;

1336 *

 = 
s
;

1337  
ue
;

1338 
	}
}

1344 
	$wre_hex16
(*
out
, 
ut16_t
 
v
)

1346 cڡ *
hex
 = "0123456789ABCDEF";

1348 *
out
++ = 
hex
[(
v
 >> 12) & 0xF];

1349 *
out
++ = 
hex
[(
v
 >> 8) & 0xF];

1350 *
out
++ = 
hex
[(
v
 >> 4) & 0xF];

1351 *
out
++ = 
hex
[ 
v
 & 0xF];

1354 
	}
}

1356 
bo
 
	$js_check
(cڡ 
JsNode
 *
node
, 
rmsg
[256])

1358 
	#obm
(...) do { \

1359 i(
rmsg
 !
NULL
) \

1360 
	`tf
(
rmsg
, 256, 
__VA_ARGS__
); \

1361  
l
; \

1362 } 0)

	)

1364 i(
node
->
key
 !
NULL
 && !
	`utf8_vide
(node->key))

1365 
	`obm
("key contains invalid UTF-8");

1367 i(!
	`g_is_vid
(
node
->
g
))

1368 
	`obm
("g ivid (%u)", 
node
->
g
);

1370 i(
node
->
g
 =
JSON_BOOL
) {

1371 i(
node
->
bo_
 !
l
 &&ode->bo_ !
ue
)

1372 
	`obm
("bo_ iÙh f (%dn܁ru(%d)", ()
l
, ()
ue
);

1373 } i(
node
->
g
 =
JSON_STRING
) {

1374 i(
node
->
rg_
 =
NULL
)

1375 
	`obm
("string_ is NULL");

1376 i(!
	`utf8_vide
(
node
->
rg_
))

1377 
	`obm
("string_ contains invalid UTF-8");

1378 } i(
node
->
g
 =
JSON_ARRAY
 ||ode->g =
JSON_OBJECT
) {

1379 
JsNode
 *
hd
 = 
node
->
chdn
.head;

1380 
JsNode
 *

 = 
node
->
chdn
.tail;

1382 i(
hd
 =
NULL
 || 

 == NULL) {

1383 i(
hd
 !
NULL
)

1384 
	`obm
("tail is NULL, but head isot");

1385 i(

 !
NULL
)

1386 
	`obm
("head is NULL, butail isot");

1388 
JsNode
 *
chd
;

1389 
JsNode
 *
ϡ
 = 
NULL
;

1391 i(
hd
->
ev
 !
NULL
)

1392 
	`obm
("First child'srevointer isot NULL");

1394 
chd
 = 
hd
; chd !
NULL
; 
ϡ
 = chd, chd = chd->
xt
) {

1395 i(
chd
 =
node
)

1396 
	`obm
("node is its own child");

1397 i(
chd
->
xt
 == child)

1398 
	`obm
("child->next == child (cycle)");

1399 i(
chd
->
xt
 =
hd
)

1400 
	`obm
("child->next == head (cycle)");

1402 i(
chd
->

 !
node
)

1403 
	`obm
("child doesotoint backoarent");

1404 i(
chd
->
xt
 !
NULL
 && chd->xt->
ev
 != child)

1405 
	`obm
("child->next doesotoint backo child");

1407 i(
node
->
g
 =
JSON_ARRAY
 && 
chd
->
key
 !
NULL
)

1408 
	`obm
("Arraylement's key isot NULL");

1409 i(
node
->
g
 =
JSON_OBJECT
 && 
chd
->
key
 =
NULL
)

1410 
	`obm
("Object member's key is NULL");

1412 i(!
	`js_check
(
chd
, 
rmsg
))

1413  
l
;

1416 i(
ϡ
 !

)

1417 
	`obm
("tail doesot matchointer found by startingt headnd followingextinks");

1421  
ue
;

1423 #unde
obm


1424 
	}
}

	@node_modules/node-sass/src/libsass/src/json.hpp

24 #ide
CCAN_JSON_H


25 
	#CCAN_JSON_H


	)

27 
	~<dbo.h
>

28 
	~<ddef.h
>

31 
	mJSON_NULL
,

32 
	mJSON_BOOL
,

33 
	mJSON_STRING
,

34 
	mJSON_NUMBER
,

35 
	mJSON_ARRAY
,

36 
	mJSON_OBJECT
,

37 } 
	tJsTag
;

39 
JsNode
 
	tJsNode
;

41 
	sJsNode


44 
JsNode
 *
	m
;

45 
JsNode
 *
	mev
, *
	mxt
;

48 *
	mkey
;

50 
JsTag
 
	mg
;

53 
bo
 
	mbo_
;

56 *
	mrg_
;

59 
	mnumb_
;

64 
JsNode
 *
	mhd
, *
	m
;

65 } 
	mchdn
;

71 
JsNode
 *
js_decode
 (cڡ *
js
);

72 *
js_code
 (cڡ 
JsNode
 *
node
);

73 *
js_code_rg
 (cڡ *
r
);

74 *
js_rgify
 (cڡ 
JsNode
 *
node
, cڡ *
a
);

75 
js_de
 (
JsNode
 *
node
);

77 
bo
 
js_vide
 (cڡ *
js
);

81 
JsNode
 *
js_fd_emt
 (JsNod*
y
, 
dex
);

82 
JsNode
 *
js_fd_memb
 (JsNod*
obje
, cڡ *
key
);

84 
JsNode
 *
js_f_chd
 (cڡ JsNod*
node
);

86 
	#js_fܗch
(
i
, 
obje__y
) \

87 (
i

	`js_f_chd
(
obje__y
); \

88 (
i
!
NULL
; \

89 (
i
(i)->
xt
)

	)

93 
JsNode
 *
js_mknu
();

94 
JsNode
 *
js_mkbo
(
bo
 
b
);

95 
JsNode
 *
js_mkrg
(cڡ *
s
);

96 
JsNode
 *
js_mknumb
(
n
);

97 
JsNode
 *
js_mky
();

98 
JsNode
 *
js_mkobje
();

100 
js_nd_emt
(
JsNode
 *
y
, JsNod*
emt
);

101 
js_d_emt
(
JsNode
 *
y
, JsNod*
emt
);

102 
js_nd_memb
(
JsNode
 *
obje
, cڡ *
key
, JsNod*
vue
);

103 
js_d_memb
(
JsNode
 *
obje
, cڡ *
key
, JsNod*
vue
);

105 
js_move_om_
(
JsNode
 *
node
);

115 
bo
 
js_check
(cڡ 
JsNode
 *
node
, 
rmsg
[256]);

	@node_modules/node-sass/src/libsass/src/kwd_arg_macros.hpp

1 #ide
SASS_KWD_ARG_MACROS_H


2 
	#SASS_KWD_ARG_MACROS_H


	)

15 
	#KWD_ARG_SET
(
t_me

ass
 
	)
set_name

17 
	#KWD_ARG
(
t_me
, 
ty
, 
me
) \

18 
ive
: \

19 
ty
 
me
##
_
; \

20 
public
: \

21 
t_me
& 
	`me
(
ty
 
me
##
__
) { \

22 
me
##
_
 =ame##
__
; \

23  *
this
; \

25 
ty
 
	`me
({  
me
##
_
; } \

26 
ive
:

	)

	@node_modules/node-sass/src/libsass/src/lexer.cpp

1 
	~"ss.h
"

2 
	~<cy
>

3 
	~<cddef
>

4 
	~<ioam
>

5 
	~<iom
>

6 
	~"x.h
"

7 
	~"cڡts.h
"

10 
mea
 
	gSass
 {

11 
usg
 
mea
 
	gCڡts
;

13 
mea
 
	gPx
 {

20 cڡ * 
kwd_
(cڡ * 
c
{  
	gexaly
<'@'>(
	gc
); }

21 cڡ * 
kwd_d
(cڡ * 
c
{  
	gexaly
<'.'>(
	gc
); }

22 cڡ * 
kwd_comma
(cڡ * 
c
{  
	gexaly
<','>(
	gc
); };

23 cڡ * 
kwd_c
(cڡ * 
c
{  
	gexaly
<':'>(
	gc
); };

24 cڡ * 
kwd_
(cڡ * 
c
{  
	gexaly
<'*'>(
	gc
); };

25 cڡ * 
kwd_us
(cڡ * 
c
{  
	gexaly
<'+'>(
	gc
); };

26 cڡ * 
kwd_mus
(cڡ * 
c
{  
	gexaly
<'-'>(
	gc
); };

27 cڡ * 
kwd_ash
(cڡ * 
c
{  
	gexaly
<'/'>(
	gc
); };

35 
bo
 
is_pha
(cڡ & 
chr
)

37  (
	gchr
 - 'A') <= 'Z' - 'A' ||

38 (
chr
 - 'a') <= 'z' - 'a';

41 
bo
 
is_a
(cڡ & 
chr
)

44  
	gchr
 =' ' || (
chr
 - '\t') <= '\r' - '\t';

47 
bo
 
is_dig
(cڡ & 
chr
)

50  (
	gchr
 - '0') <= '9' - '0';

53 
bo
 
is_xdig
(cڡ & 
chr
)

56  (
	gchr
 - '0') <= '9' - '0' ||

57 (
chr
 - 'a') <= 'f' - 'a' ||

58 (
chr
 - 'A') <= 'F' - 'A';

61 
bo
 
is_pun
(cڡ & 
chr
)

64  
	gchr
 == '.';

67 
bo
 
is_num
(cڡ & 
chr
)

69  
is_pha
(
chr
|| 
is_dig
(chr);

73 
bo
 
is_unicode
(cڡ & 
chr
)

76  (
	gchr
) > 127;

81 
bo
 
is_nascii
(cڡ & 
chr
)

84 ((
	gchr
) > 127 && (chr) < 55296) ||

85 ((
	gchr
) > 57343 && (chr) < 65534) ||

86 ((
	gchr
) > 65535 && (chr) < 1114111)

92 
bo
 
is_uri_cha
(cڡ & 
chr
)

94  ((
	gchr
) > 41 && (chr) < 127) ||

95 (
	gchr
=':' || (
chr
) == '/';

100 
bo
 
is_esb_cha
(cڡ & 
chr
)

102  (
	gchr
) > 31 && (chr) < 127;

106 
bo
 
is_cha
(cڡ & 
chr
)

109  
is_num
(
chr
|| 
is_unicode
(chr|| 
	gchr
 == '-';

117 cڡ * 
a
(cڡ * 
c
{  
is_a
(*c? 
	gc
 + 1 : 0; }

118 cڡ * 
pha
(cڡ * 
c
{  
is_pha
(*c? 
	gc
 + 1 : 0; }

119 cڡ * 
unicode
(cڡ * 
c
{  
is_unicode
(*c? 
	gc
 + 1 : 0; }

120 cڡ * 
nascii
(cڡ * 
c
{  
is_nascii
(*c? 
	gc
 + 1 : 0; }

121 cڡ * 
dig
(cڡ * 
c
{  
is_dig
(*c? 
	gc
 + 1 : 0; }

122 cڡ * 
xdig
(cڡ * 
c
{  
is_xdig
(*c? 
	gc
 + 1 : 0; }

123 cڡ * 
num
(cڡ * 
c
{  
is_num
(*c? 
	gc
 + 1 : 0; }

124 cڡ * 
pun
(cڡ * 
c
{  
is_pun
(*c? 
	gc
 + 1 : 0; }

125 cڡ * 
hyph
(cڡ * 
c
{  *
	gc
 && *src == '-' ? src + 1 : 0; }

126 cڡ * 
cha
(cڡ * 
c
{  
is_cha
(*c? 
	gc
 + 1 : 0; }

127 cڡ * 
uri_cha
(cڡ * 
c
{  
is_uri_cha
(*c? 
	gc
 + 1 : 0; }

128 cڡ * 
esb_cha
(cڡ * 
c
{  
is_esb_cha
(*c? 
	gc
 + 1 : 0; }

131 cڡ * 
as
(cڡ * 
c
{  
	ge_us
<
	ga
>(
	gc
); }

132 cڡ * 
digs
(cڡ * 
c
{  
	ge_us
<
	gdig
>(
	gc
); }

133 cڡ * 
hyphs
(cڡ * 
c
{  
	ge_us
<
	ghyph
>(
	gc
); }

136 cڡ * 
no_as
(cڡ * 
c
{  
	gge
< 
	ga
 >(
	gc
); }

137 cڡ * 
tiڮ_as
(cڡ * 
c
{  
	gzo_us
< 
	ga
 >(
	gc
); }

140 cڡ * 
y_ch
(cڡ * 
c
{  *
	gc
 ? src + 1 : src; }

143 cڡ * 
wd_boundy
(cڡ * 
c
{  
is_cha
(*c|| *
	gc
 == '#' ? 0 : src; }

146 cڡ * 
_lebak
(cڡ * 
c
)

149 i(*
	gc
 =0 || *
c
 == '\n')  src + 1;

151 i(*
	gc
 ='\r' *(
c
 + 1) == '\n' ? src + 2 : src + 1;

158 cڡ * 
d_of_le
(cڡ * 
c
)

161  *
	gc
 =0 || *
c
 == '\n' || *src == '\r' ? src : 0;

166 cڡ * 
d_of_fe
(cڡ * 
c
)

169  *
	gc
 =0 ? 
c
 : 0;

	@node_modules/node-sass/src/libsass/src/lexer.hpp

1 #ide
SASS_LEXER_H


2 
	#SASS_LEXER_H


	)

4 
	~<crg
>

6 
mea
 
	gSass
 {

7 
mea
 
	gPx
 {

14 cڡ * 
kwd_
(cڡ * 
c
);

15 cڡ * 
kwd_d
(cڡ * 
c
);

16 cڡ * 
kwd_comma
(cڡ * 
c
);

17 cڡ * 
kwd_c
(cڡ * 
c
);

18 cڡ * 
kwd_
(cڡ * 
c
);

19 cڡ * 
kwd_us
(cڡ * 
c
);

20 cڡ * 
kwd_mus
(cڡ * 
c
);

21 cڡ * 
kwd_ash
(cڡ * 
c
);

28 
bo
 
is_a
(cڡ & 
c
);

29 
bo
 
is_pha
(cڡ & 
c
);

30 
bo
 
is_pun
(cڡ & 
c
);

31 
bo
 
is_dig
(cڡ & 
c
);

32 
bo
 
is_num
(cڡ & 
c
);

33 
bo
 
is_xdig
(cڡ & 
c
);

34 
bo
 
is_unicode
(cڡ & 
c
);

35 
bo
 
is_nascii
(cڡ & 
c
);

36 
bo
 
is_cha
(cڡ & 
c
);

37 
bo
 
is_uri_cha
(cڡ & 
c
);

38 
bo
 
esb_cha
(cڡ & 
c
);

41 cڡ * 
a
(cڡ * 
c
);

42 cڡ * 
pha
(cڡ * 
c
);

43 cڡ * 
dig
(cڡ * 
c
);

44 cڡ * 
xdig
(cڡ * 
c
);

45 cڡ * 
num
(cڡ * 
c
);

46 cڡ * 
pun
(cڡ * 
c
);

47 cڡ * 
hyph
(cڡ * 
c
);

48 cڡ * 
unicode
(cڡ * 
c
);

49 cڡ * 
nascii
(cڡ * 
c
);

50 cڡ * 
cha
(cڡ * 
c
);

51 cڡ * 
uri_cha
(cڡ * 
c
);

52 cڡ * 
esb_cha
(cڡ * 
c
);

55 cڡ * 
as
(cڡ * 
c
);

56 cڡ * 
digs
(cڡ * 
c
);

57 cڡ * 
hyphs
(cڡ * 
c
);

60 cڡ * 
no_as
(cڡ * 
c
);

61 cڡ * 
tiڮ_as
(cڡ * 
c
);

64 cڡ * 
y_ch
(cڡ * 
c
);

68 cڡ * 
wd_boundy
(cڡ * 
c
);

71 cڡ * 
_lebak
(cڡ * 
c
);

75 cڡ * 
d_of_le
(cڡ * 
c
);

78 cڡ * 
d_of_fe
(cڡ * 
c
);

82 cڡ * (*
	tex
)(const *);

90 
	gme
 <
	gchr
>

91 cڡ * 
exaly
(cڡ * 
c
) {

92  *
	gc
 =
chr
 ? 
c
 + 1 : 0;

97 
	gme
 <cڡ * 
	gr
>

98 cڡ * 
exaly
(cڡ * 
c
) {

99 i(
	gr
 == 0)  0;

100 cڡ * 
	ge
 = 
r
;

101 i(
	gc
 == 0)  0;

104 *
	ge
 && *
	gc
 =*
e
) {

105 ++
c
, ++
e
;

108  *
	ge
 =0 ? 
c
 : 0;

115 
	gme
 <cڡ * 
	gr
>

116 cڡ * 
nsive
(cڡ * 
c
) {

117 i(
	gr
 == 0)  0;

118 cڡ * 
	ge
 = 
r
;

119 i(
	gc
 == 0)  0;

122 *
	ge
 && (*
	gc
 =*
e
 || *
c
+32 == *pre)) {

123 ++
c
, ++
e
;

126  *
	ge
 =0 ? 
c
 : 0;

131 
	gme
 <cڡ * 
	gch_ass
>

132 cڡ * 
ass_ch
(cڡ * 
c
) {

133 cڡ * 
	gcc
 = 
ch_ass
;

134 *
	gcc
 && *
	gc
 !*
cc
) ++cc;

135  *
	gcc
 ? 
	gc
 + 1 : 0;

140 
	gme
 <cڡ * 
	gch_ass
>

141 cڡ * 
ass_chs
(cڡ * 
c
) {

142 cڡ * 
	gp
 = 
c
;

143 
	gass_ch
<
	gch_ass
>(
	gp
)) ++p;

144  
	gp
 =
c
 ? 0 : 
p
;

149 
	gme
 <cڡ * 
	gg_ch_ass
>

150 cڡ * 
g_ass_ch
(cڡ * 
c
) {

151 i(*
	gc
 == 0)  0;

152 cڡ * 
	gcc
 = 
g_ch_ass
;

153 *
	gcc
 && *
	gc
 !*
cc
) ++cc;

154  *
	gcc
 ? 0 : 
c
 + 1;

159 
	gme
 <cڡ * 
	gg_ch_ass
>

160 cڡ * 
g_ass_chs
(cڡ * 
c
) {

161 cڡ * 
	gp
 = 
c
;

162 
	gg_ass_ch
<
	gg_ch_ass
>(
	gp
)) ++p;

163  
	gp
 =
c
 ? 0 : 
p
;

168 
	gme
 <cڡ 
	gchr
>

169 cڡ * 
y_ch_but
(cڡ * 
c
) {

170  (*
	gc
 && *!
chr
? 
c
 + 1 : 0;

176 
	gme
 <
ex
 
	gmx
>

177 cڡ * 
ge
(cڡ * 
c
) {

178  
mx
(
c
) ? 0 : src;

185 
	gme
 <
ex
 
	gmx
>

186 cڡ * 
lookahd
(cڡ * 
c
) {

187  
mx
(
c
? 
	gc
 : 0;

193 
	gme
 <cڡ 
ex
 
	gmx
>

194 cڡ * 
ives
(cڡ * 
c
) {

195 cڡ * 
	grt
;

196 i((
	grt
 = 
mx
(
c
)) 
rt
;

199 
	gme
 <cڡ 
ex
 
	gmx1
, cڡx 
	gmx2
, cڡ 
	gex
... 
	gmxs
>

200 cڡ * 
ives
(cڡ * 
c
) {

201 cڡ * 
	grt
;

202 i((
	grt
 = 
mx1
(
c
)) 
rt
;

203  
	gives
<
	gmx2
, 
	gmxs
...>(
	gc
);

209 
	gme
 <cڡ 
ex
 
	gmx1
>

210 cڡ * 
qu
(cڡ * 
c
) {

211 cڡ * 
	grt
 = 
c
;

212 i(!(
	grt
 = 
mx1
(
rt
)))  0;

213  
	grt
;

215 
	gme
 <cڡ 
ex
 
	gmx1
, cڡx 
	gmx2
, cڡ 
	gex
... 
	gmxs
>

216 cڡ * 
qu
(cڡ * 
c
) {

217 cڡ * 
	grt
 = 
c
;

218 i(!(
	grt
 = 
mx1
(
rt
)))  0;

219  
	gqu
<
	gmx2
, 
	gmxs
...>(
	grt
);

225 
	gme
 <
ex
 
	gmx
>

226 cڡ * 
tiڮ
(cڡ * 
c
) {

227 cڡ * 
	gp
 = 
mx
(
c
);

228  
	gp
 ? : 
c
;

233 
	gme
 <
ex
 
	gmx
>

234 cڡ * 
zo_us
(cڡ * 
c
) {

235 cڡ * 
	gp
 = 
mx
(
c
);

236 
	gp

	gc
 = 
p
, = 
mx
(
c
);

237  
	gc
;

242 
	gme
 <
ex
 
	gmx
>

243 cڡ * 
e_us
(cڡ * 
c
) {

244 cڡ * 
	gp
 = 
mx
(
c
);

245 i(!
	gp
)  0;

246 
	gp

	gc
 = 
p
, = 
mx
(
c
);

247  
	gc
;

253 
	gme
 <
ex
 
	gmx
,x 
	gdim
>

254 cڡ * 
n_gedy
(cڡ * 
c
) {

255 !
dim
(
c
)) {

256 cڡ * 
	gp
 = 
mx
(
c
);

257 i(
	gp
 =
c
)  0;

258 i(
	gp
 == 0)  0;

259 
	gc
 = 
p
;

261  
	gc
;

270 
	gme
 <cڡ * 
	gr
>

271 cڡ * 
keywd
(cڡ * 
c
) {

272  
	gqu
 <

273 
	gnsive
 < 
	gr
 >,

274 
	gwd_boundy


275 >(
	gc
);

280 
	gme
 <cڡ * 
	gr
>

281 cڡ * 
wd
(cڡ * 
c
) {

282  
	gqu
 <

283 
	gexaly
 < 
	gr
 >,

284 
	gwd_boundy


285 >(
	gc
);

288 
	gme
 <
	gchr
>

289 cڡ * 
looly
(cڡ * 
c
) {

290  
	gqu
 <

291 
	gtiڮ_as
,

292 
	gexaly
 < 
	gchr
 >

293 >(
	gc
);

295 
	gme
 <cڡ * 
	gr
>

296 cڡ * 
looly
(cڡ * 
c
) {

297  
	gqu
 <

298 
	gtiڮ_as
,

299 
	gexaly
 < 
	gr
 >

300 >(
	gc
);

	@node_modules/node-sass/src/libsass/src/listize.cpp

1 
	~"ss.h
"

2 
	~<ioam
>

3 
	~<tyfo
>

4 
	~<rg
>

6 
	~"liize.h
"

7 
	~"cڋxt.h
"

8 
	~"backa.h
"

9 
	~"r_hdlg.h
"

11 
mea
 
	gSass
 {

13 
	gLiize
::
Liize
(
Memy_Mag
& 
mem
)

14 : 
mem
(mem)

17 
Exessi
* 
Liize
::
ݔ
()(
Se_Li
* 
l
)

19 
Li
* 
l
 = 
SASS_MEMORY_NEW
(
mem
, Li, 
l
->
pe
(), s->
ngth
(), 
SASS_COMMA
);

20 
	gl
->
om_
(
ue
);

21 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

22 i(!(*
	gl
)[
i
]) ;

23 *
	gl
 << (*
	gl
)[
i
]->
rfm
(
this
);

25 i(
	gl
->
ngth
()) ;

26  
SASS_MEMORY_NEW
(
mem
, 
Nu
, 
l
->
pe
());

29 
Exessi
* 
	gLiize
::
ݔ
()(
Compound_Se
* 
l
)

31 
d
::
rg
 
r
;

32 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

33 
Exessi
* 
	ge
 = (*
l
)[
i
]->
rfm
(
this
);

34 i(
	ge

	gr
 +
e
->
to_rg
();

36  
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
l
->
pe
(), 
r
);

39 
Exessi
* 
	gLiize
::
ݔ
()(
Comex_Se
* 
l
)

41 
Li
* 
l
 = 
SASS_MEMORY_NEW
(
mem
, Li, 
l
->
pe
(), 2);

42 
	gl
->
om_
(
ue
);

43 
Compound_Se
* 
	ghd
 = 
l
->
hd
();

44 i(
	ghd
 && !hd->
is_emy_n
())

46 
Exessi
* 
	ghh
 = 
hd
->
rfm
(
this
);

47 i(
	ghh
*
	gl
 << hh;

50 
	gd
::
rg
 
n
 = ! 
l
->reference() ? ""

51 : 
l
->
n
()->
to_rg
();

52 
	gl
->
comb
())

54 
	gComex_Se
::
PARENT_OF
:

55 *
l
 << 
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
l
->
pe
(), ">");

57 
	gComex_Se
::
ADJACENT_TO
:

58 *
l
 << 
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
l
->
pe
(), "+");

60 
	gComex_Se
::
REFERENCE
:

61 *
l
 << 
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
l
->
pe
(), "/" + 
n
 + "/");

63 
	gComex_Se
::
PRECEDES
:

64 *
l
 << 
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
, 
l
->
pe
(), "~");

66 
	gComex_Se
::
ANCESTOR_OF
:

70 
Comex_Se
* 
	g
 = 
l
->

();

71 i(
	g
)

73 
Exessi
* 
	g
 = 

->
rfm
(
this
);

74 i(
	g
 &&t->
ce_ty
(=
Exessi
::
LIST
)

75 { *
l
 +
ic_
<
Li
*>(

); }

76 i(
	g
*
	gl
 << 
	gic_
<
	gLi
*>(tt);

78 i(
	gl
->
ngth
() == 0)  0;

79  
	gl
;

82 
Exessi
* 
	gLiize
::
back_im
(
AST_Node
* 
n
)

84  
dymic_
<
Exessi
*>(
n
);

	@node_modules/node-sass/src/libsass/src/listize.hpp

1 #ide
SASS_LISTIZE_H


2 
	#SASS_LISTIZE_H


	)

4 
	~<ve
>

5 
	~<ioam
>

7 
	~"a.h
"

8 
	~"cڋxt.h
"

9 
	~"ݔi.h
"

10 
	~"vmt.h
"

12 
mea
 
	gSass
 {

14 
	gEnvmt
<
	tAST_Node
*> 
	tEnv
;

15 
	gBacka
;

17 
ass
 
	gLiize
 : 
public
 
Oti_CRTP
<
Exessi
*, Listize> {

19 
	gMemy_Mag
& 
	gmem
;

21 
Exessi
* 
back_im
(
AST_Node
* 
n
);

23 
	gpublic
:

24 
Liize
(
Memy_Mag
&);

25 ~
Liize
() { }

27 
Exessi
* 
ݔ
()(
	gSe_Li
*);

28 
Exessi
* 
ݔ
()(
	gComex_Se
*);

29 
Exessi
* 
ݔ
()(
	gCompound_Se
*);

31 
	gme
 <
tyme
 
	gU
>

32 
Exessi
* 
back
(
U
 
x
{  
back_im
(x); }

	@node_modules/node-sass/src/libsass/src/mapping.hpp

1 #ide
SASS_MAPPING_H


2 
	#SASS_MAPPING_H


	)

4 
	~"posi.h
"

6 
mea
 
	gSass
 {

8 
	sMpg
 {

9 
Posi
 
	gig_posi
;

10 
Posi
 
	gged_posi
;

12 
Mpg
(cڡ 
Posi
& 
ig_posi
, cڡ Posi& 
ged_posi
)

13 : 
ig_posi
(ig_posi), 
ged_posi
(generated_position) { }

	@node_modules/node-sass/src/libsass/src/memory_manager.cpp

1 
	~"ss.h
"

2 
	~"a.h
"

3 
	~"memy_mag.h
"

5 
mea
 
	gSass
 {

7 
	gMemy_Mag
::
Memy_Mag
(
size_t
 
size
)

8 : 
nodes
(
d
::
ve
<
Memy_Obje
*>())

10 
size_t
 

 = 
size
;

11 i(
	g
 < 8) init = 8;

13 
	gnodes
.
rve
(

);

16 
	gMemy_Mag
::~
Memy_Mag
()

20 
size_t
 
i
 = 0, 
	gS
 = 
nodes
.
size
(); 
	gi
 < S; ++i) {

21 
do
(
nodes
[
i
]);

24 
	gnodes
.
r
();

27 
Memy_Obje
* 
	gMemy_Mag
::
add
(Memy_Obje* 

)

31 

->
fcou
 = 1;

32  
	g
;

35 
bo
 
	gMemy_Mag
::
has
(
Memy_Obje
* 

)

38  
fd
(
nodes
.
beg
(),odes.
d
(), 

) !=odes.end();

41 
Memy_Obje
* 
	gMemy_Mag
::
lo
(
size_t
 
size
)

44 * 
hp
 = 
mloc
(
size
);

46 (
	gic_
<
	gMemy_Obje
*>(
	ghp
))->
	gfcou
 = 0;

48 
	gnodes
.
push_back
(
ic_
<
Memy_Obje
*>(
hp
));

50  
	gic_
<
	gMemy_Obje
*>(
	ghp
);

53 
	gMemy_Mag
::
do
(
Memy_Obje
* 

)

56 i(

->
fcou
->~
Memy_Obje
();

58 

(

);

61 
	gMemy_Mag
::
move
(
Memy_Obje
* 

)

64 
nodes
.
a
(
fd
odes.
beg
(),odes.
d
(), 

));

68 
	gMemy_Mag
::
deroy
(
Memy_Obje
* 

)

71 
move
(

);

73 
do
(

);

	@node_modules/node-sass/src/libsass/src/memory_manager.hpp

1 #ide
SASS_MEMORY_MANAGER_H


2 
	#SASS_MEMORY_MANAGER_H


	)

4 
	~<ve
>

6 
mea
 
	gSass
 {

8 as
	cMemy_Obje
 {

9 
nd
 
ass
 
	gMemy_Mag
;

10 
	gfcou
;

11 
	gpublic
:

12 
Memy_Obje
({ 
fcou
 = 0; };

13 
	gvtu
 ~
Memy_Obje
() {};

23 as
	cMemy_Mag
 {

24 
	gd
::
ve
<
Memy_Obje
*> 
nodes
;

26 
	gpublic
:

27 
Memy_Mag
(
size_t
 
size
 = 0);

28 ~
Memy_Mag
();

30 
bo
 
has
(
Memy_Obje
* 

);

31 
Memy_Obje
* 
lo
(
size_t
 
size
);

32 
do
(
Memy_Obje
* 

);

33 
move
(
Memy_Obje
* 

);

34 
deroy
(
Memy_Obje
* 

);

35 
Memy_Obje
* 
add
(Memy_Obje* 

);

45 
	#SASS_MEMORY_NEW
(
mgr
, 
Css
, ...) \

46 (
ic_
<
Css
*>(
mgr
.
	`add
(
	`w
 (mgr.
	`lo
((Css))
	`Css
(
__VA_ARGS__
)))) \

47 

	)

	@node_modules/node-sass/src/libsass/src/node.cpp

1 
	~"ss.h
"

2 
	~<ve
>

4 
	~"node.h
"

5 
	~"cڋxt.h
"

6 
	~"rr.h
"

8 
mea
 
	gSass
 {

11 
Node
 
	gNode
::
Comb
(cڡ 
Comex_Se
::
Comb
& 
comb
) {

12 
NodeDequeP
 
nu
;

13  
Node
(
COMBINATOR
, 
comb
, 
NULL
 , 
nu
 );

17 
Node
 
	gNode
::
Se
(
Comex_Se
* 
pSe
, 
Cڋxt
& 
x
) {

18 
NodeDequeP
 
	gnu
;

20 
Comex_Se
* 
	gpSd
 = 
pSe
->
e
(
x
);

21 
	gpSd
->

(
NULL
);

22 
	gpSd
->
comb
(
Comex_Se
::
ANCESTOR_OF
);

24 
Node
 
n
(
SELECTOR
, 
Comex_Se
::
ANCESTOR_OF
, 
pSd
, 
nu
 );

25 i(
	gpSe

	gn
.
	gg_le_ed
 = 
pSe
->
has_le_ed
();

26  
	gn
;

30 
Node
 
	gNode
::
Ci
() {

31 
NodeDequeP
 
pEmyCi
 = 
d
::
make_shed
<
NodeDeque
>();

32  
Node
(
COLLECTION
, 
Comex_Se
::
ANCESTOR_OF
, 
NULL
 , 
pEmyCi
);

36 
Node
 
	gNode
::
Ci
(cڡ 
NodeDeque
& 
vues
) {

37 
NodeDequeP
 
pShlowCݛdCi
 = 
d
::
make_shed
<
NodeDeque
>(
vues
);

38  
Node
(
COLLECTION
, 
Comex_Se
::
ANCESTOR_OF
, 
NULL
 , 
pShlowCݛdCi
);

42 
Node
 
	gNode
::
N
() {

43 
NodeDequeP
 
nu
;

44  
Node
(
NIL
, 
Comex_Se
::
ANCESTOR_OF
, 
NULL
 , 
nu
 );

48 
	gNode
::
Node
(cڡ 
TYPE
& 
ty
, 
Comex_Se
::
Comb
 
comb
, Comex_Se* 
pSe
, 
NodeDequeP
& 
pCi
)

49 : 
g_le_ed
(
l
), 
mTy
(
ty
), 
mComb
(
comb
), 
mpSe
(
pSe
), 
mpCi
(
pCi
)

50 { i(
	gpSe

	gg_le_ed
 = 
pSe
->
has_le_ed
(); }

53 
Node
 
	gNode
::
e
(
Cڋxt
& 
x
) const {

54 
NodeDequeP
 
pNewCi
 = 
d
::
make_shed
<
NodeDeque
>();

55 i(
	gmpCi
) {

56 
	gNodeDeque
::

 

 = 
mpCi
->
beg
(), 
	gEnd
 = mpCi->
d
(); 
	g
 !
End
; iter++) {

57 
	gNode
& 
	gtoCle
 = *

;

58 
	gpNewCi
->
push_back
(
toCle
.
e
(
x
));

62 
Node
 
n
(
mTy
, 
mComb
, 
mpSe
 ? mpSe->
e
(
x
: 
NULL
, 
pNewCi
);

63 
	gn
.
	gg_le_ed
 = 
g_le_ed
;

64  
	gn
;

68 
bo
 
	gNode
::
cڏs
(cڡ 
Node
& 
pْtlChd
, bo 
simeSeOrdDdt
) const {

69 
bo
 
	gfound
 = 
l
;

71 
	gNodeDeque
::

 

 = 
mpCi
->
beg
(), 
	gEnd
 = mpCi->
d
(); 
	g
 !
End
; iter++) {

72 
	gNode
& 
	gtoTe
 = *

;

74 i(
nodesEqu
(
toTe
, 
pْtlChd
, 
simeSeOrdDdt
)) {

75 
	gfound
 = 
ue
;

80  
	gfound
;

84 
bo
 
	gNode
::
ݔ
==(cڡ 
Node
& 
rhs
) const {

85  
nodesEqu
(*
this
, 
rhs
, 
ue
 );

89 
bo
 
nodesEqu
(cڡ 
Node
& 
lhs
, cڡ Node& 
rhs
, bo 
simeSeOrdDdt
) {

90 i(
	glhs
.
ty
(!
rhs
.type()) {

91  
l
;

94 i(
	glhs
.
isComb
()) {

96  
	glhs
.
comb
(=
rhs
.combinator();

98 } i(
	glhs
.
isN
()) {

100  
	gue
;

102 } i(
	glhs
.
isSe
()){

104  
s_equ
(*
lhs
.

(), *
rhs
.(), 
simeSeOrdDdt
);

106 } i(
	glhs
.
isCi
()) {

108 i(
	glhs
.
ci
()->
size
(!
rhs
.collection()->size()) {

109  
l
;

112 
	gNodeDeque
::

 
lhsIr
 = 
lhs
.
ci
()->
beg
(), 
	glhsIrEnd
 =hs.ci()->
d
(),

113 
	grhsIr
 = 
rhs
.
ci
()->
beg
(); 
	glhsIr
 !
lhsIrEnd
;hsIter++,hsIter++) {

115 i(!
nodesEqu
(*
lhsIr
, *
rhsIr
, 
simeSeOrdDdt
)) {

116  
	gl
;

121  
	gue
;

126 
	gthrow
 "Comparing unknownodeypes. Aewype wasrobablyddedndhis method wasn't implemented for it.";

130 
	gNode
::
us
(
Node
& 
rhs
) {

131 i(!
this
->
isCi
(|| !
rhs
.isCollection()) {

132 
throw
 "Bothhe currentodendhs must be collections.";

134 
	gthis
->
ci
()->

(
this
->ci()->
d
(), 
rhs
.ci()->
beg
(),hs.collection()->end());

137 #ifde
DEBUG


138 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, cڡ 
	gNode
& 
	gnode
) {

140 i(
	gnode
.
isComb
()) {

142 
	gnode
.
comb
()) {

143 
	gComex_Se
::
ANCESTOR_OF
: 
os
 << "\" \""; ;

144 
	gComex_Se
::
PARENT_OF
: 
os
 << "\">\""; ;

145 
	gComex_Se
::
PRECEDES
: 
os
 << "\"~\""; ;

146 
	gComex_Se
::
ADJACENT_TO
: 
os
 << "\"+\""; ;

147 
	gComex_Se
::
REFERENCE
: 
os
 << "\"/\""; ;

150 } i(
	gnode
.
isN
()) {

152 
	gos
 << "nil";

154 } i(
	gnode
.
isSe
()){

156 
	gos
 << 
	gnode
.

()->
hd
()->
to_rg
();

158 } i(
	gnode
.
isCi
()) {

160 
	gos
 << "[";

162 
	gNodeDeque
::

 

 = 
node
.
ci
()->
beg
(), 
	gBeg
 =ode.ci()->beg(), 
	gEnd
 =ode.ci()->
d
(); 
	g
 !
End
; iter++) {

163 i(
	g
 !
Beg
) {

164 
os
 << ", ";

167 
	gos
 << (*
	g
);

170 
	gos
 << "]";

174  
	gos
;

180 
Node
 
comexSeToNode
(
Comex_Se
* 
pToCvt
, 
Cڋxt
& 
x
) {

181 i(
	gpToCvt
 =
NULL
) {

182  
Node
::
N
();

184 
Node
 
	gnode
 = Node::
Ci
();

185 
	gnode
.
	gg_le_ed
 = 
pToCvt
->
has_le_ed
();

186 
bo
 
	ghas_lf
 = 
pToCvt
->
has_le_ed
();

189 i(
	gpToCvt
->
hd
(&&ToCvt->hd()->
has__f
()) {

190 
Comex_Se
* 
	g
 = 
pToCvt
->

();

191 i(
	g
菞->
has_le_ed
(
pToCvt
->has_line_feed());

192 
	gpToCvt
 = 

;

195 
	gpToCvt
) {

197 
bo
 
	gemy__f
 = 
pToCvt
->
hd
(&&ToCvt->hd()->
is_emy_n
();

199 i(
	gpToCvt
->
hd
(=
NULL
 || 
emy__f
) {

203 i(
pToCvt
->
hd
(!
NULL
 && !
emy__f
) {

204 
node
.
ci
()->
push_back
(
Node
::
Se
(
pToCvt
, 
x
));

205 i(
	ghas_lf

	gnode
.
ci
()->
back
().
	gg_le_ed
 = 
has_lf
;

206 
	ghas_lf
 = 
l
;

209 i(
	gpToCvt
->
comb
(!
Comex_Se
::
ANCESTOR_OF
) {

210 
node
.
ci
()->
push_back
(
Node
::
Comb
(
pToCvt
->
comb
()));

211 i(
	ghas_lf

	gnode
.
ci
()->
back
().
	gg_le_ed
 = 
has_lf
;

212 
	ghas_lf
 = 
l
;

215 i(
	gpToCvt
 && 
	gemy__f
 &&ToCvt->

()) {

219 
	gpToCvt
 = 
pToCvt
->

();

222  
	gnode
;

226 
Comex_Se
* 
nodeToComexSe
(cڡ 
Node
& 
toCvt
, 
Cڋxt
& 
x
) {

227 i(
	gtoCvt
.
isN
()) {

228  
	gNULL
;

232 i(!
	gtoCvt
.
isCi
()) {

233 
	gthrow
 "Theodeo converto Complex_Selector* must be collectionype oril.";

237 
	gNodeDeque
& 
	gchdNodes
 = *
toCvt
.
ci
();

239 
	gd
::
rg
 
noPh
("");

240 
Posi
 
noPosi
(-1, -1, -1);

241 
Comex_Se
* 
	gpF
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, 
PrS
("[NODE]"), Comex_Se::
ANCESTOR_OF
, 
NULL
, NULL);

243 
Comex_Se
* 
	gpCut
 = 
pF
;

245 i(
	gtoCvt
.
isSe
()
	gpF
->
has_le_ed
(
toCvt
.
g_le_ed
);

246 i(
	gtoCvt
.
isComb
()
	gpF
->
has_le_ed
(
toCvt
.
g_le_ed
);

248 
	gNodeDeque
::

 
chdIr
 = 
chdNodes
.
beg
(), 
	gchdIrEnd
 = chdNodes.
d
(); 
	gchdIr
 !
chdIrEnd
; childIter++) {

250 
	gNode
& 
	gchd
 = *
chdIr
;

252 i(
	gchd
.
isSe
()) {

253 
	gpCut
->

(
chd
.

()->
e
(
x
));

255 
	gpCut
 = 
pCut
->

();

256 } i(
	gchd
.
isComb
()) {

257 
	gpCut
->
comb
(
chd
.combinator());

258 i(
	gchd
.
	gg_le_ed

	gpCut
->
has_le_ed
(
chd
.
g_le_ed
);

261 i(
	gchdIr
+1 !
chdIrEnd
) {

262 
Node
& 
xtNode
 = *(
chdIr
+1);

263 i(
	gxtNode
.
isComb
()) {

264 
	gpCut
->

(
SASS_MEMORY_NEW
(
x
.
mem
, 
Comex_Se
, 
PrS
("[NODE]"), Comex_Se::
ANCESTOR_OF
, 
NULL
, NULL));

265 i(
	gxtNode
.
	gg_le_ed

	gpCut
->

()->
has_le_ed
(
xtNode
.
g_le_ed
);

266 
	gpCut
 = 
pCut
->

();

270 
	gthrow
 "Theodeo convert's children must be only combinators or selectors.";

275 
Compound_Se
* 
	gkeHd
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
PrS
("[NODE]"), 1);

276 
Pt_Se
* 
	gRef
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Pt_Se, 
PrS
("[NODE]"));

277 
	gkeHd
->
emts
().
push_back
(
Ref
);

278 i(
	gtoCvt
.
	gg_le_ed

	gpF
->
has_le_ed
(
toCvt
.
g_le_ed
);

280 
	gpF
->
hd
(
keHd
);

281  
	gpF
;

286 
Node
 
	gNode
::
iveTrim
(Node& 
qs
, 
Cڋxt
& 
x
) {

288 
	gd
::
ve
<
Node
*> 
s
;

289 
	gd
::
ve
<
Comex_Se
*> 
known
;

291 
	gNodeDeque
::
v_
 
qsIr
 = 
qs
.
ci
()->
rbeg
(),

292 
	gqsIrEnd
 = 
qs
.
ci
()->
nd
();

294 ; 
	gqsIr
 !
qsIrEnd
; ++seqsesIter)

296 
	gNode
& 
	gqs1
 = *
qsIr
;

297 if
	gqs1
.
isSe
() ) {

298 
Comex_Se
* 
	gl
 = 
qs1
.

();

299 
	gd
::
ve
<
Comex_Se
*>::

 

;

300 
bo
 
	gfound
 = 
l
;

301 
	g
 = 
known
.
beg
(); i!known.
d
(); ++it) {

302 i(**
	g
 =*
l
{ 
found
 = 
ue
; ; }

304 if!
	gfound
 ) {

305 
	gknown
.
push_back
(
qs1
.

());

306 
	gs
.
push_back
(&
qs1
);

309 
	gs
.
push_back
(&
qs1
);

313 
Node
 
	gsu
 = Node::
Ci
();

315 
size_t
 
	gi
 = 
s
.
size
(- 1; i !
d
::
rg
::
os
; --i) {

316 
	gsu
.
ci
()->
push_back
(*
s
[
i
]);

319  
	gsu
;

	@node_modules/node-sass/src/libsass/src/node.hpp

1 #ide
SASS_NODE_H


2 
	#SASS_NODE_H


	)

4 
	~<deque
>

5 
	~<memy
>

7 
	~"a.h
"

10 
mea
 
	gSass
 {

15 
ass
 
	gCڋxt
;

33 
ass
 
	gNode
;

34 
	gd
::
	tdeque
<
	tNode
> 
	tNodeDeque
;

35 
	gd
::
	tshed_r
<
	tNodeDeque
> 
	tNodeDequeP
;

37 as
	cNode
 {

38 
	gpublic
:

39 
	eTYPE
 {

40 
SELECTOR
,

41 
	gCOMBINATOR
,

42 
	gCOLLECTION
,

43 
	gNIL


46 
TYPE
 
ty
(cڡ {  
	gmTy
; }

47 
bo
 
isComb
(cڡ {  
	gmTy
 =
COMBINATOR
; }

48 
bo
 
isSe
(cڡ {  
	gmTy
 =
SELECTOR
; }

49 
bo
 
isCi
(cڡ {  
	gmTy
 =
COLLECTION
; }

50 
bo
 
isN
(cڡ {  
	gmTy
 =
NIL
; }

51 
bo
 
	gg_le_ed
;

53 
	gComex_Se
::
Comb
 
comb
(cڡ {  
mComb
; }

55 
Comex_Se
* 

({  
	gmpSe
; }

56 cڡ 
Comex_Se
* 

(cڡ {  
	gmpSe
; }

58 
NodeDequeP
 
ci
({  
	gmpCi
; }

59 cڡ 
NodeDequeP
 
ci
(cڡ {  
	gmpCi
; }

61 
Node
 
Comb
(cڡ 
Comex_Se
::
Comb
& 
comb
);

64 
Node
 
Se
(
Comex_Se
* 
pSe
, 
Cڋxt
& 
x
);

66 
Node
 
Ci
();

67 
Node
 
Ci
(cڡ 
NodeDeque
& 
vues
);

69 
Node
 
N
();

70 
Node
 
iveTrim
(Node& 
qs
, 
Cڋxt
& 
x
);

72 
Node
 
e
(
Cڋxt
& 
x
) const;

74 
bo
 
	gݔ
==(cڡ 
Node
& 
rhs
) const;

75 
le
 
bo
 
	gݔ
!=(cڡ 
Node
& 
rhs
cڡ {  !(*
this
 ==hs); }

89 
us
(
Node
& 
rhs
);

94 
bo
 
cڏs
(cڡ 
Node
& 
pْtlChd
, bo 
simeSeOrdDdt
) const;

96 
	give
:

100 
Node
(cڡ 
TYPE
& 
ty
, 
Comex_Se
::
Comb
 
comb
, Comex_Se* 
pSe
, 
NodeDequeP
& 
pCi
);

102 
TYPE
 
	gmTy
;

105 
	gComex_Se
::
Comb
 
mComb
;

106 
Comex_Se
* 
	gmpSe
;

107 
NodeDequeP
 
	gmpCi
;

110 #ifde
DEBUG


111 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, cڡ 
	gNode
& 
	gnode
);

113 
Node
 
comexSeToNode
(
Comex_Se
* 
pToCvt
, 
Cڋxt
& 
x
);

114 
Comex_Se
* 
nodeToComexSe
(cڡ 
Node
& 
toCvt
, 
Cڋxt
& 
x
);

116 
bo
 
nodesEqu
(cڡ 
Node
& 
e
, cڡ Node& 
two
, bo 
simeSeOrdDdt
);

	@node_modules/node-sass/src/libsass/src/operation.hpp

1 #ide
SASS_OPERATION_H


2 
	#SASS_OPERATION_H


	)

4 
	~"a_fwd_de.h
"

6 
mea
 
	gSass
 {

8 
	gme
<
tyme
 
	gT
>

9 as
	cOti
 {

10 
	gpublic
:

11 
vtu
 
T
 
ݔ
()(
AST_Node
* 
x
) = 0;

12 
	gvtu
 ~
Oti
() { }

14 
vtu
 
T
 
ݔ
()(
Block
* 
	gx
) = 0;

15 
vtu
 
T
 
ݔ
()(
Ruˣt
* 
	gx
) = 0;

16 
vtu
 
T
 
ݔ
()(
Prݣt
* 
	gx
) = 0;

17 
vtu
 
T
 
ݔ
()(
Bubb
* 
	gx
) = 0;

18 
vtu
 
T
 
ݔ
()(
Suts_Block
* 
	gx
) = 0;

19 
vtu
 
T
 
ݔ
()(
Med_Block
* 
	gx
) = 0;

20 
vtu
 
T
 
ݔ
()(
At_Ro_Block
* 
	gx
) = 0;

21 
vtu
 
T
 
ݔ
()(
Deive
* 
	gx
) = 0;

22 
vtu
 
T
 
ݔ
()(
Keyame_Ru
* 
	gx
) = 0;

23 
vtu
 
T
 
ݔ
()(
Dei
* 
	gx
) = 0;

24 
vtu
 
T
 
ݔ
()(
Assignmt
* 
	gx
) = 0;

25 
vtu
 
T
 
ݔ
()(
Impt
* 
	gx
) = 0;

26 
vtu
 
T
 
ݔ
()(
Impt_Stub
* 
	gx
) = 0;

27 
vtu
 
T
 
ݔ
()(
Wng
* 
	gx
) = 0;

28 
vtu
 
T
 
ݔ
()(
E
* 
	gx
) = 0;

29 
vtu
 
T
 
ݔ
()(
Debug
* 
	gx
) = 0;

30 
vtu
 
T
 
ݔ
()(
Commt
* 
	gx
) = 0;

31 
vtu
 
T
 
ݔ
()(
If
* 
	gx
) = 0;

32 
vtu
 
T
 
ݔ
()(
F
* 
	gx
) = 0;

33 
vtu
 
T
 
ݔ
()(
Each
* 
	gx
) = 0;

34 
vtu
 
T
 
ݔ
()(
Whe
* 
	gx
) = 0;

35 
vtu
 
T
 
ݔ
()(
Ru
* 
	gx
) = 0;

36 
vtu
 
T
 
ݔ
()(
Cڋ
* 
	gx
) = 0;

37 
vtu
 
T
 
ݔ
()(
Exnsi
* 
	gx
) = 0;

38 
vtu
 
T
 
ݔ
()(
Defi
* 
	gx
) = 0;

39 
vtu
 
T
 
ݔ
()(
Mix_Cl
* 
	gx
) = 0;

41 
vtu
 
T
 
ݔ
()(
Li
* 
	gx
) = 0;

42 
vtu
 
T
 
ݔ
()(
M
* 
	gx
) = 0;

43 
vtu
 
T
 
ݔ
()(
By_Exessi
* 
	gx
) = 0;

44 
vtu
 
T
 
ݔ
()(
Ury_Exessi
* 
	gx
) = 0;

45 
vtu
 
T
 
ݔ
()(
Funi_Cl
* 
	gx
) = 0;

46 
vtu
 
T
 
ݔ
()(
Funi_Cl_Schema
* 
	gx
) = 0;

47 
vtu
 
T
 
ݔ
()(
Cuom_Wng
* 
	gx
) = 0;

48 
vtu
 
T
 
ݔ
()(
Cuom_E
* 
	gx
) = 0;

49 
vtu
 
T
 
ݔ
()(
Vb
* 
	gx
) = 0;

50 
vtu
 
T
 
ݔ
()(
Textu
* 
	gx
) = 0;

51 
vtu
 
T
 
ݔ
()(
Numb
* 
	gx
) = 0;

52 
vtu
 
T
 
ݔ
()(
C
* 
	gx
) = 0;

53 
vtu
 
T
 
ݔ
()(
Boޗn
* 
	gx
) = 0;

54 
vtu
 
T
 
ݔ
()(
Sg_Schema
* 
	gx
) = 0;

55 
vtu
 
T
 
ݔ
()(
Sg_Qued
* 
	gx
) = 0;

56 
vtu
 
T
 
ݔ
()(
Sg_Cڡt
* 
	gx
) = 0;

57 
vtu
 
T
 
ݔ
()(
Suts_Cdi
* 
	gx
) = 0;

58 
vtu
 
T
 
ݔ
()(
Suts_Ot
* 
	gx
) = 0;

59 
vtu
 
T
 
ݔ
()(
Suts_Negi
* 
	gx
) = 0;

60 
vtu
 
T
 
ݔ
()(
Suts_Dei
* 
	gx
) = 0;

61 
vtu
 
T
 
ݔ
()(
Suts_Ipީi
* 
	gx
) = 0;

62 
vtu
 
T
 
ݔ
()(
Med_Quy
* 
	gx
) = 0;

63 
vtu
 
T
 
ݔ
()(
Med_Quy_Exessi
* 
	gx
) = 0;

64 
vtu
 
T
 
ݔ
()(
At_Ro_Quy
* 
	gx
) = 0;

65 
vtu
 
T
 
ݔ
()(
Nu
* 
	gx
) = 0;

66 
vtu
 
T
 
ݔ
()(
Pt_Se
* 
	gx
) = 0;

68 
vtu
 
T
 
ݔ
()(
Pam
* 
	gx
) = 0;

69 
vtu
 
T
 
ݔ
()(
Pams
* 
	gx
) = 0;

70 
vtu
 
T
 
ݔ
()(
Argumt
* 
	gx
) = 0;

71 
vtu
 
T
 
ݔ
()(
Argumts
* 
	gx
) = 0;

73 
vtu
 
T
 
ݔ
()(
Se_Schema
* 
	gx
) = 0;

74 
vtu
 
T
 
ݔ
()(
Se_Phd
* 
	gx
) = 0;

75 
vtu
 
T
 
ݔ
()(
Ty_Se
* 
	gx
) = 0;

76 
vtu
 
T
 
ݔ
()(
Se_Quifr
* 
	gx
) = 0;

77 
vtu
 
T
 
ݔ
()(
Aribu_Se
* 
	gx
) = 0;

78 
vtu
 
T
 
ݔ
()(
Pudo_Se
* 
	gx
) = 0;

79 
vtu
 
T
 
ݔ
()(
Wed_Se
* 
	gx
) = 0;

80 
vtu
 
T
 
ݔ
()(
Compound_Se
* 
	gx
) = 0;

81 
vtu
 
T
 
ݔ
()(
Comex_Se
* 
	gx
) = 0;

82 
vtu
 
T
 
ݔ
()(
Se_Li
* 
	gx
) = 0;

84 
	gme
 <
tyme
 
	gU
>

85 
T
 
back
(
U
 
x
) {  T(); }

88 
	gme
 <
tyme
 
	gT
,ym
	gD
>

89 
ass
 
	gOti_CRTP
 : 
public
 
Oti
<
T
> {

90 
public
:

91 
D
& 
im
({  
ic_
<D&>(*
this
); }

92 
	gpublic
:

93 
T
 
ݔ
()(
AST_Node
* 
x
{  
ic_
<
D
*>(
this
)->
back
(x); }

95 
T
 
ݔ
()(
Block
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

96 
T
 
ݔ
()(
Ruˣt
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

97 
T
 
ݔ
()(
Prݣt
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

98 
T
 
ݔ
()(
Bubb
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

99 
T
 
ݔ
()(
Suts_Block
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

100 
T
 
ݔ
()(
Med_Block
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

101 
T
 
ݔ
()(
At_Ro_Block
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

102 
T
 
ݔ
()(
Deive
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

103 
T
 
ݔ
()(
Keyame_Ru
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

104 
T
 
ݔ
()(
Dei
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

105 
T
 
ݔ
()(
Assignmt
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

106 
T
 
ݔ
()(
Impt
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

107 
T
 
ݔ
()(
Impt_Stub
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

108 
T
 
ݔ
()(
Wng
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

109 
T
 
ݔ
()(
E
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

110 
T
 
ݔ
()(
Debug
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

111 
T
 
ݔ
()(
Commt
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

112 
T
 
ݔ
()(
If
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

113 
T
 
ݔ
()(
F
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

114 
T
 
ݔ
()(
Each
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

115 
T
 
ݔ
()(
Whe
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

116 
T
 
ݔ
()(
Ru
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

117 
T
 
ݔ
()(
Cڋ
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

118 
T
 
ݔ
()(
Exnsi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

119 
T
 
ݔ
()(
Defi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

120 
T
 
ݔ
()(
Mix_Cl
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

122 
T
 
ݔ
()(
Li
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

123 
T
 
ݔ
()(
M
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

124 
T
 
ݔ
()(
By_Exessi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

125 
T
 
ݔ
()(
Ury_Exessi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

126 
T
 
ݔ
()(
Funi_Cl
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

127 
T
 
ݔ
()(
Funi_Cl_Schema
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

128 
T
 
ݔ
()(
Cuom_Wng
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

129 
T
 
ݔ
()(
Cuom_E
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

130 
T
 
ݔ
()(
Vb
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

131 
T
 
ݔ
()(
Textu
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

132 
T
 
ݔ
()(
Numb
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

133 
T
 
ݔ
()(
C
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

134 
T
 
ݔ
()(
Boޗn
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

135 
T
 
ݔ
()(
Sg_Schema
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

136 
T
 
ݔ
()(
Sg_Cڡt
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

137 
T
 
ݔ
()(
Sg_Qued
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

138 
T
 
ݔ
()(
Suts_Cdi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

139 
T
 
ݔ
()(
Suts_Ot
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

140 
T
 
ݔ
()(
Suts_Negi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

141 
T
 
ݔ
()(
Suts_Dei
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

142 
T
 
ݔ
()(
Suts_Ipީi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

143 
T
 
ݔ
()(
Med_Quy
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

144 
T
 
ݔ
()(
Med_Quy_Exessi
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

145 
T
 
ݔ
()(
At_Ro_Quy
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

146 
T
 
ݔ
()(
Nu
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

147 
T
 
ݔ
()(
Pt_Se
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

149 
T
 
ݔ
()(
Pam
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

150 
T
 
ݔ
()(
Pams
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

151 
T
 
ݔ
()(
Argumt
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

152 
T
 
ݔ
()(
Argumts
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

154 
T
 
ݔ
()(
Se_Schema
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

155 
T
 
ݔ
()(
Se_Phd
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

156 
T
 
ݔ
()(
Ty_Se
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

157 
T
 
ݔ
()(
Se_Quifr
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

158 
T
 
ݔ
()(
Aribu_Se
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

159 
T
 
ݔ
()(
Pudo_Se
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

160 
T
 
ݔ
()(
Wed_Se
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

161 
T
 
ݔ
()(
Compound_Se
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

162 
T
 
ݔ
()(
Comex_Se
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

163 
T
 
ݔ
()(
Se_Li
* 
	gx
{  
	gic_
<
	gD
*>(
	gthis
)->
back
(
x
); }

165 
	gme
 <
tyme
 
	gU
>

166 
T
 
back
(
U
 
x
) {  T(); }

	@node_modules/node-sass/src/libsass/src/output.cpp

1 
	~"ss.h
"

2 
	~"a.h
"

3 
	~"ouut.h
"

5 
mea
 
	gSass
 {

7 
	gOuut
::
Ouut
(
Sass_Ouut_Ois
& 
t
)

8 : 
Ine
(
Emr
(
t
)),

9 
cht
(""),

10 
t_nodes
(0)

13 
	gOuut
::~
Ouut
() { }

15 
Ouut
::
back_im
(
AST_Node
* 
n
)

17  
n
->
rfm
(
this
);

20 
	gOuut
::
ݔ
()(
Numb
* 
n
)

23 
d
::
rg
 
s
 = 
n
->
to_rg
(
t
);

26 i(!
	gn
->
is_vid_css_un
()) {

27 
throw
 
	gExi
::
InvidVue
(*
n
);

30 
nd_tok
(
s
, 
n
);

33 
	gOuut
::
ݔ
()(
Impt
* 
imp
)

35 
t_nodes
.
push_back
(
imp
);

38 
	gOuut
::
ݔ
()(
M
* 
m
)

40 
d
::
rg
 
dbg
(
m
->
to_rg
(
t
));

41 
r
(
dbg
 + " i'vid CSS vue.", 
m
->
pe
());

44 
OuutBufr
 
	gOuut
::
g_bufr
()

47 
Emr
 
emr
(
t
);

48 
Ine
 
e
(
emr
);

50 
size_t
 
	gsize_nodes
 = 
t_nodes
.
size
();

51 
size_t
 
	gi
 = 0; i < 
	gsize_nodes
; i++) {

52 
	gt_nodes
[
i
]->
rfm
(&
e
);

53 
	ge
.
nd_mdy_leed
();

58 
	ge
.
fize
(
wbuf
.
bufr
.
size
() == 0);

60 
d_ouut
(
e
.
ouut
());

62 i(!
ds_wh
(
wbuf
.
bufr
, 
t
.
leed
)) {

64 i(!
	gwbuf
.
	gbufr
.
emy
()
nd_rg
(
t
.
leed
);

68 cڡ & 
	gchr
 : 
wbuf
.
bufr
) {

71 i(
ic_
<>(
chr
) < 128) ;

73 i(
ouut_y
(!
COMPRESSED
)

74 
cht
 = "@charset \"UTF-8\";"

75 + 
d
::
rg
(
t
.
leed
);

76 
	gcht
 = "\xEF\xBB\xBF";

82 i(!
	gcht
.
emy
()
d_rg
(
cht
);

84  
	gwbuf
;

88 
	gOuut
::
ݔ
()(
Commt
* 
c
)

90 
d
::
rg
 
txt
 = 
c
->
xt
()->
to_rg
(
t
);

92 
bo
 
	gimp܏
 = 
c
->
is_imp܏
();

93 i(
ouut_y
(!
COMPRESSED
 || 
imp܏
) {

94 i(
bufr
().
size
() == 0) {

95 
t_nodes
.
push_back
(
c
);

97 
	g_commt
 = 
ue
;

98 
nd_dti
();

99 
	gc
->
xt
()->
rfm
(
this
);

100 
	g_commt
 = 
l
;

101 i(
	gdti
 == 0) {

102 
nd_mdy_leed
();

104 
nd_tiڮ_leed
();

110 
	gOuut
::
ݔ
()(
Ruˣt
* 
r
)

112 
Se
* 
s
 = 
r
->

();

113 
Block
* 
	gb
 = 
r
->
block
();

114 
bo
 
	gdes
 = 
l
;

117 i(!
	gUt
::
isPrb
(
r
, 
ouut_y
())) {

118 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

119 
Smt
* 
	gm
 = (*
b
)[
i
];

120 i(
	gdymic_
<
	gHas_Block
*>(
	gm
)) {

121 
	gm
->
rfm
(
this
);

127 i(
	gb
->
has_n_hoiab
()) {

128 
	gdes
 = 
ue
;

129 i(
ouut_y
(=
NESTED

dti
 +
r
->
bs
();

130 i(
	gt
.
	gsour_commts
) {

131 
	gd
::
rgam
 
ss
;

132 
nd_dti
();

133 
	gss
 << "/*" << 
	gr
->
pe
().
	gle
 + 1 << ", " <<->pe().
	gth
 << " */";

134 
nd_rg
(
ss
.
r
());

135 
nd_tiڮ_leed
();

137 
	gs
->
rfm
(
this
);

138 
nd_sce_ݒ
(
b
);

139 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

140 
Smt
* 
	gm
 = (*
b
)[
i
];

141 
bo
 
	gbPrtExessi
 = 
ue
;

143 i(
tyid
(*
m
=tyid(
Dei
)) {

144 
Dei
* 
dec
 = 
ic_
<Dei*>(
m
);

145 i(
	gdec
->
vue
()->
ce_ty
(=
Exessi
::
STRING
) {

146 
Sg_Cڡt
* 
vCڡ
 = 
ic_
<Sg_Cڡt*>(
dec
->
vue
());

147 
	gd
::
rg
 
v
(
vCڡ
->
vue
());

148 iut
	gqr
 = 
dymic_
<
Sg_Qued
*>(
vCڡ
)) {

149 i(!
qr
->
que_mk
(&& 
v
.
emy
()) {

150 
bPrtExessi
 = 
l
;

154 i(
	gdec
->
vue
()->
ce_ty
(=
Exessi
::
LIST
) {

155 
Li
* 
li
 = 
ic_
<Li*>(
dec
->
vue
());

156 
bo
 
	gl_visib
 = 
ue
;

157 
size_t
 
	gli_i
 = 0, 
	gli_L
 = 
li
->
ngth
();ist_i <ist_L; ++list_i) {

158 
Exessi
* 
	gem
 = (*
li
)[
li_i
];

159 i(!
	gem
->
is_visib
()
	gl_visib
 = 
l
;

161 i(
	gl_visib

	gbPrtExessi
 = 
l
;

165 i(!
	gm
->
is_hoiab
(&& 
	gbPrtExessi
) {

166 
	gm
->
rfm
(
this
);

169 i(
ouut_y
(=
NESTED

dti
 -
r
->
bs
();

170 
nd_sce_or
(
b
);

173 i(
	gb
->
has_hoiab
()) {

174 i(
	gdes
++
	gdti
;

175 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

176 
Smt
* 
	gm
 = (*
b
)[
i
];

177 i(
	gm
->
is_hoiab
()) {

178 
	gm
->
rfm
(
this
);

181 i(
	gdes
--
	gdti
;

185 
	gOuut
::
ݔ
()(
Keyame_Ru
* 
r
)

187 
Block
* 
b
 = 
r
->
block
();

188 
Se
* 
	gv
 = 
r
->

();

190 i(
	gv
) {

191 
	gv
->
rfm
(
this
);

194 i(!
	gb
) {

195 
nd_c_t
();

199 
nd_sce_ݒ
();

200 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

201 
Smt
* 
	gm
 = (*
b
)[
i
];

202 i(!
	gm
->
is_hoiab
()) {

203 
	gm
->
rfm
(
this
);

204 i(
	gi
 < 
	gL
 - 1
nd_ecl_leed
();

208 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

209 
Smt
* 
	gm
 = (*
b
)[
i
];

210 i(
	gm
->
is_hoiab
()) {

211 
	gm
->
rfm
(
this
);

215 
nd_sce_or
();

218 
	gOuut
::
ݔ
()(
Suts_Block
* 
f
)

220 i(
f
->
is_visib
()) ;

222 
Suts_Cdi
* 
	gc
 = 
f
->
cdi
();

223 
Block
* 
	gb
 = 
f
->
block
();

226 i(!
	gUt
::
isPrb
(
f
, 
ouut_y
())) {

227 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

228 
Smt
* 
	gm
 = (*
b
)[
i
];

229 i(
	gdymic_
<
	gHas_Block
*>(
	gm
)) {

230 
	gm
->
rfm
(
this
);

236 i(
ouut_y
(=
NESTED

dti
 +
f
->
bs
();

237 
nd_dti
();

238 
nd_tok
("@suts", 
f
);

239 
nd_mdy_a
();

240 
	gc
->
rfm
(
this
);

241 
nd_sce_ݒ
();

243 i(
	gb
->
has_n_hoiab
()) {

245 
nd_sce_ݒ
();

247 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

248 
Smt
* 
	gm
 = (*
b
)[
i
];

249 i(!
	gm
->
is_hoiab
()) {

250 
	gm
->
rfm
(
this
);

254 
nd_sce_or
();

256 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

257 
Smt
* 
	gm
 = (*
b
)[
i
];

258 i(
	gm
->
is_hoiab
()) {

259 
	gm
->
rfm
(
this
);

265 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

266 
Smt
* 
	gm
 = (*
b
)[
i
];

267 
	gm
->
rfm
(
this
);

268 i(
	gi
 < 
	gL
 - 1
nd_ecl_leed
();

272 i(
ouut_y
(=
NESTED

dti
 -
f
->
bs
();

274 
nd_sce_or
();

278 
	gOuut
::
ݔ
()(
Med_Block
* 
m
)

280 i(
m
->
is_visib
()) ;

282 
Li
* 
	gq
 = 
m
->
med_qus
();

283 
Block
* 
	gb
 = 
m
->
block
();

286 i(!
	gUt
::
isPrb
(
m
, 
ouut_y
())) {

287 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

288 
Smt
* 
	gm
 = (*
b
)[
i
];

289 i(
	gdymic_
<
	gHas_Block
*>(
	gm
)) {

290 
	gm
->
rfm
(
this
);

295 i(
ouut_y
(=
NESTED

dti
 +
m
->
bs
();

296 
nd_dti
();

297 
nd_tok
("@med", 
m
);

298 
nd_mdy_a
();

299 
	g_med_block
 = 
ue
;

300 
	gq
->
rfm
(
this
);

301 
	g_med_block
 = 
l
;

302 
nd_sce_ݒ
();

304 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

305 i((*
	gb
)[
i
](*b)[i]->
rfm
(
this
);

306 i(
	gi
 < 
	gL
 - 1
nd_ecl_leed
();

309 i(
ouut_y
(=
NESTED

dti
 -
m
->
bs
();

310 
nd_sce_or
();

313 
	gOuut
::
ݔ
()(
Deive
* 
a
)

315 
d
::
rg
 
kwd
 = 
a
->
keywd
();

316 
Se
* 
	gs
 = 
a
->

();

317 
Exessi
* 
	gv
 = 
a
->
vue
();

318 
Block
* 
	gb
 = 
a
->
block
();

320 
nd_dti
();

321 
nd_tok
(
kwd
, 
a
);

322 i(
	gs
) {

323 
nd_mdy_a
();

324 
	g_wed
 = 
ue
;

325 
	gs
->
rfm
(
this
);

326 
	g_wed
 = 
l
;

328 i(
	gv
) {

329 
nd_mdy_a
();

331 
nd_tok
(
v
->
to_rg
( ), v);

333 i(!
	gb
) {

334 
nd_dim
();

338 i(
	gb
->
is_visib
(|| b->
ngth
() == 0) {

339 
nd_tiڮ_a
();

340  
nd_rg
("{}");

343 
nd_sce_ݒ
();

345 
bo
 
	gfm
 = 
kwd
 != "@font-face";;

347 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

348 
Smt
* 
	gm
 = (*
b
)[
i
];

349 i(!
	gm
->
is_hoiab
()) {

350 
	gm
->
rfm
(
this
);

351 i(
	gi
 < 
	gL
 - 1 && 
	gfm

nd_ecl_leed
();

355 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

356 
Smt
* 
	gm
 = (*
b
)[
i
];

357 i(
	gm
->
is_hoiab
()) {

358 
	gm
->
rfm
(
this
);

359 i(
	gi
 < 
	gL
 - 1 && 
	gfm

nd_ecl_leed
();

363 
nd_sce_or
();

366 
	gOuut
::
ݔ
()(
Sg_Qued
* 
s
)

368 i(
s
->
que_mk
()) {

369 
nd_tok
(
que
(
s
->
vue
(), s->
que_mk
()), s);

370 } i(!
	g_commt
) {

371 
nd_tok
(
rg_to_ouut
(
s
->
vue
()), s);

373 
nd_tok
(
s
->
vue
(), s);

377 
	gOuut
::
ݔ
()(
Sg_Cڡt
* 
s
)

379 
d
::
rg
 
vue
(
s
->value());

380 i(
	gs
->
n_comess_whea
(&& 
ouut_y
(=
COMPRESSED
) {

381 
vue
.
a
(
d
::
move_if
(vue.
beg
(), vue.
d
(), ::
isa
), value.end());

383 i(!
	g_commt
) {

384 
nd_tok
(
rg_to_ouut
(
vue
), 
s
);

386 
nd_tok
(
vue
, 
s
);

	@node_modules/node-sass/src/libsass/src/output.hpp

1 #ide
SASS_OUTPUT_H


2 
	#SASS_OUTPUT_H


	)

4 
	~<rg
>

5 
	~<ve
>

7 
	~"ut.h
"

8 
	~"e.h
"

9 
	~"ݔi.h
"

11 
mea
 
	gSass
 {

12 
ass
 
	gCڋxt
;

15 
le
 
bo
 
ds_wh
(
d
::
rg
 cڡ & 
vue
, std::rg cڡ & 
dg
)

17 i(
dg
.
size
(> 
vue
.size() 
l
;

18  
	gd
::
equ
(
dg
.
rbeg
(),ndg.
nd
(), 
vue
.rbegin());

21 as
	cOuut
 : 
public
 
Ine
 {

22 
eed
:

23 
usg
 
Ine
::
ݔ
();

25 
	gpublic
:

26 
Ouut
(
Sass_Ouut_Ois
& 
t
);

27 
	gvtu
 ~
Ouut
();

29 
	geed
:

30 
d
::
rg
 
cht
;

31 
	gd
::
ve
<
AST_Node
*> 
t_nodes
;

33 
	gpublic
:

34 
OuutBufr
 
g_bufr
();

36 
vtu
 
ݔ
()(
	gM
*);

37 
vtu
 
ݔ
()(
	gRuˣt
*);

39 
vtu
 
ݔ
()(
	gSuts_Block
*);

40 
vtu
 
ݔ
()(
	gMed_Block
*);

41 
vtu
 
ݔ
()(
	gDeive
*);

42 
vtu
 
ݔ
()(
	gKeyame_Ru
*);

43 
vtu
 
ݔ
()(
	gImpt
*);

44 
vtu
 
ݔ
()(
	gCommt
*);

45 
vtu
 
ݔ
()(
	gNumb
*);

46 
vtu
 
ݔ
()(
	gSg_Qued
*);

47 
vtu
 
ݔ
()(
	gSg_Cڡt
*);

49 
back_im
(
AST_Node
* 
n
);

	@node_modules/node-sass/src/libsass/src/parser.cpp

1 
	~"ss.h
"

2 
	~<cdlib
>

3 
	~<ioam
>

4 
	~<ve
>

5 
	~"rr.h
"

6 
	~"fe.h
"

7 
	~"e.h
"

8 
	~"cڡts.h
"

9 
	~"ut.h
"

10 
	~"ex.h
"

11 
	~"c_ms.h
"

12 
	~"ss/funis.h
"

13 
	~"r_hdlg.h
"

15 
	~<tyfo
>

16 
	~<tue
>

18 
mea
 
	gSass
 {

19 
usg
 
mea
 
	gCڡts
;

20 
usg
 
mea
 
	gPx
;

22 
Pr
 
	gPr
::
om_c_r
(cڡ * 
beg
, 
Cڋxt
& 
x
, 
PrS
 
pe
, cڡ * 
sour
)

24 
Pr
 
p
(
x
, 
pe
);

25 
	gp
.
	gsour
 = 
sour
 ? sour : 
beg
;

26 
	gp
.
	gposi
 = 
beg
 ? beg : 
p
.
sour
;

27 
	gp
.
	gd
 = 
p
.
posi
 + 

(p.position);

28 
Block
* 
	gro
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
pe
);

29 
	gp
.
	gblock_ack
.
push_back
(
ro
);

30 
	gro
->
is_ro
(
ue
);

31  
	gp
;

34 
Pr
 
	gPr
::
om_c_r
(cڡ * 
beg
, cڡ * 
d
, 
Cڋxt
& 
x
, 
PrS
 
pe
, cڡ * 
sour
)

36 
Pr
 
p
(
x
, 
pe
);

37 
	gp
.
	gsour
 = 
sour
 ? sour : 
beg
;

38 
	gp
.
	gposi
 = 
beg
 ? beg : 
p
.
sour
;

39 
	gp
.
	gd
 = 
d
 ?nd : 
p
.
posi
 + 

(p.position);

40 
Block
* 
	gro
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
pe
);

41 
	gp
.
	gblock_ack
.
push_back
(
ro
);

42 
	gro
->
is_ro
(
ue
);

43  
	gp
;

46 
Se_Li
* 
	gPr
::
r_
(cڡ * 
beg
, 
Cڋxt
& 
x
, 
PrS
 
pe
, cڡ * 
sour
)

48 
Pr
 
	gp
 = Pr::
om_c_r
(
beg
, 
x
, 
pe
, 
sour
);

51  
	gp
.
r__li
(
l
);

54 
bo
 
	gPr
::
ek_wle
(cڡ * 
t
)

56  
ek_leed
(
t
 ? s : 
posi
)

57 && ! 
ek_css
<
exaly
<'{'>>(
t
);

60 
Pr
 
	gPr
::
om_tok
(
Tok
 
t
, 
Cڋxt
& 
x
, 
PrS
 
pe
, cڡ * 
sour
)

62 
Pr
 
p
(
x
, 
pe
);

63 
	gp
.
	gsour
 = 
sour
 ? sour : 
t
.
beg
;

64 
	gp
.
	gposi
 = 
t
.
beg
 ?.beg : 
p
.
sour
;

65 
	gp
.
	gd
 = 
t
.
d
 ?.d : 
p
.
posi
 + 

(p.position);

66 
Block
* 
	gro
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
pe
);

67 
	gp
.
	gblock_ack
.
push_back
(
ro
);

68 
	gro
->
is_ro
(
ue
);

69  
	gp
;

73 
Block
* 
	gPr
::
r
()

75 
bo
 
is_ro
 = 
l
;

76 
Block
* 
	gro
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
pe
, 0, 
ue
);

77 
ad_bom
();

80 i(
	gx
.
	gsours
.
size
() == 1) {

81 
is_ro
 = 
ue
;

82 
	gx
.
y_cuom_hds
(
ro
, 
th
, 
pe
);

85 
	gblock_ack
.
push_back
(
ro
);

86  
r_block_nodes
(
is_ro
);

87 
	gblock_ack
.
p_back
();

90 
	gro
->
upde_pe
(
pe
);

92 i(
	gposi
 !
d
) {

93 
css_r
("Invalid CSS", "fter ", ":xpected selector ort-rule, was ");

96  
	gro
;

103 
Block
* 
	gPr
::
r_css_block
(
bo
 
is_ro
)

110 i(!
x_css
 < 
exaly
<'{'> >()) {

111 
css_r
("Invalid CSS", "fter ", ":xpected \"{\", was ");

114 
Block
* 
	gblock
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Block, 
pe
, 0, 
is_ro
);

115 
	gblock_ack
.
push_back
(
block
);

117 i(!
r_block_nodes
()
css_r
("Invalid CSS", "fter ", ":xpected \"}\", was ");;

119 i(!
	gx_css
 < 
	gexaly
<'}'> >()) {

120 
css_r
("Invalid CSS", "fter ", ":xpected \"}\", was ");

124 
	gblock
->
upde_pe
(
pe
);

129 
	gblock_ack
.
p_back
();

131  
	gblock
;

137 
Block
* 
	gPr
::
r_block
(
bo
 
is_ro
)

139 
LOCAL_FLAG
(
__ro
, 
is_ro
);

140  
r_css_block
(
is_ro
);

145 
bo
 
	gPr
::
r_block_nodes
(bo 
is_ro
)

149 
posi
 < 
d
) {

152 
r_block_commts
();

153 
	gx
 < 
	gcss_whea
 >();

155 i(
	gx
 < 
	gexaly
<';'> >()) ;

156 i(
	gek
 < 
	gd_of_fe
 >() 
	gue
;

157 i(
	gek
 < 
	gexaly
<'}'> >() 
	gue
;

159 i(
r_block_node
(
is_ro
)) ;

161 
r_block_commts
();

163 i(
	gx_css
 < 
	gexaly
<';'> >()) ;

164 i(
	gek_css
 < 
	gd_of_fe
 >() 
	gue
;

165 i(
	gek_css
 < 
	gexaly
<'}'> >() 
	gue
;

168  
	gl
;

171  
	gue
;

176 
bo
 
	gPr
::
r_block_node
(bo 
is_ro
) {

178 
Block
* 
block
 = 
block_ack
.
back
();

180 
r_block_commts
();

184 
	gx
 < 
	gcss_whea
 >();

186 
Lookahd
 
	glookahd_su
;

191 i(
	gx
 < 
	gvb
 >(
	gue
){ (*
	gblock
<< 
r_assignmt
(); }

192 i(
	gx
 < 
	gkwd_r
 >(
	gue
){ (*
	gblock
<< 
r_r
(); }

193 i(
	gx
 < 
	gkwd_dbg
 >(
	gue
){ (*
	gblock
<< 
r_debug
(); }

194 i(
	gx
 < 
	gkwd_wn
 >(
	gue
){ (*
	gblock
<< 
r_wng
(); }

195 i(
	gx
 < 
	gkwd_if_deive
 >(
	gue
){ (*
	gblock
<< 
r_if_deive
(); }

196 i(
	gx
 < 
	gkwd_f_deive
 >(
	gue
){ (*
	gblock
<< 
r_f_deive
(); }

197 i(
	gx
 < 
	gkwd_ch_deive
 >(
	gue
){ (*
	gblock
<< 
r_ch_deive
(); }

198 i(
	gx
 < 
	gkwd_whe_deive
 >(
	gue
){ (*
	gblock
<< 
r_whe_deive
(); }

199 i(
	gx
 < 
	gkwd_tu_deive
 >(
	gue
){ (*
	gblock
<< 
r_tu_deive
(); }

202 i(
	gack
.
back
(=
Sce
::
Funi
) {

203 
r
("Funiڠly cڏ vb deiڠd cڌ deives.", 
pe
);

207 i(
	gx
 < 
	gkwd_impt
 >(
	gue
)) {

208 
Sce
 
	g
 = 
ack
.
emy
(? Sce::
Rus
 : sck.
back
();

209 i(
	g
 !
Sce
::
Funi
 && 

 !Sce::
Ro
 &&!Sce::
Rus
 &&!Sce::
Med
) {

210 i(! 
ek_css
< 
uri_efix
 >(
posi
)) {

211 
r
("Imp܈deivemay bud wh cڌ deive mixs.", 
pe
);

214 
Impt
* 
	gimp
 = 
r_impt
();

216 i(!
	gimp
->
us
().
emy
()(*
	gblock
) << imp;

218 
size_t
 
	gi
 = 0, 
	gS
 = 
imp
->
cs
().
size
(); i < S; ++i) {

219 (*
	gblock
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Impt_Stub
, 
pe
, 
imp
->
cs
()[
i
]);

223 i(
	gx
 < 
	gkwd_exnd
 >(
	gue
)) {

224 i(
	gblock
->
is_ro
()) {

225 
r
("Exnd deivemay oy bud whus.", 
pe
);

228 
Lookahd
 
	glookahd
 = 
lookahd_f_ude
(
posi
);

229 i(!
	glookahd
.
	gfound

css_r
("Invalid CSS", "fter ", ":xpected selector, was ");

230 
Se
* 
	grg
;

231 i(
	glookahd
.
	ghas_ުts

	grg
 = 
r__schema
(
lookahd
.
found
);

232 
	grg
 = 
r__li
(
ue
);

233 (*
	gblock
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Exnsi
, 
pe
, 
rg
);

237 i(!(
	glookahd_su
 = 
lookahd_f_
(
posi
)).
r
)

238 { (*
block
<< 
r_ruˣt
(
lookahd_su
, 
is_ro
); }

241 i(
	gx
 < 
	gkwd_med
 >(
	gue
){ (*
	gblock
<< 
r_med_block
(); }

242 i(
	gx
 < 
	gkwd__ro
 >(
	gue
){ (*
	gblock
<< 
r__ro_block
(); }

243 i(
	gx
 < 
	gkwd_ude_deive
 >(
	gue
){ (*
	gblock
<< 
r_ude_deive
(); }

244 i(
	gx
 < 
	gkwd_cڋ_deive
 >(
	gue
){ (*
	gblock
<< 
r_cڋ_deive
(); }

245 i(
	gx
 < 
	gkwd_suts_deive
 >(
	gue
){ (*
	gblock
<< 
r_suts_deive
(); }

246 i(
	gx
 < 
	gkwd_mix
 >(
	gue
){ (*
	gblock
<< 
r_defi
(
Defi
::
MIXIN
); }

247 i(
	gx
 < 
	gkwd_funi
 >(
	gue
){ (*
	gblock
<< 
r_defi
(
Defi
::
FUNCTION
); }

250 i(
	gx
< 
	gkwd_cht_deive
 >(
	gue
){ 
r_cht_deive
(); }

253 i(
	gx
< 
	g_ecl_deive
 >(
	gue
){ (*
	gblock
<< 
r_ecl_deive
(); }

254 i(
	gx
< 
	g_efixed_deive
 >(
	gue
){ (*
	gblock
<< 
r_efixed_deive
(); }

255 i(
	gx
< 
	g_keywd
 >(
	gue
){ (*
	gblock
<< 
r_deive
(); }

257 i(
	gblock
->
is_ro
()) {

258 
	gx
< 
	gcss_whea
 >();

259 i(
	gposi
 >
d
 
ue
;

260 
css_r
("Invalid CSS", "fter ", ":xpected 1 selector ort-rule, was ");

267 
Dei
* 
	gde
 = 
r_dei
();

268 
	gde
->
bs
(
dti
);

269 (*
	gblock
<< 
	gde
;

271 i(
	gek
< 
	gexaly
<'{'> >()) {

272 i(
	gde
->
is_dd
()++ 
	gdti
;

274 
	gack
.
push_back
(
Sce
::
Prݔts
);

275 (*
	gblock
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Prݣt
, 
pe
, 
de
->
ݔty
(), 
r_block
());

276 
	gack
.
p_back
();

277 i(
	gde
->
is_dd
()-- 
	gdti
;

281  
	gue
;

286 
Impt
* 
	gPr
::
r_impt
()

288 
Impt
* 
imp
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Impt, 
pe
);

289 
	gd
::
ve
<
d
::

<d::
rg
,
	gFuni_Cl
*>> 
	gto_impt
;

290 
bo
 
	gf
 = 
ue
;

292 
	gx
< 
	gblock_commt
 >());

293 i(
	gx
< 
	gqued_rg
 >()) {

294 
	gto_impt
.
push_back
(
d
::

<d::
rg
,
Funi_Cl
*>(d::rg(
xed
), 0));

296 i(
	gx
< 
	guri_efix
 >()) {

297 
Argumts
* 
	ggs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumts, 
pe
);

298 
Funi_Cl
* 
	gsu
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Funi_Cl, 
pe
, "u", 
gs
);

300 i(
	gx
< 
	gqued_rg
 >()) {

301 
Exessi
* 
	gthe_u
 = 
r_rg
();

302 *
	ggs
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
the_u
->
pe
(),he_url);

304 i(
Sg
* 
	gthe_u
 = 
r_u_funi_gumt
()) {

305 *
gs
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
the_u
->
pe
(),he_url);

307 i(
	gek
 < 
	gsk_ov_sces
 < 
	gexaly
 < '(' >,xaly < ')' > > >(
	gposi
)) {

308 
Exessi
* 
	gthe_u
 = 
r_li
();

309 *
	ggs
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
the_u
->
pe
(),he_url);

312 
r
("mfmed URL", 
pe
);

314 i(!
	gx
< 
	gexaly
<')'> >()
r
("URI imissg ')'", 
pe
);

315 
	gto_impt
.
push_back
(
d
::

<d::
rg
, 
Funi_Cl
*>("", 
su
));

318 i(
	gf

r
("@imp܈deivqueu oquedh", 
pe
);

319 
r
("exgnh u oquedh i@imp܈li", 
pe
);

321 
	gf
 = 
l
;

322 } 
	gx_css
< 
	gexaly
<','> >());

324 i(!
	gek_css
<
	gives
<
	gexaly
<';'>,
	gd_of_fe
>>()) {

325 
Li
* 
	gmed_qus
 = 
r_med_qus
();

326 
	gimp
->
med_qus
(media_queries);

329 aut
	gloti
 : 
to_impt
) {

330 i(
loti
.
cd
) {

331 
imp
->
us
().
push_back
(
loti
.
cd
);

332 } i(!
	gx
.
_imp܋rs
(
unque
(
loti
.
f
), 
th
, 
pe
, 
imp
)) {

333 
	gx
.
impt_u
(
imp
, 
loti
.
f
, 
th
);

337  
	gimp
;

340 
Defi
* 
	gPr
::
r_defi
(Defi::
Ty
 
which_ty
)

342 
Sce
 

 = 
ack
.
emy
(? Sce::
Rus
 : sck.
back
();

343 i(
	g
 !
Sce
::
Ro
 && 

 !Sce::
Rus
 &&!Sce::
Funi
) {

344 i(
which_ty
 =
Defi
::
FUNCTION
) {

345 
r
("Funiڠmay bdefed wh cڌ deive oth mixs.", 
pe
);

347 
r
("Mixmay bdefed wh cڌ deive oth mixs.", 
pe
);

351 
	gd
::
rg
 
which_r
(
xed
);

352 i(!
	gx
< 
	gidtifr
 >()
r
("vidam " + 
which_r
 + " defi", 
pe
);

353 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
xed
));

354 i(
	gwhich_ty
 =
Defi
::
FUNCTION
 && (
me
 == "and" ||ame == "or" ||ame == "not"))

355 { 
r
("Invid funiڂam\"" + 
me
 + "\".", 
pe
); }

356 
PrS
 
	gsour_posi_of_def
 = 
pe
;

357 
Pams
* 
	gms
 = 
r_ms
();

358 i(
	gwhich_ty
 =
Defi
::
MIXIN

ack
.
push_back
(
Sce
::
Mix
);

359 
	gack
.
push_back
(
Sce
::
Funi
);

360 
Block
* 
	gbody
 = 
r_block
();

361 
	gack
.
p_back
();

362 
Defi
* 
	gdef
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Defi, 
sour_posi_of_def
, 
me
, 
ms
, 
body
, 
which_ty
);

363  
	gdef
;

366 
Pams
* 
	gPr
::
r_ms
()

368 
d
::
rg
 
me
(
xed
);

369 
Posi
 
	gposi
 = 
a_tok
;

370 
Pams
* 
	gms
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Pams, 
pe
);

371 i(
	gx_css
< 
	gexaly
<'('> >()) {

373 i(!
	gek_css
< 
	gexaly
<')'> >()) {

374 d(*
	gms
<< 
r_m
();

375 
	gx_css
< 
	gexaly
<','> >());

377 i(!
	gx_css
< 
	gexaly
<')'> >()
r
("exed vb˂am.g. $x ')' f܁hmi f " + 
me
, 
posi
);

379  
	gms
;

382 
Pam
* 
	gPr
::
r_m
()

384 
x
< 
ives
 < 
as
, 
	gblock_commt
 > >());

385 
	gx
 < 
	gvb
 >();

386 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
xed
));

387 
PrS
 
	gpos
 = 
pe
;

388 
Exessi
* 
	gv
 = 0;

389 
bo
 
	gis_
 = 
l
;

390 
	gx
< 
	gives
 < 
	gas
, 
	gblock_commt
 > >());

391 i(
	gx
< 
	gexaly
<':'> >()) {

392 
	gx
< 
	gblock_commt
 >());

393 
	gv
 = 
r_a_li
();

394 
	gv
->
is_dayed
(
l
);

396 i(
	gx
< 
	gexaly
< 
	glsis
 > >()) {

397 
	gis_
 = 
ue
;

399 
Pam
* 
	gp
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Pam, 
pos
, 
me
, 
v
, 
is_
);

400  
	gp
;

403 
Argumts
* 
	gPr
::
r_gumts
()

405 
d
::
rg
 
me
(
xed
);

406 
Posi
 
	gposi
 = 
a_tok
;

407 
Argumts
* 
	ggs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumts, 
pe
);

408 i(
	gx_css
< 
	gexaly
<'('> >()) {

410 i(!
	gek_css
< 
	gexaly
<')'> >()) {

411 d(*
	ggs
<< 
r_gumt
();

412 
	gx_css
< 
	gexaly
<','> >());

414 i(!
	gx_css
< 
	gexaly
<')'> >()
r
("exed vb˂am.g. $x ')' f܁hmi f " + 
me
, 
posi
);

416  
	ggs
;

419 
Argumt
* 
	gPr
::
r_gumt
()

421 i(
ek_css
< 
qu
 < 
exaly
< 
hash_lb
 >, 
	gexaly
< 
	grb
 > > >()) {

422 
	gposi
 += 2;

423 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

426 
Argumt
* 
	gg
;

427 i(
	gek_css
< 
	gqu
 < 
	gvb
, 
	gtiڮ_css_commts
, 
	gexaly
<':'> > >()) {

428 
	gx_css
< 
	gvb
 >();

429 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
xed
));

430 
PrS
 
	gp
 = 
pe
;

431 
	gx_css
< 
	gexaly
<':'> >();

432 
Exessi
* 
	gv
 = 
r_a_li
();

433 
	gv
->
is_dayed
(
l
);

434 
	gg
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
p
, 
v
, 
me
);

437 
bo
 
	gis_gli
 = 
l
;

438 
bo
 
	gis_keywd
 = 
l
;

439 
Exessi
* 
	gv
 = 
r_a_li
();

440 
	gv
->
is_dayed
(
l
);

441 
Li
* 
	gl
 = 
dymic_
<Li*>(
v
);

442 i(
	gx_css
< 
	gexaly
< 
	glsis
 > >()) {

443 i(
	gv
->
ce_ty
(=
Exessi
::
MAP
 || (

444 (
l
 !
NULL
 &&->
t
(=
SASS_HASH
)

445 )
is_keywd
 = 
ue
;

446 
	gis_gli
 = 
ue
;

448 
	gg
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Argumt
, 
pe
, 
v
, "", 
is_gli
, 
is_keywd
);

450  
	gg
;

453 
Assignmt
* 
	gPr
::
r_assignmt
()

455 
d
::
rg
 
me
(
Ut
::
nmize_undsces
(
xed
));

456 
PrS
 
	gv_sour_posi
 = 
pe
;

457 i(!
	gx
< 
	gexaly
<':'> >()
r
("exed ':' " + 
me
 + " iassignmemt", 
pe
);

458 
Exessi
* 
	gv
;

459 
Lookahd
 
	glookahd
 = 
lookahd_f_vue
(
posi
);

460 i(
	glookahd
.
	ghas_ުts
 &&ookahd.
	gfound
) {

461 
	gv
 = 
r_vue_schema
(
lookahd
.
found
);

463 
	gv
 = 
r_li
();

465 
	gv
->
is_dayed
(
l
);

466 
bo
 
	gis_deu
 = 
l
;

467 
bo
 
	gis_glob
 = 
l
;

468 
	gek
< 
	gives
 < 
	gdeu_ag
, 
	gglob_ag
 > >()) {

469 i(
	gx
< 
	gdeu_ag
 >()
	gis_deu
 = 
ue
;

470 i(
	gx
< 
	gglob_ag
 >()
	gis_glob
 = 
ue
;

472 
Assignmt
* 
	gv
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Assignmt, 
v_sour_posi
, 
me
, 
v
, 
is_deu
, 
is_glob
);

473  
	gv
;

477 
Ruˣt
* 
	gPr
::
r_ruˣt
(
Lookahd
 
lookahd
, 
bo
 
is_ro
)

480 
	gx
 < 
	gtiڮ_css_whea
 >(
	gl
, 
	gue
);

482 
Ruˣt
* 
	gruˣt
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Ruˣt, 
pe
);

484 i(
	glookahd
.
	grb

	gruˣt
->

(
r__li
(
is_ro
));

485 
	gruˣt
->

(
r__schema
(
lookahd
.
found
));

487 
	gack
.
push_back
(
Sce
::
Rus
);

488 
	gruˣt
->
block
(
r_block
());

489 
	gack
.
p_back
();

491 
	gruˣt
->
upde_pe
(
pe
);

494 
	gruˣt
->
is_ro
(is_root);

496  
	gruˣt
;

502 
Se_Schema
* 
	gPr
::
r__schema
(cڡ * 
d_of_
)

505 
x
< 
tiڮ_as
 >();

506 cڡ * 
	gi
 = 
posi
;

508 
Sg_Schema
* 
	gschema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

510 
Se_Schema
* 
	g_schema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Schema, 
pe
, 
schema
);

511 
	g_schema
->
med_block
(
ϡ_med_block
);

514 
	gi
 < 
	gd_of_
) {

516 i(cڡ * 
	gp
 = 
fd_f__rv
< 
exaly
<
hash_lb
>, 
	gblock_commt
 >(
	gi
, 
	gd_of_
)) {

518 i(
	gi
 < 
	gp
(*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
i
, 
p
));

520 i(
	gek
 < 
	gqu
 < 
	gtiڮ_as
, 
	gexaly
<
	grb
> > >(
	gp
+2){ 
	gposi
 = 
p
+2;

521 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

524 cڡ * 
	gj
 = 
sk_ov_sces
< 
exaly
<
hash_lb
>, 
	gexaly
<
	grb
> >(
	gp
 + 2, 
	gd_of_
);

526 
Exessi
* 
	gުt
 = 
Pr
::
om_c_r
(
p
+2, 
j
, 
x
, 
pe
).
r_li
();

528 
	gުt
->
is_ުt
(
ue
);

531 (*
	gschema
<< 
	gުt
;

533 
	gi
 = 
j
;

539 i(
	gi
 < 
	gd_of_
(*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
i
, 
d_of_
));

541 
	gi
 = 
d_of_
;

547 
	gposi
 = 
i
;

550 
	g_schema
->
upde_pe
(
pe
);

553  
	g_schema
;

557 
	gPr
::
r_cht_deive
()

559 
x
 <

560 
qu
 <

561 
qued_rg
,

562 
	gtiڮ_as
,

563 
	gexaly
 <';'>

569 
Mix_Cl
* 
	gPr
::
r_ude_deive
()

572 
x_idtifr
();

574 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
xed
));

576 
Mix_Cl
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Mix_Cl, 
pe
, 
me
, 0, 0);

578 
	g
->
gumts
(
r_gumts
());

580 i(
	gek
 < 
	gexaly
 <'{'> >()) {

581 
	g
->
block
(
r_block
());

584  
	g
;

590 
Se_Li
* 
	gPr
::
r__li
(
bo
 
_ro
)

592 
bo
 
lo
 = 
ue
;

593 
bo
 
	ghad_leed
 = 
l
;

594 
Comex_Se
* 
	gl
 = 0;

595 
Se_Li
* 
	ggroup
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 
pe
);

596 
	ggroup
->
med_block
(
ϡ_med_block
);

599 
	glo
 = 
l
;

601 
	ghad_leed
 = 
had_leed
 || 
ek_wle
();

603 i(
	gek_css
< 
	gass_ch
 < 
	g_li_dims
 > >())

608 
	gl
 = 
r_comex_
(
_ro
);

610 i(!
	gl
 
	ggroup
;

612 
	gl
->
has_le_ed
(
had_leed
);

614 
	ghad_leed
 = 
l
;

616 
	gek_css
< 
	gexaly
<','> >())

618 
	gx
< 
	gcss_commts
 >(
	gl
);

620 
	glo
 = 
x
< 
exaly
<','> >() != 0;

622 
	ghad_leed
 = 
had_leed
 || 
ek_wle
();

625 (*
	ggroup
<< 
	gl
;

627 
	glo
);

628 
	gx_css
< 
	gkwd_tiڮ
 >()) {

629 
	ggroup
->
is_tiڮ
(
ue
);

632 
	ggroup
->
upde_pe
(
pe
);

633 i(
	gl
l->
ϡ
()->
has_le_bak
(
l
);

634  
	ggroup
;

642 
Comex_Se
* 
	gPr
::
r_comex_
(
bo
 
_ro
)

645 
Sg
* 
n
 = 0;

646 
	gx
 < 
	gblock_commt
 >();

648 
Compound_Se
* 
	glhs
 = 0;

650 i(!
	gek_css
< 
	gass_ch
 < 
	g_comb_s
 > >()) {

652 
	glhs
 = 
r_compound_
();

656 i(
	gek
 < 
	gd_of_fe
 >())  0;

659 
	gComex_Se
::
Comb
 
comb
;

660 i(
	gx
< 
	gexaly
<'+'> >()
	gcomb
 = 
Comex_Se
::
ADJACENT_TO
;

661 i(
	gx
< 
	gexaly
<'~'> >()
	gcomb
 = 
Comex_Se
::
PRECEDES
;

662 i(
	gx
< 
	gexaly
<'>'> >()
	gcomb
 = 
Comex_Se
::
PARENT_OF
;

663 i(
	gx
< 
	gqu
 < 
	gexaly
<'/'>, 
	gge
 <xactly < '*' > > > >()) {

665 
	gcomb
 = 
Comex_Se
::
REFERENCE
;

666 i(!
	gx
 < 
	g_n_comb
 >())  0;

667 
	gn
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

668 i(!
	gx
 < 
	gexaly
 < '/' > >())  0;

670 
	gcomb
 = 
Comex_Se
::
ANCESTOR_OF
;

672 i(!
	glhs
 && 
	gcomb
 =
Comex_Se
::
ANCESTOR_OF
)  0;

677 
Comex_Se
* 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Comex_Se, 
pe
, 
comb
, 
lhs
);

678 
	gl
->
med_block
(
ϡ_med_block
);

680 i(
	gcomb
 =
Comex_Se
::
REFERENCE

l
->
n
(reference);

682 
	gl
->
has_le_bak
(
ek_wle
());

686 i(!
	gek_css
< 
	gass_ch
 < 
	gcomex__dims
 > >()) {

688 
	gl
->

(
r_comex_
(
ue
));

689 i(
	gl
->

()) {

692 i(
	gl
->

()->
has_ahd
()l->has_ahd(
ue
);

698 i(!
	gl
->
has__f
(&& !
	g__ro
 && !
	g_ro
) {

700 
Pt_Se
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Pt_Se, 
pe
);

701 
	g
->
med_block
(
ϡ_med_block
);

702 
Compound_Se
* 
	ghd
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
pe
);

703 
	ghd
->
med_block
(
ϡ_med_block
);

705 (*
	ghd
<< 
	g
;

707 i(!
	gl
->
hd
()) { sel->head(head); }

710 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Comex_Se
, 
pe
, Comex_Se::
ANCESTOR_OF
, 
hd
, 
l
);

711 
	gl
->
med_block
(
ϡ_med_block
);

718  
	gl
;

725 
Compound_Se
* 
	gPr
::
r_compound_
()

728 
Compound_Se
* 
q
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Compound_Se, 
pe
);

729 
	gq
->
med_block
(
ϡ_med_block
);

732 
	gx
< 
	gcss_whea
 >();

735 
	gue
)

738 
	gx
< 
	gdimed_by
< 
	gash_
, 
	g_ash
, 
	gl
 > >(false);

740 i(
	gmch
 < 
	g_pudo_
 >())

742 (*
	gq
<< 
r_sime_
();

745 i(
	gx
< 
	gexaly
<'&'> >(
	gl
))

748 
	gq
->
has__n
(
ue
);

749 (*
	gq
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Pt_Se
, 
pe
);

752 i(
	gq
->
ngth
() > 1) {

753 
PrS
 
e
(
pe
);

754 
Sime_Se
* 
	gcur
 = (*
q
)[q->
ngth
()-1];

755 
Sime_Se
* 
	gev
 = (*
q
)[q->
ngth
()-2];

756 
	gd
::
rg
 
l
(
ev
->
to_rg
({ 
NESTED
, 5 }));

757 
	gd
::
rg
 
found
(
cur
->
to_rg
({ 
NESTED
, 5 }));

758 i(
	gx
 < 
	gidtifr
 >(){ 
	gfound
 +
d
::
rg
(
xed
); }

759 
r
("Invid CSS \"" + 
l
 + "\":xed \"{\", wa\"" + 
found
 + "\"\n\n"

760 "\"" + 
found
 + "\" may oy budthbegng ocompound se.", 
e
);

764 i(
	gx
< 
	g_ty_
 >(
	gl
))

766 (*
	gq
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Ty_Se
, 
pe
, 
xed
);

769 i(
	gek
< 
	gas
 >()) ;

770 i(
	gek
< 
	gd_of_fe
 >()) { ; }

771 i(
	gek_css
 < 
	gass_ch
 < 
	g_comb_s
 > >()) ;

772 i(
	gek_css
 < 
	gass_ch
 < 
	gcomex__dims
 > >()) ;

775 
Sime_Se
* 
	gl
 = 
r_sime_
();

776 i(!
	gl
)  0;

777 (*
	gq
<< 
	gl
;

781 i(
	gq
 && !
	gek_css
<
	gexaly
<'{'>>()) {

782 
	gq
->
has_le_bak
(
ek_wle
());

786  
	gq
;

791 
Sime_Se
* 
	gPr
::
r_sime_
()

793 
x
 < 
css_commts
 >(
l
);

794 i(
	gx
< 
	gives
 < 
	gid_me
, 
	gass_me
 > >()) {

795  
SASS_MEMORY_NEW
(
x
.
mem
, 
Se_Quifr
, 
pe
, 
xed
);

797 i(
	gx
< 
	gqued_rg
 >()) {

798  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ty_Se
, 
pe
, 
unque
(
xed
));

800 i(
	gx
< 
	gives
 < 
	gvb
, 
	gnumb
, 
	gic_n_comb
 > >()) {

801  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ty_Se
, 
pe
, 
xed
);

803 i(
	gek
< 
	gpudo_n
 >()) {

804  
r_ged_
();

806 i(
	gek
< 
	g_pudo_
 >()) {

807  
r_pudo_
();

809 i(
	gek
< 
	gexaly
<':'> >()) {

810  
r_pudo_
();

812 i(
	gx
 < 
	gexaly
<'['> >()) {

813  
r_ibu_
();

815 i(
	gx
< 
	gahd
 >()) {

816 
Se_Phd
* 
	gl
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Phd, 
pe
, 
xed
);

817 
	gl
->
med_block
(
ϡ_med_block
);

818  
	gl
;

824 
Wed_Se
* 
	gPr
::
r_ged_
()

826 
x
< 
pudo_n
 >();

827 
	gd
::
rg
 
me
(
xed
);

828 
PrS
 
	gnsour_posi
 = 
pe
;

829 
Se
* 
	gged
 = 
r__li
(
ue
);

830 i(!
	gx
< 
	gexaly
<')'> >()) {

831 
r
("ged se imissg ')'", 
pe
);

833 
	gme
.
a
(
me
.
size
() - 1);

834  
SASS_MEMORY_NEW
(
x
.
mem
, 
Wed_Se
, 
nsour_posi
, 
me
, 
ged
);

839 
Sime_Se
* 
	gPr
::
r_pudo_
() {

840 i(
x
< 
qu
<

841 
tiڮ
 < 
pudo_efix
 >,

845 
	gqu
< 
	gidtifr
, 
	gtiڮ
 < 
	gblock_commt
 >, 
	gexaly
<'('> >

849 
	gd
::
rg
 
me
(
xed
);

850 
	gme
.
a
(
me
.
size
() - 1);

851 
PrS
 
	gp
 = 
pe
;

855 i(
	gek_css
 <

856 
	gqu
 <

857 
	gives
 <

858 
	gic_vue
,

859 
	gboml


861 
	gtiڮ_css_whea
,

862 
	gexaly
<')'>

866 
	gx_css
< 
	gives
 < 
	gic_vue
, 
	gboml
 > >();

867 
Sg_Cڡt
* 
	gex
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Cڡt, 
pe
, 
xed
);

868 i(
	gex
 && 
	gx_css
< 
	gexaly
<')'> >()) {

869 
	gex
->
n_comess_whea
(
ue
);

870  
SASS_MEMORY_NEW
(
x
.
mem
, 
Pudo_Se
, 
p
, 
me
, 
ex
);

873 i(
Se
* 
	gwed
 = 
r__li
(
ue
)) {

874 i(
wed
 && 
x_css
< 
exaly
<')'> >()) {

875  
SASS_MEMORY_NEW
(
x
.
mem
, 
Wed_Se
, 
p
, 
me
, 
wed
);

882 i(
	gx
 < 
	gqu
< 
	gtiڮ
 < 
	gpudo_efix
 >, 
	gidtifr
 > >()) {

883  
SASS_MEMORY_NEW
(
x
.
mem
, 
Pudo_Se
, 
pe
, 
xed
);

885 if(
	gx
 < 
	gpudo_efix
 >()) {

886 
css_r
("Invalid CSS", "fter ", ":xpectedseudoclass orseudoelement, was ");

889 
css_r
("Invalid CSS", "fter ", ":xpected \")\", was ");

895 
Aribu_Se
* 
	gPr
::
r_ibu_
()

897 
PrS
 
p
 = 
pe
;

898 i(!
	gx_css
< 
	gibu_me
 >()
r
("vidribuamribu se", 
pe
);

899 
	gd
::
rg
 
me
(
xed
);

900 i(
	gx_css
< 
	gives
 < 
	gexaly
<']'>,xaly<'/'> > >() 
SASS_MEMORY_NEW
(
x
.
mem
, 
Aribu_Se
, 
p
, 
me
, "", 0);

901 i(!
	gx_css
< 
	gives
< 
	gexa_mch
, 
	gass_mch
, 
	gdash_mch
,

902 
	gefix_mch
, 
	gsuffix_mch
, 
	gsubrg_mch
 > >()) {

903 
r
("vid ot iibu se f " + 
me
, 
pe
);

905 
	gd
::
rg
 
mch
(
xed
);

907 
Sg
* 
	gvue
 = 0;

908 i(
	gx_css
< 
	gidtifr
 >()) {

909 
	gvue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
p
, 
xed
);

911 i(
	gx_css
< 
	gqued_rg
 >()) {

912 
	gvue
 = 
r_ީed_chunk
(
xed
, 
ue
);

915 
r
("exed sg cڡ idtifribu se f " + 
me
, 
pe
);

918 i(!
	gx_css
< 
	gives
 < 
	gexaly
<']'>,xaly<'/'> > >()
r
("umedribu se f " + 
me
, 
pe
);

919  
SASS_MEMORY_NEW
(
x
.
mem
, 
Aribu_Se
, 
p
, 
me
, 
mch
, 
vue
);

923 
	gPr
::
r_block_commts
()

925 
Block
* 
block
 = 
block_ack
.
back
();

926 
	gx
< 
	gblock_commt
 >()) {

927 
bo
 
	gis_imp܏
 = 
xed
.
beg
[2] == '!';

929 
Sg
* 
	gcڋs
 = 
r_ީed_chunk
(
xed
, 
ue
);

930 (*
	gblock
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Commt
, 
pe
, 
cڋs
, 
is_imp܏
);

934 
Dei
* 
	gPr
::
r_dei
() {

935 
Sg
* 

 = 0;

936 i(
	gx
< 
	gqu
< 
	gtiڮ
< 
	gexaly
<'*'> >, 
	gidtifr_schema
 > >()) {

937 
	g
 = 
r_idtifr_schema
();

939 i(
	gx
< 
	gqu
< 
	gtiڮ
< 
	gexaly
<'*'> >, 
	gidtifr
, 
	gzo_us
< 
	gblock_commt
 > > >()) {

940 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

941 
	g
->
is_dayed
(
ue
);

944 
css_r
("Invalid CSS", "fter ", ":xpected \"}\", was ");

946 
bo
 
	gis_dd
 = 
ue
;

947 cڡ 
	gd
::
rg
 
ݔty
(
xed
);

948 i(!
	gx_css
< 
	ge_us
< 
	gexaly
<':'> > >()
r
("ݔty \"" + 
ݔty
 + "\" mu bflowed by ':'", 
pe
);

949 
	gx
 < 
	gcss_commts
 >(
	gl
);

950 i(
	gek_css
< 
	gexaly
<';'> >()
r
("y dei mu cڏ vue", 
pe
);

951 i(
	gek_css
< 
	gexaly
<'{'> >()
	gis_dd
 = 
l
;

952 i(
	gek_css
< 
	gic_vue
 >()) {

953  
SASS_MEMORY_NEW
(
x
.
mem
, 
Dei
, 

->
pe
(),r, 
r_ic_vue
() );

956 
Exessi
* 
	gvue
;

957 
Lookahd
 
	glookahd
 = 
lookahd_f_vue
(
posi
);

958 i(
	glookahd
.
	gfound
) {

959 i(
	glookahd
.
	ghas_ުts
) {

960 
	gvue
 = 
r_vue_schema
(
lookahd
.
found
);

962 
	gvue
 = 
r_li
();

966 
	gvue
 = 
r_li
();

967 i(
Li
* 
	gli
 = 
dymic_
<Li*>(
vue
)) {

968 i(
li
->
ngth
(=0 && !
ek
< 
exaly
 <'{'> >()) {

969 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

973 
	gx
 < 
	gcss_commts
 >(
	gl
);

974 aut
	gde
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Dei
, 

->
pe
(),r, 
vue
 );

975 
	gde
->
is_dd
(is_indented);

976  
	gde
;

981 
bo
 
	gPr
::
r_numb_efix
()

983 
bo
 
posive
 = 
ue
;

984 
	gue
) {

985 i(
	gx
 < 
	gblock_commt
 >()) ;

986 i(
	gx
 < 
	gnumb_efix
 >()) ;

987 i(
	gx
 < 
	gexaly
 < '-' > >()) {

988 
	gposive
 = !
posive
;

993  
	gposive
;

996 
Exessi
* 
	gPr
::
r_m
()

998 
Exessi
* 
key
 = 
r_li
();

999 
Li
* 
	gm
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 0, 
SASS_HASH
);

1000 i(
Sg_Qued
* 
	gr
 = 
dymic_
<Sg_Qued*>(
key
)) {

1001 i(!
r
->
que_mk
(&& !r->
is_dayed
()) {

1002 i(cڡ 
C
* 
c
 = 
me_to_c
(
r
->
vue
())) {

1003 
C
* 
c
 = 
SASS_MEMORY_NEW
(
x
.
mem
, C, *
c
);

1004 
	gc
->
pe
(
r
->pstate());

1005 
	gc
->
di
(
r
->
vue
());

1006 
	gkey
 = 
c
;

1012 i(!
	gx_css
< 
	gexaly
<':'> >())

1013 {  
	gkey
; }

1015 
Exessi
* 
	gvue
 = 
r_a_li
();

1017 (*
	gm
<< 
	gkey
 << 
	gvue
;

1019 
	gx_css
< 
	gexaly
<','> >())

1022 i(
	gek_css
< 
	gexaly
<')'> >(
	gposi
))

1025 
Exessi
* 
	gkey
 = 
r_li
();

1026 i(
Sg_Qued
* 
	gr
 = 
dymic_
<Sg_Qued*>(
key
)) {

1027 i(!
r
->
que_mk
(&& !r->
is_dayed
()) {

1028 i(cڡ 
C
* 
c
 = 
me_to_c
(
r
->
vue
())) {

1029 
C
* 
c
 = 
SASS_MEMORY_NEW
(
x
.
mem
, C, *
c
);

1030 
	gc
->
pe
(
r
->pstate());

1031 
	gc
->
di
(
r
->
vue
());

1032 
	gkey
 = 
c
;

1037 i(!(
	gx
< 
	gexaly
<':'> >()))

1038 { 
r
("vid syax", 
pe
); }

1040 
Exessi
* 
	gvue
 = 
r_a_li
();

1042 (*
	gm
<< 
	gkey
 << 
	gvue
;

1045 
PrS
 
	gps
 = 
m
->
pe
();

1046 
	gps
.
	gofft
 = 
pe
 - 
ps
 +e.
offt
;

1047 
	gm
->
pe
(
ps
);

1049  
	gm
;

1055 
Exessi
* 
	gPr
::
r_li
()

1058  
r_comma_li
();

1062 
Exessi
* 
	gPr
::
r_comma_li
()

1066 i(
ek_css
< 
ives
 <

1068 
exaly
<';'>,

1069 
	gexaly
<'}'>,

1070 
	gexaly
<'{'>,

1071 
	gexaly
<')'>,

1072 
	gexaly
<':'>,

1073 
	gd_of_fe
,

1074 
	gexaly
<
	glsis
>,

1075 
	gdeu_ag
,

1076 
	gglob_ag


1077 > >(
	gposi
))

1078 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Li
, 
pe
, 0); }

1081 
Exessi
* 
	gli
 = 
r_a_li
();

1083 i(!
	gek_css
< 
	gexaly
<','> >(
	gposi
) 
	gli
;

1086 
Li
* 
	gcomma_li
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 2, 
SASS_COMMA
);

1088 (*
	gcomma_li
<< 
	gli
;

1090 
	gx_css
< 
	gexaly
<','> >())

1093 i(
	gek_css
< 
	gives
 <

1094 
	gexaly
<';'>,

1095 
	gexaly
<'}'>,

1096 
	gexaly
<'{'>,

1097 
	gexaly
<')'>,

1098 
	gexaly
<':'>,

1099 
	gd_of_fe
,

1100 
	gexaly
<
	glsis
>,

1101 
	gdeu_ag
,

1102 
	gglob_ag


1103 > >(
	gposi
)

1106 (*
	gcomma_li
<< 
r_a_li
();

1109  
	gcomma_li
;

1114 
Exessi
* 
	gPr
::
r_a_li
()

1116 
Exessi
* 
disj1
 = 
r_disjuni
();

1118 i(
	gek_css
< 
	gives
 <

1120 
	gexaly
<';'>,

1121 
	gexaly
<'}'>,

1122 
	gexaly
<'{'>,

1123 
	gexaly
<')'>,

1124 
	gexaly
<','>,

1125 
	gexaly
<':'>,

1126 
	gd_of_fe
,

1127 
	gexaly
<
	glsis
>,

1128 
	gdeu_ag
,

1129 
	gglob_ag


1130 > >(
	gposi
)

1131 {  
	gdisj1
; }

1133 
Li
* 
	ga_li
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 2, 
SASS_SPACE
);

1134 (*
	ga_li
<< 
	gdisj1
;

1136 !(
	gek_css
< 
	gives
 <

1138 
	gexaly
<';'>,

1139 
	gexaly
<'}'>,

1140 
	gexaly
<'{'>,

1141 
	gexaly
<')'>,

1142 
	gexaly
<','>,

1143 
	gexaly
<':'>,

1144 
	gd_of_fe
,

1145 
	gexaly
<
	glsis
>,

1146 
	gdeu_ag
,

1147 
	gglob_ag


1148 > >(
	gposi
)&& 
	gek_css
< 
	gtiڮ_css_whea
 >(!
d


1151 (*
a_li
<< 
r_disjuni
();

1154  
	ga_li
;

1159 
Exessi
* 
	gPr
::
r_disjuni
()

1162 
Exessi
* 
cj
 = 
r_cjuni
();

1164 
	gd
::
ve
<
Exessi
*> 
ݔds
;

1165 
	gx_css
< 
	gkwd_
 >())

1166 
	gݔds
.
push_back
(
r_cjuni
());

1168 i(
	gݔds
.
size
(=0 
cj
;

1170  
fd_ݔds
(
cj
, 
ݔds
, { 
Sass_OP
::
OR
 });

1175 
Exessi
* 
	gPr
::
r_cjuni
()

1178 
Exessi
* 
l
 = 
r_ti
();

1180 
	gd
::
ve
<
Exessi
*> 
ݔds
;

1181 
	gx_css
< 
	gkwd_d
 >())

1182 
	gݔds
.
push_back
(
r_ti
());

1184 i(
	gݔds
.
size
(=0 
l
;

1186  
fd_ݔds
(
l
, 
ݔds
, { 
Sass_OP
::
AND
 });

1191 
Exessi
* 
	gPr
::
r_ti
()

1194 
Exessi
* 
lhs
 = 
r_exessi
();

1195 
	gd
::
ve
<
Exessi
*> 
ݔds
;

1196 
	gd
::
ve
<
Ond
> 
ݔs
;

1198 
	gek
< 
	gives
 <

1199 
	gkwd_eq
,

1200 
	gkwd_q
,

1201 
	gkwd_g
,

1202 
	gkwd_gt
,

1203 
	gkwd_e
,

1204 
	gkwd_


1205 > >(
	gposi
))

1208 
bo
 
	g_ws
 = 
ek
 < 
css_commts
 >(!
NULL
;

1210 
Sass_OP
 
	g


1211 
x
<
kwd_eq
>(? 
Sass_OP
::
EQ


1212 : 
x
<
kwd_q
>(? 
Sass_OP
::
NEQ


1213 : 
x
<
kwd_g
>(? 
Sass_OP
::
GTE


1214 : 
x
<
kwd_e
>(? 
Sass_OP
::
LTE


1215 : 
x
<
kwd_gt
>(? 
Sass_OP
::
GT


1216 : 
x
<
kwd_
>(? 
Sass_OP
::
LT


1218 : 
Sass_OP
::
EQ
;

1220 
bo
 
	gright_ws
 = 
ek
 < 
css_commts
 >(!
NULL
;

1221 
	gݔs
.
push_back
({ 

, 
_ws
, 
right_ws
 });

1222 
	gݔds
.
push_back
(
r_exessi
());

1223 
	g_ws
 = 
ek
 < 
css_commts
 >(!
NULL
;

1226  
fd_ݔds
(
lhs
, 
ݔds
, 
ݔs
);

1235 
Exessi
* 
	gPr
::
r_exessi
()

1240 
Exessi
* 
lhs
 = 
r_ݔs
();

1242 i(!(
	gek_css
< 
	gexaly
<'+'> >(
	gposi
) ||

1244 (
	gek
< 
	gno_as
 >(
	gposi
&&k< 
	gqu
< 
	gge
< 
	gunsigd_numb
 >, 
	gexaly
<'-'>,ege< 
	ga
 > > >(position)) ||

1245 (
	gek
< 
	gqu
< 
	gge
< 
	gunsigd_numb
 >, 
	gexaly
<'-'>,ege< unsigd_numb > > >(
	gposi
))) ||

1246 
	gek
< 
	gqu
 < 
	gzo_us
 < 
	gexaly
 <'-' > >, 
	gidtifr
 > >(
	gposi
))

1247 {  
	glhs
; }

1249 
	gd
::
ve
<
Exessi
*> 
ݔds
;

1250 
	gd
::
ve
<
Ond
> 
ݔs
;

1251 
bo
 
	g_ws
 = 
ek
 < 
css_commts
 >(!
NULL
;

1253 
	gx_css
< 
	gexaly
<'+'> >() ||

1256 ! 
	gek_css
< 
	gqu
 < 
	gzo_us
 < 
	gexaly
 <'-' > >, 
	gidtifr
 > >(
	gposi
)

1257 && 
	gx_css
< 
	gqu
< 
	gge
< 
	gdig
 >, 
	gexaly
<'-'> > >()

1263 
bo
 
	gright_ws
 = 
ek
 < 
css_commts
 >(!
NULL
;

1264 
	gݔs
.
push_back
({ 
xed
.
to_rg
(="+" ? 
Sass_OP
::
ADD
 : Sass_OP::
SUB
, 
_ws
, 
right_ws
 });

1265 
	gݔds
.
push_back
(
r_ݔs
());

1266 
	g_ws
 = 
ek
 < 
css_commts
 >(!
NULL
;

1269 i(
	gݔds
.
size
(=0 
lhs
;

1270  
fd_ݔds
(
lhs
, 
ݔds
, 
ݔs
);

1274 
Exessi
* 
	gPr
::
r_ݔs
()

1276 
Exessi
* 

 = 
r_
();

1278 
	gd
::
ve
<
Exessi
*> 
ݔds
;

1279 
	gd
::
ve
<
Ond
> 
ݔs
;

1281 cڡ * 
	g_ws
 = 
ek
 < 
css_commts
 >();

1282 
	gx_css
< 
	gass_ch
< 
	gic_s
 > >()) {

1283 cڡ * 
	gright_ws
 = 
ek
 < 
css_commts
 >();

1284 *
	gxed
.
	gbeg
) {

1285 '*': 
ݔs
.
push_back
({ 
Sass_OP
::
MUL
, 
_ws
 !0, 
right_ws
 != 0 }); ;

1286 '/': 
ݔs
.
push_back
({ 
Sass_OP
::
DIV
, 
_ws
 !0, 
right_ws
 != 0 }); ;

1287 '%': 
ݔs
.
push_back
({ 
Sass_OP
::
MOD
, 
_ws
 !0, 
right_ws
 != 0 }); ;

1288 : 
throw
 
d
::
ruime_r
("unknown static oparsed"); ;

1290 
	gݔds
.
push_back
(
r_
());

1291 
	g_ws
 = 
ek
 < 
css_commts
 >();

1294  
fd_ݔds
(

, 
ݔds
, 
ݔs
);

1301 
Exessi
* 
	gPr
::
r_
()

1303 
x
 < 
css_commts
 >(
l
);

1304 i(
	gx_css
< 
	gexaly
<'('> >()) {

1306 
Exessi
* 
	gvue
 = 
r_m
();

1308 i(!
	gx_css
< 
	gexaly
<')'> >()
r
("unodthesis", 
pe
);

1311 i(
	gvue
->
ce_ty
(=
Exessi
::
LIST
) {

1314 } i(
tyid
(*
vue
=tyid(
By_Exessi
)) {

1315 
By_Exessi
* 
b
 = 
ic_
<By_Exessi*>(
vue
);

1316 i(
	gb
 && b->
ty
(=
Sass_OP
::
DIV

b
->
t_dayed
(
l
);

1318  
	gvue
;

1324 i(
	gek
< 
	g_ݔty
 >()) {

1325  
r__ݔty
();

1327 i(
	gek
< 
	g_keywd_g
 >()) {

1328  
r__keywd_g
();

1330 i(
	gek
< 
	gqu
 < 
	glc__
, 
	gexaly
 <'('> > >()) {

1331  
r_lc_funi
();

1333 i(
	gx
 < 
	gfuniڮ_schema
 >()) {

1334  
r_funi__schema
();

1336 i(
	gx
< 
	gidtifr_schema
 >()) {

1337 
Sg
* 
	grg
 = 
r_idtifr_schema
();

1338 i(
Sg_Schema
* 
	gschema
 = 
dymic_
<Sg_Schema*>(
rg
)) {

1339 i(
x
 < 
exaly
 < '(' > >()) {

1340 *
schema
 << 
r_li
();

1341 
	gx
 < 
	gexaly
 < ')' > >();

1344  
	grg
;

1346 i(
	gek
< 
	gqu
< 
	guri_efix
, 
	gW
, 
	g_uri_vue
 > >()) {

1347  
r_u_funi_rg
();

1349 i(
	gek
< 
	g_funiڮ
 >()) {

1350  
r_funi_
();

1352 i(
	gx
< 
	gexaly
<'+'> >()) {

1353  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ury_Exessi
, 
pe
, Ury_Exessi::
PLUS
, 
r_
());

1355 i(
	gx
< 
	gexaly
<'-'> >()) {

1356  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ury_Exessi
, 
pe
, Ury_Exessi::
MINUS
, 
r_
());

1358 i(
	gx
< 
	gqu
< 
	gkwd_n
 > >()) {

1359  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ury_Exessi
, 
pe
, Ury_Exessi::
NOT
, 
r_
());

1361 i(
	gek
 < 
	gqu
 < 
	ge_us
 < 
	gives
 < 
	gcss_whea
, 
	gexaly
<'-'>,xaly<'+'> > >, 
	gnumb
 > >()) {

1362 i(
r_numb_efix
() 
r_vue
();

1363  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ury_Exessi
, 
pe
, Ury_Exessi::
MINUS
, 
r_vue
());

1366  
r_vue
();

1371 
Exessi
* 
	gPr
::
r_vue
()

1373 
x
< 
css_commts
 >(
l
);

1374 i(
	gx
< 
	gamrnd
 >())

1376  
SASS_MEMORY_NEW
(
x
.
mem
, 
Pt_Se
, 
pe
); }

1378 i(
	gx
< 
	gkwd_imp܏
 >())

1379 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, "!important"); }

1382 i(
	gx
< 
	gqu
 < 
	grage
, 
	glookahd
 < 
	gnumb
 > > >())

1383 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
PERCENTAGE
, 
xed
); }

1385 i(
	gx
< 
	gqu
 < 
	gnumb
, 
	glookahd
< sequ < 
	g
,umber > > > >())

1386 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
NUMBER
, 
xed
); }

1389 i(
	gx
< 
	gqu
 < 
	gqued_rg
, 
	glookahd
 < 
	gexaly
 <'-'> > > >())

1390 {  
r_rg
(); }

1392 i(cڡ * 
	g
 = 
ek
< 
vue_schema
 >())

1393 {  
r_vue_schema
(

); }

1396 i(
	gx
< 
	gqued_rg
 >())

1397 {  
r_rg
(); }

1399 i(
	gx
< 
	gkwd_ue
 >())

1400 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
ue
); }

1402 i(
	gx
< 
	gkwd_l
 >())

1403 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Boޗn
, 
pe
, 
l
); }

1405 i(
	gx
< 
	gkwd_nu
 >())

1406 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Nu
, 
pe
); }

1408 i(
	gx
< 
	gidtifr
 >()) {

1409  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

1412 i(
	gx
< 
	grage
 >())

1413 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
PERCENTAGE
, 
xed
); }

1416 i(
	gx
< 
	gqu
 < 
	gives
< 
	ghex
, 
	ghex0
 >, 
	gge
 < 
	gexaly
<'-'> > > >())

1417 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
HEX
, 
xed
); }

1419 i(
	gx
< 
	gqu
 < 
	gexaly
 <'#'>, 
	gidtifr
 > >())

1420 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
xed
); }

1424 i(
	gx
< 
	gqu
< 
	gdimsi
, 
	gtiڮ
< sequ< 
	gexaly
<'-'>, 
	glookahd
< 
	gives
 < 
	ga
 > > > > > >())

1425 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
DIMENSION
, 
xed
); }

1427 i(
	gx
< 
	gqu
< 
	gic_compڒt
, 
	ge_us
< 
	gri_idtifr
 > > >())

1428 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
); }

1430 i(
	gx
< 
	gnumb
 >())

1431 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
NUMBER
, 
xed
); }

1433 i(
	gx
< 
	gvb
 >())

1434 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Vb
, 
pe
, 
Ut
::
nmize_undsces
(
xed
)); }

1437 i(
	gx
< 
	gqu
< 
	gexaly
<'%'>, 
	gtiڮ
< 
	grage
 > > >())

1438 {  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
); }

1440 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

1448 
Sg
* 
	gPr
::
r_ީed_chunk
(
Tok
 
chunk
, 
bo
 
cڡt
)

1450 cڡ * 
	gi
 = 
chunk
.
beg
;

1452 cڡ * 
	gp
 = 
cڡt
 ? 
fd_f__rv
< 
exaly
<
hash_lb
> >(
i
, 
	gchunk
.
	gd
) :

1453 
fd_f__rv
< 
exaly
<
hash_lb
>, 
	gblock_commt
 >(
	gi
, 
	gchunk
.
	gd
);

1455 i(!
	gp
) {

1456 
Sg_Qued
* 
	gr_qued
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Qued, 
pe
, 
d
::
rg
(
i
, 
chunk
.
d
));

1457 i(!
	gcڡt
 && 
	gr_qued
->
que_mk
()) str_quoted->quote_mark('*');

1458 
	gr_qued
->
is_dayed
(
ue
);

1459  
	gr_qued
;

1462 
Sg_Schema
* 
	gschema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

1463 
	gschema
->
is_ުt
(
ue
);

1464 
	gi
 < 
	gchunk
.
	gd
) {

1465 
	gp
 = 
cڡt
 ? 
fd_f__rv
< 
exaly
<
hash_lb
> >(
i
, 
	gchunk
.
	gd
) :

1466 
fd_f__rv
< 
exaly
<
hash_lb
>, 
	gblock_commt
 >(
	gi
, 
	gchunk
.
	gd
);

1467 i(
	gp
) {

1468 i(
	gi
 < 
	gp
) {

1470 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
i
, 
p
));

1474 i(
	gek
 < 
	gqu
 < 
	gtiڮ_as
, 
	gexaly
<
	grb
> > >(
	gp
+2){ 
	gposi
 = 
p
+2;

1475 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

1477 cڡ * 
	gj
 = 
sk_ov_sces
< 
exaly
<
hash_lb
>, 
	gexaly
<
	grb
> >(
	gp
 + 2, 
	gchunk
.
	gd
);

1478 i(
	gj
) { --j;

1480 
Exessi
* 
	g_node
 = 
Pr
::
om_tok
(
Tok
(
p
+2, 
j
), 
x
, 
pe
, 
sour
).
r_li
();

1481 
	g_node
->
is_ުt
(
ue
);

1482 (*
	gschema
<< 
	g_node
;

1483 
	gi
 = 
j
;

1487 
r
("umed ipުsidrg cڡ" + 
chunk
.
to_rg
(), 
pe
);

1492 i(
	gi
 < 
	gchunk
.
	gd
(*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
i
, 
chunk
.
d
));

1495 ++ 
	gi
;

1498  
	gschema
;

1501 
Sg_Cڡt
* 
	gPr
::
r_ic_exessi
()

1503 i(
ek
< 
qu
< 
numb
, 
	gtiڮ_as
, 
	gexaly
<'/'>, oiڮ_as, 
	gnumb
 > >()) {

1504  
r_ic_vue
();

1509 
Sg_Cڡt
* 
	gPr
::
r_ic_vue
()

1511 
x
< 
ic_vue
 >();

1512 
Tok
 
r
(
xed
);

1513 --
	gr
.
	gd
;

1514 --
	gposi
;

1516 
Sg_Cڡt
* 
	gr_node
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Cڡt, 
pe
, 
r
.
time_wa
());

1517 
	gr_node
->
is_dayed
(
ue
);

1518  
	gr_node
;

1521 
Sg
* 
	gPr
::
r_rg
()

1523  
r_ީed_chunk
(
Tok
(
xed
));

1526 
Sg
* 
	gPr
::
r__ݔty
()

1528 
x
< 
_ݔty
 >();

1529 
Tok
 
r
(
xed
);

1530 cڡ * 
	gi
 = 
r
.
beg
;

1532 cڡ * 
	gp
 = 
fd_f__rv
< 
exaly
<
hash_lb
>, 
	gblock_commt
 >(
	gr
.
	gbeg
, s.
	gd
);

1533 i(!
	gp
) {

1534  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
d
::
rg
(
r
.
beg
, s.
d
));

1537 
Sg_Schema
* 
	gschema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

1538 
	gi
 < 
	gr
.
	gd
) {

1539 
	gp
 = 
fd_f__rv
< 
exaly
<
hash_lb
>, 
	gblock_commt
 >(
	gi
, 
	gr
.
	gd
);

1540 i(
	gp
) {

1541 i(
	gi
 < 
	gp
) {

1542 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
i
, 
p
));

1544 i(
	gek
 < 
	gqu
 < 
	gtiڮ_as
, 
	gexaly
<
	grb
> > >(
	gp
+2){ 
	gposi
 = 
p
+2;

1545 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

1547 cڡ * 
	gj
 = 
sk_ov_sces
< 
exaly
<
hash_lb
>, 
	gexaly
<
	grb
> >(
	gp
+2, 
	gr
.
	gd
);

1548 i(
	gj
) {

1550 
Exessi
* 
	g_node
 = 
Pr
::
om_tok
(
Tok
(
p
+2, 
j
), 
x
, 
pe
, 
sour
).
r_li
();

1551 
	g_node
->
is_ުt
(
ue
);

1552 (*
	gschema
<< 
	g_node
;

1553 
	gi
 = 
j
;

1557 
r
("umed ipުsidIE funi " + 
r
.
to_rg
(), 
pe
);

1561 i(
	gi
 < 
	gr
.
	gd
) {

1562 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
i
, 
r
.
d
));

1567  
	gschema
;

1570 
Sg
* 
	gPr
::
r__keywd_g
()

1572 
Sg_Schema
* 
kwd_g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
, 3);

1573 i(
	gx
< 
	gvb
 >()) {

1574 *
	gkwd_g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Vb
, 
pe
, 
Ut
::
nmize_undsces
(
xed
));

1576 
	gx
< 
	gives
< 
	gidtifr_schema
, 
	gidtifr
 > >();

1577 *
	gkwd_g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

1579 
	gx
< 
	gexaly
<'='> >();

1580 *
	gkwd_g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

1581 i(
	gek
< 
	gvb
 >()*
	gkwd_g
 << 
r_li
();

1582 i(
	gx
< 
	gnumb
 >()*
	gkwd_g
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
NUMBER
, 
Ut
::
nmize_decims
(
xed
));

1583 i(
	gek
 < 
	g_keywd_g_vue
 >(){ *
	gkwd_g
 << 
r_li
(); }

1584  
	gkwd_g
;

1587 
Sg_Schema
* 
	gPr
::
r_vue_schema
(cڡ * 

)

1590 
Sg_Schema
* 
schema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

1592 i(
	gek
<
	gexaly
<'}'>>()) {

1593 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

1596 cڡ * 
	ge
 = 0;

1597 cڡ * 
	g
 = 
d
;

1598 
	gd
 = 

;

1599 
size_t
 
	gnum_ems
 = 0;

1600 
bo
 
	ged_a
 = 
l
;

1601 
	gposi
 < 
	g
) {

1603 i(
	gx
< 
	gas
 >(&& 
	gnum_ems
) {

1604 
	ged_a
 = 
ue
;

1606 i(
	ged_a
) {

1607 
	ged_a
 = 
l
;

1610 i((
	ge
 = 
ek
< 
_funiڮ
 >()&& 
e
 < 

) {

1611 (*
schema
<< 
r_funi_
();

1614 i(
	gx
< 
	gexaly
 < 
	ghash_lb
 > >()) {

1616 i(
	gek
< 
	gexaly
< 
	grb
 > >()) {

1617 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

1619 
Exessi
* 
	gex
 = 0;

1620 i(
	gx
< 
	g_ic_exessi
 >()) {

1621 
	gex
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

1623 
	gex
 = 
r_li
();

1625 
	gex
->
is_ުt
(
ue
);

1626 (*
	gschema
<< 
	gex
;

1628 
	gx
 < 
	gexaly
 < 
	grb
 > >();

1632 i(
	gx
< 
	gives
 < 
	gexaly
<'%'>,xactly < '-' >,xactly < '+' > > >()) {

1633 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

1636 i(
	gx
< 
	gqued_rg
 >()) {

1640 (*
	gschema
<< 
r_rg
();

1641 i((*
	gposi
 ='"' || *
posi
 ='\''|| 
ek
 < 
ives
 < 
pha
 > >()) {

1644 i(
ek
 < 
exaly
 < '-' > >()) ;

1646 i(
	gx
< 
	gqu
 < 
	gidtifr
 > >()) {

1647 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

1648 i((*
	gposi
 ='"' || *
posi
 ='\''|| 
ek
 < 
ives
 < 
pha
 > >()) {

1653 i(
	gx
< 
	gvb
 >()) {

1654 
	gd
::
rg
 
me
(
Ut
::
nmize_undsces
(
xed
));

1655 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Vb
, 
pe
, 
me
);

1658 i(
	gx
< 
	grage
 >()) {

1659 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
PERCENTAGE
, 
xed
);

1662 i(
	gx
< 
	gdimsi
 >()) {

1663 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
DIMENSION
, 
xed
);

1666 i(
	gx
< 
	gnumb
 >()) {

1667 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
NUMBER
, 
xed
);

1670 i(
	gx
< 
	gqu
 < 
	ghex
, 
	gge
 < 
	gexaly
 < '-' > > > >()) {

1671 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Textu
, 
pe
, Textu::
HEX
, 
xed
);

1673 i(
	gx
< 
	gqu
 < 
	gexaly
 <'#'>, 
	gidtifr
 > >()) {

1674 (*
	gschema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Qued
, 
pe
, 
xed
);

1677 i(
	gek
< 
	ghe_sce
 >()) {

1678 (*
	gschema
<< 
r_
();

1683 ++
	gnum_ems
;

1685 i(
	gposi
 !

) {

1686 (*
schema
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
posi
, 

));

1687 
	gposi
 = 

;

1689 
	gd
 = 

;

1690  
	gschema
;

1695 
Sg
* 
	gPr
::
r_idtifr_schema
()

1697 
Tok
 
id
(
xed
);

1698 cڡ * 
	gi
 = 
id
.
beg
;

1700 cڡ * 
	gp
 = 
fd_f__rv
< 
exaly
<
hash_lb
>, 
	gblock_commt
 >(
	gid
.
	gbeg
, id.
	gd
);

1701 i(!
	gp
) {

1702  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
d
::
rg
(
id
.
beg
, id.
d
));

1705 
Sg_Schema
* 
	gschema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

1706 
	gi
 < 
	gid
.
	gd
) {

1707 
	gp
 = 
fd_f__rv
< 
exaly
<
hash_lb
>, 
	gblock_commt
 >(
	gi
, 
	gid
.
	gd
);

1708 i(
	gp
) {

1709 i(
	gi
 < 
	gp
) {

1711 cڡ * 
	go
 = 
posi
; 
	gposi
 = 
i
;

1712 *
	gschema
 << 
r_vue_schema
(
p
);

1713 
	gposi
 = 
o
;

1717 i(
	gek
 < 
	gqu
 < 
	gtiڮ_as
, 
	gexaly
<
	grb
> > >(
	gp
+2){ 
	gposi
 = 
p
;

1718 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was ");

1720 cڡ * 
	gj
 = 
sk_ov_sces
< 
exaly
<
hash_lb
>, 
	gexaly
<
	grb
> >(
	gp
+2, 
	gid
.
	gd
);

1721 i(
	gj
) {

1723 
Exessi
* 
	g_node
 = 
Pr
::
om_tok
(
Tok
(
p
+2, 
j
), 
x
, 
pe
, 
sour
).
r_li
();

1724 
	g_node
->
is_ުt
(
ue
);

1725 (*
	gschema
<< 
	g_node
;

1727 
	gi
 = 
j
;

1731 
r
("umed ipުsidީed idtif" + 
id
.
to_rg
(), 
pe
);

1735 i(
	gi
 < 
	gd
) {

1736 cڡ * 
	go
 = 
posi
; 
	gposi
 = 
i
;

1737 *
	gschema
 << 
r_vue_schema
(
id
.
d
);

1738 
	gposi
 = 
o
;

1743  
	gschema
;

1747 
Funi_Cl
* 
	gPr
::
r_lc_funi
()

1749 
x
< 
idtifr
 >();

1750 
	gd
::
rg
 
me
(
xed
);

1751 
PrS
 
	g_pos
 = 
pe
;

1752 
	gx
< 
	gexaly
<'('> >();

1753 
PrS
 
	gg_pos
 = 
pe
;

1754 cڡ * 
	gg_beg
 = 
posi
;

1755 
r_li
();

1756 cڡ * 
	gg_d
 = 
posi
;

1757 
	gx
< 
	gsk_ov_sces
 <

1758 
	gexaly
 < '(' >,

1759 
	gexaly
 < ')' >

1762 
Argumt
* 
	gg
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumt, 
g_pos
, 
r_ީed_chunk
(
Tok
(
g_beg
, 
g_d
)));

1763 
Argumts
* 
	ggs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Argumts, 
g_pos
);

1764 *
	ggs
 << 
	gg
;

1765  
SASS_MEMORY_NEW
(
x
.
mem
, 
Funi_Cl
, 
_pos
, 
me
, 
gs
);

1768 
Sg
* 
	gPr
::
r_u_funi_rg
()

1770 
d
::
rg
 
efix
("");

1771 i(
	gx
< 
	guri_efix
 >()) {

1772 
	gefix
 = 
d
::
rg
(
xed
);

1775 
	gx
 < 
	gtiڮ_as
 >();

1776 
Sg
* 
	gu_rg
 = 
r_u_funi_gumt
();

1778 
	gd
::
rg
 
suffix
("");

1779 i(
	gx
< 
	g_uri_suffix
 >()) {

1780 
	gsuffix
 = 
d
::
rg
(
xed
);

1783 
	gd
::
rg
 
uri
("");

1784 i(
	gu_rg
) {

1785 
	guri
 = 
u_rg
->
to_rg
({ 
NESTED
, 5 });

1788 i(
Sg_Schema
* 
	gschema
 = 
dymic_
<Sg_Schema*>(
u_rg
)) {

1789 
Sg_Schema
* 
s
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

1790 (*
	gs
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
efix
);

1791 (*
	gs
+
schema
;

1792 (*
	gs
<< 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
suffix
);

1793  
	gs
;

1795 
	gd
::
rg
 
s
 = 
efix
 + 
uri
 + 
suffix
;

1796  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
s
);

1800 
Sg
* 
	gPr
::
r_u_funi_gumt
()

1802 cڡ * 
p
 = 
posi
;

1804 
	gd
::
rg
 
uri
("");

1805 i(
	gx
< 
	g_uri_vue
 >(
	gl
)) {

1806 
	guri
 = 
xed
.
to_rg
();

1809 i(
	gek
< 
	gexaly
< 
	ghash_lb
 > >()) {

1810 cڡ * 
	g
 = 
posi
;

1812 
	g
 && 
	gek
< 
	gexaly
< 
	ghash_lb
 > >(pp)) {

1813 
	g
 = 
qu
< 
ުt
, 
	g_uri_vue
 >(pp);

1815 
	gposi
 = 

;

1816  
r_ީed_chunk
(
Tok
(
p
, 
posi
));

1818 i(
	guri
 != "") {

1819 
d
::
rg
 
s
 = 
Ut
::
rim
(
uri
);

1820  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
s
);

1826 
Funi_Cl
* 
	gPr
::
r_funi_
()

1828 
x
< 
idtifr
 >();

1829 
	gd
::
rg
 
me
(
xed
);

1831 
PrS
 
	g_pos
 = 
pe
;

1832 
Argumts
* 
	ggs
 = 
r_gumts
();

1833  
SASS_MEMORY_NEW
(
x
.
mem
, 
Funi_Cl
, 
_pos
, 
me
, 
gs
);

1836 
Funi_Cl_Schema
* 
	gPr
::
r_funi__schema
()

1838 
Sg
* 
me
 = 
r_idtifr_schema
();

1839 
PrS
 
	gsour_posi_of_
 = 
pe
;

1841 
Funi_Cl_Schema
* 
	gthe_
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Funi_Cl_Schema, 
sour_posi_of_
, 
me
, 
r_gumts
());

1842  
	gthe_
;

1845 
Cڋ
* 
	gPr
::
r_cڋ_deive
()

1847 
bo
 
missg_mix_
 = 
ue
;

1848 aut
	g
 : 
ack
) {

1849 i(

 =
Sce
::
Mix
) {

1850 
missg_mix_
 = 
l
;

1854 i(
	gmissg_mix_
) {

1855 
r
("@cڋ may oy bud wh mix", 
pe
);

1857  
SASS_MEMORY_NEW
(
x
.
mem
, 
Cڋ
, 
pe
);

1860 
If
* 
	gPr
::
r_if_deive
(
bo
 
_if
)

1862 
ack
.
push_back
(
Sce
::
Cڌ
);

1863 
PrS
 
	gif_sour_posi
 = 
pe
;

1864 
Exessi
* 
	gedi
 = 
r_li
();

1865 
	gedi
->
is_dayed
(
l
);

1866 
Block
* 
	gblock
 = 
r_block
();

1867 
Block
* 
	give
 = 0;

1871 i(
	gx_css
< 
	gif_deive
 >()) {

1872 
	give
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Block
, 
pe
);

1873 (*
	give
<< 
r_if_deive
(
ue
);

1875 i(
	gx_css
< 
	gkwd__deive
 >()) {

1876 
	give
 = 
r_block
();

1878 
	gack
.
p_back
();

1879  
SASS_MEMORY_NEW
(
x
.
mem
, 
If
, 
if_sour_posi
, 
edi
, 
block
, 
ive
);

1882 
F
* 
	gPr
::
r_f_deive
()

1884 
ack
.
push_back
(
Sce
::
Cڌ
);

1885 
PrS
 
	gf_sour_posi
 = 
pe
;

1886 
x_vb
();

1887 
	gd
::
rg
 
v
(
Ut
::
nmize_undsces
(
xed
));

1888 i(!
	gx
< 
	gkwd_om
 >()
r
("exed 'om' keywd i@f deive", 
pe
);

1889 
Exessi
* 
	glow_bound
 = 
r_exessi
();

1890 
	glow_bound
->
is_dayed
(
l
);

1891 
bo
 
	gusive
 = 
l
;

1892 i(
	gx
< 
	gkwd_through
 >()
	gusive
 = 
ue
;

1893 i(
	gx
< 
	gkwd_to
 >()
	gusive
 = 
l
;

1894 
r
("exed 'through' o'to' keywd i@f deive", 
pe
);

1895 
Exessi
* 
	gu_bound
 = 
r_exessi
();

1896 
	gu_bound
->
is_dayed
(
l
);

1897 
Block
* 
	gbody
 = 
r_block
();

1898 
	gack
.
p_back
();

1899  
SASS_MEMORY_NEW
(
x
.
mem
, 
F
, 
f_sour_posi
, 
v
, 
low_bound
, 
u_bound
, 
body
, 
usive
);

1903 
Tok
 
	gPr
::
x_vb
()

1906 i(!
ek
< 
exaly
 <'$'> >()) {

1907 
css_r
("Invalid CSS", "fter ", ":xpected \"$\", was ");

1910 i(!
	gx
< 
	gqu
 < 
	gexaly
 <'$'>, 
	gidtifr
 > >()) {

1911 
	gx
< 
	gexaly
 <'$'> >();

1912 
css_r
("Invalid CSS", "fter ", ":xpected identifier, was ");

1915  
	gtok
;

1918 
Tok
 
	gPr
::
x_idtifr
()

1921 i(!
x
< 
idtifr
 >()) {

1922 
css_r
("Invalid CSS", "fter ", ":xpected identifier, was ");

1925  
	gtok
;

1928 
Each
* 
	gPr
::
r_ch_deive
()

1930 
ack
.
push_back
(
Sce
::
Cڌ
);

1931 
PrS
 
	gch_sour_posi
 = 
pe
;

1932 
	gd
::
ve
<
d
::
rg
> 
vs
;

1933 
x_vb
();

1934 
	gvs
.
push_back
(
Ut
::
nmize_undsces
(
xed
));

1935 
	gx
< 
	gexaly
<','> >()) {

1936 i(!
	gx
< 
	gvb
 >()
r
("@ch deivque iti vb", 
pe
);

1937 
	gvs
.
push_back
(
Ut
::
nmize_undsces
(
xed
));

1939 i(!
	gx
< 
	gkwd_
 >()
r
("exed '' keywd i@ch deive", 
pe
);

1940 
Exessi
* 
	gli
 = 
r_li
();

1941 
	gli
->
is_dayed
(
l
);

1942 i(
	gli
->
ce_ty
(=
Exessi
::
LIST
) {

1943 
Li
* 
l
 = 
ic_
<Li*>(
li
);

1944 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

1945 (*
	gl
)[
i
]->
is_dayed
(
l
);

1948 
Block
* 
	gbody
 = 
r_block
();

1949 
	gack
.
p_back
();

1950  
SASS_MEMORY_NEW
(
x
.
mem
, 
Each
, 
ch_sour_posi
, 
vs
, 
li
, 
body
);

1954 
Whe
* 
	gPr
::
r_whe_deive
()

1956 
ack
.
push_back
(
Sce
::
Cڌ
);

1958 
Whe
* 
	g
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Whe, 
pe
, 0, 0);

1960 
Exessi
* 
	gedi
 = 
r_li
();

1961 
	gedi
->
is_dayed
(
l
);

1962 
	g
->
edi
(predicate);

1964 
	g
->
block
(
r_block
());

1966 
	gack
.
p_back
();

1968  
	g
;

1972 
Med_Block
* 
	gPr
::
r_med_block
()

1974 
ack
.
push_back
(
Sce
::
Med
);

1975 
Med_Block
* 
	gmed_block
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Med_Block, 
pe
, 0, 0);

1976 
	gmed_block
->
med_qus
(
r_med_qus
());

1978 
Med_Block
* 
	gev_med_block
 = 
ϡ_med_block
;

1979 
	gϡ_med_block
 = 
med_block
;

1980 
	gmed_block
->
block
(
r_css_block
());

1981 
	gϡ_med_block
 = 
ev_med_block
;

1982 
	gack
.
p_back
();

1983  
	gmed_block
;

1986 
Li
* 
	gPr
::
r_med_qus
()

1988 
Li
* 
med_qus
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
pe
, 0, 
SASS_COMMA
);

1989 i(!
	gek_css
 < 
	gexaly
 <'{'> >()(*
	gmed_qus
<< 
r_med_quy
();

1990 
	gx_css
 < 
	gexaly
 <','> >()(*
	gmed_qus
<< 
r_med_quy
();

1991  
	gmed_qus
;

1995 
Med_Quy
* 
	gPr
::
r_med_quy
()

1997 
Med_Quy
* 
med_quy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Med_Quy, 
pe
);

1999 
	gx
 < 
	gcss_commts
 >(
	gl
);

2000 i(
	gx
 < 
	gkwd_n
 >()
	gmed_quy
->
is_ged
(
ue
);

2001 i(
	gx
 < 
	gkwd_ly
 >()
	gmed_quy
->
is_ried
(
ue
);

2003 
	gx
 < 
	gcss_commts
 >(
	gl
);

2004 i(
	gx
 < 
	gidtifr_schema
 >()
	gmed_quy
->
med_ty
(
r_idtifr_schema
());

2005 i(
	gx
 < 
	gidtifr
 >()
	gmed_quy
->
med_ty
(
r_ީed_chunk
(
xed
));

2006 (*
	gmed_quy
<< 
r_med_exessi
();

2008 
	gx_css
 < 
	gkwd_d
 >()(*
	gmed_quy
<< 
r_med_exessi
();

2009 i(
	gx
 < 
	gidtifr_schema
 >()) {

2010 
Sg_Schema
* 
	gschema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

2011 *
	gschema
 << 
	gmed_quy
->
med_ty
();

2012 *
	gschema
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, " ");

2013 *
	gschema
 << 
r_idtifr_schema
();

2014 
	gmed_quy
->
med_ty
(
schema
);

2016 
	gx_css
 < 
	gkwd_d
 >()(*
	gmed_quy
<< 
r_med_exessi
();

2017  
	gmed_quy
;

2020 
Med_Quy_Exessi
* 
	gPr
::
r_med_exessi
()

2022 i(
x
 < 
idtifr_schema
 >()) {

2023 
Sg
* 
ss
 = 
r_idtifr_schema
();

2024  
SASS_MEMORY_NEW
(
x
.
mem
, 
Med_Quy_Exessi
, 
pe
, 
ss
, 0, 
ue
);

2026 i(!
	gx_css
< 
	gexaly
<'('> >()) {

2027 
r
("med quyxessi mu beg wh '('", 
pe
);

2029 
Exessi
* 
	gu
 = 0;

2030 i(
	gek_css
< 
	gexaly
<')'> >()) {

2031 
r
("med ftuequed imed quyxessi", 
pe
);

2033 
	gu
 = 
r_exessi
();

2034 
Exessi
* 
	gexessi
 = 0;

2035 i(
	gx_css
< 
	gexaly
<':'> >()) {

2036 
	gexessi
 = 
r_li
();

2038 i(!
	gx_css
< 
	gexaly
<')'> >()) {

2039 
r
("unodthesi med quyxessi", 
pe
);

2041  
SASS_MEMORY_NEW
(
x
.
mem
, 
Med_Quy_Exessi
, 
u
->
pe
(), ftu, 
exessi
);

2046 
Suts_Block
* 
	gPr
::
r_suts_deive
()

2048 
Suts_Cdi
* 
cd
 = 
r_suts_cdi
();

2050 
Suts_Block
* 
	gquy
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Suts_Block, 
pe
, 
cd
);

2053 
	gquy
->
block
(
r_block
());

2055  
	gquy
;

2060 
Suts_Cdi
* 
	gPr
::
r_suts_cdi
()

2062 
x
 < 
css_whea
 >();

2063 
Suts_Cdi
* 
	gcd
 = 
r_suts_gi
();

2064 i(!
	gcd
cd = 
r_suts_ݔ
();

2065 i(!
	gcd
cd = 
r_suts_ީi
();

2066  
	gcd
;

2069 
Suts_Cdi
* 
	gPr
::
r_suts_gi
()

2071 i(!
x
 < 
kwd_n
 >())  0;

2073 
Suts_Cdi
* 
	gcd
 = 
r_suts_cdi__ns
();

2074  
SASS_MEMORY_NEW
(
x
.
mem
, 
Suts_Negi
, 
pe
, 
cd
);

2077 
Suts_Cdi
* 
	gPr
::
r_suts_ݔ
()

2079 
Suts_Cdi
* 
cd
 = 
r_suts_cdi__ns
();

2080 i(!
	gcd
)  0;

2082 
	gue
) {

2083 
	gSuts_Ot
::
Ond
 

 = 
Suts_Ot
::
OR
;

2084 i(
	gx
 < 
	gkwd_d
 >(){ 
	g
 = 
Suts_Ot
::
AND
; }

2085 if(!
	gx
 < 
	gkwd_
 >()) { ; }

2087 
	gx
 < 
	gcss_whea
 >();

2088 
Suts_Cdi
* 
	gright
 = 
r_suts_cdi__ns
();

2091 
	gcd
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Suts_Ot
, 
pe
, 
cd
, 
right
, 

);

2093  
	gcd
;

2096 
Suts_Cdi
* 
	gPr
::
r_suts_ީi
()

2098 i(!
x
 < 
ުt
 >())  0;

2100 
Sg
* 
	g
 = 
r_ީed_chunk
(
xed
);

2101 i(!
	g
)  0;

2103  
SASS_MEMORY_NEW
(
x
.
mem
, 
Suts_Ipީi
, 
pe
, 

);

2108 
Suts_Cdi
* 
	gPr
::
r_suts_dei
()

2110 
Suts_Cdi
* 
cd
 = 0;

2112 
Dei
* 
	gdei
 = 
r_dei
();

2113 i(!
	gdei

r
("@sutcdiڃxed dei", 
pe
);

2114 
	gcd
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Suts_Dei
,

2115 
dei
->
pe
(),

2116 
dei
->
ݔty
(),

2117 
dei
->
vue
());

2119  
	gcd
;

2122 
Suts_Cdi
* 
	gPr
::
r_suts_cdi__ns
()

2124 
Suts_Cdi
* 

 = 
r_suts_ީi
();

2125 i(
	g
 !0 

;

2127 i(!
	gx
 < 
	gexaly
 <'('> >())  0;

2128 
	gx
 < 
	gcss_whea
 >();

2130 
Suts_Cdi
* 
	gcd
 = 
r_suts_cdi
();

2131 i(
	gcd
 != 0) {

2132 i(!
x
 < 
exaly
 <')'> >()
r
("unodthesi @sutdei", 
pe
);

2134 
	gcd
 = 
r_suts_dei
();

2135 i(!
	gx
 < 
	gexaly
 <')'> >()
r
("unodthesi @sutdei", 
pe
);

2137 
	gx
 < 
	gcss_whea
 >();

2138  
	gcd
;

2141 
At_Ro_Block
* 
	gPr
::
r__ro_block
()

2143 
PrS
 
_sour_posi
 = 
pe
;

2144 
Block
* 
	gbody
 = 0;

2145 
At_Ro_Quy
* 
	gex
 = 0;

2146 
Lookahd
 
	glookahd_su
;

2147 
LOCAL_FLAG
(
__ro
, 
ue
);

2148 i(
	gx_css
< 
	gexaly
<'('> >()) {

2149 
	gex
 = 
r__ro_quy
();

2151 i(
	gek_css
 < 
	gexaly
<'{'> >()) {

2152 
	gx
 <
	gtiڮ_as
>();

2153 
	gbody
 = 
r_block
(
ue
);

2155 i((
	glookahd_su
 = 
lookahd_f_
(
posi
)).
found
) {

2156 
Ruˣt
* 
r
 = 
r_ruˣt
(
lookahd_su
, 
l
);

2157 
	gbody
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
Block
, 
r
->
pe
(), 1, 
ue
);

2158 *
	gbody
 << 
	gr
;

2160 
At_Ro_Block
* 
	g_ro
 = 
SASS_MEMORY_NEW
(
x
.
mem
, At_Ro_Block, 
_sour_posi
, 
body
);

2161 i(
	gex

	g_ro
->
exessi
(
ex
);

2162  
	g_ro
;

2165 
At_Ro_Quy
* 
	gPr
::
r__ro_quy
()

2167 i(
ek
< 
exaly
<')'> >()
r
("-ro ftuequed i-roكxessi", 
pe
);

2169 i(!
	gek
< 
	gives
< 
	gkwd_wh_deive
, 
	gkwd_whout_deive
 > >()) {

2170 
css_r
("Invalid CSS", "fter ", ":xpected \"with\" or \"without\", was ");

2173 
Exessi
* 
	gu
 = 
r_li
();

2174 i(!
	gx_css
< 
	gexaly
<':'> >()
r
("y dei mu cڏ vue", 
pe
);

2175 
Exessi
* 
	gexessi
 = 
r_li
();

2176 
Li
* 
	gvue
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Li, 
u
->
pe
(), 1);

2178 i(
	gexessi
->
ce_ty
(=
Exessi
::
LIST
) {

2179 
vue
 = 
ic_
<
Li
*>(
exessi
);

2181 *
	gvue
 << 
	gexessi
;

2183 
At_Ro_Quy
* 
	gcd
 = 
SASS_MEMORY_NEW
(
x
.
mem
, At_Root_Query,

2184 
vue
->
pe
(),

2185 
u
,

2186 
vue
);

2187 i(!
	gx_css
< 
	gexaly
<')'> >()
r
("unodthesi @-roكxessi", 
pe
);

2188  
	gcd
;

2191 
Deive
* 
	gPr
::
r_ecl_deive
()

2193 
d
::
rg
 
kwd
(
xed
);

2195 i(
	gxed
 ="@"
r
("Invid CSS: @ mu coma @if", 
pe
);

2197 
Deive
* 
	g_ru
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Deive, 
pe
, 
kwd
);

2198 
Lookahd
 
	glookahd
 = 
lookahd_f_ude
(
posi
);

2199 i(
	glookahd
.
	gfound
 && !lookahd.
	ghas_ުts
) {

2200 
	g_ru
->

(
r__li
(
ue
));

2203 
	gx
 < 
	gcss_commts
 >(
	gl
);

2205 i(
	gx
 < 
	gic_ݔty
 >()) {

2206 
	g_ru
->
vue
(
r_ީed_chunk
(
Tok
(
xed
)));

2207 } i(!(
	gek
 < 
	gives
 < 
	gexaly
<'{'>,xactly<'}'>,xactly<';'> > >())) {

2208 
	g_ru
->
vue
(
r_li
());

2211 
	gx
 < 
	gcss_commts
 >(
	gl
);

2213 i(
	gek
< 
	gexaly
<'{'> >()) {

2214 
	g_ru
->
block
(
r_block
());

2217  
	g_ru
;

2220 
Deive
* 
	gPr
::
r_efixed_deive
()

2222 
d
::
rg
 
kwd
(
xed
);

2224 i(
	gxed
 ="@"
r
("Invid CSS: @ mu coma @if", 
pe
);

2226 
Deive
* 
	g_ru
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Deive, 
pe
, 
kwd
);

2227 
Lookahd
 
	glookahd
 = 
lookahd_f_ude
(
posi
);

2228 i(
	glookahd
.
	gfound
 && !lookahd.
	ghas_ުts
) {

2229 
	g_ru
->

(
r__li
(
ue
));

2232 
	gx
 < 
	gcss_commts
 >(
	gl
);

2234 i(
	gx
 < 
	gic_ݔty
 >()) {

2235 
	g_ru
->
vue
(
r_ީed_chunk
(
Tok
(
xed
)));

2236 } i(!(
	gek
 < 
	gives
 < 
	gexaly
<'{'>,xactly<'}'>,xactly<';'> > >())) {

2237 
	g_ru
->
vue
(
r_li
());

2240 
	gx
 < 
	gcss_commts
 >(
	gl
);

2242 i(
	gek
< 
	gexaly
<'{'> >()) {

2243 
	g_ru
->
block
(
r_block
());

2246  
	g_ru
;

2250 
Deive
* 
	gPr
::
r_deive
()

2252 
Deive
* 
deive
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Deive, 
pe
, 
xed
);

2253 
Exessi
* 
	gv
 = 
r_mo_y_vue
();

2257 
	gdeive
->
vue
(
v
);

2258 i(
	gek
< 
	gexaly
<'{'> >()) {

2259 
	gdeive
->
block
(
r_block
());

2260 } i(!
	gv
) {

2261 
css_r
("most def");

2263  
	gdeive
;

2266 
Exessi
* 
	gPr
::
x_ީi
()

2268 i(
x
 < 
ުt
 >(
ue
!
NULL
) {

2269  
r_ީed_chunk
(
xed
, 
ue
);

2274 
Exessi
* 
	gPr
::
x__uri
()

2277  
x_
< 
_rg_uri_ݒ
, 
	g_rg_uri_o
 >();

2280 
Exessi
* 
	gPr
::
x__rg
()

2282 
Exessi
* 
rv
 = 0;

2283 i((
	grv
 = 
x_
< 
_rg_doub_ݒ
, 
	g_rg_doub_o
 >()!
NULL
 
rv
;

2284 i((
	grv
 = 
x_
< 
_rg_sg_ݒ
, 
	g_rg_sg_o
 >()!
NULL
 
rv
;

2285  
	grv
;

2288 
Exessi
* 
	gPr
::
x_mo_y_vue_chs
()

2290 cڡ * 
mch
 =

2291 
x
 <

2292 
e_us
 <

2293 
ives
 <

2294 
qu
 <

2295 
exaly
 <'\\'>,

2296 
	gy_ch


2298 
	gqu
 <

2299 
	gge
 <

2300 
	gqu
 <

2301 
	gexaly
 < 
	gu_kwd
 >,

2302 
	gexaly
 <'('>

2305 
	gg_ass_ch
 <

2306 
	gmo_y_vue_ass


2309 
	gqu
 <

2310 
	gexaly
 <'/'>,

2311 
	gge
 <

2312 
	gives
 <

2313 
	gexaly
 <'/'>,

2314 
	gexaly
 <'*'>

2318 
	gqu
 <

2319 
	gexaly
 <'\\'>,

2320 
	gexaly
 <'#'>,

2321 
	gge
 <

2322 
	gexaly
 <'{'>

2325 
	gqu
 <

2326 
	gexaly
 <'!'>,

2327 
	gge
 <

2328 
	gpha


2333 >(
	gl
);

2334 i(
	gmch
) {

2336  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

2338  
	gNULL
;

2341 
Exessi
* 
	gPr
::
x_mo_y_vue_tok
()

2343 
Exessi
* 
rv
 = 0;

2344 i(*
	gposi
 == 0)  0;

2345 i((
	grv
 = 
x_mo_y_vue_chs
()!
NULL
 
rv
;

2348 i((
	grv
 = 
x__rg
()!
NULL
 
rv
;

2349 i((
	grv
 = 
x__uri
()!
NULL
 
rv
;

2350 i((
	grv
 = 
x_ީi
()!
NULL
 
rv
;

2351  
	grv
;

2354 
Sg_Schema
* 
	gPr
::
r_mo_y_vue
()

2357 
Sg_Schema
* 
schema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

2358 i(*
	gposi
 == 0)  0;

2359 
	gx
 < 
	gas
 >(
	gl
);

2360 
Exessi
* 
	gtok
 = 
x_mo_y_vue_tok
();

2361 i(!
	gtok
)  0;

2363 *
	gschema
 << 
	gtok
;

2364 i(*
	gposi
 == 0) {

2365 
schema
->
rim
();

2366  
	gschema
;

2369 (
	gtok
 = 
x_mo_y_vue_tok
())) {

2370 *
schema
 << 
tok
;

2373 
	gx
 < 
	gcss_whea
 >();

2375 
	gschema
->
rim
();

2377  
	gschema
;

2380 
Wng
* 
	gPr
::
r_wng
()

2382 i(
ack
.
back
(!
Sce
::
Ro
 &&

2383 
ack
.
back
(!
Sce
::
Funi
 &&

2384 
ack
.
back
(!
Sce
::
Mix
 &&

2385 
ack
.
back
(!
Sce
::
Cڌ
 &&

2386 
ack
.
back
(!
Sce
::
Rus
) {

2387 
r
("Iegeg: Oyrݔtmay báed bthrݔts.", 
pe
);

2389  
SASS_MEMORY_NEW
(
x
.
mem
, 
Wng
, 
pe
, 
r_li
());

2392 
E
* 
	gPr
::
r_r
()

2394 i(
ack
.
back
(!
Sce
::
Ro
 &&

2395 
ack
.
back
(!
Sce
::
Funi
 &&

2396 
ack
.
back
(!
Sce
::
Mix
 &&

2397 
ack
.
back
(!
Sce
::
Cڌ
 &&

2398 
ack
.
back
(!
Sce
::
Rus
) {

2399 
r
("Iegeg: Oyrݔtmay báed bthrݔts.", 
pe
);

2401  
SASS_MEMORY_NEW
(
x
.
mem
, 
E
, 
pe
, 
r_li
());

2404 
Debug
* 
	gPr
::
r_debug
()

2406 i(
ack
.
back
(!
Sce
::
Ro
 &&

2407 
ack
.
back
(!
Sce
::
Funi
 &&

2408 
ack
.
back
(!
Sce
::
Mix
 &&

2409 
ack
.
back
(!
Sce
::
Cڌ
 &&

2410 
ack
.
back
(!
Sce
::
Rus
) {

2411 
r
("Iegeg: Oyrݔtmay báed bthrݔts.", 
pe
);

2413  
SASS_MEMORY_NEW
(
x
.
mem
, 
Debug
, 
pe
, 
r_li
());

2416 
Ru
* 
	gPr
::
r_tu_deive
()

2419 i(
ek_css
 < 
ives
 < 
exaly
 < ';' >, 
	gexaly
 < '}' >, 
	gd_of_fe
 > >())

2420 { 
css_r
("Invalid CSS", "fter ", ":xpectedxpression (e.g. 1px, bold), was "); }

2421  
SASS_MEMORY_NEW
(
x
.
mem
, 
Ru
, 
pe
, 
r_li
());

2424 
Lookahd
 
	gPr
::
lookahd_f_
(cڡ * 
t
)

2427 
Lookahd
 
rv
 = Lookahead();

2429 cڡ * 
	gp
 = 
t
 ? s : 
posi
;

2431 
	grv
.
	gr
 = 
p
;

2432 i(cڡ * 
	gq
 =

2433 
ek
 <

2434 
__li


2435 >(
p
)

2437 
p
 < 
q
) {

2439 i(*
p
 == '#' && *(p+1) == '{') {

2440 
rv
.
has_ުts
 = 
ue
;

2441 
	gp
 = 
q
; ;

2443 ++ 
	gp
;

2449 
	grv
.
	gr
 = 
q
;

2450 
	grv
.
	gposi
 = 
q
;

2453 i(
	gek
 < 
	gexaly
<'{'> >(
	gq
)
	grv
.
	gfound
 = 
q
;

2454 i(
	gek
 < 
	gexaly
<'('> >(
	gq
)
	grv
.
	gfound
 = 
q
;

2457 i(
	grv
.
	gfound
 || *
	gp
 =0
rv
.
r
 = 0;

2460 
	grv
.
	grb
 = ! 
rv
.
has_ުts
;

2463  
	grv
;

2470 
Lookahd
 
	gPr
::
lookahd_f_ude
(cڡ * 
t
)

2473 
Lookahd
 
rv
 = 
lookahd_f_
(
t
);

2475 i(cڡ * 
	gp
 = 
rv
.
posi
) {

2477 i(
ek
 < 
exaly
<';'> >(
p
)
rv
.
found
 =;

2478 i(
	gek
 < 
	gexaly
<'}'> >(
	gp
)
	grv
.
	gfound
 = 
p
;

2481  
	grv
;

2489 
Lookahd
 
	gPr
::
lookahd_f_vue
(cڡ * 
t
)

2492 
Lookahd
 
rv
 = Lookahead();

2494 cڡ * 
	gp
 = 
t
 ? s : 
posi
;

2496 i(cڡ * 
	gq
 =

2497 
ek
 <

2498 
n_gedy
 <

2499 
ives
 <

2501 
block_commt
,

2503 
	gqu
 <

2504 
	gުt
,

2505 
	gtiڮ
 <

2506 
	gqued_rg


2509 
	gidtifr
,

2510 
	gvb
,

2512 
	gqu
 <

2513 
	ghe_sce
,

2514 
	gުt
,

2515 
	gtiڮ
 <

2516 
	gqued_rg


2520 
	gqu
 <

2522 
	gives
 <

2523 
	gexaly
<'{'>,

2524 
	gexaly
<'}'>,

2525 
	gexaly
<';'>

2529 >(
	gp
)

2531 i(
	gp
 =
q
 
rv
;

2532 
	gp
 < 
	gq
) {

2534 i(*
	gp
 ='#' && *(
p
+1) == '{') {

2535 
rv
.
has_ުts
 = 
ue
;

2536 
	gp
 = 
q
; ;

2538 ++ 
	gp
;

2542 
	grv
.
	gposi
 = 
q
;

2545 i(
	gek
 < 
	gexaly
<'{'> >(
	gq
)
	grv
.
	gfound
 = 
q
;

2546 i(
	gek
 < 
	gexaly
<';'> >(
	gq
)
	grv
.
	gfound
 = 
q
;

2547 i(
	gek
 < 
	gexaly
<'}'> >(
	gq
)
	grv
.
	gfound
 = 
q
;

2551  
	grv
;

2555 
	gPr
::
ad_bom
()

2557 
size_t
 
sk
 = 0;

2558 
	gd
::
rg
 
codg
;

2559 
bo
 
	gutf_8
 = 
l
;

2560 (
	gsour
[0]) {

2562 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
utf_8_bom
, 3);

2563 
	gcodg
 = "UTF-8";

2564 
	gutf_8
 = 
ue
;

2567 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
utf_16_bom_be
, 2);

2568 
	gcodg
 = "UTF-16 (bigndian)";

2571 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
utf_16_bom_
, 2);

2572 
	gsk
 +(
sk
 ? 
check_bom_chs
(
sour
, 
d
, 
utf_32_bom_
, 4) : 0);

2573 
	gcodg
 = (
sk
 == 2 ? "UTF-16 (littlendian)" : "UTF-32 (littlendian)");

2576 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
utf_32_bom_be
, 4);

2577 
	gcodg
 = "UTF-32 (bigndian)";

2580 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
utf_7_bom_1
, 4)

2581 | 
check_bom_chs
(
sour
, 
d
, 
utf_7_bom_2
, 4)

2582 | 
check_bom_chs
(
sour
, 
d
, 
utf_7_bom_3
, 4)

2583 | 
check_bom_chs
(
sour
, 
d
, 
utf_7_bom_4
, 4)

2584 | 
check_bom_chs
(
sour
, 
d
, 
utf_7_bom_5
, 5);

2585 
	gcodg
 = "UTF-7";

2588 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
utf_1_bom
, 3);

2589 
	gcodg
 = "UTF-1";

2592 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
utf_ebcdic_bom
, 4);

2593 
	gcodg
 = "UTF-EBCDIC";

2596 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
scsu_bom
, 3);

2597 
	gcodg
 = "SCSU";

2600 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
bocu_1_bom
, 3);

2601 
	gcodg
 = "BOCU-1";

2604 
sk
 = 
check_bom_chs
(
sour
, 
d
, 
gb_18030_bom
, 4);

2605 
	gcodg
 = "GB-18030";

2608 i(
	gsk
 > 0 && !
	gutf_8

r
("ly UTF-8 documtcuy su܋d; youdocumtb" + 
codg
, 
pe
);

2609 
	gposi
 +
sk
;

2612 
size_t
 
check_bom_chs
(cڡ * 
c
, cڡ *
d
, cڡ * 
bom
, size_
n
)

2614 
size_t
 
	gsk
 = 0;

2615 i(
	gc
 + 
	gn
 > 
	gd
)  0;

2616 
size_t
 
	gi
 = 0; i < 
	gn
; ++i, ++
	gsk
) {

2617 i((
	gc
[
i
] !
bom
[i])  0;

2619  
	gsk
;

2623 
Exessi
* 
	gPr
::
fd_ݔds
(Exessi* 
ba
, 
d
::
ve
<Exessi*>& 
ݔds
, 
Ond
 

)

2625 
size_t
 
	gi
 = 0, 
	gS
 = 
ݔds
.
size
(); i < S; ++i) {

2626 
	gba
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
By_Exessi
, 
pe
, 

, 
ba
, 
ݔds
[
i
]);

2627 
By_Exessi
* 
	gb
 = 
ic_
<By_Exessi*>(
ba
);

2628 i(
	g
.
	gݔd
 =
Sass_OP
::
DIV
 && 
b
->

()->
is_dayed
(&& b->
right
()->is_delayed()) {

2629 
ba
->
is_dayed
(
ue
);

2631 i(
	gb
 && b->

().
	gݔd
 !
Sass_OP
::
DIV
) {

2632 
b
->

()->
is_dayed
(
l
);

2633 
	gb
->
right
()->
is_dayed
(
l
);

2636  
	gba
;

2639 
Exessi
* 
	gPr
::
fd_ݔds
(Exessi* 
ba
, 
d
::
ve
<Exessi*>& 
ݔds
, std::ve<
Ond
>& 
s
, 
size_t
 
i
)

2642 i(
Sg_Schema
* 
	gschema
 = 
dymic_
<Sg_Schema*>(
ba
)) {

2644 i(
schema
->
has_ުts
()) {

2645 i(
i
 + 1 < 
ݔds
.
size
() && (

2646 (
s
[0].
ݔd
 =
Sass_OP
::
EQ
)

2647 || (
s
[0].
ݔd
 =
Sass_OP
::
ADD
)

2648 || (
s
[0].
ݔd
 =
Sass_OP
::
DIV
)

2649 || (
s
[0].
ݔd
 =
Sass_OP
::
MUL
)

2650 || (
s
[0].
ݔd
 =
Sass_OP
::
NEQ
)

2651 || (
s
[0].
ݔd
 =
Sass_OP
::
LT
)

2652 || (
s
[0].
ݔd
 =
Sass_OP
::
GT
)

2653 || (
s
[0].
ݔd
 =
Sass_OP
::
LTE
)

2654 || (
s
[0].
ݔd
 =
Sass_OP
::
GTE
)

2656 
Exessi
* 
rhs
 = 
fd_ݔds
(
ݔds
[0], onds, 
s
, 1);

2657 
	grhs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
By_Exessi
, 
ba
->
pe
(), 
s
[0], 
schema
, 
rhs
);

2658 
	grhs
->
t_dayed
(
l
);

2659 
	grhs
->
is_dayed
(
ue
);

2660  
	grhs
;

2666 
size_t
 
	gS
 = 
ݔds
.
size
(); 
	gi
 < S; ++i) {

2667 i(
Sg_Schema
* 
	gschema
 = 
dymic_
<Sg_Schema*>(
ݔds
[
i
])) {

2668 i(
schema
->
has_ުts
()) {

2669 i(
i
 + 1 < 
S
) {

2670 
Exessi
* 
rhs
 = 
fd_ݔds
(
ݔds
[
i
+1], onds, 
s
, i + 2);

2671 
	grhs
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
By_Exessi
, 
ba
->
pe
(), 
s
[
i
], 
schema
, 
rhs
);

2672 
	gba
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
By_Exessi
, 
ba
->
pe
(), 
s
[
i
], ba, 
rhs
);

2673 
	grhs
->
is_dayed
(
ue
);

2674 
	gba
->
is_dayed
(
ue
);

2675  
	gba
;

2677 
	gba
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
By_Exessi
, 
ba
->
pe
(), 
s
[
i
], ba, 
ݔds
[i]);

2678 i(
	gs
[
i
].
	gݔd
 !
Sass_OP
::
DIV

ba
->
is_dayed
(
ue
);

2679  
	gba
;

2681 
	gba
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
By_Exessi
, 
ba
->
pe
(), 
s
[
i
], ba, 
ݔds
[i]);

2684 
	gba
 = 
SASS_MEMORY_NEW
(
x
.
mem
, 
By_Exessi
, 
ba
->
pe
(), 
s
[
i
], ba, 
ݔds
[i]);

2686 
By_Exessi
* 
	gb
 = 
ic_
<By_Exessi*>(
ba
);

2687 i(
	gb
 && 
	gs
[
i
].
	gݔd
 =
Sass_OP
::
DIV
 && 
b
->

()->
is_dayed
(&& b->
right
()->is_delayed()) {

2688 
ba
->
is_dayed
(
ue
);

2690 i(
	gb
) {

2691 
	gb
->

()->
is_dayed
(
l
);

2692 
	gb
->
right
()->
is_dayed
(
l
);

2696  
	gba
;

2699 
	gPr
::
r
(
d
::
rg
 
msg
, 
Posi
 
pos
)

2701 
throw
 
	gExi
::
InvidSass
(
PrS
(
th
, 
sour
, 
pos
.
le
 ?o: 
befe_tok
, 
Offt
(0, 0)), 
msg
);

2705 
	gPr
::
css_r
(cڡ 
d
::
rg
& 
msg
, cڡ std::rg& 
efix
, cڡ std::rg& 
midd
)

2707 
max_n
 = 18;

2708 cڡ * 
	gd
 = 
this
->
d
;

2709 *
	gd
 !0++ 
d
;

2710 cڡ * 
	gpos
 = 
ek
 < 
tiڮ_as
 >();

2712 cڡ * 
ϡ_pos
(
pos
);

2713 i(
	gϡ_pos
 > 
	gsour
) {

2714 
	gutf8
::
i
(
ϡ_pos
, 
sour
);

2717 
	gϡ_pos
 > 
	gsour
 &&a_po< 
	gd
) {

2718 i(!
	gPx
::
is_a
(*
ϡ_pos
)) ;

2719 
	gutf8
::
i
(
ϡ_pos
, 
sour
);

2722 
bo
 
	glsis_
 = 
l
;

2723 cڡ * 
pos_
(
ϡ_pos
);

2724 cڡ * 
d_
(
ϡ_pos
);

2726 
	gutf8
::
xt
(
pos_
, 
d
);

2727 
	gutf8
::
xt
(
d_
, 
d
);

2728 
	gpos_
 > 
	gsour
) {

2729 i(
	gutf8
::
di
(
pos_
, 
d_
>
max_n
) {

2730 
utf8
::
i
(
pos_
, 
sour
);

2731 
	glsis_
 = *(
pos_
) != '\n' &&

2732 *(
pos_
) != '\r';

2733 
	gutf8
::
xt
(
pos_
, 
d
);

2737 cڡ * 
	gev
 = 
pos_
;

2738 
	gutf8
::
i
(
ev
, 
sour
);

2739 i(*
	gev
 == '\r') ;

2740 i(*
	gev
 == '\n') ;

2741 
	gpos_
 = 
ev
;

2743 i(
	gpos_
 < 
	gsour
) {

2744 
	gpos_
 = 
sour
;

2747 
bo
 
	glsis_right
 = 
l
;

2748 cڡ * 
d_right
(
pos
);

2749 cڡ * 
pos_right
(
pos
);

2750 
	gd_right
 < 
	gd
) {

2751 i(
	gutf8
::
di
(
pos_right
, 
d_right
> 
	gmax_n
) {

2752 
	glsis_
 = *(
pos_right
) != '\n' &&

2753 *(
pos_right
) != '\r';

2756 i(*
	gd_right
 == '\r') ;

2757 i(*
	gd_right
 == '\n') ;

2758 
	gutf8
::
xt
(
d_right
, 
d
);

2762 
	gd
::
rg
 

(
pos_
, 
d_
);

2763 
	gd
::
rg
 
right
(
pos_right
, 
d_right
);

2764 
size_t
 
	g_subpos
 = 

.
size
() > 15 ?eft.size() - 15 : 0;

2765 
size_t
 
	gright_subpos
 = 
right
.
size
() > 15 ?ight.size() - 15 : 0;

2766 i(
	g_subpos
 && 
	glsis_

	g
 = 
lsis
 + 

.
subr
(
_subpos
);

2767 i(
	gright_subpos
 && 
	glsis_right

	gright
 = 
right
.
subr
(
right_subpos
+ 
lsis
;

2769 
r
(
msg
 + 
efix
 + 
que
(

+ 
midd
 + que(
right
), 
pe
);

	@node_modules/node-sass/src/libsass/src/parser.hpp

1 #ide
SASS_PARSER_H


2 
	#SASS_PARSER_H


	)

4 
	~<rg
>

5 
	~<ve
>

7 
	~"a.h
"

8 
	~"posi.h
"

9 
	~"cڋxt.h
"

10 
	~"posi.h
"

11 
	~"ex.h
"

13 
	sLookahd
 {

14 cڡ * 
	mfound
;

15 cڡ * 
	mr
;

16 cڡ * 
	mposi
;

17 
bo
 
	mrb
;

18 
bo
 
	mhas_ުts
;

21 
mea
 
	gSass
 {

23 as
	cPr
 : 
public
 
PrS
 {

24 
public
:

26 
	eSce
 { 
Ro
, 
	gMix
, 
	gFuni
, 
	gMed
, 
	gCڌ
, 
	gPrݔts
, 
	gRus
 };

28 
	gCڋxt
& 
	gx
;

29 
	gd
::
ve
<
Block
*> 
block_ack
;

30 
	gd
::
ve
<
Sce
> 
ack
;

31 
Med_Block
* 
	gϡ_med_block
;

32 cڡ * 
	gsour
;

33 cڡ * 
	gposi
;

34 cڡ * 
	gd
;

35 
Posi
 
	gbefe_tok
;

36 
Posi
 
	ga_tok
;

37 
PrS
 
	gpe
;

38 
	gdti
;

41 
Tok
 
	gxed
;

42 
bo
 
	g__ro
;

44 
Pr
(
Cڋxt
& 
x
, cڡ 
PrS
& 
pe
)

45 : 
PrS
(
pe
), 
x
(x), 
block_ack
(0), 
ack
(0), 
ϡ_med_block
(0),

46 
sour
(0), 
posi
(0), 
d
(0), 
befe_tok
(
pe
), 
a_tok
աe),eաe), 
dti
(0)

47 { 
	g__ro
 = 
l
; 
	gack
.
push_back
(
Sce
::
Ro
); }

50 
Pr
 
om_c_r
(cڡ * 
c
, 
Cڋxt
& 
x
, 
PrS
 
pe
 = PrS("[CSTRING]"), cڡ * 
sour
 = 0);

51 
Pr
 
om_c_r
(cڡ * 
beg
, cڡ * 
d
, 
Cڋxt
& 
x
, 
PrS
 
pe
 = PrS("[CSTRING]"), cڡ * 
sour
 = 0);

52 
Pr
 
om_tok
(
Tok
 
t
, 
Cڋxt
& 
x
, 
PrS
 
pe
 = PrS("[TOKEN]"), cڡ * 
sour
 = 0);

54 
Se_Li
* 
r_
(cڡ * 
c
, 
Cڋxt
& 
x
, 
PrS
 
pe
 = PrS("[SELECTOR]"), cڡ * 
sour
 = 0);

56 #ifde
__g__


63 #agm
g
 
dgnoic
 
push


64 #agm
g
 
dgnoic
 
igned
 "-Wtautological-compare"

69 
bo
 
ek_wle
(cڡ * 
t
 = 0);

72 
	gme
 <
	gPx
::
ex
 
mx
>

73 cڡ * 
k
(cڡ * 
t
 = 0)

75 
usg
 
mea
 
Px
;

78 cڡ * 
	g_posi
 = 
t
 ? s : 
posi
;

81 i(
	gmx
 =
as
 ||

82 
mx
 =
no_as
 ||

83 
mx
 =
css_commts
 ||

84 
mx
 =
css_whea
 ||

85 
mx
 =
tiڮ_as
 ||

86 
mx
 =
tiڮ_css_commts
 ||

87 
mx
 =
tiڮ_css_whea


89  
_posi
;

93 cڡ * 
	gpos
 = 
tiڮ_css_whea
(
_posi
);

95  
	gpos
 ?o: 
_posi
;

101 
	gme
 <
	gPx
::
ex
 
mx
>

102 cڡ * 
mch
(cڡ * 
t
 = 0)

105  
mx
(
posi
);

110 
	gme
 <
	gPx
::
ex
 
mx
>

111 cڡ * 
ek
(cڡ * 
t
 = 0)

116 cڡ * 
_befe_tok
 = 
k
 < 
mx
 >(
t
);

119 cڡ * 
	gmch
 = 
mx
(
_befe_tok
);

122  
	gmch
 <
d
 ? 
mch
 : 0;

132 
	gme
 <
	gPx
::
ex
 
mx
>

133 cڡ * 
x
(
bo
 
zy
 = 
ue
, bo 
f
 = 
l
)

136 i(*
posi
 == 0)  0;

141 cڡ * 
	g_befe_tok
 = 
posi
;

145 i(
	gzy

	g_befe_tok
 = 
k
 < 
mx
 >(
posi
);

148 cڡ * 
	g_a_tok
 = 
mx
(
_befe_tok
);

151 i(
	g_a_tok
 > 
	gd
)  0;

154 i(
	gf
 =
l
) {

156 i(
_a_tok
 == 0)  0;

158 i(
	g_a_tok
 =
_befe_tok
)  0;

162 
	gxed
 = 
Tok
(
posi
, 
_befe_tok
, 
_a_tok
);

165 
	gbefe_tok
 = 
a_tok
.
add
(
posi
, 
_befe_tok
);

168 
	ga_tok
.
add
(
_befe_tok
, 
_a_tok
);

171 
	gpe
 = 
PrS
(
th
, 
sour
, 
xed
, 
befe_tok
, 
a_tok
 - before_token);

174  
	gposi
 = 
_a_tok
;

181 
	gme
 <
	gPx
::
ex
 
mx
>

182 cڡ * 
x_css
()

185 
Tok
 
ev
 = 
xed
;

187 cڡ * 
	gdpos
 = 
posi
;

188 
Posi
 
	gbt
 = 
befe_tok
;

189 
Posi
 
	g
 = 
a_tok
;

190 
PrS
 
	g
 = 
pe
;

193 
	gx
 < 
	gPx
::
css_commts
 >();

195 cڡ * 
	gpos
 = 
x
< 
mx
 >();

197 i(
	gpos
 == 0) {

198 
pe
 = 

;

199 
	gxed
 = 
ev
;

200 
	gposi
 = 
dpos
;

201 
	ga_tok
 = 

;

202 
	gbefe_tok
 = 
bt
;

205  
	gpos
;

209 
	gme
 <
	gPx
::
ex
 
mx
>

210 cڡ * 
ek_css
(cڡ * 
t
 = 0)

213  
ek
< 
mx
 >Փk < 
Px
::
css_commts
 >(
t
));

216 #ifde
__g__


218 #agm
g
 
dgnoic
 
p


222 
r
(
d
::
rg
 
msg
, 
Posi
 
pos
);

225 
css_r
(cڡ 
d
::
rg
& 
msg
,

226 cڡ 
d
::
rg
& 
efix
 = "fter ",

227 cڡ 
d
::
rg
& 
midd
 = ", was: ");

228 
ad_bom
();

230 
Block
* 
r
();

231 
Impt
* 
r_impt
();

232 
Defi
* 
r_defi
(Defi::
Ty
 
which_ty
);

233 
Pams
* 
r_ms
();

234 
Pam
* 
r_m
();

235 
Mix_Cl
* 
r_ude_deive
();

236 
Argumts
* 
r_gumts
();

237 
Argumt
* 
r_gumt
();

238 
Assignmt
* 
r_assignmt
();

240 
Ruˣt
* 
r_ruˣt
(
Lookahd
 
lookahd
, 
bo
 
is_ro
 = 
l
);

241 
Se_Schema
* 
r__schema
(cڡ * 
d_of_
);

242 
Se_Li
* 
r__li
(
bo
 
_ro
 = 
l
);

243 
Comex_Se
* 
r_comex_
(
bo
 
_ro
 = 
ue
);

244 
Compound_Se
* 
r_compound_
();

245 
Sime_Se
* 
r_sime_
();

246 
Wed_Se
* 
r_ged_
();

247 
Sime_Se
* 
r_pudo_
();

248 
Aribu_Se
* 
r_ibu_
();

249 
Block
* 
r_block
(
bo
 
is_ro
 = 
l
);

250 
Block
* 
r_css_block
(
bo
 
is_ro
 = 
l
);

251 
bo
 
r_block_nodes
(bo 
is_ro
 = 
l
);

252 
bo
 
r_block_node
(bo 
is_ro
 = 
l
);

254 
bo
 
r_numb_efix
();

255 
Dei
* 
r_dei
();

256 
Exessi
* 
r_m_vue
();

257 
Exessi
* 
r_m
();

258 
Exessi
* 
r_li
();

259 
Exessi
* 
r_comma_li
();

260 
Exessi
* 
r_a_li
();

261 
Exessi
* 
r_disjuni
();

262 
Exessi
* 
r_cjuni
();

263 
Exessi
* 
r_ti
();

264 
Exessi
* 
r_exessi
();

265 
Exessi
* 
r_ݔs
();

266 
Exessi
* 
r_
();

267 
Exessi
* 
r_vue2
();

268 
Exessi
* 
r_vue
();

269 
Funi_Cl
* 
r_lc_funi
();

270 
Funi_Cl
* 
r_funi_
();

271 
Funi_Cl_Schema
* 
r_funi__schema
();

272 
Sg
* 
r_u_funi_rg
();

273 
Sg
* 
r_u_funi_gumt
();

274 
Sg
* 
r_ީed_chunk
(
Tok
, 
bo
 
cڡt
 = 
l
);

275 
Sg
* 
r_rg
();

276 
Sg_Cڡt
* 
r_ic_exessi
();

278 
Sg_Cڡt
* 
r_ic_vue
();

279 
Sg
* 
r__ݔty
();

280 
Sg
* 
r__keywd_g
();

281 
Sg_Schema
* 
r_vue_schema
(cڡ * 

);

282 
Sg
* 
r_idtifr_schema
();

284 
If
* 
r_if_deive
(
bo
 
_if
 = 
l
);

285 
F
* 
r_f_deive
();

286 
Each
* 
r_ch_deive
();

287 
Whe
* 
r_whe_deive
();

288 
Ru
* 
r_tu_deive
();

289 
Cڋ
* 
r_cڋ_deive
();

290 
r_cht_deive
();

291 
Med_Block
* 
r_med_block
();

292 
Li
* 
r_med_qus
();

293 
Med_Quy
* 
r_med_quy
();

294 
Med_Quy_Exessi
* 
r_med_exessi
();

295 
Suts_Block
* 
r_suts_deive
();

296 
Suts_Cdi
* 
r_suts_cdi
();

297 
Suts_Cdi
* 
r_suts_gi
();

298 
Suts_Cdi
* 
r_suts_ݔ
();

299 
Suts_Cdi
* 
r_suts_ީi
();

300 
Suts_Cdi
* 
r_suts_dei
();

301 
Suts_Cdi
* 
r_suts_cdi__ns
();

302 
At_Ro_Block
* 
r__ro_block
();

303 
At_Ro_Quy
* 
r__ro_quy
();

304 
Sg_Schema
* 
r_mo_y_vue
();

305 
Deive
* 
r_ecl_deive
();

306 
Deive
* 
r_efixed_deive
();

307 
Deive
* 
r_deive
();

308 
Wng
* 
r_wng
();

309 
E
* 
r_r
();

310 
Debug
* 
r_debug
();

313 
Exessi
* 
x_mo_y_vue_tok
();

314 
Exessi
* 
x_mo_y_vue_chs
();

315 
Exessi
* 
x__rg
();

316 
Exessi
* 
x__uri
();

317 
Exessi
* 
x_ީi
();

320 
Tok
 
x_vb
();

321 
Tok
 
x_idtifr
();

323 
r_block_commts
();

325 
Lookahd
 
lookahd_f_vue
(cڡ * 
t
 = 0);

326 
Lookahd
 
lookahd_f_
(cڡ * 
t
 = 0);

327 
Lookahd
 
lookahd_f_ude
(cڡ * 
t
 = 0);

329 
Exessi
* 
fd_ݔds
(Exessi* 
ba
, 
d
::
ve
<Exessi*>& 
ݔds
, 
Ond
 

);

330 
Exessi
* 
fd_ݔds
(Exessi* 
ba
, 
d
::
ve
<Exessi*>& 
ݔds
, std::ve<
Ond
>& 
s
, 
size_t
 
i
 = 0);

332 
throw_syax_r
(
d
::
rg
 
mesge
, 
size_t
 

 = 0);

333 
throw_ad_r
(
d
::
rg
 
mesge
, 
size_t
 

 = 0);

336 
	gme
 <
	gPx
::
ex
 
ݒ
, Px::ex 
o
>

337 
Exessi
* 
x_
()

339 i(
x
 < 
ݒ
 >(
l
)) {

340 
Sg_Schema
* 
schema
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Sg_Schema, 
pe
);

342 *
	gschema
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

343 i(
	gposi
[0] ='#' && 
posi
[1] == '{') {

344 
Exessi
* 

 = 
x_ީi
();

345 i(
	g
*
	gschema
 << itpl;

346 
	gx
 < 
	go
 >(
	gl
)) {

348 *
	gschema
 << 
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

349 i(
	gposi
[0] ='#' && 
posi
[1] == '{') {

350 
Exessi
* 

 = 
x_ީi
();

351 i(
	g
*
	gschema
 << itpl;

353  
	gschema
;

357  
SASS_MEMORY_NEW
(
x
.
mem
, 
Sg_Cڡt
, 
pe
, 
xed
);

364 
size_t
 
check_bom_chs
(cڡ * 
c
, cڡ *
d
, cڡ * 
bom
, size_
n
);

	@node_modules/node-sass/src/libsass/src/paths.hpp

1 #ide
SASS_PATHS_H


2 
	#SASS_PATHS_H


	)

4 
	~<rg
>

5 
	~<ve
>

6 
	~<sam
>

9 
	gme
<
tyme
 
	gT
>

10 
	gd
::
rg
 
ve_to_rg
(
d
::
ve
<
T
> 
v
)

12 
d
::
rgam
 
bufr
;

13 
	gbufr
 << "[";

15 i(!
	gv
.
emy
())

16 { 
	gbufr
 << 
	gv
[0]; }

18 { 
	gbufr
 << "]"; }

20 i(
	gv
.
size
() == 1)

21 { 
bufr
 << "]"; }

24 
size_t
 
	gi
 = 1, 
	gS
 = 
v
.
size
(); i < S; ++i
	gbufr
 << ", " << 
	gv
[
i
];

25 
	gbufr
 << "]";

28  
	gbufr
.
r
();

31 
mea
 
	gSass
 {

34 
	gme
<
tyme
 
	gT
>

35 
	gd
::
ve
<
d
::ve<
T
> > 
ths
(d::ve<d::ve<T> > 

, 
size_t
 
om_d
 = 0)

37 i(

.
emy
()) {

38  
d
::
ve
<d::ve<
T
> >();

41 
size_t
 
	gd
 = 

.
size
(- 
om_d
;

42 i(
	gd
 <= 1) {

43 
d
::
ve
<d::ve<
T
> > 
tg_pots
;

44 
	gtg_pots
.
rve
(

[0].
size
());

45 
size_t
 
	gi
 = 0, 
	gS
 = 

[0].
size
(); i < S; ++i) {

46 
	gd
::
ve
<
T
> 
tg_pot
;

47 
	gtg_pot
.
push_back
(

[0][
i
]);

48 
	gtg_pots
.
push_back
(
tg_pot
);

50  
	gtg_pots
;

53 
	gd
::
ve
<
d
::ve<
T
> > 
up_to_he
 = 
ths
(

, 
om_d
 + 1);

54 
	gd
::
ve
<
T
> 
he
 = 

[
d
-1];

56 
	gd
::
ve
<
d
::ve<
T
> > 
bnches
;

57 
	gbnches
.
rve
(
up_to_he
.
size
(* 
he
.size());

58 
size_t
 
	gi
 = 0, 
	gS1
 = 
up_to_he
.
size
(); i < S1; ++i) {

59 
size_t
 
	gj
 = 0, 
	gS2
 = 
he
.
size
(); j < S2; ++j) {

60 
	gd
::
ve
<
T
> 
bnch
 = 
up_to_he
[
i
];

61 
	gbnch
.
push_back
(
he
[
j
]);

62 
	gbnches
.
push_back
(
bnch
);

66  
	gbnches
;

	@node_modules/node-sass/src/libsass/src/plugins.cpp

1 #ifde
_WIN32


2 
	~<wdows.h
>

4 
	~<sys/tys.h
>

5 
	~<dt.h
>

6 
	~<o.h
>

7 
	~<dlf.h
>

10 
	~"ss.h
"

11 
	~<ioam
>

12 
	~"ouut.h
"

13 
	~"ugs.h
"

15 
mea
 
	gSass
 {

17 
	gPlugs
::
Plugs
() { }

18 
Plugs
::~Plugins() { }

23 
le
 
bo
 
comtiby
(cڡ * 
the_vsi
)

27 cڡ * 
our_vsi
 = 
libss_vsi
();

28 i(!
rcmp
(
the_vsi
, "[]") 
	gl
;

29 i(!
rcmp
(
our_vsi
, "[]") 
	gl
;

32 
size_t
 
	gpos
 = 
d
::
rg
(
our_vsi
).
fd
('.', 0);

33 i(
	gpos
 !
d
::
rg
::
os

pos
 = std::rg(
our_vsi
).
fd
('.',os + 1);

36 i(
	gpos
 =
d
::
rg
::
os
{  
rcmp
(
the_vsi
, 
our_vsi
) ? 0 : 1; }

38 {  
cmp
(
the_vsi
, 
our_vsi
, 
pos
) ? 0 : 1; }

43 
bo
 
	gPlugs
::
ld_ug
 (cڡ 
d
::
rg
& 
th
)

46 cڡ * (*
	t__ug_vsi__
)();

47 
Sass_Funi_Li
 (*
	t__ug_ld_s__
)();

48 
Sass_Imp܋r_Li
 (*
	t__ug_ld_imps__
)();

50 i(
LOAD_LIB
(
ug
, 
th
))

53 i(
LOAD_LIB_FN
(
__ug_vsi__
, 
ug_vsi
, "libsass_get_version"))

56 i(!
comtiby
(
ug_vsi
()) 
	gl
;

58 i(
LOAD_LIB_FN
(
__ug_ld_s__
, 
ug_ld_funis
, "libsass_load_functions"))

60 
Sass_Funi_Li
 
	gs
 = 
ug_ld_funis
();

61 
	gs
 && *s{ 
	gfunis
.
push_back
(*
s
); ++ fns; }

64 i(
LOAD_LIB_FN
(
__ug_ld_imps__
, 
ug_ld_imp܋rs
, "libsass_load_importers"))

66 
Sass_Imp܋r_Li
 
	gimps
 = 
ug_ld_imp܋rs
();

67 
	gimps
 && *imps{ 
	gimp܋rs
.
push_back
(*
imps
); ++ imps; }

70 i(
LOAD_LIB_FN
(
__ug_ld_imps__
, 
ug_ld_hds
, "libsass_load_headers"))

72 
Sass_Imp܋r_Li
 
	gimps
 = 
ug_ld_hds
();

73 
	gimps
 && *imps{ 
	ghds
.
push_back
(*
imps
); ++ imps; }

76  
	gue
;

81 
	gd
::

 << "eddg 'libss_sut' i<" << 
th
 << ">" << 
d
::
dl
;

82 i(cڡ * 
	gdlsym_r
 = 
d˼
()
d
::

 << 
dlsym_r
 << std::
dl
;

83 
CLOSE_LIB
(
ug
);

89 
	gd
::

 << "eddglug <" << 
th
 << ">" << 
d
::
dl
;

90 i(cڡ * 
	gdlݒ_r
 = 
d˼
()
d
::

 << 
dlݒ_r
 << std::
dl
;

93  
	gl
;

97 
size_t
 
	gPlugs
::
ld_ugs
(cڡ 
d
::
rg
& 
th
)

101 
size_t
 
lded
 = 0;

103 #ifde
_WIN32


105 
	gy


109 
WIN32_FIND_DATAW
 
	gda
;

111 
	gd
::
rg
 
globch
(
th
 + "*.dll");

113 
	gd
::
wrg
 
wglobch
(
UTF_8
::
cvt_to_utf16
(
globch
));

114 
HANDLE
 
	ghFe
 = 
FdFFeW
(
wglobch
.
c_r
(), &
da
);

117 i(
	ghFe
 =
INVALID_HANDLE_VALUE
)  -1;

120 
	gue
)

122 
	gy


125 
	gd
::
rg
 
y
 = 
UTF_8
::
cvt_om_utf16
(
da
.
cFeName
);

127 i(!
ds_wh
(
y
, ".dll")) ;

129 i(
ld_ug
(
th
 + 
y
)++ 
	glded
;

131 i(
GLaE
(=
ERROR_NO_MORE_FILES
) ;

133 i(!
FdNextFeW
(
hFe
, &
da
)) ;

135 
tch
 (...)

139 
	gd
::

 << "famlugh havid utf8?" << 
d
::
dl
;

143 
tch
 (
utf8
::
vid_utf8
)

147 
d
::

 << "ugh cڏvid utf8" << std::
dl
;

152 
DIR
 *
	gdp
;

153 
dt
 *
	gdp
;

154 if((
	gdp
 = 
ݒd
(
th
.
c_r
())=
NULL
)  -1;

155 (
	gdp
 = 
add
(
dp
)!
NULL
) {

156 i(!
ds_wh
(
dp
->
d_me
, ".so")) ;

157 i(
ld_ug
(
th
 + 
dp
->
d_me
)++ 
	glded
;

159 
od
(
dp
);

162  
	glded
;

	@node_modules/node-sass/src/libsass/src/plugins.hpp

1 #ide
SASS_PLUGINS_H


2 
	#SASS_PLUGINS_H


	)

4 
	~<rg
>

5 
	~<ve
>

6 
	~"utf8_rg.h
"

7 
	~"ss/funis.h
"

9 #ifde
_WIN32


11 
	#LOAD_LIB
(
v
, 
th

HMODULE
 v = 
	`LdLibryW
(
UTF_8
::
	`cvt_to_utf16
թh).
	`c_r
())

	)

12 
	#LOAD_LIB_WCHR
(
v
, 
th_wide_r

HMODULE
 v = 
	`LdLibryW
թh_wide_r.
	`c_r
())

	)

13 
	#LOAD_LIB_FN
(
ty
, 
v
, 
me
ty v = (ty
	`GProcAddss
(
ug
,ame)

	)

14 
	#CLOSE_LIB
(
v

	`FeLibry
(v)

	)

16 #ide
d˼


17 
	#d˼
(0

	)

22 
	#LOAD_LIB
(
v
, 
th
* v = 
	`dlݒ
թh.
	`c_r
(), 
RTLD_LAZY
)

	)

23 
	#LOAD_LIB_FN
(
ty
, 
v
, 
me
ty v = (ty
	`dlsym
(
ug
,ame)

	)

24 
	#CLOSE_LIB
(
v

	`dlo
(v)

	)

28 
mea
 
	gSass
 {

31 as
	cPlugs
 {

33 
	gpublic
:

34 
Plugs
();

35 ~
Plugs
();

37 
	gpublic
:

39 
bo
 
ld_ug
(cڡ 
d
::
rg
& 
th
);

41 
size_t
 
ld_ugs
(cڡ 
d
::
rg
& 
th
);

43 
	gpublic
:

44 cڡ 
d
::
ve
<
Sass_Imp܋r_Ery
> 
g_hds
({  
hds
; }

45 cڡ 
	gd
::
ve
<
Sass_Imp܋r_Ery
> 
g_imp܋rs
({  
imp܋rs
; }

46 cڡ 
	gd
::
ve
<
Sass_Funi_Ery
> 
g_funis
({  
funis
; }

48 
	give
:

49 
d
::
ve
<
Sass_Imp܋r_Ery
> 
hds
;

50 
	gd
::
ve
<
Sass_Imp܋r_Ery
> 
imp܋rs
;

51 
	gd
::
ve
<
Sass_Funi_Ery
> 
funis
;

	@node_modules/node-sass/src/libsass/src/position.cpp

1 
	~"ss.h
"

2 
	~"posi.h
"

4 
mea
 
	gSass
 {

7 
	gOfft
::
Offt
(cڡ * 
rg
)

8 : 
le
(0), 
cumn
(0)

10 *
	gthis
 = 
c
(
rg
, sg + 

(string));

13 
	gOfft
::
Offt
(cڡ 
d
::
rg
& 
xt
)

14 : 
le
(0), 
cumn
(0)

16 *
	gthis
 = 
c
(
xt
.
c_r
(),ext.c_r(+ext.
size
());

19 
	gOfft
::
Offt
(cڡ 
size_t
 
le
, cڡ size_
cumn
)

20 : 
le
֚e), 
cumn
(column) { }

23 
Offt
 
	gOfft
::

(cڡ * 
beg
, cڡ * 
d
)

25 
Offt
 
offt
(0, 0);

26 i(
	gd
 == 0) {

27 
d
 +

(
beg
);

29 
	gofft
.
add
(
beg
, 
d
);

30  
	gofft
;

36 
Offt
 
	gOfft
::
add
(cڡ * 
beg
, cڡ * 
d
)

38 i(
	gd
 =0 *
this
;

39 
	gbeg
 < 
	gd
 && *begin) {

40 i(*
	gbeg
 == '\n') {

41 ++ 
le
;

43 
	gcumn
 = 0;

45 ++ 
	gcumn
;

47 ++
	gbeg
;

49  *
	gthis
;

54 
Offt
 
	gOfft
::
c
(cڡ * 
beg
, cڡ * 
d
) const

56 
Offt
 
offt
(
le
, 
cumn
);

57 
	gofft
.
add
(
beg
, 
d
);

58  
	gofft
;

61 
bo
 
	gOfft
::
ݔ
=(cڡ 
Offt
 &
pos
) const

63  
le
 =
pos
.l&& 
cumn
 ==os.column;

66 
bo
 
	gOfft
::
ݔ
!(cڡ 
Offt
 &
pos
) const

68  
le
 !
pos
.l|| 
cumn
 !=os.column;

71 
	gOfft
::
ݔ
+(cڡ 
Offt
 &
off
)

73 *
this
 = 
Offt
(
le
 + 
off
.le, off.l> 0 ? off.
cumn
 : column + off.column);

76 
Offt
 
	gOfft
::
ݔ
+ (cڡ Off&
off
) const

78  
Offt
(
le
 + 
off
.le, off.l> 0 ? off.
cumn
 : column + off.column);

81 
Offt
 
	gOfft
::
ݔ
- (cڡ Off&
off
) const

83  
Offt
(
le
 - 
off
.le, off.l=l? 
cumn
 - off.column : column);

86 
	gPosi
::
Posi
(cڡ 
size_t
 
fe
)

87 : 
Offt
(0, 0), 
fe
(file) { }

89 
	gPosi
::
Posi
(cڡ 
size_t
 
fe
, cڡ 
Offt
& 
offt
)

90 : 
Offt
(
offt
), 
fe
(file) { }

92 
	gPosi
::
Posi
(cڡ 
size_t
 
le
, cڡ size_
cumn
)

93 : 
Offt
(
le
, 
cumn
), 
fe
(-1) { }

95 
	gPosi
::
Posi
(cڡ 
size_t
 
fe
, cڡ size_
le
, cڡ size_
cumn
)

96 : 
Offt
(
le
, 
cumn
), 
fe
(file) { }

99 
	gPrS
::
PrS
(cڡ * 
th
, cڡ * 
c
, cڡ 
size_t
 
fe
)

100 : 
Posi
(
fe
, 0, 0), 
th
թh), 
c
(c), 
offt
(0, 0), 
tok
() { }

102 
	gPrS
::
PrS
(cڡ * 
th
, cڡ * 
c
, cڡ 
Posi
& 
posi
, 
Offt
 
offt
)

103 : 
Posi
(
posi
), 
th
թh), 
c
(c), 
offt
(offt), 
tok
() { }

105 
	gPrS
::
PrS
(cڡ * 
th
, cڡ * 
c
, cڡ 
Tok
& 
tok
, cڡ 
Posi
& 
posi
, 
Offt
 
offt
)

106 : 
Posi
(
posi
), 
th
թh), 
c
(c), 
offt
(offt), 
tok
(token) { }

108 
Posi
 
	gPosi
::
add
(cڡ * 
beg
, cڡ * 
d
)

110 
	gOfft
::
add
(
beg
, 
d
);

111  *
	gthis
;

114 
Posi
 
	gPosi
::
c
(cڡ * 
beg
, cڡ * 
d
) const

116 
Offt
 
offt
(
le
, 
cumn
);

117 
	gofft
 = 
offt
.
c
(
beg
, 
d
);

118  
Posi
(
fe
, 
offt
);

121 
bo
 
	gPosi
::
ݔ
=(cڡ 
Posi
 &
pos
) const

123  
fe
 =
pos
.f&& 
le
 =pos.l&& 
cumn
 ==os.column;

126 
bo
 
	gPosi
::
ݔ
!(cڡ 
Posi
 &
pos
) const

128  
fe
 =
pos
.f|| 
le
 !pos.l|| 
cumn
 !=os.column;

131 
	gPosi
::
ݔ
+(cڡ 
Offt
 &
off
)

133 *
this
 = 
Posi
(
fe
, 
le
 + 
off
.le, off.l> 0 ? off.
cumn
 : column + off.column);

136 cڡ 
Posi
 
	gPosi
::
ݔ
+ (cڡ 
Offt
 &
off
) const

138  
Posi
(
fe
, 
le
 + 
off
.le, off.l> 0 ? off.
cumn
 : column + off.column);

141 cڡ 
Offt
 
	gPosi
::
ݔ
- (cڡ Off&
off
) const

143  
Offt
(
le
 - 
off
.le, off.l=l? 
cumn
 - off.column : column);

	@node_modules/node-sass/src/libsass/src/position.hpp

1 #ide
SASS_POSITION_H


2 
	#SASS_POSITION_H


	)

4 
	~<rg
>

5 
	~<crg
>

8 
mea
 
	gSass
 {

11 as
	cOfft
 {

13 
	gpublic
:

14 
Offt
(cڡ * 
rg
);

15 
Offt
(cڡ 
d
::
rg
& 
xt
);

16 
Offt
(cڡ 
size_t
 
le
, cڡ size_
cumn
);

19 
Offt
 
add
(cڡ * 
beg
, cڡ * 
d
);

20 
Offt
 
c
(cڡ * 
beg
, cڡ * 
d
) const;

23 
Offt
 

(cڡ * 
beg
, cڡ * 
d
);

25 
	gpublic
:

26 
ݔ
+(cڡ 
Offt
 &
pos
);

27 
bo
 
	gݔ
=(cڡ 
Offt
 &
pos
) const;

28 
bo
 
	gݔ
!(cڡ 
Offt
 &
pos
) const;

29 
Offt
 
	gݔ
+ (cڡ 
	gOfft
 &
	goff
) const;

30 
Offt
 
	gݔ
- (cڡ 
	gOfft
 &
	goff
) const;

32 
	gpublic
:

35 
public
:

36 
Offt
 
off
({  *
this
; }

38 
	gpublic
:

39 
size_t
 
le
;

40 
size_t
 
	gcumn
;

44 as
	cPosi
 : 
public
 
Offt
 {

46 
public
:

47 
Posi
(cڡ 
size_t
 
fe
);

48 
Posi
(cڡ 
size_t
 
fe
, cڡ 
Offt
& 
offt
);

49 
Posi
(cڡ 
size_t
 
le
, cڡ size_
cumn
);

50 
Posi
(cڡ 
size_t
 
fe
, cڡ size_
le
, cڡ size_
cumn
);

52 
	gpublic
:

53 
ݔ
+(cڡ 
Offt
 &
off
);

54 
bo
 
	gݔ
=(cڡ 
Posi
 &
pos
) const;

55 
bo
 
	gݔ
!(cڡ 
Posi
 &
pos
) const;

56 cڡ 
Posi
 
	gݔ
+ (cڡ 
	gOfft
 &
	goff
) const;

57 cڡ 
Offt
 
	gݔ
- (cڡ 
	gOfft
 &
	goff
) const;

59 
Posi
 
add
(cڡ * 
beg
, cڡ * 
d
);

60 
Posi
 
c
(cڡ * 
beg
, cڡ * 
d
) const;

62 
	gpublic
:

65 
public
:

66 
size_t
 
fe
;

71 as
	cTok
 {

72 
	gpublic
:

73 cڡ * 
efix
;

74 cڡ * 
	gbeg
;

75 cڡ * 
	gd
;

77 
Tok
()

78 : 
efix
(0), 
beg
(0), 
d
(0) { }

79 
Tok
(cڡ * 
b
, cڡ * 
e
)

80 : 
efix
(
b
), 
beg
(b), 
d
(
e
) { }

81 
Tok
(cڡ * 
r
)

82 : 
efix
(
r
), 
beg
(r), 
d
(+ 

(str)) { }

83 
Tok
(cڡ * 
p
, cڡ * 
b
, cڡ * 
e
)

84 : 
efix
(
p
), 
beg
(
b
), 
d
(
e
) { }

86 
size_t
 
ngth
(cڡ {  
	gd
 - 
	gbeg
; }

87 
	gd
::
rg
 
ws_befe
(cڡ {  
d
::rg(
efix
, 
beg
); }

88 
	gd
::
rg
 
to_rg
(cڡ {  
d
::rg(
beg
, 
d
); }

89 
	gd
::
rg
 
time_wa
() const {

90 
d
::
rg
 
r
(
to_rg
());

91 
	gd
::
rg
 
wheas
(" \t\f\v\n\r");

92  
	gr
.
a
(
r
.
fd_ϡ_n_of
(
wheas
)+1);

95 
ݔ
 
bo
({  
	gbeg
 && 
	gd
 && beg >
d
; }

96 
ݔ
 
	gd
::
rg
({  
to_rg
(); }

98 
bo
 
	gݔ
==(
Tok
 
t
{  
to_rg
() ==.to_string(); }

101 as
	cPrS
 : 
public
 
Posi
 {

103 
public
:

104 
PrS
(cڡ * 
th
, cڡ * 
c
 = 0, cڡ 
size_t
 
fe
 = 
d
::
rg
::
os
);

105 
PrS
(cڡ * 
th
, cڡ * 
c
, cڡ 
Posi
& 
posi
, 
Offt
 
offt
 = Offset(0, 0));

106 
PrS
(cڡ * 
th
, cڡ * 
c
, cڡ 
Tok
& 
tok
, cڡ 
Posi
& 
posi
, 
Offt
 
offt
 = Offset(0, 0));

108 
	gpublic
:

109 
Offt
 
off
({  *
this
; }

110 
Posi
 
pos
({  *
	gthis
; }

111 
PrS
 
pe
({  *
	gthis
; }

113 
	gpublic
:

114 cڡ * 
th
;

115 cڡ * 
	gc
;

116 
Offt
 
	gofft
;

117 
Tok
 
	gtok
;

	@node_modules/node-sass/src/libsass/src/prelexer.cpp

1 
	~"ss.h
"

2 
	~<cy
>

3 
	~<cddef
>

4 
	~<ioam
>

5 
	~<iom
>

6 
	~"ut.h
"

7 
	~"posi.h
"

8 
	~"ex.h
"

9 
	~"cڡts.h
"

12 
mea
 
	gSass
 {

14 
usg
 
mea
 
	gCڡts
;

16 
mea
 
	gPx
 {

73 cڡ 
rg_doub_ges
[] = "\"\\#";

74 cڡ * 
_rg_doub_o
(cڡ * 
c
)

76  
	gqu
 <

78 
	gzo_us
 <

79 
	gives
 <

81 
	gqu
 <

82 
	gexaly
 <'\\'>,

83 
	gy_ch


86 
	gqu
 <

87 
	gexaly
 <'#'>,

88 
	gge
 <

89 
	gexaly
 <'{'>

93 
	gg_ass_ch
 <

94 
	grg_doub_ges


100 
	gives
 <

101 
	gexaly
 <'"'>,

102 
	glookahd
 < 
	gexaly
< 
	ghash_lb
 > >

104 >(
	gc
);

107 cڡ * 
_rg_doub_ݒ
(cڡ * 
c
)

109  
	gqu
 <

111 
	gexaly
 <'"'>,

113 
	gzo_us
 <

114 
	gives
 <

116 
	gqu
 <

117 
	gexaly
 <'\\'>,

118 
	gy_ch


121 
	gqu
 <

122 
	gexaly
 <'#'>,

123 
	gge
 <

124 
	gexaly
 <'{'>

128 
	gg_ass_ch
 <

129 
	grg_doub_ges


135 
	gives
 <

136 
	gexaly
 <'"'>,

137 
	glookahd
 < 
	gexaly
< 
	ghash_lb
 > >

139 >(
	gc
);

142 cڡ 
rg_sg_ges
[] = "'\\#";

143 cڡ * 
_rg_sg_o
(cڡ * 
c
)

145  
	gqu
 <

147 
	gzo_us
 <

148 
	gives
 <

150 
	gqu
 <

151 
	gexaly
 <'\\'>,

152 
	gy_ch


155 
	gqu
 <

156 
	gexaly
 <'#'>,

157 
	gge
 <

158 
	gexaly
 <'{'>

162 
	gg_ass_ch
 <

163 
	grg_sg_ges


169 
	gives
 <

170 
	gexaly
 <'\''>,

171 
	glookahd
 < 
	gexaly
< 
	ghash_lb
 > >

173 >(
	gc
);

176 cڡ * 
_rg_sg_ݒ
(cڡ * 
c
)

178  
	gqu
 <

180 
	gexaly
 <'\''>,

182 
	gzo_us
 <

183 
	gives
 <

185 
	gqu
 <

186 
	gexaly
 <'\\'>,

187 
	gy_ch


190 
	gqu
 <

191 
	gexaly
 <'#'>,

192 
	gge
 <

193 
	gexaly
 <'{'>

197 
	gg_ass_ch
 <

198 
	grg_sg_ges


204 
	gives
 <

205 
	gexaly
 <'\''>,

206 
	glookahd
 < 
	gexaly
< 
	ghash_lb
 > >

208 >(
	gc
);

217 cڡ * 
_rg_uri_o
(cڡ * 
c
)

219  
	gqu
 <

220 
	gn_gedy
<

221 
	gives
<

222 
	gass_ch
< 
	g_uri_chs
 >,

223 
	guri_cha
,

224 
	gNONASCII
,

225 
	gESCAPE


227 
	gives
<

228 
	gqu
 < 
	gtiڮ
 < 
	gW
 >, 
	gexaly
 <')'> >,

229 
	glookahd
 < 
	gexaly
< 
	ghash_lb
 > >

232 
	gtiڮ
 <

233 
	gqu
 < 
	gtiڮ
 < 
	gW
 >, 
	gexaly
 <')'> >

235 >(
	gc
);

238 cڡ * 
_rg_uri_ݒ
(cڡ * 
c
)

240  
	gqu
 <

241 
	gexaly
 <'u'>,

242 
	gexaly
 <'r'>,

243 
	gexaly
 <'l'>,

244 
	gexaly
 <'('>,

245 
	gW
,

246 
	gn_gedy
<

247 
	gives
<

248 
	gass_ch
< 
	g_uri_chs
 >,

249 
	guri_cha
,

250 
	gNONASCII
,

251 
	gESCAPE


253 
	gives
<

254 
	gqu
 < 
	gW
, 
	gexaly
 <')'> >,

255 
	gexaly
< 
	ghash_lb
 >

258 >(
	gc
);

262 cڡ * 
le_commt
(cڡ * 
c
)

264  
	gqu
<

265 
	gexaly
 <

266 
	gash_ash


268 
	gn_gedy
<

269 
	gy_ch
,

270 
	gd_of_le


272 >(
	gc
);

276 cڡ * 
block_commt
(cڡ * 
c
)

278  
	gqu
<

279 
	gdimed_by
<

280 
	gash_
,

281 
	g_ash
,

282 
	gl


284 >(
	gc
);

297 cڡ * 
tiڮ_css_whea
(cڡ * 
c
) {

298  
	gzo_us
< 
	gives
<
	gas
, 
	gle_commt
> >(
	gc
);

300 cڡ * 
css_whea
(cڡ * 
c
) {

301  
	ge_us
< 
	gives
<
	gas
, 
	gle_commt
> >(
	gc
);

304 cڡ * 
tiڮ_css_commts
(cڡ * 
c
) {

305  
	gzo_us
< 
	gives
<
	gas
, 
	gle_commt
, 
	gblock_commt
> >(
	gc
);

307 cڡ * 
css_commts
(cڡ * 
c
) {

308  
	ge_us
< 
	gives
<
	gas
, 
	gle_commt
, 
	gblock_commt
> >(
	gc
);

312 cڡ * 
es_q
(cڡ * 
c
)

314  
	gqu
<

315 
	gexaly
<'\\'>,

316 
	gives
 <

317 
	gmmax_nge
<

318 1, 3, 
	gxdig


320 
	gy_ch


322 
	gtiڮ
 <

323 
	gexaly
 <' '>

325 >(
	gc
);

329 cڡ * 
idtifr_pha
(cڡ * 
c
)

331  
	gives
<

332 
	gunicode_q
,

333 
	gpha
,

334 
	gunicode
,

335 
	gexaly
<'-'>,

336 
	gexaly
<'_'>,

337 
	gNONASCII
,

338 
	gESCAPE
,

339 
	ges_q


340 >(
	gc
);

344 cڡ * 
idtifr_num
(cڡ * 
c
)

346  
	gives
<

347 
	gunicode_q
,

348 
	gnum
,

349 
	gunicode
,

350 
	gexaly
<'-'>,

351 
	gexaly
<'_'>,

352 
	gNONASCII
,

353 
	gESCAPE
,

354 
	ges_q


355 >(
	gc
);

359 cڡ * 
ri_idtifr
(cڡ * 
c
)

361  
	gqu
<

362 
	ge_us
 < 
	gri_idtifr_pha
 >,

363 
	gzo_us
 < 
	gri_idtifr_num
 >

365 >(
	gc
);

369 cڡ * 
idtifr
(cڡ * 
c
)

371  
	gqu
<

372 
	gzo_us
< 
	gexaly
<'-'> >,

373 
	ge_us
 < 
	gidtifr_pha
 >,

374 
	gzo_us
 < 
	gidtifr_num
 >

376 >(
	gc
);

379 cڡ * 
ri_idtifr_pha
(cڡ * 
c
)

381  
	gives
 <

382 
	gpha
,

383 
	gunicode
,

384 
	ges_q
,

385 
	gexaly
<'_'>

386 >(
	gc
);

389 cڡ * 
ri_idtifr_num
(cڡ * 
c
)

391  
	gives
 <

392 
	gnum
,

393 
	gunicode
,

394 
	ges_q
,

395 
	gexaly
<'_'>

396 >(
	gc
);

400 cڡ * 
e_un
(cڡ * 
c
)

402  
	gqu
 <

403 
	gtiڮ
 < 
	gexaly
 <'-'> >,

404 
	gri_idtifr_pha
,

405 
	gzo_us
 < 
	gives
<

406 
	gri_idtifr_num
,

407 
	gqu
 <

408 
	ge_us
 < 
	gexaly
<'-'> >,

409 
	gri_idtifr_pha


412 >(
	gc
);

416 cڡ * 
muɝ_uns
(cڡ * 
c
)

419 
	gqu
 <

420 
	ge_un
,

421 
	gzo_us
 <

422 
	gqu
 <

423 
	gexaly
 <'*'>,

424 
	ge_un


427 >(
	gc
);

431 cڡ * 
un_idtifr
(cڡ * 
c
)

433  
	gqu
 <

434 
	gmuɝ_uns
,

435 
	gtiڮ
 <

436 
	gqu
 <

437 
	gexaly
 <'/'>,

438 
	gmuɝ_uns


440 >(
	gc
);

443 cڡ * 
idtifr_nums
(cڡ * 
c
)

445  
	ge_us
< 
	gidtifr_num
 >(
	gc
);

449 cڡ * 
numb_efix
(cڡ * 
c
) {

450  
	gives
 <

451 
	gexaly
 < '+' >,

452 
	gqu
 <

453 
	gexaly
 < '-' >,

454 
	gtiڮ_css_whea
,

455 
	gexaly
< '-' >

457 >(
	gc
);

461 cڡ * 
idtifr_schema
(cڡ * 
c
) {

463  
	gqu
 <

464 
	ge_us
 <

465 
	gqu
 <

466 
	gzo_us
 <

467 
	gives
 <

468 
	gqu
 <

469 
	gtiڮ
 <

470 
	gexaly
 <'$'>

472 
	gidtifr


474 
	gexaly
 <'-'>

477 
	gުt
,

478 
	gzo_us
 <

479 
	gives
 <

480 
	gdigs
,

481 
	gqu
 <

482 
	gtiڮ
 <

483 
	gexaly
 <'$'>

485 
	gidtifr


487 
	gqued_rg
,

488 
	gexaly
<'-'>

493 
	gge
 <

494 
	gexaly
<'%'>

496 > (
	gc
);

500 cڡ * 
ުt
(cڡ * 
c
) {

501  
	gcursive_sces
< 
	gexaly
<
	ghash_lb
>,xaly<
	grb
> >(
	gc
);

505 cڡ * 
sg_qued_rg
(cڡ * 
c
) {

507  
	gqu
 <

508 
	gexaly
 <'\''>,

509 
	gzo_us
 <

510 
	gives
 <

512 
	gqu
 <

513 
	gexaly
 < '\\' >,

514 
	g_lebak


516 
	ges_q
,

517 
	gunicode_q
,

519 
	gުt
,

521 
	gy_ch_but
 < '\'' >

524 
	gexaly
 <'\''>

525 >(
	gc
);

529 cڡ * 
doub_qued_rg
(cڡ * 
c
) {

531  
	gqu
 <

532 
	gexaly
 <'"'>,

533 
	gzo_us
 <

534 
	gives
 <

536 
	gqu
 <

537 
	gexaly
 < '\\' >,

538 
	g_lebak


540 
	ges_q
,

541 
	gunicode_q
,

543 
	gުt
,

545 
	gy_ch_but
 < '"' >

548 
	gexaly
 <'"'>

549 >(
	gc
);

553 cڡ * 
qued_rg
(cڡ * 
c
) {

555  
	gives
<

556 
	gsg_qued_rg
,

557 
	gdoub_qued_rg


558 >(
	gc
);

561 cڡ * 
ss_vue
(cڡ * 
c
) {

562  
	gives
 <

563 
	gqued_rg
,

564 
	gidtifr
,

565 
	grage
,

566 
	ghex
,

567 
	gdimsi
,

568 
	gnumb


569 >(
	gc
);

574 cڡ * 
vue_combis
(cڡ * 
c
) {

576 
bo
 
	gwas_numb
 = 
l
;

577 cڡ * 
	gpos
 = 
c
;

578 
	gc
) {

579 i((
	gpos
 = 
ives
 < 
qued_rg
, 
	gidtifr
, 
	grage
, 
	ghex
 >(
	gc
))) {

580 
	gwas_numb
 = 
l
;

581 
	gc
 = 
pos
;

582 } i(!
	gwas_numb
 && !
	gexaly
<'+'>(
	gc
&& (
	gpos
 = 
ives
 < 
dimsi
, 
	gnumb
 >(src))) {

583 
	gwas_numb
 = 
ue
;

584 
	gc
 = 
pos
;

589  
	gc
;

597 cڡ * 
vue_schema
(cڡ * 
c
)

599  
	gqu
 <

600 
	ge_us
 <

601 
	gqu
 <

602 
	gtiڮ
 < 
	gvue_combis
 >,

603 
	gުt
,

604 
	gtiڮ
 < 
	gvue_combis
 >

607 >(
	gc
);

611 cڡ * 
_keywd
(cڡ * 
c
) {

612  
	gqu
<
	gexaly
<'@'>, 
	gidtifr
>(
	gc
);

632 cڡ * 
_mo_y_vue_tok
(cڡ * 
c
) {

634  
	gives
 <

635 
	ge_us
 <

636 
	gives
 <

637 
	gqu
 <

638 
	gexaly
 <'\\'>,

639 
	gy_ch


641 
	gqu
 <

642 
	gge
 <

643 
	gqu
 <

644 
	gexaly
 < 
	gu_kwd
 >,

645 
	gexaly
 <'('>

648 
	gg_ass_ch
 <

649 
	gmo_y_vue_ass


652 
	gqu
 <

653 
	gexaly
 <'/'>,

654 
	gge
 <

655 
	gives
 <

656 
	gexaly
 <'/'>,

657 
	gexaly
 <'*'>

661 
	gqu
 <

662 
	gexaly
 <'\\'>,

663 
	gexaly
 <'#'>,

664 
	gge
 <

665 
	gexaly
 <'{'>

668 
	gqu
 <

669 
	gexaly
 <'!'>,

670 
	gge
 <

671 
	gpha


676 
	gblock_commt
,

677 
	gle_commt
,

678 
	gުt
,

679 
	ga
,

680 
	gqu
 <

681 
	gexaly
<'u'>,

682 
	gexaly
<'r'>,

683 
	gexaly
<'l'>,

684 
	gexaly
<'('>,

685 
	gzo_us
 <

686 
	gives
 <

687 
	gass_ch
< 
	g_uri_chs
 >,

688 
	guri_cha
,

689 
	gNONASCII
,

690 
	gESCAPE


695 
	gexaly
<')'>

697 >(
	gc
);

705 cڡ * 
_ecl_deive
(cڡ * 
c
) {

706  
	gives
 <

707 
	gwd
 < 
	gmix_kwd
 >,

708 
	gwd
 < 
	gude_kwd
 >,

709 
	gwd
 < 
	gfuni_kwd
 >,

710 
	gwd
 < 
	gtu_kwd
 >,

711 
	gwd
 < 
	gdebug_kwd
 >,

712 
	gwd
 < 
	gwn_kwd
 >,

713 
	gwd
 < 
	gf_kwd
 >,

714 
	gwd
 < 
	gch_kwd
 >,

715 
	gwd
 < 
	gwhe_kwd
 >,

716 
	gwd
 < 
	gif_kwd
 >,

717 
	gwd
 < 
	g_kwd
 >,

718 
	gwd
 < 
	gexnd_kwd
 >,

719 
	gwd
 < 
	gimpt_kwd
 >,

720 
	gwd
 < 
	gmed_kwd
 >,

721 
	gwd
 < 
	gcht_kwd
 >,

722 
	gwd
 < 
	gcڋ_kwd
 >,

724 
	gwd
 < 
	g_ro_kwd
 >,

725 
	gwd
 < 
	gr_kwd
 >

726 >(
	gc
);

729 cڡ * 
_efixed_deive
(cڡ * 
c
) {

730  
	gqu
 <

731 
	gtiڮ
 <

732 
	gqu
 <

733 
	gexaly
 <'-'>,

734 
	ge_us
 < 
	gnum
 >,

735 
	gexaly
 <'-'>

738 
	gexaly
 < 
	gsuts_kwd
 >

739 >(
	gc
);

742 cڡ * 
_n_comb
(cڡ * 
c
) {

743  
	gqu
 <

744 
	gtiڮ
 <

745 
	gqu
 <

746 
	gzo_us
 <

747 
	gexaly
 <'-'>

749 
	gidtifr
,

750 
	gexaly
 <'|'>

753 
	gzo_us
 <

754 
	gexaly
 <'-'>

756 
	gidtifr


757 >(
	gc
);

760 cڡ * 
ic_n_comb
(cڡ * 
c
) {

761  
	gqu
 <

762 
	gexaly
 <'/'>,

763 
	g_n_comb
,

764 
	gexaly
 <'/'>

765 >(
	gc
);

768 cڡ * 
schema_n_comb
(cڡ * 
c
) {

769  
	gqu
 <

770 
	gexaly
 <'/'>,

771 
	gtiڮ
 <

772 
	gqu
 <

773 
	gcss__idtifr
,

774 
	gexaly
 <'|'>

777 
	gcss__idtifr
,

778 
	gexaly
 <'/'>

779 > (
	gc
);

782 cڡ * 
kwd_impt
(cڡ * 
c
) {

783  
	gwd
<
	gimpt_kwd
>(
	gc
);

786 cڡ * 
kwd__ro
(cڡ * 
c
) {

787  
	gwd
<
	g_ro_kwd
>(
	gc
);

790 cڡ * 
kwd_wh_deive
(cڡ * 
c
) {

791  
	gwd
<
	gwh_kwd
>(
	gc
);

794 cڡ * 
kwd_whout_deive
(cڡ * 
c
) {

795  
	gwd
<
	gwhout_kwd
>(
	gc
);

798 cڡ * 
kwd_med
(cڡ * 
c
) {

799  
	gwd
<
	gmed_kwd
>(
	gc
);

802 cڡ * 
kwd_suts_deive
(cڡ * 
c
) {

803  
	gwd
<
	gsuts_kwd
>(
	gc
);

806 cڡ * 
kwd_mix
(cڡ * 
c
) {

807  
	gwd
<
	gmix_kwd
>(
	gc
);

810 cڡ * 
kwd_funi
(cڡ * 
c
) {

811  
	gwd
<
	gfuni_kwd
>(
	gc
);

814 cڡ * 
kwd_tu_deive
(cڡ * 
c
) {

815  
	gwd
<
	gtu_kwd
>(
	gc
);

818 cڡ * 
kwd_ude_deive
(cڡ * 
c
) {

819  
	gwd
<
	gude_kwd
>(
	gc
);

822 cڡ * 
kwd_cڋ_deive
(cڡ * 
c
) {

823  
	gwd
<
	gcڋ_kwd
>(
	gc
);

826 cڡ * 
kwd_cht_deive
(cڡ * 
c
) {

827  
	gwd
<
	gcht_kwd
>(
	gc
);

830 cڡ * 
kwd_exnd
(cڡ * 
c
) {

831  
	gwd
<
	gexnd_kwd
>(
	gc
);

835 cڡ * 
kwd_if_deive
(cڡ * 
c
) {

836  
	gwd
<
	gif_kwd
>(
	gc
);

839 cڡ * 
kwd__deive
(cڡ * 
c
) {

840  
	gwd
<
	g_kwd
>(
	gc
);

842 cڡ * 
if_deive
(cڡ * 
c
) {

843  
	gqu
< 
	gexaly
< 
	g_kwd
 >,

844 
	gtiڮ_css_commts
,

845 
	gwd
< 
	gif_a__kwd
 > >(
	gc
);

848 cڡ * 
kwd_f_deive
(cڡ * 
c
) {

849  
	gwd
<
	gf_kwd
>(
	gc
);

852 cڡ * 
kwd_om
(cڡ * 
c
) {

853  
	gwd
<
	gom_kwd
>(
	gc
);

856 cڡ * 
kwd_to
(cڡ * 
c
) {

857  
	gwd
<
	gto_kwd
>(
	gc
);

860 cڡ * 
kwd_through
(cڡ * 
c
) {

861  
	gwd
<
	gthrough_kwd
>(
	gc
);

864 cڡ * 
kwd_ch_deive
(cڡ * 
c
) {

865  
	gwd
<
	gch_kwd
>(
	gc
);

868 cڡ * 
kwd_
(cڡ * 
c
) {

869  
	gwd
<
	g_kwd
>(
	gc
);

872 cڡ * 
kwd_whe_deive
(cڡ * 
c
) {

873  
	gwd
<
	gwhe_kwd
>(
	gc
);

876 cڡ * 
me
(cڡ * 
c
) {

877  
	ge_us
< 
	gives
< 
	gnum
,

878 
	gexaly
<'-'>,

879 
	gexaly
<'_'>,

880 
	ges_q
 > >(
	gc
);

883 cڡ * 
kwd_wn
(cڡ * 
c
) {

884  
	gwd
<
	gwn_kwd
>(
	gc
);

887 cڡ * 
kwd_r
(cڡ * 
c
) {

888  
	gwd
<
	gr_kwd
>(
	gc
);

891 cڡ * 
kwd_dbg
(cڡ * 
c
) {

892  
	gwd
<
	gdebug_kwd
>(
	gc
);

900 cڡ * 
kwd_nu
(cڡ * 
c
) {

901  
	gwd
<
	gnu_kwd
>(
	gc
);

904 cڡ * 
css_idtifr
(cڡ * 
c
) {

905  
	gqu
 <

906 
	gzo_us
 <

907 
	gexaly
 <'-'>

909 
	gidtifr


910 >(
	gc
);

913 cڡ * 
css__idtifr
(cڡ * 
c
) {

914  
	gqu
 <

915 
	gzo_us
 <

916 
	gexaly
 <'-'>

918 
	gives
 <

919 
	gidtifr
,

920 
	gުt


922 >(
	gc
);

926 cڡ * 
mea_efix
(cڡ * 
c
) {

927  
	gqu
 <

928 
	gtiڮ
 <

929 
	gives
 <

930 
	gexaly
 <'*'>,

931 
	gcss_idtifr


934 
	gexaly
 <'|'>,

935 
	gge
 <

936 
	gexaly
 <'='>

938 >(
	gc
);

942 cڡ * 
mea_schema
(cڡ * 
c
) {

943  
	gqu
 <

944 
	gtiڮ
 <

945 
	gives
 <

946 
	gexaly
 <'*'>,

947 
	gcss__idtifr


950 
	gexaly
<'|'>,

951 
	gge
 <

952 
	gexaly
 <'='>

954 >(
	gc
);

957 cڡ * 
hyphs_d_idtifr
(cڡ * 
c
) {

958  
	gqu
< 
	gzo_us
< 
	gexaly
< '-' > >, 
	gidtifr_nums
 >(
	gc
);

960 cڡ * 
hyphs_d_me
(cڡ * 
c
) {

961  
	gqu
< 
	gzo_us
< 
	gexaly
< '-' > >, 
	gme
 >(
	gc
);

963 cڡ * 
univl
(cڡ * 
c
) {

964  
	gqu
< 
	gtiڮ
<
	gmea_schema
>, 
	gexaly
<'*'> >(
	gc
);

967 cڡ * 
id_me
(cڡ * 
c
) {

968  
	gqu
<
	gexaly
<'#'>, 
	gidtifr_nums
 >(
	gc
);

971 cڡ * 
ass_me
(cڡ * 
c
) {

972  
	gqu
<
	gexaly
<'.'>, 
	gidtifr
 >(
	gc
);

975 cڡ * 
ibu_me
(cڡ * 
c
) {

976  
	gives
< 
	gqu
< 
	gtiڮ
<
	gmea_schema
>, 
	gidtifr
>,

977 
	gidtifr
 >(
	gc
);

980 cڡ * 
ahd
(cڡ * 
c
) {

981  
	gqu
<
	gexaly
<'%'>, 
	gidtifr_nums
 >(
	gc
);

985 cڡ * 

(cڡ * 
c
) {

986  
	gass_ch
<
	g_chs
>(
	gc
);

988 cڡ * 
sign
(cڡ * 
c
) {

989  
	gass_ch
<
	gsign_chs
>(
	gc
);

991 cڡ * 
unsigd_numb
(cڡ * 
c
) {

992  
	gives
<
	gqu
< 
	gzo_us
<
	gdigs
>,

993 
	gexaly
<'.'>,

994 
	ge_us
<
	gdigs
> >,

995 
	gdigs
>(
	gc
);

997 cڡ * 
numb
(cڡ * 
c
) {

998  
	gqu
< 
	gtiڮ
<
	gsign
>, 
	gunsigd_numb
>(
	gc
);

1000 cڡ * 
cffic
(cڡ * 
c
) {

1001  
	gives
< 
	gqu
< 
	gtiڮ
<
	gsign
>, 
	gdigs
 >,

1002 
	gsign
 >(
	gc
);

1004 cڡ * 
boml
(cڡ * 
c
) {

1005  
	gqu
 <

1006 
	gtiڮ
 < 
	gsign
 >,

1007 
	gtiڮ
 < 
	gdigs
 >,

1008 
	gexaly
 <'n'>,

1009 
	gzo_us
 < 
	gqu
 <

1010 
	gtiڮ_css_whea
, 
	gsign
,

1011 
	gtiڮ_css_whea
, 
	gdigs


1013 >(
	gc
);

1015 cڡ * 
rage
(cڡ * 
c
) {

1016  
	gqu
< 
	gnumb
, 
	gexaly
<'%'> >(
	gc
);

1018 cڡ * 
amrnd
(cڡ * 
c
) {

1019  
	gexaly
<'&'>(
	gc
);

1026 cڡ * 
dimsi
(cڡ * 
c
) {

1027  
	gqu
<
	gnumb
, 
	gun_idtifr
 >(
	gc
);

1029 cڡ * 
hex
(cڡ * 
c
) {

1030 cڡ * 
	gp
 = 
qu
< 
exaly
<'#'>, 
	ge_us
<
	gxdig
> >(
	gc
);

1031 
rdiff_t
 
	gn
 = 
p
 - 
c
;

1032  (
	gn
 !4 && 
n
 !7? 0 : 
p
;

1034 cڡ * 
hexa
(cڡ * 
c
) {

1035 cڡ * 
	gp
 = 
qu
< 
exaly
<'#'>, 
	ge_us
<
	gxdig
> >(
	gc
);

1036 
rdiff_t
 
	gn
 = 
p
 - 
c
;

1037  (
	gn
 !4 && 
n
 !7 && !9? 0 : 
p
;

1039 cڡ * 
hex0
(cڡ * 
c
) {

1040 cڡ * 
	gp
 = 
qu
< 
exaly
<'0'>, 
	gexaly
<'x'>, 
	ge_us
<
	gxdig
> >(
	gc
);

1041 
rdiff_t
 
	gn
 = 
p
 - 
c
;

1042  (
	gn
 !5 && 
n
 !8? 0 : 
p
;

1051 cڡ * 
uri_efix
(cڡ * 
c
) {

1052  
	gqu
 <

1053 
	gexaly
 <

1054 
	gu_kwd


1056 
	gzo_us
 <

1057 
	gqu
 <

1058 
	gexaly
 <'-'>,

1059 
	ge_us
 <

1060 
	gpha


1064 
	gexaly
 <'('>

1065 >(
	gc
);

1089 cڡ * 
kwd_imp܏
(cڡ * 
c
) {

1090  
	gqu
< 
	gexaly
<'!'>,

1091 
	gtiڮ_css_whea
,

1092 
	gwd
<
	gimp܏_kwd
> >(
	gc
);

1095 cڡ * 
kwd_tiڮ
(cڡ * 
c
) {

1096  
	gqu
< 
	gexaly
<'!'>,

1097 
	gtiڮ_css_whea
,

1098 
	gwd
<
	gtiڮ_kwd
> >(
	gc
);

1101 cڡ * 
deu_ag
(cڡ * 
c
) {

1102  
	gqu
< 
	gexaly
<'!'>,

1103 
	gtiڮ_css_whea
,

1104 
	gwd
<
	gdeu_kwd
> >(
	gc
);

1107 cڡ * 
glob_ag
(cڡ * 
c
) {

1108  
	gqu
< 
	gexaly
<'!'>,

1109 
	gtiڮ_css_whea
,

1110 
	gwd
<
	gglob_kwd
> >(
	gc
);

1113 cڡ * 
pudo_efix
(cڡ * 
c
) {

1114  
	gqu
< 
	gexaly
<':'>, 
	gtiڮ
<xaly<':'> > >(
	gc
);

1117 cڡ * 
funiڮ_schema
(cڡ * 
c
) {

1118  
	gqu
 <

1119 
	ge_us
 <

1120 
	gqu
 <

1121 
	gzo_us
 <

1122 
	gives
 <

1123 
	gidtifr
,

1124 
	gexaly
 <'-'>

1127 
	ge_us
 <

1128 
	gqu
 <

1129 
	gުt
,

1130 
	gives
 <

1131 
	gdigs
,

1132 
	gidtifr
,

1133 
	gexaly
<'+'>,

1134 
	gexaly
<'-'>

1140 
	gge
 <

1141 
	gexaly
 <'%'>

1143 
	glookahd
 <

1144 
	gexaly
 <'('>

1146 > (
	gc
);

1149 cڡ * 
_nhg
(cڡ * 
c
) {

1150  
	gc
;

1153 cڡ * 
_funiڮ
(cڡ * 
c
) {

1154  
	gqu
< 
	gidtifr
, 
	gtiڮ
 < 
	gblock_commt
 >, 
	gexaly
<'('> >(
	gc
);

1156 cڡ * 
_pudo_
(cڡ * 
c
) {

1157  
	gqu
< 
	gidtifr
, 
	gtiڮ
 < 
	gblock_commt
 >, 
	gexaly
<'('> >(
	gc
);

1160 cڡ * 
pudo_n
(cڡ * 
c
) {

1161  
	gwd
< 
	gpudo_n_kwd
 >(
	gc
);

1164 cڡ * 
ev
(cڡ * 
c
) {

1165  
	gwd
<
	gev_kwd
>(
	gc
);

1167 cڡ * 
odd
(cڡ * 
c
) {

1168  
	gwd
<
	godd_kwd
>(
	gc
);

1171 cڡ * 
exa_mch
(cڡ * 
c
{  
	gexaly
<'='>(
	gc
); }

1172 cڡ * 
ass_mch
(cڡ * 
c
{  
	gexaly
<
	gtde_equ
>(
	gc
); }

1173 cڡ * 
dash_mch
(cڡ * 
c
{  
	gexaly
<
	gpe_equ
>(
	gc
); }

1174 cڡ * 
efix_mch
(cڡ * 
c
{  
	gexaly
<
	gt_equ
>(
	gc
); }

1175 cڡ * 
suffix_mch
(cڡ * 
c
{  
	gexaly
<
	gdr_equ
>(
	gc
); }

1176 cڡ * 
subrg_mch
(cڡ * 
c
{  
	gexaly
<
	g_equ
>(
	gc
); }

1193 cڡ * 
vb
(cڡ * 
c
) {

1194  
	gqu
<
	gexaly
<'$'>, 
	gidtifr
>(
	gc
);

1199 cڡ * 
lc__
(cڡ * 
c
) {

1200  
	gqu
 <

1201 
	gtiڮ
 < 
	gqu
 <

1202 
	ghyphs
,

1203 
	ge_us
 < 
	gqu
 <

1204 
	gri_idtifr
,

1205 
	ghyphs


1208 
	gexaly
 < 
	glc__kwd
 >,

1209 
	gwd_boundy


1210 >(
	gc
);

1214 cڡ * 
kwd_ue
(cڡ * 
c
) {

1215  
	gwd
<
	gue_kwd
>(
	gc
);

1217 cڡ * 
kwd_l
(cڡ * 
c
) {

1218  
	gwd
<
	gl_kwd
>(
	gc
);

1220 cڡ * 
kwd_ly
(cڡ * 
c
) {

1221  
	gkeywd
 < 
	gly_kwd
 >(
	gc
);

1223 cڡ * 
kwd_d
(cڡ * 
c
) {

1224  
	gkeywd
 < 
	gd_kwd
 >(
	gc
);

1226 cڡ * 
kwd_
(cڡ * 
c
) {

1227  
	gkeywd
 < 
	g_kwd
 >(
	gc
);

1229 cڡ * 
kwd_n
(cڡ * 
c
) {

1230  
	gkeywd
 < 
	gn_kwd
 >(
	gc
);

1232 cڡ * 
kwd_eq
(cڡ * 
c
) {

1233  
	gexaly
<
	geq
>(
	gc
);

1235 cڡ * 
kwd_q
(cڡ * 
c
) {

1236  
	gexaly
<
	gq
>(
	gc
);

1238 cڡ * 
kwd_gt
(cڡ * 
c
) {

1239  
	gexaly
<
	ggt
>(
	gc
);

1241 cڡ * 
kwd_g
(cڡ * 
c
) {

1242  
	gexaly
<
	gg
>(
	gc
);

1244 cڡ * 
kwd_
(cڡ * 
c
) {

1245  
	gexaly
<
	g
>(
	gc
);

1247 cڡ * 
kwd_e
(cڡ * 
c
) {

1248  
	gexaly
<
	ge
>(
	gc
);

1252 cڡ * 
_ogid
(cڡ * 
c
) {

1253  
	gqu
 <

1254 
	gwd
<
	gogid_kwd
>,

1255 
	gexaly
<':'>,

1256 
	gives
< 
	gidtifr_schema
, 
	gidtifr
 >,

1257 
	gzo_us
< 
	gqu
<

1258 
	gexaly
<'.'>,

1259 
	gives
< 
	gidtifr_schema
, 
	gidtifr
 >

1261 
	gzo_us
 < 
	gqu
<

1262 
	gexaly
<'('>,

1263 
	gtiڮ_css_whea
,

1264 
	gtiڮ
 < 
	gqu
<

1265 
	gives
< 
	gvb
, 
	gidtifr_schema
, 
	gidtifr
 >,

1266 
	gtiڮ_css_whea
,

1267 
	gexaly
<'='>,

1268 
	gtiڮ_css_whea
,

1269 
	gives
< 
	gvb
, 
	gidtifr_schema
, 
	gidtifr
, 
	gqued_rg
, 
	gnumb
, 
	ghexa
 >,

1270 
	gzo_us
< 
	gqu
<

1271 
	gtiڮ_css_whea
,

1272 
	gexaly
<','>,

1273 
	gtiڮ_css_whea
,

1274 
	gqu
<

1275 
	gives
< 
	gvb
, 
	gidtifr_schema
, 
	gidtifr
 >,

1276 
	gtiڮ_css_whea
,

1277 
	gexaly
<'='>,

1278 
	gtiڮ_css_whea
,

1279 
	gives
< 
	gvb
, 
	gidtifr_schema
, 
	gidtifr
, 
	gqued_rg
, 
	gnumb
, 
	ghexa
 >

1283 
	gtiڮ_css_whea
,

1284 
	gexaly
<')'>

1286 >(
	gc
);

1288 cڡ * 
_exessi
(cڡ * 
c
) {

1289  
	gqu
 < 
	gwd
<
	gexessi_kwd
>, 
	gexaly
<'('>, 
	gsk_ov_sces
<xaly<'('>,xaly<')'> > >(
	gc
);

1291 cڡ * 
_ݔty
(cڡ * 
c
) {

1292  
	gives
 < 
	g_exessi
, 
	g_ogid
 >(
	gc
);

1300 cڡ * 
_keywd_g_ݔty
(cڡ * 
c
) {

1301  
	gives
 <

1302 
	gvb
,

1303 
	gidtifr_schema
,

1304 
	gidtifr


1305 >(
	gc
);

1307 cڡ * 
_keywd_g_vue
(cڡ * 
c
) {

1308  
	gives
 <

1309 
	gvb
,

1310 
	gidtifr_schema
,

1311 
	gidtifr
,

1312 
	gqued_rg
,

1313 
	gnumb
,

1314 
	ghexa
,

1315 
	gqu
 <

1316 
	gexaly
 < '(' >,

1317 
	gsk_ov_sces
 <

1318 
	gexaly
 < '(' >,

1319 
	gexaly
 < ')' >

1322 >(
	gc
);

1325 cڡ * 
_keywd_g
(cڡ * 
c
) {

1326  
	gqu
 <

1327 
	g_keywd_g_ݔty
,

1328 
	gtiڮ_css_whea
,

1329 
	gexaly
<'='>,

1330 
	gtiڮ_css_whea
,

1331 
	g_keywd_g_vue


1332 >(
	gc
);

1382 cڡ * 
H
(cڡ * 
c
) {

1383  
	gd
::
isxdig
(*
c
) ? src+1 : 0;

1386 cڡ * 
W
(cڡ * 
c
) {

1387  
	gzo_us
< 
	gives
<

1388 
	ga
,

1389 
	gexaly
< '\t' >,

1390 
	gexaly
< '\r' >,

1391 
	gexaly
< '\n' >,

1392 
	gexaly
< '\f' >

1393 > >(
	gc
);

1396 cڡ * 
UUNICODE
(cڡ * 
c
) {

1397  
	gqu
< 
	gexaly
<'\\'>,

1398 
	gbwn
<
	gH
, 1, 6>,

1399 
	gtiڮ
< 
	gW
 >

1400 >(
	gc
);

1403 cڡ * 
NONASCII
(cڡ * 
c
) {

1404  
nascii
(
c
);

1407 cڡ * 
ESCAPE
(cڡ * 
c
) {

1408  
	gives
<

1409 
	gUUNICODE
,

1410 
	gqu
<

1411 
	gexaly
<'\\'>,

1412 
	gives
<

1413 
	gNONASCII
,

1414 
	gesb_cha


1417 >(
	gc
);

1428 cڡ * 
_uri_suffix
(cڡ * 
c
) {

1429  
	gqu
< 
	gW
, 
	gexaly
< ')' > >(
	gc
);

1432 cڡ * 
_uri_vue
(cڡ * 
c
) {

1434 
	gqu
<

1435 
	gn_gedy
<

1436 
	gives
<

1437 
	gass_ch
< 
	g_uri_chs
 >,

1438 
	guri_cha
,

1439 
	gNONASCII
,

1440 
	gESCAPE


1442 
	gives
<

1443 
	g_uri_suffix
,

1444 
	gexaly
< 
	ghash_lb
 >

1448 (
	gc
);

1451 cڡ * 
ic_rg
(cڡ * 
c
) {

1452 cڡ * 
	gpos
 = 
c
;

1453 cڡ * 
	gs
 = 
qued_rg
(
pos
);

1454 
Tok
 
t
(
pos
, 
s
);

1455 cڡ 
	gp
 = 
cou_rv
< 
ުt
 >(
t
.
beg
, 
	gt
.
	gd
);

1456  (
	gp
 =0? 
t
.
d
 : 0;

1459 cڡ * 
unicode_q
(cڡ * 
c
) {

1460  
	gqu
 <

1461 
	gives
 <

1462 
	gexaly
< 'U' >,

1463 
	gexaly
< 'u' >

1465 
	gexaly
< '+' >,

1466 
	gdded_tok
 <

1467 6, 
	gxdig
,

1468 
	gexaly
 < '?' >

1470 >(
	gc
);

1473 cڡ * 
ic_compڒt
(cڡ * 
c
) {

1474  
	gives
< 
	gidtifr
,

1475 
	gic_rg
,

1476 
	grage
,

1477 
	ghex
,

1478 
	gexaly
<'|'>,

1480 
	gqu
 < 
	gnumb
, 
	gun_idtifr
 >,

1481 
	gnumb
,

1482 
	gqu
< 
	gexaly
<'!'>, 
	gwd
<
	gimp܏_kwd
> >

1483 >(
	gc
);

1486 cڡ * 
ic_ݔty
(cڡ * 
c
) {

1488 
	gqu
 <

1489 
	gzo_us
<

1490 
	gqu
 <

1491 
	gtiڮ_css_commts
,

1492 
	gives
 <

1493 
	gexaly
<','>,

1494 
	gexaly
<'('>,

1495 
	gexaly
<')'>,

1496 
	gkwd_tiڮ
,

1497 
	gqued_rg
,

1498 
	gުt
,

1499 
	gidtifr
,

1500 
	grage
,

1501 
	gdimsi
,

1502 
	gvb
,

1503 
	gnum
,

1504 
	gqu
 <

1505 
	gexaly
 <'\\'>,

1506 
	gy_ch


1511 
	glookahd
 <

1512 
	gqu
 <

1513 
	gtiڮ_css_commts
,

1514 
	gives
 <

1515 
	gexaly
 <';'>,

1516 
	gexaly
 <'}'>,

1517 
	gd_of_fe


1521 >(
	gc
);

1524 cڡ * 
ic_vue
(cڡ * 
c
) {

1525  
	gqu
< sequence<

1526 
	gic_compڒt
,

1527 
	gzo_us
< 
	gidtifr
 >

1529 
	gzo_us
 < 
	gqu
<

1530 
	gives
<

1531 
	gqu
< 
	gtiڮ_as
, 
	gives
<

1532 
	gexaly
 < '/' >,

1533 
	gexaly
 < ',' >,

1534 
	gexaly
 < ' ' >

1535 >, 
	gtiڮ_as
 >,

1536 
	gas


1538 
	gic_compڒt


1540 
	gzo_us
 < 
	gas
 >,

1541 
	gives
< 
	gexaly
<';'>,xactly<'}'> >

1542 >(
	gc
);

1545 cڡ * 
he_sce
(cڡ * 
c
) {

1546  
	gqu
 <

1547 
	gexaly
 < '(' >,

1548 
	gsk_ov_sces
 <

1549 
	gexaly
 < '(' >,

1550 
	gexaly
 < ')' >

1552 >(
	gc
);

1555 cڡ * 
__li
(cڡ * 
c
) {

1556  
	gives
 <

1558 
	gqu
 <

1559 
	gamrnd
,

1560 
	ge_us
 <

1561 
	gexaly
 < '-' >

1563 
	gwd_boundy
,

1564 
	gtiڮ_as


1567 
	ge_us
 <

1568 
	gives
 <

1570 
	gas
, 
	gblock_commt
, 
	gle_commt
,

1573 
	gschema_n_comb
,

1575 
	gass_ch
 < 
	g_lookahd_s
 >,

1577 
	gass_ch
 < 
	g_comb_s
 >,

1579 
	gqu
 <

1580 
	gexaly
 <'('>,

1581 
	gtiڮ_as
,

1582 
	gtiڮ
 <
	g__li
>,

1583 
	gtiڮ_as
,

1584 
	gexaly
 <')'>

1586 
	gives
 <

1587 
	gexa_mch
, 
	gass_mch
, 
	gdash_mch
,

1588 
	gefix_mch
, 
	gsuffix_mch
, 
	gsubrg_mch


1591 
	gqu
 <

1593 
	gtiڮ
 < 
	gmea_schema
 >,

1595 
	gives
 <

1596 
	gqu
 <

1597 
	gexaly
 <'#'>,

1599 
	gge
 < 
	gexaly
 <'{'> >

1602 
	gexaly
 <'.'>,

1604 
	gtiڮ
 < 
	gpudo_efix
 >

1607 
	ge_us
 < 
	gqu
 <

1609 
	gzo_us
 < 
	gexaly
<'-'> >,

1611 
	gives
 <

1612 
	gkwd_tiڮ
,

1613 
	gexaly
 <'*'>,

1614 
	gqued_rg
,

1615 
	gުt
,

1616 
	gidtifr
,

1617 
	gvb
,

1618 
	grage
,

1619 
	gboml
,

1620 
	gdimsi
,

1621 
	gnum


1625 
	gzo_us
 < 
	gexaly
<'-'> >

1629 >(
	gc
);

1632 cڡ * 
ty_
(cڡ * 
c
) {

1633  
	gqu
< 
	gtiڮ
<
	gmea_schema
>, 
	gidtifr
>(
	gc
);

1635 cڡ * 
_ty_
(cڡ * 
c
) {

1636  
	gives
< 
	gty_
, 
	gunivl
, 
	gqued_rg
, 
	gdimsi
, 
	grage
, 
	gnumb
, 
	gidtifr_nums
 >(
	gc
);

1638 cڡ * 
_ty_2
(cڡ * 
c
) {

1639  
	gives
< 
	gty_
, 
	gunivl
, 
	gqued_rg
, 
	gdimsi
, 
	grage
, 
	gnumb
, 
	gidtifr_nums
 >(
	gc
);

1641 cڡ * 
_ic_exessi
(cڡ * 
c
) {

1642  
	gqu
< 
	gnumb
, 
	gtiڮ_as
, 
	gexaly
<'/'>, oiڮ_as,umb >(
	gc
);

1647 cڡ * 
_ecl_fun
(cڡ * 
c
) {

1650 i(cڡ * 
	glc
 = 
lc__
(
c
)) {

1651  
lc
;

1654  
	gqu
 <

1655 
	gtiڮ
 <

1656 
	gqu
 <

1657 
	gexaly
 <'-'>,

1658 
	ge_us
 <

1659 
	gives
 <

1660 
	gpha
,

1661 
	gexaly
 <'+'>,

1662 
	gexaly
 <'-'>

1667 
	gives
 <

1668 
	gwd
 < 
	gexessi_kwd
 >,

1669 
	gqu
 <

1670 
	gqu
 <

1671 
	gexaly
 < 
	gogid_kwd
 >,

1672 
	gexaly
 <':'>

1674 
	gzo_us
 <

1675 
	gives
 <

1676 
	gch_nge
 <'a', 'z'>,

1677 
	gexaly
 <'.'>

1682 >(
	gc
);

	@node_modules/node-sass/src/libsass/src/prelexer.hpp

1 #ide
SASS_PRELEXER_H


2 
	#SASS_PRELEXER_H


	)

4 
	~<crg
>

5 
	~"x.h
"

7 
mea
 
	gSass
 {

9 
mea
 
	gPx
 {

16 cڡ * 
kwd_ue
(cڡ * 
c
);

17 cڡ * 
kwd_l
(cڡ * 
c
);

18 cڡ * 
kwd_ly
(cڡ * 
c
);

19 cڡ * 
kwd_d
(cڡ * 
c
);

20 cڡ * 
kwd_
(cڡ * 
c
);

21 cڡ * 
kwd_n
(cڡ * 
c
);

22 cڡ * 
kwd_eq
(cڡ * 
c
);

23 cڡ * 
kwd_q
(cڡ * 
c
);

24 cڡ * 
kwd_gt
(cڡ * 
c
);

25 cڡ * 
kwd_g
(cڡ * 
c
);

26 cڡ * 
kwd_
(cڡ * 
c
);

27 cڡ * 
kwd_e
(cڡ * 
c
);

30 cڡ * 
kwd_
(cڡ * 
c
);

31 cڡ * 
kwd_d
(cڡ * 
c
);

32 cڡ * 
kwd_comma
(cڡ * 
c
);

33 cڡ * 
kwd_c
(cڡ * 
c
);

34 cڡ * 
kwd_ash
(cڡ * 
c
);

35 cڡ * 
kwd_
(cڡ * 
c
);

36 cڡ * 
kwd_us
(cڡ * 
c
);

37 cڡ * 
kwd_mus
(cڡ * 
c
);

44 
	gme
 <
	gbeg
, 
	gd
, 
bo
 
	gesc
>

45 cڡ * 
dimed_by
(cڡ * 
c
) {

46 
	gc
 = 
exaly
<
beg
>(
c
);

47 i(!
	gc
)  0;

48 cڡ * 
	g
;

50 i(!*
	gc
)  0;

51 
	g
 = 
exaly
<
d
>(
c
);

52 i(
	g
 && (!
	gesc
 || *(
	gc
 - 1!'\\') 

;

53 
	gc
 = 

 ? st : 
c
 + 1;

61 
	gme
<
ex
 
	gt
,x 
	g
>

62 cڡ * 
sk_ov_sces
(cڡ * 
c
, cڡ * 
d
) {

64 
size_t
 
	gv
 = 0;

65 
bo
 
	g_sque
 = 
l
;

66 
bo
 
	g_dque
 = 
l
;

69 *
	gc
) {

72 i(
	gd
 && 
	gc
 >
d
) ;

75 i(*
	gc
 == '\\') {

76 ++ 
c
;

78 i(*
	gc
 == '"') {

79 
_dque
 = ! in_dquote;

81 i(*
	gc
 == '\'') {

82 
_sque
 = ! in_squote;

84 i(
	g_dque
 || 
	g_sque
) {

89 i(cڡ * 
	gpos
 = 
t
(
c
)) {

90 ++ 
v
;

91 
	gc
 = 
pos
 - 1;

95 i(cڡ * 
	gf
 = 

(
c
)) {

97 i(
v
 > 0) --evel;

100  
	gf
;

102 
	gc
 = 
f
 - 1;

106 ++ 
	gc
;

114 cڡ * 
he_sce
(cڡ * 
c
);

120 
	gme
<
ex
 
	gt
,x 
	g
>

121 cڡ * 
sk_ov_sces
(cڡ * 
c
) {

122  
	gsk_ov_sces
<
	gt
, 
	g
>(
	gc
, 0);

126 
	gme
 <
ex
 
	gt
,x 
	g
>

127 cڡ * 
cursive_sces
(cڡ * 
c
) {

129 
	gc
 = 
t
(
c
);

131 i(!
	gc
)  0;

133  
	gsk_ov_sces
<
	gt
, 
	g
>(
	gc
);

137 
	gme
 <cڡ * 
	gbeg
, cڡ * 
	gd
, 
bo
 
	gesc
>

138 cڡ * 
dimed_by
(cڡ * 
c
) {

139 
	gc
 = 
exaly
<
beg
>(
c
);

140 i(!
	gc
)  0;

141 cڡ * 
	g
;

143 i(!*
	gc
)  0;

144 
	g
 = 
exaly
<
d
>(
c
);

145 i(
	g
 && (!
	gesc
 || *(
	gc
 - 1!'\\') 

;

146 
	gc
 = 

 ? st : 
c
 + 1;

151 
	gme
<
ex
 
	gmx
, 
size_t
 
	glo
, size_
	ghi
>

152 cڡ * 
bwn
(cڡ * 
c
) {

153 
size_t
 
	gi
 = 0; i < 
	glo
; ++i) {

154 
	gc
 = 
mx
(
c
);

155 i(!
	gc
)  0;

157 
size_t
 
	gi
 = 
lo
; i <
hi
; ++i) {

158 cڡ * 
	gw_c
 = 
mx
(
c
);

159 i(!
	gw_c
 
	gc
;

160 
	gc
 = 
w_c
;

162  
	gc
;

166 cڡ * 
_rg_doub_ݒ
(cڡ * 
c
);

167 cڡ * 
_rg_doub_o
(cڡ * 
c
);

168 cڡ * 
_rg_sg_ݒ
(cڡ * 
c
);

169 cڡ * 
_rg_sg_o
(cڡ * 
c
);

170 cڡ * 
_rg_uri_ݒ
(cڡ * 
c
);

171 cڡ * 
_rg_uri_o
(cڡ * 
c
);

174 cڡ * 
le_commt
(cڡ * 
c
);

177 cڡ * 
block_commt
(cڡ * 
c
);

179 cڡ * 
commt
(cڡ * 
c
);

181 cڡ * 
doub_qued_rg
(cڡ * 
c
);

182 cڡ * 
sg_qued_rg
(cڡ * 
c
);

183 cڡ * 
qued_rg
(cڡ * 
c
);

185 cڡ * 
ުt
(cڡ * 
c
);

187 cڡ * 
numb_efix
(cڡ * 
c
);

190 cڡ * 
tiڮ_css_whea
(cڡ * 
c
);

191 cڡ * 
css_whea
(cڡ * 
c
);

193 cڡ * 
tiڮ_css_commts
(cڡ * 
c
);

194 cڡ * 
css_commts
(cڡ * 
c
);

197 cڡ * 
es_q
(cڡ * 
c
);

200 cڡ * 
cuom_ݔty_me
(cڡ * 
c
);

202 cڡ * 
idtifr
(cڡ * 
c
);

203 cڡ * 
idtifr_pha
(cڡ * 
c
);

204 cڡ * 
idtifr_num
(cڡ * 
c
);

205 cڡ * 
ri_idtifr
(cڡ * 
c
);

206 cڡ * 
ri_idtifr_pha
(cڡ * 
c
);

207 cڡ * 
ri_idtifr_num
(cڡ * 
c
);

209 cڡ * 
e_un
(cڡ * 
c
);

210 cڡ * 
muɝ_uns
(cڡ * 
c
);

211 cڡ * 
un_idtifr
(cڡ * 
c
);

214 cڡ * 
_n_comb
(cڡ * 
c
);

215 cڡ * 
ic_n_comb
(cڡ * 
c
);

216 cڡ * 
schema_n_comb
(cڡ * 
c
);

219 cڡ * 
idtifr_schema
(cڡ * 
c
);

220 cڡ * 
vue_schema
(cڡ * 
c
);

221 cڡ * 
ss_vue
(cڡ * 
c
);

226 cڡ * 
vd_efix
(cڡ * 
c
);

228 cڡ * 
_ecl_deive
(cڡ * 
c
);

229 cڡ * 
_efixed_deive
(cڡ * 
c
);

230 cڡ * 
_mo_y_vue_tok
(cڡ * 
c
);

233 cڡ * 
_keywd
(cڡ * 
c
);

234 cڡ * 
kwd_impt
(cڡ * 
c
);

235 cڡ * 
kwd__ro
(cڡ * 
c
);

236 cڡ * 
kwd_wh_deive
(cڡ * 
c
);

237 cڡ * 
kwd_whout_deive
(cڡ * 
c
);

238 cڡ * 
kwd_med
(cڡ * 
c
);

239 cڡ * 
kwd_suts_deive
(cڡ * 
c
);

242 cڡ * 
kwd_mix
(cڡ * 
c
);

243 cڡ * 
kwd_funi
(cڡ * 
c
);

244 cڡ * 
kwd_tu_deive
(cڡ * 
c
);

245 cڡ * 
kwd_ude_deive
(cڡ * 
c
);

246 cڡ * 
kwd_cڋ_deive
(cڡ * 
c
);

247 cڡ * 
kwd_cht_deive
(cڡ * 
c
);

248 cڡ * 
kwd_exnd
(cڡ * 
c
);

250 cڡ * 
unicode_q
(cڡ * 
c
);

252 cڡ * 
kwd_if_deive
(cڡ * 
c
);

253 cڡ * 
kwd__deive
(cڡ * 
c
);

254 cڡ * 
if_deive
(cڡ * 
c
);

256 cڡ * 
kwd_f_deive
(cڡ * 
c
);

257 cڡ * 
kwd_om
(cڡ * 
c
);

258 cڡ * 
kwd_to
(cڡ * 
c
);

259 cڡ * 
kwd_through
(cڡ * 
c
);

261 cڡ * 
kwd_ch_deive
(cڡ * 
c
);

262 cڡ * 
kwd_
(cڡ * 
c
);

264 cڡ * 
kwd_whe_deive
(cڡ * 
c
);

266 cڡ * 
_nhg
(cڡ * 
c
);

267 cڡ * 
_ty_2
(cڡ * 
c
);

269 cڡ * 
_ecl_fun
(cڡ * 
c
);

271 cڡ * 
kwd_wn
(cڡ * 
c
);

272 cڡ * 
kwd_r
(cڡ * 
c
);

273 cڡ * 
kwd_dbg
(cڡ * 
c
);

275 cڡ * 
kwd_nu
(cڡ * 
c
);

277 cڡ * 
__li
(cڡ * 
c
);

278 cڡ * 
_ty_
(cڡ * 
c
);

279 cڡ * 
_ic_exessi
(cڡ * 
c
);

282 cڡ * 
css_idtifr
(cڡ * 
c
);

283 cڡ * 
css__idtifr
(cڡ * 
c
);

286 cڡ * 
mea_schema
(cڡ * 
c
);

287 cڡ * 
mea_efix
(cڡ * 
c
);

288 cڡ * 
ty_
(cڡ * 
c
);

289 cڡ * 
hyphs_d_idtifr
(cڡ * 
c
);

290 cڡ * 
hyphs_d_me
(cڡ * 
c
);

291 cڡ * 
univl
(cڡ * 
c
);

293 cڡ * 
id_me
(cڡ * 
c
);

295 cڡ * 
ass_me
(cڡ * 
c
);

297 cڡ * 
ibu_me
(cڡ * 
c
);

299 cڡ * 
ahd
(cڡ * 
c
);

301 cڡ * 

(cڡ * 
c
);

302 cڡ * 
sign
(cڡ * 
c
);

303 cڡ * 
unsigd_numb
(cڡ * 
c
);

304 cڡ * 
numb
(cڡ * 
c
);

305 cڡ * 
cffic
(cڡ * 
c
);

306 cڡ * 
boml
(cڡ * 
c
);

307 cڡ * 
rage
(cڡ * 
c
);

308 cڡ * 
amrnd
(cڡ * 
c
);

309 cڡ * 
dimsi
(cڡ * 
c
);

310 cڡ * 
hex
(cڡ * 
c
);

311 cڡ * 
hexa
(cڡ * 
c
);

312 cڡ * 
hex0
(cڡ * 
c
);

315 cڡ * 
uri_efix
(cڡ * 
c
);

317 cڡ * 
kwd_imp܏
(cڡ * 
c
);

319 cڡ * 
kwd_tiڮ
(cڡ * 
c
);

321 cڡ * 
deu_ag
(cڡ * 
c
);

322 cڡ * 
glob_ag
(cڡ * 
c
);

324 cڡ * 
pudo_efix
(cڡ * 
c
);

326 cڡ * 
_funiڮ
(cڡ * 
c
);

327 cڡ * 
_pudo_
(cڡ * 
c
);

328 cڡ * 
funiڮ_schema
(cڡ * 
c
);

329 cڡ * 
pudo_n
(cڡ * 
c
);

331 cڡ * 
ev
(cڡ * 
c
);

332 cڡ * 
odd
(cڡ * 
c
);

334 cڡ * 
exa_mch
(cڡ * 
c
);

335 cڡ * 
ass_mch
(cڡ * 
c
);

336 cڡ * 
dash_mch
(cڡ * 
c
);

337 cڡ * 
efix_mch
(cڡ * 
c
);

338 cڡ * 
suffix_mch
(cڡ * 
c
);

339 cڡ * 
subrg_mch
(cڡ * 
c
);

347 cڡ * 
vb
(cڡ * 
c
);

348 cڡ * 
lc__
(cڡ * 
c
);

351 cڡ * 
_ogid
(cڡ * 
c
);

352 cڡ * 
_exessi
(cڡ * 
c
);

353 cڡ * 
_ݔty
(cڡ * 
c
);

354 cڡ * 
_keywd_g
(cڡ * 
c
);

355 cڡ * 
_keywd_g_vue
(cڡ * 
c
);

356 cڡ * 
_keywd_g_ݔty
(cڡ * 
c
);

359 cڡ * 
H
(cڡ * 
c
);

360 cڡ * 
W
(cڡ * 
c
);

362 cڡ * 
UUNICODE
(cڡ * 
c
);

363 cڡ * 
NONASCII
(cڡ * 
c
);

364 cڡ * 
ESCAPE
(cڡ * 
c
);

365 cڡ * 
_uri_suffix
(cڡ * 
c
);

367 cڡ * 
_uri_vue
(cڡ * 
c
);

374 cڡ * 
ic_rg
(cڡ * 
c
);

375 cڡ * 
ic_compڒt
(cڡ * 
c
);

376 cڡ * 
ic_ݔty
(cڡ * 
c
);

377 cڡ * 
ic_vue
(cڡ * 
c
);

380 
	gme
<
	gc
>

381 cڡ * 
fd_f
(cڡ * 
c
) {

382 *
	gc
 && *!
c
++
c
;

383  *
	gc
 ? src : 0;

385 
	gme
<
ex
 
	gmx
>

386 cڡ * 
fd_f
(cڡ * 
c
) {

387 *
	gc
 && !
mx
(
c
)) ++src;

388  *
	gc
 ? src : 0;

390 
	gme
<
ex
 
	gmx
>

391 cڡ * 
fd_f__rv
(cڡ * 
beg
, cڡ * 
d
) {

392 
bo
 
	gesc
 = 
l
;

393 (
	gbeg
 < 
	gd
) && *beg) {

394 i(
	gesc
es
l
;

395 i(*
	gbeg
 ='\\'
esc
 = 
ue
;

396 i(
mx
(
beg
) 
	gbeg
;

397 ++
	gbeg
;

401 
	gme
<
ex
 
	gmx
,x 
	gsk
>

402 cڡ * 
fd_f__rv
(cڡ * 
beg
, cڡ * 
d
) {

403 
bo
 
	gesc
 = 
l
;

404 (
	gbeg
 < 
	gd
) && *beg) {

405 i(
	gesc
es
l
;

406 i(*
	gbeg
 ='\\'
esc
 = 
ue
;

407 i(cڡ * 
	gpos
 = 
sk
(
beg
)beg = 
pos
;

408 i(
mx
(
beg
) 
	gbeg
;

409 ++
	gbeg
;

413 
	gme
 <
ex
 
	gmx
>

414 
cou_rv
(cڡ * 
beg
, cڡ * 
d
) {

415 
	gcou
 = 0;

416 
bo
 
	gesc
 = 
l
;

417 
	gbeg
 < 
	gd
 && *beg) {

418 cڡ * 
	gp
;

419 i(
	gesc
) {

420 
	gesc
 = 
l
;

421 ++
	gbeg
;

422 } i(*
	gbeg
 == '\\') {

423 
esc
 = 
ue
;

424 ++
	gbeg
;

425 } i((
	gp
 = 
mx
(
beg
))) {

426 ++
cou
;

427 
	gbeg
 = 
p
;

430 ++
	gbeg
;

433  
	gcou
;

436 
	gme
 <
size_t
 
	gsize
, 
ex
 
	gmx
,x 
	gd
>

437 cڡ * 
dded_tok
(cڡ * 
c
)

439 
size_t
 
	gg
 = 0;

440 cڡ * 
	gpos
 = 
c
;

441 
	gg
 < 
	gsize
) {

442 i(!
mx
(
pos
)) ;

443 ++ 
	gpos
; ++ 
	gg
;

445 
	gg
 < 
	gsize
) {

446 i(!
d
(
pos
)) ;

447 ++ 
	gpos
; ++ 
	gg
;

449  
	gg
 ? 
	gpos
 : 0;

452 
	gme
 <
size_t
 
	gm
, size_
	gmax
, 
ex
 
	gmx
>

453 cڡ * 
mmax_nge
(cڡ * 
c
)

455 
size_t
 
	gg
 = 0;

456 cڡ * 
	gpos
 = 
c
;

457 
	gg
 < 
	gmax
) {

458 i(!
mx
(
pos
)) ;

459 ++ 
	gpos
; ++ 
	gg
;

461 i(
	gg
 < 
	gm
)  0;

462 i(
	gg
 > 
	gmax
)  0;

463  
	gpos
;

466 
	gme
 <
	gm
, 
	gmax
>

467 cڡ * 
ch_nge
(cڡ * 
c
)

469 i(*
	gc
 < 
	gm
)  0;

470 i(*
	gc
 > 
	gmax
)  0;

471  
	gc
 + 1;

	@node_modules/node-sass/src/libsass/src/remove_placeholders.cpp

1 
	~"ss.h
"

2 
	~"move_ahds.h
"

3 
	~"cڋxt.h
"

4 
	~"e.h
"

5 
	~<ioam
>

7 
mea
 
	gSass
 {

9 
	gRemove_Phds
::
Remove_Phds
(
Cڋxt
& 
x
)

10 : 
x
(ctx)

13 
Remove_Phds
::
ݔ
()(
Block
* 
b
) {

14 
size_t
 
i
 = 0, 
	gL
 = 
b
->
ngth
(); 
	gi
 < L; ++i) {

15 (*
	gb
)[
i
]->
rfm
(
this
);

19 
Se_Li
* 
	gRemove_Phds
::
move_ahds
(Se_Li* 

)

21 
Se_Li
* 
w_
 = 
SASS_MEMORY_NEW
(
x
.
mem
, Se_Li, 

->
pe
());

23 
size_t
 
	gi
 = 0, 
	gL
 = 

->
ngth
(); i < L; ++i) {

24 i(!(*
	g
)[
i
]->
cڏs_ahd
()) {

25 *
	gw_
 << (*
	g
)[
i
];

29  
	gw_
;

34 
	gRemove_Phds
::
ݔ
()(
Ruˣt
* 
r
) {

36 
Se_Li
* 

 = 
ic_
<Se_Li*>(
r
->

());

38 i(
	g
) {

40 
	gr
->

(
move_ahds
(

));

42 
Comex_Se
* 
	gcs
 : *

) {

43 
cs
) {

44 i(
cs
->
hd
()) {

45 
Sime_Se
* 
ss
 : *
cs
->
hd
()) {

46 i(
Wed_Se
* 
ws
 = 
dymic_
<Wed_Se*>(
ss
)) {

47 i(
Se_Li
* 

 = 
dymic_
<Se_Li*>(
ws
->

())) {

48 
Se_Li
* 
n
 = 
move_ahds
(

);

51 
	gn
->
move__s
();

52 
	gws
->

(
n
);

57 
	gcs
 = 
cs
->

();

63 
Block
* 
	gb
 = 
r
->
block
();

65 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

66 i((*
	gb
)[
i
](*b)[i]->
rfm
(
this
);

70 
	gRemove_Phds
::
ݔ
()(
Med_Block
* 
m
) {

71 
ݔ
()(
m
->
block
());

73 
	gRemove_Phds
::
ݔ
()(
Suts_Block
* 
m
) {

74 
ݔ
()(
m
->
block
());

77 
	gRemove_Phds
::
ݔ
()(
Deive
* 
a
) {

78 i(
a
->
block
()a->block()->
rfm
(
this
);

	@node_modules/node-sass/src/libsass/src/remove_placeholders.hpp

1 #ide
SASS_REMOVE_PLACEHOLDERS_H


2 
	#SASS_REMOVE_PLACEHOLDERS_H


	)

4 #agm



6 
	~"a.h
"

7 
	~"ݔi.h
"

9 
mea
 
	gSass
 {

12 
ass
 
	gCڋxt
;

14 
ass
 
	gRemove_Phds
 : 
public
 
Oti_CRTP
<, Remove_Placeholders> {

16 
	gCڋxt
& 
	gx
;

18 
back_im
(
AST_Node
* 
n
) {}

20 
	gpublic
:

21 
Se_Li
* 
move_ahds
(Selector_List*);

23 
	gpublic
:

24 
Remove_Phds
(
Cڋxt
&);

25 ~
Remove_Phds
() { }

27 
ݔ
()(
	gBlock
*);

28 
ݔ
()(
	gRuˣt
*);

29 
ݔ
()(
	gMed_Block
*);

30 
ݔ
()(
	gSuts_Block
*);

31 
ݔ
()(
	gDeive
*);

33 
	gme
 <
tyme
 
	gU
>

34 
back
(
U
 
x
{  
back_im
(x); }

	@node_modules/node-sass/src/libsass/src/sass.cpp

1 
	~"ss.h
"

2 
	~<cdlib
>

3 
	~<crg
>

4 
	~<ve
>

5 
	~<sam
>

7 
	~"ss.h
"

8 
	~"fe.h
"

9 
	~"ut.h
"

12 
usg
 
mea
 
Sass
;

16 * 
ADDCALL
 
ss_loc_memy
(
size_t
 
size
)

18 * 
r
 = 
mloc
(
size
);

19 i(
r
 =
NULL
)

20 
out_of_memy
();

21  
r
;

24 * 
ADDCALL
 
ss_cy_c_rg
(cڡ * 
r
)

26 
size_t
 
n
 = 

(
r
) + 1;

27 * 
y
 = (*
ss_loc_memy
(
n
);

28 
d
::
memy
(
y
, 
r
, 
n
);

29  
y
;

33 
ADDCALL
 
ss__memy
(* 
r
)

35 i(
r


 (ptr);

39 * 
ADDCALL
 
ss_rg_que
 (cڡ *
r
, cڡ 
que_mk
)

41 
d
::
rg
 
qued
 = 
que
(
r
, 
que_mk
);

42  
ss_cy_c_rg
(
qued
.
c_r
());

46 * 
ADDCALL
 
ss_rg_unque
 (cڡ *
r
)

48 
d
::
rg
 
unqued
 = 
unque
(
r
);

49  
ss_cy_c_rg
(
unqued
.
c_r
());

54 * 
ADDCALL
 
ss_sve_fe
 (cڡ * 
fe
, cڡ * 
ths
[])

56 
d
::
rg
 
sved
(
Fe
::
fd_fe
(
fe
, 
ths
));

57  
ss_cy_c_rg
(
sved
.
c_r
());

61 cڡ * 
ADDCALL
 
libss_vsi
()

63  
LIBSASS_VERSION
;

67 cڡ * 
ADDCALL
 
libss_nguage_vsi
()

69  
LIBSASS_LANGUAGE_VERSION
;

	@node_modules/node-sass/src/libsass/src/sass.hpp

2 #ide
SASS_SASS_H


3 
	#SASS_SASS_H


	)

8 #unde
__EXTENSIONS__


10 #ifde
_MSC_VER


11 #agm
wng
(
dib
 : 4005)

15 #ifde
_WIN32


17 
	#NOGDI


	)

19 
	#NOMINMAX


	)

21 
	#_NO_W32_PSEUDO_MODIFIERS


	)

27 #ide
FS_CASE_SENSITIVE


28 #ifde
_WIN32


29 
	#FS_CASE_SENSITIVE
 0

	)

31 
	#FS_CASE_SENSITIVE
 1

	)

36 #ide
PATH_SEP


37 #ifde
_WIN32


38 
	#PATH_SEP
 ';'

	)

40 
	#PATH_SEP
 ':'

	)

46 
	~"ss/ba.h
"

49 
mea
 
	gSass
 {

52 cڡ 
Sass_Ouut_Sty
 
	gNESTED
 = 
SASS_STYLE_NESTED
;

53 cڡ 
Sass_Ouut_Sty
 
	gCOMPACT
 = 
SASS_STYLE_COMPACT
;

54 cڡ 
Sass_Ouut_Sty
 
	gEXPANDED
 = 
SASS_STYLE_EXPANDED
;

55 cڡ 
Sass_Ouut_Sty
 
	gCOMPRESSED
 = 
SASS_STYLE_COMPRESSED
;

57 cڡ 
Sass_Ouut_Sty
 
	gINSPECT
 = 
SASS_STYLE_INSPECT
;

58 cڡ 
Sass_Ouut_Sty
 
	gTO_SASS
 = 
SASS_STYLE_TO_SASS
;

63 
	eSass_Iut_Sty
 {

64 
	mSASS_CONTEXT_NULL
,

65 
	mSASS_CONTEXT_FILE
,

66 
	mSASS_CONTEXT_DATA
,

67 
	mSASS_CONTEXT_FOLDER


71 
	srg_li
 {

72 
rg_li
* 
	mxt
;

73 * 
	mrg
;

77 
	sSass_Ine_Ois
 {

81 
Sass_Ouut_Sty
 
	mouut_y
;

84 
	mecisi
;

87 
Sass_Ine_Ois
(
Sass_Ouut_Sty
 
y
 = 
Sass
::
NESTED
,

88 
ecisi
 = 5)

89 : 
ouut_y
(
y
), 
ecisi
(precision)

95 
	gSass_Ouut_Ois
 : 
Sass_Ine_Ois
 {

98 cڡ * 
dt
;

100 cڡ * 
	gleed
;

104 
bo
 
	gsour_commts
;

107 
Sass_Ouut_Ois
(
Sass_Ine_Ois
 
t
,

108 cڡ * 
dt
 = " ",

109 cڡ * 
leed
 = "\n",

110 
bo
 
sour_commts
 = 
l
)

111 : 
Sass_Ine_Ois
(
t
),

112 
dt
(dt), 
leed
(linefeed),

113 
sour_commts
(source_comments)

117 
Sass_Ouut_Ois
(
Sass_Ouut_Sty
 
y
 = 
Sass
::
NESTED
,

118 
ecisi
 = 5,

119 cڡ * 
dt
 = " ",

120 cڡ * 
leed
 = "\n",

121 
bo
 
sour_commts
 = 
l
)

122 : 
Sass_Ine_Ois
(
y
, 
ecisi
),

123 
dt
(dt), 
leed
(linefeed),

124 
sour_commts
(source_comments)

	@node_modules/node-sass/src/libsass/src/sass2scss.cpp

7 #ifde
_MSC_VER


8 
	#_CRT_SECURE_NO_WARNINGS


	)

9 
	#_CRT_NONSTDC_NO_DEPRECATE


	)

13 
	~<ack
>

14 
	~<rg
>

15 
	~<crg
>

16 
	~<cdlib
>

17 
	~<sam
>

18 
	~<ioam
>

19 
	~<dio.h
>

33 
	~"ss2scss.h
"

36 
mea
 
	gSass


40 
	#PRETTIFY
(
cvr
(cvr.
tis
 - (cvr.tiڠ& 248))

	)

42 
	#KEEP_COMMENT
(
cvr
((cvr.
tis
 & 
SASS2SCSS_KEEP_COMMENT
=SASS2SCSS_KEEP_COMMENT)

	)

43 
	#STRIP_COMMENT
(
cvr
((cvr.
tis
 & 
SASS2SCSS_STRIP_COMMENT
=SASS2SCSS_STRIP_COMMENT)

	)

44 
	#CONVERT_COMMENT
(
cvr
((cvr.
tis
 & 
SASS2SCSS_CONVERT_COMMENT
=SASS2SCSS_CONVERT_COMMENT)

	)

47 
	#INDENT
(
cvr
(cvr.
dts
.
	`t
())

	)

50 
	#IS_PARSING
(
cvr
(cvr.
commt
 ="")

	)

51 
	#IS_COMMENT
(
cvr
(cvr.
commt
 !"")

	)

52 
	#IS_SRC_COMMENT
(
cvr
(cvr.
commt
 ="//" && ! 
	`CONVERT_COMMENT
(cvr))

	)

53 
	#IS_CSS_COMMENT
(
cvr
(cvr.
commt
 ="/*" || (cvr.comm="//" && 
	`CONVERT_COMMENT
(cvr)))

	)

56 
	gd
::
rg
 
or
 (cڡ 
cvr
& converter)

58  
PRETTIFY
(
cvr
) == 0 ? " }" :

59 
PRETTIFY
(
cvr
) <= 1 ? " }" :

60 "\n" + 
INDENT
(
cvr
) + "}";

64 
	gd
::
rg
 
ݒ
 (cڡ 
cvr
& converter)

66  
PRETTIFY
(
cvr
) == 0 ? " { " :

67 
PRETTIFY
(
cvr
) <= 2 ? " {" :

68 "\n" + 
INDENT
(
cvr
) + "{";

73 
bo
 
isPudoSe
 (
d
::
rg
& 
l
)

76 
size_t
 
n
 = 
l
.
ngth
();

77 i(
	gn
 < 1 
	gl
;

78 
size_t
 
	gpos
 = 
l
.
fd_f_n_of
("abcdefghijklmnopqrstuvwxyz-ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1);

79 i(
	gpos
 !
d
::
rg
::
os

l
.
a
(
pos
, std::string::npos);

80 
size_t
 
	gi
 = 
l
.
ngth
();

81 
	gi
 -- > 0{ 
	gl
.

(
i

tow
(
l
.at(i)); }

84 i(
	gl
 =":lk" 
ue
;

85 i(
	gl
 =":vised" 
ue
;

86 i(
	gl
 =":aive" 
ue
;

89 i(
	gl
 =":ng" 
ue
;

90 i(
	gl
 =":f-chd" 
ue
;

91 i(
	gl
 =":hov" 
ue
;

92 i(
	gl
 =":focus" 
ue
;

96 i(
	gl
 =":f" 
ue
;

99 i(
	gl
 =":rg" 
ue
;

100 i(
	gl
 =":ro" 
ue
;

101 i(
	gl
 =":h-chd" 
ue
;

102 i(
	gl
 =":h-ϡ-of-chd" 
ue
;

103 i(
	gl
 =":h-of-ty" 
ue
;

104 i(
	gl
 =":h-ϡ-of-ty" 
ue
;

105 i(
	gl
 =":ϡ-chd" 
ue
;

106 i(
	gl
 =":f-of-ty" 
ue
;

107 i(
	gl
 =":ϡ-of-ty" 
ue
;

108 i(
	gl
 =":ly-chd" 
ue
;

109 i(
	gl
 =":ly-of-ty" 
ue
;

110 i(
	gl
 =":emy" 
ue
;

111 i(
	gl
 =":n" 
ue
;

114 i(
	gl
 =":deu" 
ue
;

115 i(
	gl
 =":vid" 
ue
;

116 i(
	gl
 =":vid" 
ue
;

117 i(
	gl
 =":-nge" 
ue
;

118 i(
	gl
 =":out-of-nge" 
ue
;

119 i(
	gl
 =":qued" 
ue
;

120 i(
	gl
 =":tiڮ" 
ue
;

121 i(
	gl
 =":ad-ly" 
ue
;

122 i(
	gl
 =":ad-wre" 
ue
;

123 i(
	gl
 =":d" 
ue
;

124 i(
	gl
 =":abd" 
ue
;

125 i(
	gl
 =":dibd" 
ue
;

126 i(
	gl
 =":checked" 
ue
;

127 i(
	gl
 =":dme" 
ue
;

128 i(
	gl
 =":h-ϡ-chd" 
ue
;

131 i(
	gl
 =":y-lk" 
ue
;

132 i(
	gl
 =":lol-lk" 
ue
;

133 i(
	gl
 =":sce" 
ue
;

134 i(
	gl
 =":aive-dr-rg" 
ue
;

135 i(
	gl
 =":vid-dr-rg" 
ue
;

136 i(
	gl
 =":vid-dr-rg" 
ue
;

137 i(
	gl
 =":cut" 
ue
;

138 i(
	gl
 =":" 
ue
;

139 i(
	gl
 =":futu" 
ue
;

140 i(
	gl
 =":ahd-shown" 
ue
;

141 i(
	gl
 =":ur-r" 
ue
;

142 i(
	gl
 =":bnk" 
ue
;

143 i(
	gl
 =":h-mch" 
ue
;

144 i(
	gl
 =":h-ϡ-mch" 
ue
;

145 i(
	gl
 =":h-cumn" 
ue
;

146 i(
	gl
 =":h-ϡ-cumn" 
ue
;

147 i(
	gl
 =":mches" 
ue
;

150 i(
	gl
 =":fusn" 
ue
;

153  
	gl
;

159 
bo
 
hasChDa
 (
d
::
rg
& 
ss
)

162 
size_t
 
c_pos
 = 0;

164 
	gue
)

168 
	gc_pos
 = 
ss
.
fd_f_n_of
(" \t\n\v\f\r", 
c_pos
);

171 i(
	gc_pos
 =
d
::
rg
::
os
 
l
;

174 i(
	gss
.
subr
(
c_pos
, 2) == "/*")

177 
c_pos
 = 
ss
.
fd
("*/", col_pos);

179 i(
	gc_pos
 =
d
::
rg
::
os
 
l
;

181 
	gc_pos
 += 2;

185  
	gue
;

195 
size_t
 
fdCommtOr
 (
d
::
rg
& 
ss
)

198 
size_t
 
c_pos
 = 0;

199 
bo
 
	gd
 = 
l
;

200 
bo
 
	gqued
 = 
l
;

201 
bo
 
	gcommt
 = 
l
;

202 
size_t
 
	gbcks
 = 0;

204 
	gc_pos
 !
d
::
rg
::
os
)

208 
c_pos
 = 
ss
.
fd_f_of
("\"\'/\\*()", col_pos);

211 i(
	gc_pos
 !
d
::
rg
::
os
)

213 
cha
 = 
ss
.

(
c_pos
);

215 i(
	gcha
 == '(')

217 i(!
qued
 && !
d

bcks
 ++;

219 i(
	gcha
 == ')')

221 i(!
qued
 && !
d

bcks
 --;

223 i(
	gcha
 == '\"')

226 i(!
d
 && !
commt

qued
 = !quoted;

228 i(
	gcha
 == '\'')

231 i(!
qued
 && !
commt

d
 = !apoed;

233 i(
	gc_pos
 > 0 && 
	gcha
 == '/')

235 i(
ss
.

(
c_pos
 - 1) == '*')

237 
commt
 = 
l
;

240 i(
	gss
.

(
c_pos
 - 1) == '/')

243 i(!
qued
 && !
d
 && !
commt
 && 
bcks
 =0 
c_pos
 - 1;

246 i(
	gcha
 == '\\')

249 i(
qued
 || 
d

c_pos
 ++;

252 i(
	gc_pos
 > 0 && 
	gcha
 == '*')

255 i(
ss
.

(
c_pos
 - 1) == '/')

258 i(!
qued
 && !
d

commt
 = 
ue
;

263 
	gc_pos
 ++;

270  
	gc_pos
;

277 
	gd
::
rg
 
moveMuɞeCommt
 (
d
::rg &
ss
)

280 
d
::
rg
 
n
 = "";

281 
size_t
 
	gc_pos
 = 0;

282 
size_t
 
	gݒ_pos
 = 0;

283 
size_t
 
	go_pos
 = 0;

284 
bo
 
	gd
 = 
l
;

285 
bo
 
	gqued
 = 
l
;

286 
bo
 
	gcommt
 = 
l
;

289 
	gc_pos
 !
d
::
rg
::
os
)

293 
c_pos
 = 
ss
.
fd_f_of
("\"\'/\\*", col_pos);

296 i(
	gc_pos
 !
d
::
rg
::
os
)

298 
cha
 = 
ss
.

(
c_pos
);

301 i(
	gcha
 == '\"')

303 i(!
d
 && !
commt

qued
 = !quoted;

305 i(
	gcha
 == '\'')

307 i(!
qued
 && !
commt

d
 = !apoed;

310 i(
	gcha
 == '/')

313 i(
commt
 && 
c_pos
 > 0 && 
ss
.

(col_pos - 1) == '*')

315 
o_pos
 = 
c_pos
 + 1; 
	gcommt
 = 
l
;

318 i(
	gcha
 == '\\')

321 i(
qued
 || 
d

c_pos
 ++;

324 i(
	gcha
 == '*')

327 i(!
qued
 && !
d
 && 
c_pos
 > 0 && 
ss
.

(col_pos - 1) == '/')

329 
commt
 = 
ue
; 
	gݒ_pos
 = 
c_pos
 - 1;

330 
	gn
 +
ss
.
subr
(
o_pos
, 
ݒ_pos
 - close_pos);

335 
	gc_pos
 ++;

343 i(
	gcommt

	gn
 +
ss
.
subr
(
ݒ_pos
);

344 
	gn
 +
ss
.
subr
(
o_pos
);

347  
	gn
;

353 
	gd
::
rg
 
rim
(cڡ 
d
::rg &
ss
)

355 
d
::
rg
 
immed
 = 
ss
;

356 
size_t
 
	gpos_ws
 = 
immed
.
fd_ϡ_n_of
(" \t\n\v\f\r");

357 i(
	gpos_ws
 !
d
::
rg
::
os
)

358 { 
immed
.
a
(
pos_ws
 + 1); }

359 { 
	gimmed
.
r
(); }

360  
	gimmed
;

366 
	gd
::
rg
 
ush
 (
d
::rg& 
ss
, 
cvr
& converter)

370 
	gd
::
rg
 
scss
 = "";

373 
	gscss
 +
PRETTIFY
(
cvr
) > 0 ?

374 
cvr
.
whea
 : "";

376 
	gcvr
.
	gwhea
 = "";

379 
size_t
 
	gpos_right
 = 
ss
.
fd_ϡ_n_of
("\n\r");

380 i(
	gpos_right
 =
d
::
rg
::
os
 
scss
;

383 
	gd
::
rg
 
lfs
 = 
ss
.
subr
(
pos_right
 + 1);

384 
	gss
 = 
ss
.
subr
(0, 
pos_right
 + 1);

387 
size_t
 
	gcommt_pos
 = 
fdCommtOr
(
ss
);

389 i(
	gcommt_pos
 !
d
::
rg
::
os
)

392 i(
CONVERT_COMMENT
(
cvr
&& !
IS_COMMENT
(converter))

395 
ss
.

(
commt_pos
 + 1) = '*';

397 
	gss
 += " */";

400 i(
	gcommt_pos
 > 0)

403 
size_t
 
	gws_pos
 = 
ss
.
fd_ϡ_n_of
(
SASS2SCSS_FIND_WHITESPACE
, 
commt_pos
 - 1);

404 
	gcommt_pos
 = 
ws_pos
 =
d
::
rg
::
os
 ? 0 : ws_pos + 1;

406 i(!
STRIP_COMMENT
(
cvr
))

409 
	gcvr
.
	gwhea
 +
ss
.
subr
(
commt_pos
);

416 
	gss
 = 
ss
.
subr
(0, 
commt_pos
);

420 
	gcvr
.
	gwhea
 +
lfs
 + "\n";

423 i(
PRETTIFY
(
cvr
) == 0)

426 
size_t
 
pos_
 = 
ss
.
fd_f_n_of
(
SASS2SCSS_FIND_WHITESPACE
);

427 i(
	gpos_
 !
d
::
rg
::
os

ss
 = sass.
subr
(
pos_
);

431 
	gscss
 +
ss
;

434  
	gscss
;

440 
	gd
::
rg
 
oss
 (
d
::rg& 
ss
, 
cvr
& converter)

444 
	gd
::
rg
 
scss
 = "";

447 i(
STRIP_COMMENT
(
cvr
))

449 
	gss
 = 
moveMuɞeCommt
(
ss
);

453 
	gss
 = 
rim
(
ss
);

456 
size_t
 
	gpos_
 = 
ss
.
fd_f_n_of
(
SASS2SCSS_FIND_WHITESPACE
);

459 i(
	gcvr
.
	gd_of_fe

	gpos_
 = 0;

462 i(
	gpos_
 =
d
::
rg
::
os
)

465 
cvr
.
whea
 +
ss
 + "\n";

472 
	gd
::
rg
 
dt
 = 
ss
.
subr
(0, 
pos_
);

475 
	gd
::
rg
 
ݒ
 = 
ss
.
subr
(
pos_
, 2);

479 i(
	gdt
.
ngth
(<
INDENT
(
cvr
).length())

483 i(
IS_CSS_COMMENT
(
cvr
))

486 i(!
STRIP_COMMENT
(
cvr
)
scss
 += " */";

489 i(
IS_SRC_COMMENT
(
cvr
))

497 i(
	gcvr
.
	gݔty
)

500 i(!
	gcvr
.
	gcomma
)

504 i(
	gcvr
.
	g

	gscss
 += " {}";

506 i(!
	gcvr
.
	gmic

	gscss
 += ";";

511 
	gcvr
.
	gcommt
 = "";

516 
	gdt
.
ngth
(< 
INDENT
(
cvr
).length())

519 
	gcvr
.
	gdts
.
p
();

521 i(
IS_PARSING
(
cvr
))

522 { 
	gscss
 +
or
(
cvr
); }

523 { 
	gscss
 += " */"; }

525 
	gcvr
.
	gcommt
 = "";

529 
	gcvr
.
	g
 = 
l
;

533 i(
	gss
.
subr
(
pos_
, 1) == "\\") {

534 
cvr
.

 = 
ue
;

535 
	gss
[
pos_
] = ' ';

539 i(
	gss
.
subr
(
pos_
, 1=":" && 
ss
.substr(pos_left, 2) != "::")

544 
cvr
.

 = 
ue
;

546 
size_t
 
	gpos_wa
 = 
ss
.
fd_f_of
(
SASS2SCSS_FIND_WHITESPACE
, 
pos_
);

548 i(
	gpos_wa
 !
d
::
rg
::
os
)

551 
d
::
rg
 
pudo
 = 
ss
.
subr
(
pos_
, 
pos_wa
 -os_left);

554 
size_t
 
	gpos_vue
 = 
ss
.
fd_f_n_of
(
SASS2SCSS_FIND_WHITESPACE
, 
pos_wa
);

556 i(
	gpos_vue
 !
d
::
rg
::
os
)

559 i(!(
ss
.

(
pos_vue
=':' || 
isPudoSe
(
pudo
)))

562 
ss
 = 
dt
 + sass.
subr
(
pos_
 + 1, 
pos_wa
 -os_ - 1+ ":" + 
	gss
.substr(pos_wspace);

564 
size_t
 
	gpos_c
 = 
ss
.
fd_f_n_of
(":", 
pos_
);

566 i(
	gpos_c
 !
d
::
rg
::
os
)

569 
pos_c
 = 
ss
.
fd_f_of
(":",os_colon);

571 
	gcvr
.
	g
 = 
pos_c
 =
d
::
rg
::
os
;

581 
	gss
.
subr
(
pos_
, 5) == "@warn" ||

582 
ss
.
subr
(
pos_
, 6) == "@debug" ||

583 
ss
.
subr
(
pos_
, 6) == "@error" ||

584 
ss
.
subr
(
pos_
, 8) == "@charset"

585 { 
ss
 = 
dt
 + sass.
subr
(
pos_
); }

587 i(
	gss
.
subr
(
pos_
, 1="=" && 
ss
.
fd_f_of
(
SASS2SCSS_FIND_WHITESPACE
,os_left) !=os_left + 1)

588 { 
ss
 = 
dt
 + "@mix " + sass.
subr
(
pos_
 + 1); }

589 i(
	gss
.
subr
(
pos_
, 1="+" && 
ss
.
fd_f_of
(
SASS2SCSS_FIND_WHITESPACE
,os_left) !=os_left + 1)

590 { 
ss
 = 
dt
 + "@ud" + sass.
subr
(
pos_
 + 1); }

593 i(
	gss
.
subr
(
pos_
, 7) == "@import")

596 
size_t
 
pos_impt
 = 
ss
.
fd_f_of
(
SASS2SCSS_FIND_WHITESPACE
, 
pos_
 + 7);

597 
size_t
 
	gpos_que
 = 
ss
.
fd_f_n_of
(
SASS2SCSS_FIND_WHITESPACE
, 
pos_impt
);

599 i(
	gss
.
subr
(
pos_que
, 4) != "url(")

602 i(
ss
.
subr
(
pos_que
, 1) != "\"" && sass.substr(pos_quote, 1) != "\'")

605 
size_t
 
pos_d
 = 
ss
.
fd_ϡ_n_of
(
SASS2SCSS_FIND_WHITESPACE
);

607 i(
	gpos_d
 !
d
::
rg
::
os
)

610 
ss
 = sass.
subr
(0, 
pos_que
+ "\"" + 
	gss
.subros_que, 
pos_d
 -os_quote + 1) + "\"";

617 
	gss
.
subr
(
pos_
, 7) != "@return" &&

618 
ss
.
subr
(
pos_
, 7) != "@extend" &&

619 
ss
.
subr
(
pos_
, 8) != "@include" &&

620 
ss
.
subr
(
pos_
, 8) != "@content"

624 
cvr
.

 = 
ue
;

626 
size_t
 
	gpos_c
 = 
ss
.
fd_f_of
(":", 
pos_
);

628 i(
	gpos_c
 !
d
::
rg
::
os
)

631 i(
ss
[
pos_c
+1] =' '
cvr
.

 = 
l
;

632 i(
	gss
[
pos_c
+1] =' '
cvr
.

 = 
l
;

638 i(
	gdt
.
ngth
(>
INDENT
(
cvr
).length())

641 i(
IS_PARSING
(
cvr
))

644 i(
hasChDa
(
ss
))

648 
cvr
.
ݔty
 = 
ue
;

653 i(
	gdt
.
ngth
(> 
INDENT
(
cvr
).length())

656 i(
IS_PARSING
(
cvr
))

659 i(
	gcvr
.
	gݔty
)

662 
	gscss
 +
ݒ
(
cvr
);

664 
	gcvr
.
	gdts
.
push
("");

666 
INDENT
(
cvr

dt
;

670 i(!
IS_CSS_COMMENT
(
cvr
))

674 
	gss
.

(
INDENT
(
cvr
).
ngth
()+0) = '/';

677 
	gss
.

(
INDENT
(
cvr
).
ngth
()+1) = '/';

684 i(
	gݒ
 ="/*" || 
ݒ
 == "//")

687 
cvr
.
ݔty
 = 
l
;

689 i(
IS_CSS_COMMENT
(
cvr
&& 
	gݒ
 != "")

691 i(!
STRIP_COMMENT
(
cvr
&& !
CONVERT_COMMENT
(cvr)
scss
 += " */";

695 i(
CONVERT_COMMENT
(
cvr
))

697 i(
IS_PARSING
(
cvr
))

698 { 
	gss
.

(
pos_
 + 1) = '*'; }

701 
	gcvr
.
	gcommt
 = 
ݒ
;

708 (
IS_COMMENT
(
cvr
&& 
STRIP_COMMENT
(converter)) ||

711 (
IS_SRC_COMMENT
(
cvr
&& ! 
KEEP_COMMENT
(converter))

715 
	gscss
 +
ush
(
ss
, 
cvr
);

719 
size_t
 
	gpos_right
 = 
ss
.
fd_ϡ_n_of
(
SASS2SCSS_FIND_WHITESPACE
);

722 i(
	gpos_right
 !
d
::
rg
::
os
)

726 
d
::
rg
 
o
 = 
ss
.
subr
(
pos_right
, 1);

729 
	gcvr
.
	gcomma
 = 
IS_PARSING
(
cvr
&& 
o
 == ",";

730 
	gcvr
.
	gmic
 = 
IS_PARSING
(
cvr
&& 
o
 == ";";

734 i(
	gpos_right
 > 0)

738 
	gd
::
rg
 
o
 = 
ss
.
subr
(
pos_right
 - 1, 2);

740 i(
	go
 ="*/"
cvr
.
commt
 = "";

751  
	gscss
;

758 
	gd
::
iam
& 
Gle
(
d
::iam& 
is
, std::
rg
& 
t
)

760 
t
.
r
();

768 
	gd
::
iam
::
ry
 

(
is
, 
ue
);

769 
	gd
::
ambuf
* 
sb
 = 
is
.
rdbuf
();

772 
	gc
 = 
sb
->
sbumpc
();

773 
	gc
) {

775  
is
;

777 if(
sb
->
sgc
() == '\n')

778 
sb
->
sbumpc
();

779  
	gis
;

780 
	gEOF
:

782 if(
t
.
emy
())

783 
is
.
te
(
d
::
ios
::
eofb
);

784  
	gis
;

786 
t
 +()
c
;

792 * 
ss2scss
 (cڡ 
d
::
rg
& 
ss
, cڡ 
tis
)

796 
	gd
::
rg
 
le
;

797 
	gd
::
rg
 
scss
 = "";

798 
	gd
::
rgam
 
am
(
ss
);

801 
cvr
 
	gcvr
;

803 
	gcvr
.
	gcomma
 = 
l
;

804 
	gcvr
.
	gݔty
 = 
l
;

805 
	gcvr
.
	g
 = 
l
;

806 
	gcvr
.
	gmic
 = 
l
;

807 
	gcvr
.
	gd_of_fe
 = 
l
;

808 
	gcvr
.
	gcommt
 = "";

809 
	gcvr
.
	gwhea
 = "";

810 
	gcvr
.
	gdts
.
push
("");

811 
	gcvr
.
	gtis
 = 
tis
;

814 
Gle
(
am
, 
le
&& !
	gam
.
eof
())

815 { 
	gscss
 +
oss
(
le
, 
cvr
); }

818 
	gd
::
rg
 
or
 = "";

820 
	gcvr
.
	gd_of_fe
 = 
ue
;

822 
	gscss
 +
oss
(
or
, 
cvr
);

826 * 
	gcr
 = (*
mloc
 (
scss
.
ngth
() + 1);

828 
ry
 (
cr
, 
scss
.
c_r
());

830  &
	gcr
[0];

842 * 
ADDCALL
 
ss2scss
 (cڡ * 
ss
, cڡ 
tis
)

844  
Sass
::
ss2scss
(
ss
, 
tis
);

848 cڡ * 
ADDCALL
 
ss2scss_vsi
() {

849  
SASS2SCSS_VERSION
;

	@node_modules/node-sass/src/libsass/src/sass_context.cpp

1 
	~"ss.h
"

2 
	~<crg
>

3 
	~<dex
>

4 
	~<sam
>

5 
	~<rg
>

6 
	~<ve
>

8 
	~"ss.h
"

9 
	~"fe.h
"

10 
	~"js.h
"

11 
	~"ut.h
"

12 
	~"cڋxt.h
"

13 
	~"ss_cڋxt.h
"

14 
	~"ss_funis.h
"

15 
	~"a_fwd_de.h
"

16 
	~"r_hdlg.h
"

18 
	#LFEED
 "\n"

	)

21 
usg
 
mea
 
Sass
;

23 
cy_tis
(
Sass_Ois
* 
to
, Sass_Ois* 
om
) { *to = *from; }

25 
	#IMPLEMENT_SASS_OPTION_ACCESSOR
(
ty
, 
ti
) \

26 
ty
 
ADDCALL
 
ss_ti_g_
##
	`ti
 (
Sass_Ois
* 
tis
{  ois->
ti
; } \

27 
ADDCALL
 
ss_ti_t_
##
	`ti
 (
Sass_Ois
* 
tis
, 
ty
 
ti
{ ois->ti = oi; }

	)

28 
	#IMPLEMENT_SASS_OPTION_STRING_ACCESSOR
(
ty
, 
ti
, 
def
) \

29 
ty
 
ADDCALL
 
ss_ti_g_
##
	`ti
 (
Sass_Ois
* 
tis
{  
	`_r
(tis->
ti
, 
def
); } \

30 
ADDCALL
 
ss_ti_t_
##
	`ti
 (
Sass_Ois
* 
tis
, 
ty
 
ti
) \

31 { 
	`
(
tis
->
ti
); ois->ti = oi || 
def
 ? 
	`ss_cy_c_rg
(ti ? oi : def: 0; }

	)

33 
	#IMPLEMENT_SASS_CONTEXT_GETTER
(
ty
, 
ti
) \

34 
ty
 
ADDCALL
 
ss_cڋxt_g_
##
	`ti
 (
Sass_Cڋxt
* 
x
{  ctx->
ti
; }

	)

35 
	#IMPLEMENT_SASS_CONTEXT_TAKER
(
ty
, 
ti
) \

36 
ty
 
ss_cڋxt_ke_
##
	`ti
 (
Sass_Cڋxt
* 
x
) \

37 { 
ty
 
foo
 = 
x
->
ti
; ctx->ti = 0;  foo; }

	)

39 
hd_r
(
Sass_Cڋxt
* 
c_x
) {

40 
y
 {

41 
throw
;

43 
tch
 (
Exi
::
Ba
& 
e
) {

44 
d
::
rgam
 
msg_am
;

45 
d
::
rg
 
cwd
(
Sass
::
Fe
::
g_cwd
());

47 
d
::
rg
 
msg_efix
(
e
.
y
());

48 
bo
 
g_wle
 = 
l
;

49 
msg_am
 << 
msg_efix
 << ": ";

50 cڡ * 
msg
 = 
e
.
wh
();

51 
msg
 && *msg) {

52 i(*
msg
 == '\r') {

53 
g_wle
 = 
ue
;

54 } i(*
msg
 == '\n') {

55 
g_wle
 = 
ue
;

56 } i(
g_wle
) {

57 
msg_am
 << 
d
::
rg
(
msg_efix
.
size
() + 2, ' ');

58 
g_wle
 = 
l
;

60 
msg_am
 << *
msg
;

61 ++ 
msg
;

63 i(!
g_wle

msg_am
 << "\n";

64 i(
e
.
impt_ack
) {

65 
size_t
 
i
 = 1; i < 
e
.
impt_ack
->
size
() - 1; ++i) {

66 
d
::
rg
 
th
((*
e
.
impt_ack
)[
i
]->
imp_th
);

67 
d
::
rg
 
l_th
(
Sass
::
Fe
::
abs2l
(
th
, 
cwd
, cwd));

68 
msg_am
 << 
d
::
rg
(
msg_efix
.
size
() + 2, ' ');

69 
msg_am
 << (
i
 == 1 ? " onine " : " fromine ");

70 
msg_am
 << 
e
.
pe
.
le
+1 << " o" << 
l_th
 << "\n";

73 
d
::
rg
 
l_th
(
Sass
::
Fe
::
abs2l
(
e
.
pe
.
th
, 
cwd
, cwd));

74 
msg_am
 << 
d
::
rg
(
msg_efix
.
size
() + 2, ' ');

75 
msg_am
 << " ol" << 
e
.
pe
.
le
+1 << " o" << 
l_th
 << "\n";

79 i(
e
.
pe
.
le
 !
d
::
rg
::
os
 &&.pe.
cumn
 != std::string::npos) {

80 
size_t
 
le
 = 
e
.
pe
.line;

81 cڡ * 
le_beg
 = 
e
.
pe
.
c
;

82 
le_beg
 && *le_beg && 
le
) {

83 i(*
le_beg
 ='\n'-- 
le
;

84 ++ 
le_beg
;

86 cڡ * 
le_d
 = 
le_beg
;

87 
le_d
 && *line_end && *line_end != '\n') {

88 i(*
le_d
 == '\n') ;

89 i(*
le_d
 == '\r') ;

90 
le_d
 ++;

92 
size_t
 
max_
 = 42; size_
max_right
 = 78;

93 
size_t
 
move_
 = 
e
.
pe
.
cumn
 > 
max_
 ?.pstate.column - max_left : 0;

94 
size_t
 
sh܋n
 = (
le_d
 - 
le_beg
- 
move_
 > 
max_right
 ?

95 (
le_d
 - 
le_beg
- 
move_
 - 
max_right
 : 0;

96 
msg_am
 << ">> " << 
d
::
rg
(
le_beg
 + 
move_
, 
le_d
 - 
sh܋n
) << "\n";

97 
msg_am
 << " " << 
d
::
rg
(
e
.
pe
.
cumn
 - 
move_
, '-') << "^\n";

100 
JsNode
* 
js_r
 = 
js_mkobje
();

101 
js_nd_memb
(
js_r
, "us", 
js_mknumb
(1));

102 
js_nd_memb
(
js_r
, "fe", 
js_mkrg
(
e
.
pe
.
th
));

103 
js_nd_memb
(
js_r
, "le", 
js_mknumb
(()(
e
.
pe
.
le
+1)));

104 
js_nd_memb
(
js_r
, "cumn", 
js_mknumb
(()(
e
.
pe
.
cumn
+1)));

105 
js_nd_memb
(
js_r
, "mesge", 
js_mkrg
(
e
.
wh
()));

106 
js_nd_memb
(
js_r
, "fmd", 
js_mkrg
(
msg_am
.
r
().
c_r
()));

108 
y
 { 
c_x
->
r_js
 = 
js_rgify
(
js_r
, " "); } 
tch
(...) {}

109 
c_x
->
r_mesge
 = 
ss_cy_c_rg
(
msg_am
.
r
().
c_r
());

110 
c_x
->
r_xt
 = 
ss_cy_c_rg
(
e
.
wh
());

111 
c_x
->
r_us
 = 1;

112 
c_x
->
r_fe
 = 
ss_cy_c_rg
(
e
.
pe
.
th
);

113 
c_x
->
r_le
 = 
e
.
pe
.
le
+1;

114 
c_x
->
r_cumn
 = 
e
.
pe
.
cumn
+1;

115 
c_x
->
r_c
 = 
e
.
pe
.
c
;

116 
c_x
->
ouut_rg
 = 0;

117 
c_x
->
sour_m_rg
 = 0;

118 
js_de
(
js_r
);

120 
tch
 (
d
::
bad_loc
& 
ba
) {

121 
d
::
rgam
 
msg_am
;

122 
JsNode
* 
js_r
 = 
js_mkobje
();

123 
msg_am
 << "Ubˁخlo memy: " << 
ba
.
wh
(<< 
d
::
dl
;

124 
js_nd_memb
(
js_r
, "us", 
js_mknumb
(2));

125 
js_nd_memb
(
js_r
, "mesge", 
js_mkrg
(
ba
.
wh
()));

126 
js_nd_memb
(
js_r
, "fmd", 
js_mkrg
(
msg_am
.
r
().
c_r
()));

127 
y
 { 
c_x
->
r_js
 = 
js_rgify
(
js_r
, " "); } 
tch
(...) {}

128 
c_x
->
r_mesge
 = 
ss_cy_c_rg
(
msg_am
.
r
().
c_r
());

129 
c_x
->
r_xt
 = 
ss_cy_c_rg
(
ba
.
wh
());

130 
c_x
->
r_us
 = 2;

131 
c_x
->
ouut_rg
 = 0;

132 
c_x
->
sour_m_rg
 = 0;

133 
js_de
(
js_r
);

135 
tch
 (
d
::
exi
& 
e
) {

136 
d
::
rgam
 
msg_am
;

137 
JsNode
* 
js_r
 = 
js_mkobje
();

138 
msg_am
 << "IE: " << 
e
.
wh
(<< 
d
::
dl
;

139 
js_nd_memb
(
js_r
, "us", 
js_mknumb
(3));

140 
js_nd_memb
(
js_r
, "mesge", 
js_mkrg
(
e
.
wh
()));

141 
js_nd_memb
(
js_r
, "fmd", 
js_mkrg
(
msg_am
.
r
().
c_r
()));

142 
y
 { 
c_x
->
r_js
 = 
js_rgify
(
js_r
, " "); } 
tch
(...) {}

143 
c_x
->
r_mesge
 = 
ss_cy_c_rg
(
msg_am
.
r
().
c_r
());

144 
c_x
->
r_xt
 = 
ss_cy_c_rg
(
e
.
wh
());

145 
c_x
->
r_us
 = 3;

146 
c_x
->
ouut_rg
 = 0;

147 
c_x
->
sour_m_rg
 = 0;

148 
js_de
(
js_r
);

150 
tch
 (
d
::
rg
& 
e
) {

151 
d
::
rgam
 
msg_am
;

152 
JsNode
* 
js_r
 = 
js_mkobje
();

153 
msg_am
 << "IE: " << 
e
 << 
d
::
dl
;

154 
js_nd_memb
(
js_r
, "us", 
js_mknumb
(4));

155 
js_nd_memb
(
js_r
, "mesge", 
js_mkrg
(
e
.
c_r
()));

156 
js_nd_memb
(
js_r
, "fmd", 
js_mkrg
(
msg_am
.
r
().
c_r
()));

157 
y
 { 
c_x
->
r_js
 = 
js_rgify
(
js_r
, " "); } 
tch
(...) {}

158 
c_x
->
r_mesge
 = 
ss_cy_c_rg
(
msg_am
.
r
().
c_r
());

159 
c_x
->
r_xt
 = 
ss_cy_c_rg
(
e
.
c_r
());

160 
c_x
->
r_us
 = 4;

161 
c_x
->
ouut_rg
 = 0;

162 
c_x
->
sour_m_rg
 = 0;

163 
js_de
(
js_r
);

165 
tch
 (cڡ * 
e
) {

166 
d
::
rgam
 
msg_am
;

167 
JsNode
* 
js_r
 = 
js_mkobje
();

168 
msg_am
 << "IE: " << 
e
 << 
d
::
dl
;

169 
js_nd_memb
(
js_r
, "us", 
js_mknumb
(4));

170 
js_nd_memb
(
js_r
, "mesge", 
js_mkrg
(
e
));

171 
js_nd_memb
(
js_r
, "fmd", 
js_mkrg
(
msg_am
.
r
().
c_r
()));

172 
y
 { 
c_x
->
r_js
 = 
js_rgify
(
js_r
, " "); } 
tch
(...) {}

173 
c_x
->
r_mesge
 = 
ss_cy_c_rg
(
msg_am
.
r
().
c_r
());

174 
c_x
->
r_xt
 = 
ss_cy_c_rg
(
e
);

175 
c_x
->
r_us
 = 4;

176 
c_x
->
ouut_rg
 = 0;

177 
c_x
->
sour_m_rg
 = 0;

178 
js_de
(
js_r
);

180 
tch
 (...) {

181 
d
::
rgam
 
msg_am
;

182 
JsNode
* 
js_r
 = 
js_mkobje
();

183 
msg_am
 << "Unknowr occued" << 
d
::
dl
;

184 
js_nd_memb
(
js_r
, "us", 
js_mknumb
(5));

185 
js_nd_memb
(
js_r
, "mesge", 
js_mkrg
("unknown"));

186 
y
 { 
c_x
->
r_js
 = 
js_rgify
(
js_r
, " "); } 
tch
(...) {}

187 
c_x
->
r_mesge
 = 
ss_cy_c_rg
(
msg_am
.
r
().
c_r
());

188 
c_x
->
r_xt
 = 
ss_cy_c_rg
("unknown");

189 
c_x
->
r_us
 = 5;

190 
c_x
->
ouut_rg
 = 0;

191 
c_x
->
sour_m_rg
 = 0;

192 
js_de
(
js_r
);

194  
c_x
->
r_us
;

199 
hd_rs
(
Sass_Cڋxt
* 
c_x
) {

200 
y
 {  
hd_r
(
c_x
); }

201 
tch
 (...{  
hd_r
(
c_x
); }

202  
c_x
->
r_us
;

206 
Sass_Comp
* 
ss_e_cڋxt
 (
Sass_Cڋxt
* 
c_x
, 
Cڋxt
* 
p_x

throw
()

208 
y
 {

210 i(
c_x
->
c_funis
) {

211 aut
this_func_da
 = 
c_x
->
c_funis
;

212 
this_func_da
 && *this_func_data) {

213 
p_x
->
add_c_funi
(*
this_func_da
);

214 ++
this_func_da
;

219 i(
c_x
->
c_hds
) {

220 aut
this_hd_da
 = 
c_x
->
c_hds
;

221 
this_hd_da
 && *this_head_data) {

222 
p_x
->
add_c_hd
(*
this_hd_da
);

223 ++
this_hd_da
;

228 i(
c_x
->
c_imp܋rs
) {

229 aut
this_imp_da
 = 
c_x
->
c_imp܋rs
;

230 
this_imp_da
 && *this_imp_data) {

231 
p_x
->
add_c_imp܋r
(*
this_imp_da
);

232 ++
this_imp_da
;

237 
c_x
->
r_js
 = 0;

238 
c_x
->
r_xt
 = 0;

239 
c_x
->
r_mesge
 = 0;

240 
c_x
->
r_us
 = 0;

242 
c_x
->
r_c
 = 0;

243 
c_x
->
r_fe
 = 0;

244 
c_x
->
r_le
 = 
d
::
rg
::
os
;

245 
c_x
->
r_cumn
 = 
d
::
rg
::
os
;

248 
Sass_Comp
* 
comp
 = (Sass_Comp*
oc
(1, (Sass_Compiler));

249 
comp
->
e
 = 
SASS_COMPILER_CREATED
;

252 
comp
->
c_x
 = c_ctx;

253 
comp
->
p_x
 = cpp_ctx;

254 
p_x
->
c_comp
 = 
comp
;

257  
comp
;

261 
tch
 (...{ 
hd_rs
(
c_x
); }

268 
Block
* 
ss_r_block
 (
Sass_Comp
* 
comp

throw
()

272 i(
comp
 == 0)  0;

274 
Cڋxt
* 
p_x
 = 
comp
->cpp_ctx;

275 
Sass_Cڋxt
* 
c_x
 = 
comp
->c_ctx;

277 
comp
->
p_x
->
c_comp
 = compiler;

278 
comp
->
e
 = 
SASS_COMPILER_PARSED
;

280 
y
 {

283 
d
::
rg
 
put_th
 = 
_r
(
c_x
->input_path);

284 
d
::
rg
 
ouut_th
 = 
_r
(
c_x
->output_path);

287 
Block
* 
ro
 = 0;

291 
bo
 
sk
 = 
c_x
->
ty
 =
SASS_CONTEXT_DATA
;

294 
ro
 = 
p_x
->
r
();

296 i(!
ro
)  0;

302 
size_t
 
hds
 = 
p_x
->
hd_impts
;

305 i(
cy_rgs
(
p_x
->
g_uded_fes
(
sk
, 
hds
), &
c_x
->
uded_fes
=
NULL
)

306 
throw
(
d
::
bad_loc
());

309  
ro
;

313 
tch
 (...{ 
hd_rs
(
c_x
); }

321 
ss_compe_cڋxt
 (
Sass_Cڋxt
* 
c_x
, 
Cڋxt
* 
p_x
)

325 
Sass_Comp
* 
comp
 = 
ss_e_cڋxt
(
c_x
, 
p_x
);

327 
y
 {

329 
ss_comp_r
(
comp
);

330 
ss_comp_execu
(
comp
);

333 
tch
 (...{ 
hd_rs
(
c_x
); }

335 
ss_de_comp
(
comp
);

337  
c_x
->
r_us
;

340 
le
 
_tis
 (
Sass_Ois
* 
tis
)

342 
tis
->
ecisi
 = 5;

343 
tis
->
dt
 = " ";

344 
tis
->
leed
 = 
LFEED
;

347 
Sass_Ois
* 
ADDCALL
 
ss_make_tis
 ()

349 
Sass_Ois
* 
tis
 = (Sass_Ois*
oc
(1, (Sass_Options));

350 i(
tis
 =0{ 
d
::

 << "E܇otg memy f ois" << std::
dl
;  0; }

351 
_tis
(
tis
);

352  
tis
;

355 
Sass_Fe_Cڋxt
* 
ADDCALL
 
ss_make_fe_cڋxt
(cڡ * 
put_th
)

357 
Sass_Fe_Cڋxt
* 
x
 = (Sass_Fe_Cڋxt*
oc
(1, (Sass_File_Context));

358 i(
x
 =0{ 
d
::

 << "E܇otg memy f fcڋxt" << std::
dl
;  0; }

359 
x
->
ty
 = 
SASS_CONTEXT_FILE
;

360 
_tis
(
x
);

361 
y
 {

362 i(
put_th
 =0{ 
throw
(
d
::
ruime_r
("File context created withoutn inputath")); }

363 i(*
put_th
 =0{ 
throw
(
d
::
ruime_r
("File context created withmpty inputath")); }

364 
ss_ti_t_put_th
(
x
, 
put_th
);

365 } 
tch
 (...) {

366 
hd_rs
(
x
);

368  
x
;

371 
Sass_Da_Cڋxt
* 
ADDCALL
 
ss_make_da_cڋxt
(* 
sour_rg
)

373 
Sass_Da_Cڋxt
* 
x
 = (Sass_Da_Cڋxt*
oc
(1, (Sass_Data_Context));

374 i(
x
 =0{ 
d
::

 << "E܇otg memy f dcڋxt" << std::
dl
;  0; }

375 
x
->
ty
 = 
SASS_CONTEXT_DATA
;

376 
_tis
(
x
);

377 
y
 {

378 i(
sour_rg
 =0{ 
throw
(
d
::
ruime_r
("Data context created without source string")); }

379 i(*
sour_rg
 =0{ 
throw
(
d
::
ruime_r
("Data context created withmpty source string")); }

380 
x
->
sour_rg
 = source_string;

381 } 
tch
 (...) {

382 
hd_rs
(
x
);

384  
x
;

387 
Sass_Comp
* 
ADDCALL
 
ss_make_da_comp
 (
Sass_Da_Cڋxt
* 
da_x
)

389 i(
da_x
 == 0)  0;

390 
Cڋxt
* 
p_x
 = 
w
 
Da_Cڋxt
(*
da_x
);

391  
ss_e_cڋxt
(
da_x
, 
p_x
);

394 
Sass_Comp
* 
ADDCALL
 
ss_make_fe_comp
 (
Sass_Fe_Cڋxt
* 
fe_x
)

396 i(
fe_x
 == 0)  0;

397 
Cڋxt
* 
p_x
 = 
w
 
Fe_Cڋxt
(*
fe_x
);

398  
ss_e_cڋxt
(
fe_x
, 
p_x
);

401 
ADDCALL
 
ss_compe_da_cڋxt
(
Sass_Da_Cڋxt
* 
da_x
)

403 i(
da_x
 == 0)  1;

404 i(
da_x
->
r_us
)

405  
da_x
->
r_us
;

406 
y
 {

407 i(
da_x
->
sour_rg
 =0{ 
throw
(
d
::
ruime_r
("Data context haso source string")); }

411 
tch
 (...{  
hd_rs
(
da_x
) | 1; }

412 
Cڋxt
* 
p_x
 = 
w
 
Da_Cڋxt
(*
da_x
);

413  
ss_compe_cڋxt
(
da_x
, 
p_x
);

416 
ADDCALL
 
ss_compe_fe_cڋxt
(
Sass_Fe_Cڋxt
* 
fe_x
)

418 i(
fe_x
 == 0)  1;

419 i(
fe_x
->
r_us
)

420  
fe_x
->
r_us
;

421 
y
 {

422 i(
fe_x
->
put_th
 =0{ 
throw
(
d
::
ruime_r
("File context haso inputath")); }

423 i(*
fe_x
->
put_th
 =0{ 
throw
(
d
::
ruime_r
("File context hasmpty inputath")); }

425 
tch
 (...{  
hd_rs
(
fe_x
) | 1; }

426 
Cڋxt
* 
p_x
 = 
w
 
Fe_Cڋxt
(*
fe_x
);

427  
ss_compe_cڋxt
(
fe_x
, 
p_x
);

430 
ADDCALL
 
ss_comp_r
(
Sass_Comp
* 
comp
)

432 i(
comp
 == 0)  1;

433 i(
comp
->
e
 =
SASS_COMPILER_PARSED
)  0;

434 i(
comp
->
e
 !
SASS_COMPILER_CREATED
)  -1;

435 i(
comp
->
c_x
 =
NULL
)  1;

436 i(
comp
->
p_x
 =
NULL
)  1;

437 i(
comp
->
c_x
->
r_us
)

438  
comp
->
c_x
->
r_us
;

440 
comp
->
ro
 = 
ss_r_block
(compiler);

445 
ADDCALL
 
ss_comp_execu
(
Sass_Comp
* 
comp
)

447 i(
comp
 == 0)  1;

448 i(
comp
->
e
 =
SASS_COMPILER_EXECUTED
)  0;

449 i(
comp
->
e
 !
SASS_COMPILER_PARSED
)  -1;

450 i(
comp
->
c_x
 =
NULL
)  1;

451 i(
comp
->
p_x
 =
NULL
)  1;

452 i(
comp
->
ro
 =
NULL
)  1;

453 i(
comp
->
c_x
->
r_us
)

454  
comp
->
c_x
->
r_us
;

455 
comp
->
e
 = 
SASS_COMPILER_EXECUTED
;

456 
Cڋxt
* 
p_x
 = 
comp
->cpp_ctx;

457 
Block
* 
ro
 = 
comp
->root;

459 
y
 { 
comp
->
c_x
->
ouut_rg
 = 
p_x
->
nd
(
ro
); }

461 
tch
 (...{  
hd_rs
(
comp
->
c_x
) | 1; }

463 
comp
->
c_x
->
sour_m_rg
 = 
p_x
->
nd_cm
();

469 
ss_r_tis
 (
Sass_Ois
* 
tis
)

471 i(
tis
 == 0) ;

473 i(
tis
->
c_funis
) {

474 
Sass_Funi_Li
 
this_func_da
 = 
tis
->
c_funis
;

475 
this_func_da
 && *this_func_data) {

476 

(*
this_func_da
);

477 ++
this_func_da
;

481 i(
tis
->
c_hds
) {

482 
Sass_Imp܋r_Li
 
this_hd_da
 = 
tis
->
c_hds
;

483 
this_hd_da
 && *this_head_data) {

484 

(*
this_hd_da
);

485 ++
this_hd_da
;

489 i(
tis
->
c_imp܋rs
) {

490 
Sass_Imp܋r_Li
 
this_imp_da
 = 
tis
->
c_imp܋rs
;

491 
this_imp_da
 && *this_imp_data) {

492 

(*
this_imp_da
);

493 ++
this_imp_da
;

497 i(
tis
->
ug_ths
) {

498 
rg_li
* 
cur
;

499 
rg_li
* 
xt
;

500 
cur
 = 
tis
->
ug_ths
;

501 
cur
) {

502 
xt
 = 
cur
->next;

503 

(
cur
->
rg
);

504 

(
cur
);

505 
cur
 = 
xt
;

509 i(
tis
->
ude_ths
) {

510 
rg_li
* 
cur
;

511 
rg_li
* 
xt
;

512 
cur
 = 
tis
->
ude_ths
;

513 
cur
) {

514 
xt
 = 
cur
->next;

515 

(
cur
->
rg
);

516 

(
cur
);

517 
cur
 = 
xt
;

521 

(
tis
->
c_funis
);

523 

(
tis
->
c_imp܋rs
);

524 

(
tis
->
c_hds
);

526 
tis
->
c_funis
 = 0;

527 
tis
->
c_imp܋rs
 = 0;

528 
tis
->
c_hds
 = 0;

529 
tis
->
ug_ths
 = 0;

530 
tis
->
ude_ths
 = 0;

535 
ss_r_cڋxt
 (
Sass_Cڋxt
* 
x
)

537 i(
x
 == 0) ;

539 i(
x
->
ouut_rg


(ctx->output_string);

540 i(
x
->
sour_m_rg


(ctx->source_map_string);

541 i(
x
->
r_mesge


(ctx->error_message);

542 i(
x
->
r_xt


(ctx->error_text);

543 i(
x
->
r_js


(ctx->error_json);

544 i(
x
->
r_fe


(ctx->error_file);

545 i(
x
->
put_th


(ctx->input_path);

546 i(
x
->
ouut_th


(ctx->output_path);

547 i(
x
->
ug_th


(ctx->plugin_path);

548 i(
x
->
ude_th


(ctx->include_path);

549 i(
x
->
sour_m_fe


(ctx->source_map_file);

550 i(
x
->
sour_m_ro


(ctx->source_map_root);

551 
_rg_y
(
x
->
uded_fes
);

553 
x
->
ouut_rg
 = 0;

554 
x
->
sour_m_rg
 = 0;

555 
x
->
r_mesge
 = 0;

556 
x
->
r_xt
 = 0;

557 
x
->
r_js
 = 0;

558 
x
->
r_fe
 = 0;

559 
x
->
put_th
 = 0;

560 
x
->
ouut_th
 = 0;

561 
x
->
ude_th
 = 0;

562 
x
->
sour_m_fe
 = 0;

563 
x
->
sour_m_ro
 = 0;

564 
x
->
uded_fes
 = 0;

566 
ss_r_tis
(
x
);

569 
ADDCALL
 
ss_de_comp
 (
Sass_Comp
* 
comp
)

571 i(
comp
 == 0) {

574 
Cڋxt
* 
p_x
 = 
comp
->cpp_ctx;

575 i(
p_x

de
(cpp_ctx);

576 
comp
->
p_x
 = 0;

577 

(
comp
);

581 
ADDCALL
 
ss_de_fe_cڋxt
 (
Sass_Fe_Cڋxt
* 
x
)

584 
ss_r_cڋxt
(
x
); 

(ctx);

587 
ADDCALL
 
ss_de_da_cڋxt
 (
Sass_Da_Cڋxt
* 
x
)

591 i(
x
->
sour_rg


(ctx->source_string);

593 
ss_r_cڋxt
(
x
); 

(ctx);

597 
Sass_Cڋxt
* 
ADDCALL
 
ss_fe_cڋxt_g_cڋxt
(
Sass_Fe_Cڋxt
* 
x
) {  ctx; }

598 
Sass_Cڋxt
* 
ADDCALL
 
ss_da_cڋxt_g_cڋxt
(
Sass_Da_Cڋxt
* 
x
) {  ctx; }

601 
Sass_Ois
* 
ADDCALL
 
ss_cڋxt_g_tis
(
Sass_Cڋxt
* 
x
) {  ctx; }

602 
Sass_Ois
* 
ADDCALL
 
ss_fe_cڋxt_g_tis
(
Sass_Fe_Cڋxt
* 
x
) {  ctx; }

603 
Sass_Ois
* 
ADDCALL
 
ss_da_cڋxt_g_tis
(
Sass_Da_Cڋxt
* 
x
) {  ctx; }

604 
ADDCALL
 
ss_fe_cڋxt_t_tis
 (
Sass_Fe_Cڋxt
* 
x
, 
Sass_Ois
* 
t
{ 
cy_tis
(ctx, opt); }

605 
ADDCALL
 
ss_da_cڋxt_t_tis
 (
Sass_Da_Cڋxt
* 
x
, 
Sass_Ois
* 
t
{ 
cy_tis
(ctx, opt); }

608 
Sass_Comp_S
 
ADDCALL
 
ss_comp_g_e
(
Sass_Comp
* 
comp
{  comp->
e
; }

609 
Sass_Cڋxt
* 
ADDCALL
 
ss_comp_g_cڋxt
(
Sass_Comp
* 
comp
{  comp->
c_x
; }

610 
Sass_Ois
* 
ADDCALL
 
ss_comp_g_tis
(
Sass_Comp
* 
comp
{  comp->
c_x
; }

612 
size_t
 
ADDCALL
 
ss_comp_g_impt_ack_size
(
Sass_Comp
* 
comp
{  comp->
p_x
->
impt_ack
.
size
(); }

613 
Sass_Impt_Ery
 
ADDCALL
 
ss_comp_g_ϡ_impt
(
Sass_Comp
* 
comp
{  comp->
p_x
->
impt_ack
.
back
(); }

614 
Sass_Impt_Ery
 
ADDCALL
 
ss_comp_g_impt_y
(
Sass_Comp
* 
comp
, 
size_t
 
idx
{  comp->
p_x
->
impt_ack
[idx]; }

617 
size_t
 
ADDCALL
 
ss_cڋxt_g_uded_fes_size
 (
Sass_Cڋxt
* 
x
)

618 { 
size_t
 
l
 = 0;ut
i
 = 
x
->
uded_fes
; i && *i) { ++i; ++l; } ; }

621 
IMPLEMENT_SASS_OPTION_ACCESSOR
(, 
ecisi
);

622 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
Sass_Ouut_Sty
, 
ouut_y
);

623 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
bo
, 
sour_commts
);

624 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
bo
, 
sour_m_embed
);

625 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
bo
, 
sour_m_cڋs
);

626 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
bo
, 
om_sour_m_u
);

627 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
bo
, 
is_dd_syax_c
);

628 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
Sass_Funi_Li
, 
c_funis
);

629 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
Sass_Imp܋r_Li
, 
c_imp܋rs
);

630 
IMPLEMENT_SASS_OPTION_ACCESSOR
(
Sass_Imp܋r_Li
, 
c_hds
);

631 
IMPLEMENT_SASS_OPTION_ACCESSOR
(cڡ *, 
dt
);

632 
IMPLEMENT_SASS_OPTION_ACCESSOR
(cڡ *, 
leed
);

633 
IMPLEMENT_SASS_OPTION_STRING_ACCESSOR
(cڡ *, 
put_th
, 0);

634 
IMPLEMENT_SASS_OPTION_STRING_ACCESSOR
(cڡ *, 
ouut_th
, 0);

635 
IMPLEMENT_SASS_OPTION_STRING_ACCESSOR
(cڡ *, 
ug_th
, 0);

636 
IMPLEMENT_SASS_OPTION_STRING_ACCESSOR
(cڡ *, 
ude_th
, 0);

637 
IMPLEMENT_SASS_OPTION_STRING_ACCESSOR
(cڡ *, 
sour_m_fe
, 0);

638 
IMPLEMENT_SASS_OPTION_STRING_ACCESSOR
(cڡ *, 
sour_m_ro
, 0);

641 
IMPLEMENT_SASS_CONTEXT_GETTER
(, 
r_us
);

642 
IMPLEMENT_SASS_CONTEXT_GETTER
(cڡ *, 
r_js
);

643 
IMPLEMENT_SASS_CONTEXT_GETTER
(cڡ *, 
r_mesge
);

644 
IMPLEMENT_SASS_CONTEXT_GETTER
(cڡ *, 
r_xt
);

645 
IMPLEMENT_SASS_CONTEXT_GETTER
(cڡ *, 
r_fe
);

646 
IMPLEMENT_SASS_CONTEXT_GETTER
(
size_t
, 
r_le
);

647 
IMPLEMENT_SASS_CONTEXT_GETTER
(
size_t
, 
r_cumn
);

648 
IMPLEMENT_SASS_CONTEXT_GETTER
(cڡ *, 
r_c
);

649 
IMPLEMENT_SASS_CONTEXT_GETTER
(cڡ *, 
ouut_rg
);

650 
IMPLEMENT_SASS_CONTEXT_GETTER
(cڡ *, 
sour_m_rg
);

651 
IMPLEMENT_SASS_CONTEXT_GETTER
(**, 
uded_fes
);

654 
IMPLEMENT_SASS_CONTEXT_TAKER
(*, 
r_js
);

655 
IMPLEMENT_SASS_CONTEXT_TAKER
(*, 
r_mesge
);

656 
IMPLEMENT_SASS_CONTEXT_TAKER
(*, 
r_xt
);

657 
IMPLEMENT_SASS_CONTEXT_TAKER
(*, 
r_fe
);

658 
IMPLEMENT_SASS_CONTEXT_TAKER
(*, 
ouut_rg
);

659 
IMPLEMENT_SASS_CONTEXT_TAKER
(*, 
sour_m_rg
);

660 
IMPLEMENT_SASS_CONTEXT_TAKER
(**, 
uded_fes
);

663 
ADDCALL
 
ss_ti_push_ude_th
(
Sass_Ois
* 
tis
, cڡ * 
th
)

666 
rg_li
* 
ude_th
 = (rg_li*
oc
(1, (string_list));

667 i(
ude_th
 == 0) ;

668 
ude_th
->
rg
 = 
th
 ? 
ss_cy_c_rg
(path) : 0;

669 
rg_li
* 
ϡ
 = 
tis
->
ude_ths
;

670 i(!
tis
->
ude_ths
) {

671 
tis
->
ude_ths
 = 
ude_th
;

673 
ϡ
->
xt
)

674 
ϡ
 =a->
xt
;

675 
ϡ
->
xt
 = 
ude_th
;

681 
ADDCALL
 
ss_ti_push_ug_th
(
Sass_Ois
* 
tis
, cڡ * 
th
)

684 
rg_li
* 
ug_th
 = (rg_li*
oc
(1, (string_list));

685 i(
ug_th
 == 0) ;

686 
ug_th
->
rg
 = 
th
 ? 
ss_cy_c_rg
(path) : 0;

687 
rg_li
* 
ϡ
 = 
tis
->
ug_ths
;

688 i(!
tis
->
ug_ths
) {

689 
tis
->
ug_ths
 = 
ug_th
;

691 
ϡ
->
xt
)

692 
ϡ
 =a->
xt
;

693 
ϡ
->
xt
 = 
ug_th
;

	@node_modules/node-sass/src/libsass/src/sass_context.hpp

1 #ide
SASS_SASS_CONTEXT_H


2 
	#SASS_SASS_CONTEXT_H


	)

4 
	~"ss.h
"

5 
	~"ss.h
"

6 
	~"cڋxt.h
"

7 
	~"a_fwd_de.h
"

10 
	gSass_Ois
 : 
Sass_Ouut_Ois
 {

13 
bo
 
sour_m_embed
;

16 
bo
 
	gsour_m_cڋs
;

19 
bo
 
	gom_sour_m_u
;

22 
bo
 
	gis_dd_syax_c
;

30 * 
	gput_th
;

36 * 
	gouut_th
;

41 * 
	gude_th
;

42 * 
	gug_th
;

45 
rg_li
* 
	gude_ths
;

47 
rg_li
* 
	gug_ths
;

52 * 
	gsour_m_fe
;

55 * 
	gsour_m_ro
;

58 
Sass_Funi_Li
 
	gc_funis
;

61 
Sass_Imp܋r_Li
 
	gc_imp܋rs
;

64 
Sass_Imp܋r_Li
 
	gc_hds
;

70 
	gSass_Cڋxt
 : 
Sass_Ois


74 
Sass_Iut_Sty
 
ty
;

77 * 
	gouut_rg
;

80 * 
	gsour_m_rg
;

83 
	gr_us
;

84 * 
	gr_js
;

85 * 
	gr_xt
;

86 * 
	gr_mesge
;

88 * 
	gr_fe
;

89 
size_t
 
	gr_le
;

90 
size_t
 
	gr_cumn
;

91 cڡ * 
	gr_c
;

94 ** 
	guded_fes
;

99 
	gSass_Fe_Cڋxt
 : 
Sass_Cڋxt
 {

107 
	gSass_Da_Cڋxt
 : 
Sass_Cڋxt
 {

110 * 
sour_rg
;

111 * 
	gcm_rg
;

116 
	sSass_Comp
 {

118 
Sass_Comp_S
 
	me
;

120 
Sass_Cڋxt
* 
	mc_x
;

122 
	mSass
::
Cڋxt
* 
p_x
;

124 
	mSass
::
Block
* 
ro
;

	@node_modules/node-sass/src/libsass/src/sass_functions.cpp

1 
	~"ss.h
"

2 
	~<crg
>

3 
	~"ut.h
"

4 
	~"cڋxt.h
"

5 
	~"ss/funis.h
"

6 
	~"ss_funis.h
"

9 
usg
 
mea
 
Sass
;

11 
Sass_Funi_Li
 
ADDCALL
 
ss_make_funi_li
(
size_t
 
ngth
)

13  (
Sass_Funi_Li

oc
(
ngth
 + 1, (
Sass_Funi_Ery
));

16 
Sass_Funi_Ery
 
ADDCALL
 
ss_make_funi
(cڡ * 
sigtu
, 
Sass_Funi_Fn
 
funi
, * 
cook
)

18 
Sass_Funi_Ery
 
cb
 = (Sass_Funi_Ery
oc
(1, (
Sass_Funi
));

19 i(
cb
 == 0)  0;

20 
cb
->
sigtu
 = signature;

21 
cb
->
funi
 = function;

22 
cb
->
cook
 = cookie;

23  
cb
;

27 
Sass_Funi_Ery
 
ADDCALL
 
ss_funi_g_li_y
(
Sass_Funi_Li
 
li
, 
size_t
 
pos
) { ist[pos]; }

28 
ss_funi_t_li_y
(
Sass_Funi_Li
 
li
, 
size_t
 
pos
, 
Sass_Funi_Ery
 
cb
) {ist[pos] = cb; }

30 cڡ * 
ADDCALL
 
ss_funi_g_sigtu
(
Sass_Funi_Ery
 
cb
{  cb->
sigtu
; }

31 
Sass_Funi_Fn
 
ADDCALL
 
ss_funi_g_funi
(
Sass_Funi_Ery
 
cb
{  cb->
funi
; }

32 * 
ADDCALL
 
ss_funi_g_cook
(
Sass_Funi_Ery
 
cb
{  cb->
cook
; }

34 
Sass_Imp܋r_Ery
 
ADDCALL
 
ss_make_imp܋r
(
Sass_Imp܋r_Fn
 
imp܋r
, 
iܙy
, * 
cook
)

36 
Sass_Imp܋r_Ery
 
cb
 = (Sass_Imp܋r_Ery
oc
(1, (
Sass_Imp܋r
));

37 i(
cb
 == 0)  0;

38 
cb
->
imp܋r
 = importer;

39 
cb
->
iܙy
 =riority;

40 
cb
->
cook
 = cookie;

41  
cb
;

44 
Sass_Imp܋r_Fn
 
ADDCALL
 
ss_imp܋r_g_funi
(
Sass_Imp܋r_Ery
 
cb
{  cb->
imp܋r
; }

45 
ADDCALL
 
ss_imp܋r_g_iܙy
 (
Sass_Imp܋r_Ery
 
cb
{  cb->
iܙy
; }

46 * 
ADDCALL
 
ss_imp܋r_g_cook
(
Sass_Imp܋r_Ery
 
cb
{  cb->
cook
; }

49 
ADDCALL
 
ss_de_imp܋r
 (
Sass_Imp܋r_Ery
 
cb
)

51 

(
cb
);

55 
Sass_Imp܋r_Li
 
ADDCALL
 
ss_make_imp܋r_li
(
size_t
 
ngth
)

57  (
Sass_Imp܋r_Li

oc
(
ngth
 + 1, (
Sass_Imp܋r_Ery
));

60 
Sass_Imp܋r_Ery
 
ADDCALL
 
ss_imp܋r_g_li_y
(
Sass_Imp܋r_Li
 
li
, 
size_t
 
idx
) { ist[idx]; }

61 
ADDCALL
 
ss_imp܋r_t_li_y
(
Sass_Imp܋r_Li
 
li
, 
size_t
 
idx
, 
Sass_Imp܋r_Ery
 
cb
) {ist[idx] = cb; }

64 
Sass_Impt_Li
 
ADDCALL
 
ss_make_impt_li
(
size_t
 
ngth
)

66  (
Sass_Impt
**
oc
(
ngth
 + 1, (Sass_Import*));

71 
Sass_Impt_Ery
 
ADDCALL
 
ss_make_impt
(cڡ * 
imp_th
, cڡ * 
abs_th
, * 
sour
, * 
cm
)

73 
Sass_Impt
* 
v
 = (Sass_Impt*
oc
(1, (Sass_Import));

74 i(
v
 == 0)  0;

75 
v
->
imp_th
 = imp_th ? 
ss_cy_c_rg
(imp_path) : 0;

76 
v
->
abs_th
 =bs_th ? 
ss_cy_c_rg
(abs_path) : 0;

77 
v
->
sour
 = source;

78 
v
->
cm
 = srcmap;

79 
v
->
r
 = 0;

80 
v
->
le
 = -1;

81 
v
->
cumn
 = -1;

82  
v
;

86 
Sass_Impt_Ery
 
ADDCALL
 
ss_make_impt_y
(cڡ * 
th
, * 
sour
, * 
cm
)

88  
ss_make_impt
(
th
,h, 
sour
, 
cm
);

92 
Sass_Impt_Ery
 
ADDCALL
 
ss_impt_t_r
(Sass_Impt_Ery 
impt
, cڡ * 
r
, 
size_t
 
le
, size_
c
)

94 i(
impt
 == 0)  0;

95 i(
impt
->
r


(import->error);

96 
impt
->
r
 = ? 
ss_cy_c_rg
(error) : 0;

97 
impt
->
le
 =ine ?ine : -1;

98 
impt
->
cumn
 = 
c
 ? col : -1;

99  
impt
;

103 
ADDCALL
 
ss_impt_t_li_y
(
Sass_Impt_Li
 
li
, 
size_t
 
idx
, 
Sass_Impt_Ery
 
y
) {ist[idx] =ntry; }

104 
Sass_Impt_Ery
 
ADDCALL
 
ss_impt_g_li_y
(
Sass_Impt_Li
 
li
, 
size_t
 
idx
) { ist[idx]; }

107 
ADDCALL
 
ss_de_impt_li
(
Sass_Impt_Li
 
li
)

109 
Sass_Impt_Li
 

 = 
li
;

110 i(
li
 == 0) ;

111 *
li
) {

112 
ss_de_impt
(*
li
);

113 ++
li
;

115 

(

);

119 
ADDCALL
 
ss_de_impt
(
Sass_Impt_Ery
 
impt
)

121 

(
impt
->
imp_th
);

122 

(
impt
->
abs_th
);

123 

(
impt
->
sour
);

124 

(
impt
->
cm
);

125 

(
impt
->
r
);

126 

(
impt
);

130 cڡ * 
ADDCALL
 
ss_impt_g_imp_th
(
Sass_Impt_Ery
 
y
{ ry->
imp_th
; }

131 cڡ * 
ADDCALL
 
ss_impt_g_abs_th
(
Sass_Impt_Ery
 
y
{ ry->
abs_th
; }

132 cڡ * 
ADDCALL
 
ss_impt_g_sour
(
Sass_Impt_Ery
 
y
{ ry->
sour
; }

133 cڡ * 
ADDCALL
 
ss_impt_g_cm
(
Sass_Impt_Ery
 
y
{ ry->
cm
; }

136 
size_t
 
ADDCALL
 
ss_impt_g_r_le
(
Sass_Impt_Ery
 
y
{ ry->
le
; }

137 
size_t
 
ADDCALL
 
ss_impt_g_r_cumn
(
Sass_Impt_Ery
 
y
{ ry->
cumn
; }

138 cڡ * 
ADDCALL
 
ss_impt_g_r_mesge
(
Sass_Impt_Ery
 
y
{ ry->
r
; }

142 * 
ADDCALL
 
ss_impt_ke_sour
(
Sass_Impt_Ery
 
y
{ * 
r
 =ry->
sour
;ntry->source = 0; tr; }

143 * 
ADDCALL
 
ss_impt_ke_cm
(
Sass_Impt_Ery
 
y
{ * 
r
 =ry->
cm
;ntry->srcmap = 0; tr; }

	@node_modules/node-sass/src/libsass/src/sass_functions.hpp

1 #ide
SASS_SASS_FUNCTIONS_H


2 
	#SASS_SASS_FUNCTIONS_H


	)

4 
	~"ss.h
"

7 
	sSass_Funi
 {

8 cڡ * 
	msigtu
;

9 
Sass_Funi_Fn
 
	mfuni
;

10 * 
	mcook
;

14 
	sSass_Impt
 {

15 * 
	mimp_th
;

16 *
	mabs_th
;

17 * 
	msour
;

18 * 
	mcm
;

20 * 
	mr
;

21 
size_t
 
	mle
;

22 
size_t
 
	mcumn
;

26 
	sSass_Imp܋r
 {

27 
Sass_Imp܋r_Fn
 
	mimp܋r
;

28 
	miܙy
;

29 * 
	mcook
;

	@node_modules/node-sass/src/libsass/src/sass_util.cpp

1 
	~"ss.h
"

2 
	~"node.h
"

4 
mea
 
	gSass
 {

40 
Node
 
ths
(cڡ Node& 
rs
, 
Cڋxt
& 
x
) {

42 
Node
 
	gloS
 = Node::
Ci
();

43 
	gloS
.
ci
()->
push_back
(
Node
::
Ci
());

45 
	gNodeDeque
::

 
rsIr
 = 
rs
.
ci
()->
beg
(), 
	grsEndIr
 =s.ci()->
d
();

46 
	grsIr
 !
rsEndIr
; ++arrsIter) {

48 
	gNode
& 
	gr
 = *
rsIr
;

50 
Node
 
	grmutis
 = Node::
Ci
();

52 
	gNodeDeque
::

 
rIr
 = 
r
.
ci
()->
beg
(), 
	grIrEnd
 =.ci()->
d
();

53 
	grIr
 !
rIrEnd
; ++arrIter) {

55 
	gNode
& 
	ge
 = *
rIr
;

57 
	gNodeDeque
::

 
loSIr
 = 
loS
.
ci
()->
beg
(), 
	gloSIrEnd
 =oS.ci()->
d
();

58 
	gloSIr
 !
loSIrEnd
; ++loopStartIter) {

60 
	gNode
& 
	gth
 = *
loSIr
;

62 
Node
 
	gwPmuti
 = Node::
Ci
();

63 
	gwPmuti
.
	gg_le_ed
 = 
r
.
g_le_ed
;

64 
	gwPmuti
.
us
(
th
);

65 
	gwPmuti
.
ci
()->
push_back
(
e
);

67 
	grmutis
.
ci
()->
push_back
(
wPmuti
);

71 
	gloS
 = 
rmutis
;

74  
	gloS
;

111 
Node
 
橋n
(Node& 
r
, 
Cڋxt
& 
x
, 
n
) {

112 i(
	gn
 !-1 && 
n
 == 0) {

113  
r
;

116 
Node
 
	g橋d
 = Node::
Ci
();

117 i(
	gr
.
	gg_le_ed

	g橋d
.g_le_ed = 
ue
;

119 
	gNodeDeque
::

 

 = 
r
.
ci
()->
beg
(), 
	gEnd
 =.ci()->
d
();

120 
	g
 !
End
; iter++) {

121 
	gNode
& 
	ge
 = *

;

124 i(
	ge
.
isCi
()) {

127 
Node
 
	gcurFωed
 = 
橋n
(
e
, 
x
, 
n
 - 1);

129 if(
	ge
.
	gg_le_ed
) {

130 
	g橋d
.
	gg_le_ed
 = 
e
.
g_le_ed
;

131 
	gcurFωed
.
	gg_le_ed
 = 
e
.
g_le_ed
;

134 aut
	gi
 : (*
curFωed
.
ci
())) {

135 i(
curFωed
.
g_le_ed
) {

137 
i
.
g_le_ed
 = 
ue
;

139 
	g橋d
.
ci
()->
push_back
(
i
);

143 
	g橋d
.
ci
()->
push_back
(
e
);

147  
	g橋d
;

	@node_modules/node-sass/src/libsass/src/sass_util.hpp

1 #ide
SASS_SASS_UTIL_H


2 
	#SASS_SASS_UTIL_H


	)

4 
	~"a.h
"

5 
	~"node.h
"

6 
	~"debug.h
"

8 
mea
 
	gSass
 {

31 
Node
 
ths
(cڡ Node& 
rs
, 
Cڋxt
& 
x
);

38 as
	cDeuLcsComt
 {

39 
	gpublic
:

40 
bo
 
ݔ
()(cڡ 
Node
& 
e
, cڡ 
	gNode
& 
	gtwo
, Node& 
	gout
) const {

43 i(
	ge
 =
two
) {

44 
out
 = 
e
;

45  
	gue
;

48  
	gl
;

53 
	gd
::
	tve
<
	td
::ve<> > 
	tLCSTab
;

62 
	gme
<
tyme
 
	gComtTy
>

63 
Node
 
	$lcs_backa
(cڡ 
LCSTab
& 
c
, cڡ 
Node
& 
x
, cڡ Node& 
y
, 
i
, 
j
, cڡ 
ComtTy
& 
comt
) {

64 
	`DEBUG_PRINTLN
(
LCS
, "LCSBACK: X=" << 
x
 << " Y=" << 
y
 << " I=" << 
i
 << " J=" << 
j
)

66 i(
i
 =0 || 
j
 == 0) {

67 
	`DEBUG_PRINTLN
(
LCS
, "RETURNING EMPTY")

68  
Node
::
	`Ci
();

71 
NodeDeque
& 
xChdn
 = *(
x
.
	`ci
());

72 
NodeDeque
& 
yChdn
 = *(
y
.
	`ci
());

74 
Node
 
comOut
 = Node::
	`N
();

75 i(
	`comt
(
xChdn
[
i
], 
yChdn
[
j
], 
comOut
)) {

76 
	`DEBUG_PRINTLN
(
LCS
, "RETURNING AFTER ELEM COMPARE")

77 
Node
 
su
 = 
	`lcs_backa
(
c
, 
x
, 
y
, 
i
 - 1, 
j
 - 1, 
comt
);

78 
su
.
	`ci
()->
	`push_back
(
comOut
);

79  
su
;

82 i(
c
[
i
][
j
 - 1] > c[i - 1][j]) {

83 
	`DEBUG_PRINTLN
(
LCS
, "RETURNING AFTER TABLE COMPARE")

84  
	`lcs_backa
(
c
, 
x
, 
y
, 
i
, 
j
 - 1, 
comt
);

87 
	`DEBUG_PRINTLN
(
LCS
, "FINAL RETURN")

88  
	`lcs_backa
(
c
, 
x
, 
y
, 
i
 - 1, 
j
, 
comt
);

89 
	}
}

98 
	gme
<
tyme
 
	gComtTy
>

99 
	$lcs_b
(cڡ 
Node
& 
x
, cڡ Node& 
y
, cڡ 
ComtTy
& 
comt
, 
LCSTab
& 
out
) {

100 
	`DEBUG_PRINTLN
(
LCS
, "LCSTABLE: X=" << 
x
 << " Y=" << 
y
)

102 
NodeDeque
& 
xChdn
 = *(
x
.
	`ci
());

103 
NodeDeque
& 
yChdn
 = *(
y
.
	`ci
());

105 
LCSTab
 
	`c
(
xChdn
.
	`size
(), 
d
::
ve
<>(
yChdn
.size()));

111 
size_t
 
i
 = 1; i < 
xChdn
.
	`size
(); i++) {

112 
size_t
 
j
 = 1; j < 
yChdn
.
	`size
(); j++) {

113 
Node
 
comOut
 = Node::
	`N
();

115 i(
	`comt
(
xChdn
[
i
], 
yChdn
[
j
], 
comOut
)) {

116 
c
[
i
][
j
] = c[i - 1][j - 1] + 1;

118 
c
[
i
][
j
] = 
d
::
	`max
(c[i][j - 1], c[i - 1][j]);

123 
out
 = 
c
;

124 
	}
}

141 
	gme
<
tyme
 
	gComtTy
>

142 
Node
 
	$lcs
(
Node
& 
x
, Node& 
y
, cڡ 
ComtTy
& 
comt
, 
Cڋxt
& 
x
) {

143 
	`DEBUG_PRINTLN
(
LCS
, "LCS: X=" << 
x
 << " Y=" << 
y
)

145 
Node
 
wX
 = Node::
	`Ci
();

146 
wX
.
	`ci
()->
	`push_back
(
Node
::
	`N
());

147 
wX
.
	`us
(
x
);

149 
Node
 
wY
 = Node::
	`Ci
();

150 
wY
.
	`ci
()->
	`push_back
(
Node
::
	`N
());

151 
wY
.
	`us
(
y
);

153 
LCSTab
 
b
;

154 
	`lcs_b
(
wX
, 
wY
, 
comt
, 
b
);

156  
	`lcs_backa
(
b
, 
wX
, 
wY
, 
ic_
<>ewX.
	`ci
()->
	`size
()- 1, stic_<>ewY.ci()->size()- 1, 
comt
);

157 
	}
}

172 
Node
 
橋n
(Node& 
r
, 
Cڋxt
& 
x
, 
n
 = -1);

219 
	gme
<
tyme
 
	gEnumTy
,ym
	gKeyTy
,ym
	gKeyFunTy
>

220 
group_by_to_a
(
d
::
ve
<
EnumTy
>& 
umi
, 
KeyFunTy
& 
keyFunc
, std::ve<d::

<
KeyTy
, std::ve<EnumTy> > >& 
r
 ) {

222 
d
::
m
<, 
	gKeyTy
> 
	gd
;

224 
	gd
::
m
<
size_t
, std::
ve
<
EnumTy
> > 
groud
;

226 
tyme
 
	gd
::
ve
<
EnumTy
>::

 
umIr
 = 
umi
.
beg
(), 
	gumIrEnd
 =numi.
d
(); 
	gumIr
 !
umIrEnd
;numIter++) {

227 
	gEnumTy
& 
	ge
 = *
umIr
;

229 
KeyTy
 
	gkey
 = 
keyFunc
(
e
);

231 i(
	ggroud
.
fd
(
key
.
hash
()=
groud
.
d
()) {

232 
d
.

(
d
::
make_
(()d.
size
(), 
key
));

234 
	gd
::
ve
<
EnumTy
> 
wCi
;

235 
	gwCi
.
push_back
(
e
);

236 
	ggroud
.

(
d
::
make_
(
key
.
hash
(), 
wCi
));

238 
	gd
::
ve
<
EnumTy
>& 
ci
 = 
groud
.

(
key
.
hash
());

239 
	gci
.
push_back
(
e
);

243 
	gdex
 = 0; index < 
	gd
.
size
(); index++) {

244 
	gKeyTy
& 
	gkey
 = 
d
.

(
dex
);

245 
	gd
::
ve
<
EnumTy
>& 
vues
 = 
groud
.

(
key
.
hash
());

247 
	gd
::

<
KeyTy
, std::
ve
<
EnumTy
> > 
groupg
 = 
d
::
make_
(
key
, 
vues
);

249 
	gr
.
push_back
(
groupg
);

	@node_modules/node-sass/src/libsass/src/sass_values.cpp

1 
	~"ss.h
"

2 
	~<cdlib
>

3 
	~<crg
>

4 
	~"ut.h
"

5 
	~"ev.h
"

6 
	~"vues.h
"

7 
	~"ss/vues.h
"

8 
	~"ss_vues.h
"

11 
usg
 
mea
 
Sass
;

14 
Sass_Tag
 
ADDCALL
 
ss_vue_g_g
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
; }

17 
bo
 
ADDCALL
 
ss_vue_is_nu
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_NULL
; }

18 
bo
 
ADDCALL
 
ss_vue_is_numb
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_NUMBER
; }

19 
bo
 
ADDCALL
 
ss_vue_is_rg
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_STRING
; }

20 
bo
 
ADDCALL
 
ss_vue_is_boޗn
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_BOOLEAN
; }

21 
bo
 
ADDCALL
 
ss_vue_is_c
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_COLOR
; }

22 
bo
 
ADDCALL
 
ss_vue_is_li
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_LIST
; }

23 
bo
 
ADDCALL
 
ss_vue_is_m
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_MAP
; }

24 
bo
 
ADDCALL
 
ss_vue_is_r
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_ERROR
; }

25 
bo
 
ADDCALL
 
ss_vue_is_wng
(cڡ 
Sass_Vue
* 
v
{  v->
unknown
.
g
 =
SASS_WARNING
; }

28 
ADDCALL
 
ss_numb_g_vue
(cڡ 
Sass_Vue
* 
v
{  v->
numb
.
vue
; }

29 
ADDCALL
 
ss_numb_t_vue
(
Sass_Vue
* 
v
, 
vue
{ v->
numb
.value = value; }

30 cڡ * 
ADDCALL
 
ss_numb_g_un
(cڡ 
Sass_Vue
* 
v
{  v->
numb
.
un
; }

31 
ADDCALL
 
ss_numb_t_un
(
Sass_Vue
* 
v
, * 
un
{ v->
numb
.unit = unit; }

34 cڡ * 
ADDCALL
 
ss_rg_g_vue
(cڡ 
Sass_Vue
* 
v
{  v->
rg
.
vue
; }

35 
ADDCALL
 
ss_rg_t_vue
(
Sass_Vue
* 
v
, * 
vue
{ v->
rg
.value = value; }

36 
bo
 
ADDCALL
 
ss_rg_is_qued
(cڡ 
Sass_Vue
* 
v
{  v->
rg
.
qued
; }

37 
ADDCALL
 
ss_rg_t_qued
(
Sass_Vue
* 
v
, 
bo
 
qued
{ v->
rg
.quoted = quoted; }

40 
bo
 
ADDCALL
 
ss_boޗn_g_vue
(cڡ 
Sass_Vue
* 
v
{  v->
boޗn
.
vue
; }

41 
ADDCALL
 
ss_boޗn_t_vue
(
Sass_Vue
* 
v
, 
bo
 
vue
{ v->
boޗn
.value = value; }

44 
ADDCALL
 
ss_c_g_r
(cڡ 
Sass_Vue
* 
v
{  v->
c
.
r
; }

45 
ADDCALL
 
ss_c_t_r
(
Sass_Vue
* 
v
, 
r
{ v->
c
.r =; }

46 
ADDCALL
 
ss_c_g_g
(cڡ 
Sass_Vue
* 
v
{  v->
c
.
g
; }

47 
ADDCALL
 
ss_c_t_g
(
Sass_Vue
* 
v
, 
g
{ v->
c
.g = g; }

48 
ADDCALL
 
ss_c_g_b
(cڡ 
Sass_Vue
* 
v
{  v->
c
.
b
; }

49 
ADDCALL
 
ss_c_t_b
(
Sass_Vue
* 
v
, 
b
{ v->
c
.b = b; }

50 
ADDCALL
 
ss_c_g_a
(cڡ 
Sass_Vue
* 
v
{  v->
c
.
a
; }

51 
ADDCALL
 
ss_c_t_a
(
Sass_Vue
* 
v
, 
a
{ v->
c
.a =; }

54 
size_t
 
ADDCALL
 
ss_li_g_ngth
(cڡ 
Sass_Vue
* 
v
{  v->
li
.
ngth
; }

55 
Sass_S
 
ADDCALL
 
ss_li_g_t
(cڡ 
Sass_Vue
* 
v
{  v->
li
.
t
; }

56 
ADDCALL
 
ss_li_t_t
(
Sass_Vue
* 
v
, 
Sass_S
 
t
{ v->
li
.separator = separator; }

58 
Sass_Vue
* 
ADDCALL
 
ss_li_g_vue
(cڡ Sass_Vue* 
v
, 
size_t
 
i
{  v->
li
.
vues
[i]; }

59 
ADDCALL
 
ss_li_t_vue
(
Sass_Vue
* 
v
, 
size_t
 
i
, Sass_Vue* 
vue
{ v->
li
.
vues
[i] = value; }

62 
size_t
 
ADDCALL
 
ss_m_g_ngth
(cڡ 
Sass_Vue
* 
v
{  v->
m
.
ngth
; }

64 
Sass_Vue
* 
ADDCALL
 
ss_m_g_key
(cڡ Sass_Vue* 
v
, 
size_t
 
i
{  v->
m
.
s
[i].
key
; }

65 
Sass_Vue
* 
ADDCALL
 
ss_m_g_vue
(cڡ Sass_Vue* 
v
, 
size_t
 
i
{  v->
m
.
s
[i].
vue
; }

66 
ADDCALL
 
ss_m_t_key
(
Sass_Vue
* 
v
, 
size_t
 
i
, Sass_Vue* 
key
{ v->
m
.
s
[i].key = key; }

67 
ADDCALL
 
ss_m_t_vue
(
Sass_Vue
* 
v
, 
size_t
 
i
, Sass_Vue* 
v
{ v->
m
.
s
[i].
vue
 = val; }

70 * 
ADDCALL
 
ss_r_g_mesge
(cڡ 
Sass_Vue
* 
v
{  v->
r
.
mesge
; };

71 
ADDCALL
 
ss_r_t_mesge
(
Sass_Vue
* 
v
, * 
msg
{ v->
r
.
mesge
 = msg; };

74 * 
ADDCALL
 
ss_wng_g_mesge
(cڡ 
Sass_Vue
* 
v
{  v->
wng
.
mesge
; };

75 
ADDCALL
 
ss_wng_t_mesge
(
Sass_Vue
* 
v
, * 
msg
{ v->
wng
.
mesge
 = msg; };

79 
Sass_Vue
* 
ADDCALL
 
ss_make_boޗn
(
bo
 
v
)

81 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

82 i(
v
 == 0)  0;

83 
v
->
boޗn
.
g
 = 
SASS_BOOLEAN
;

84 
v
->
boޗn
.
vue
 = 
v
;

85  
v
;

88 
Sass_Vue
* 
ADDCALL
 
ss_make_numb
(
v
, cڡ * 
un
)

90 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

91 i(
v
 == 0)  0;

92 
v
->
numb
.
g
 = 
SASS_NUMBER
;

93 
v
->
numb
.
vue
 = 
v
;

94 
v
->
numb
.
un
 = un ? 
ss_cy_c_rg
(unit) : 0;

95 i(
v
->
numb
.
un
 =0{ 

(v);  0; }

96  
v
;

99 
Sass_Vue
* 
ADDCALL
 
ss_make_c
(
r
, 
g
, 
b
, 
a
)

101 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

102 i(
v
 == 0)  0;

103 
v
->
c
.
g
 = 
SASS_COLOR
;

104 
v
->
c
.
r
 =;

105 
v
->
c
.
g
 = g;

106 
v
->
c
.
b
 = b;

107 
v
->
c
.
a
 =;

108  
v
;

111 
Sass_Vue
* 
ADDCALL
 
ss_make_rg
(cڡ * 
v
)

113 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

114 i(
v
 == 0)  0;

115 
v
->
rg
.
qued
 = 
l
;

116 
v
->
rg
.
g
 = 
SASS_STRING
;

117 
v
->
rg
.
vue
 = 
v
 ? 
ss_cy_c_rg
(val) : 0;

118 i(
v
->
rg
.
vue
 =0{ 

(v);  0; }

119  
v
;

122 
Sass_Vue
* 
ADDCALL
 
ss_make_qrg
(cڡ * 
v
)

124 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

125 i(
v
 == 0)  0;

126 
v
->
rg
.
qued
 = 
ue
;

127 
v
->
rg
.
g
 = 
SASS_STRING
;

128 
v
->
rg
.
vue
 = 
v
 ? 
ss_cy_c_rg
(val) : 0;

129 i(
v
->
rg
.
vue
 =0{ 

(v);  0; }

130  
v
;

133 
Sass_Vue
* 
ADDCALL
 
ss_make_li
(
size_t
 
n
, 
Sass_S
 
p
)

135 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

136 i(
v
 == 0)  0;

137 
v
->
li
.
g
 = 
SASS_LIST
;

138 
v
->
li
.
ngth
 = 
n
;

139 
v
->
li
.
t
 = 
p
;

140 
v
->
li
.
vues
 = (
Sass_Vue
**
oc
(
n
, (Sass_Value*));

141 i(
v
->
li
.
vues
 =0{ 

(v);  0; }

142  
v
;

145 
Sass_Vue
* 
ADDCALL
 
ss_make_m
(
size_t
 
n
)

147 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

148 i(
v
 == 0)  0;

149 
v
->
m
.
g
 = 
SASS_MAP
;

150 
v
->
m
.
ngth
 = 
n
;

151 
v
->
m
.
s
 = (
Sass_MPa
*
oc
(
n
, (Sass_MapPair));

152 i(
v
->
m
.
s
 =0{ 

(v);  0; }

153  
v
;

156 
Sass_Vue
* 
ADDCALL
 
ss_make_nu
()

158 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

159 i(
v
 == 0)  0;

160 
v
->
nu
.
g
 = 
SASS_NULL
;

161  
v
;

164 
Sass_Vue
* 
ADDCALL
 
ss_make_r
(cڡ * 
msg
)

166 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

167 i(
v
 == 0)  0;

168 
v
->
r
.
g
 = 
SASS_ERROR
;

169 
v
->
r
.
mesge
 = 
msg
 ? 
ss_cy_c_rg
(msg) : 0;

170 i(
v
->
r
.
mesge
 =0{ 

(v);  0; }

171  
v
;

174 
Sass_Vue
* 
ADDCALL
 
ss_make_wng
(cڡ * 
msg
)

176 
Sass_Vue
* 
v
 = (Sass_Vue*
oc
(1, (Sass_Value));

177 i(
v
 == 0)  0;

178 
v
->
wng
.
g
 = 
SASS_WARNING
;

179 
v
->
wng
.
mesge
 = 
msg
 ? 
ss_cy_c_rg
(msg) : 0;

180 i(
v
->
wng
.
mesge
 =0{ 

(v);  0; }

181  
v
;

185 
ADDCALL
 
ss_de_vue
(
Sass_Vue
* 
v
) {

187 
size_t
 
i
;

188 i(
v
 == 0) ;

189 
v
->
unknown
.
g
) {

190 
SASS_NULL
: {

192 
SASS_BOOLEAN
: {

194 
SASS_NUMBER
: {

195 

(
v
->
numb
.
un
);

197 
SASS_COLOR
: {

199 
SASS_STRING
: {

200 

(
v
->
rg
.
vue
);

202 
SASS_LIST
: {

203 
i
=0; i<
v
->
li
.
ngth
; i++) {

204 
ss_de_vue
(
v
->
li
.
vues
[
i
]);

206 

(
v
->
li
.
vues
);

208 
SASS_MAP
: {

209 
i
=0; i<
v
->
m
.
ngth
; i++) {

210 
ss_de_vue
(
v
->
m
.
s
[
i
].
key
);

211 
ss_de_vue
(
v
->
m
.
s
[
i
].
vue
);

213 

(
v
->
m
.
s
);

215 
SASS_ERROR
: {

216 

(
v
->
r
.
mesge
);

218 
SASS_WARNING
: {

219 

(
v
->
r
.
mesge
);

223 

(
v
);

228 
Sass_Vue
* 
ADDCALL
 
ss_e_vue
 (cڡ Sass_Vue* 
v
)

231 
size_t
 
i
;

232 i(
v
 == 0)  0;

233 
v
->
unknown
.
g
) {

234 
SASS_NULL
: {

235  
ss_make_nu
();

237 
SASS_BOOLEAN
: {

238  
ss_make_boޗn
(
v
->
boޗn
.
vue
);

240 
SASS_NUMBER
: {

241  
ss_make_numb
(
v
->
numb
.
vue
, v->numb.
un
);

243 
SASS_COLOR
: {

244  
ss_make_c
(
v
->
c
.
r
, v->c.
g
, v->c.
b
, v->c.
a
);

246 
SASS_STRING
: {

247  
ss_rg_is_qued
(
v
? 
ss_make_qrg
(v->
rg
.
vue
: 
ss_make_rg
(val->string.value);

249 
SASS_LIST
: {

250 
Sass_Vue
* 
li
 = 
ss_make_li
(
v
->li.
ngth
, v->li.
t
);

251 
i
 = 0; i < 
li
->li.
ngth
; i++) {

252 
li
->li.
vues
[
i
] = 
ss_e_vue
(
v
->list.values[i]);

254  
li
;

256 
SASS_MAP
: {

257 
Sass_Vue
* 
m
 = 
ss_make_m
(
v
->m.
ngth
);

258 
i
 = 0; i < 
v
->
m
.
ngth
; i++) {

259 
m
->m.
s
[
i
].
key
 = 
ss_e_vue
(
v
->map.pairs[i].key);

260 
m
->m.
s
[
i
].
vue
 = 
ss_e_vue
(
v
->map.pairs[i].value);

262  
m
;

264 
SASS_ERROR
: {

265  
ss_make_r
(
v
->
r
.
mesge
);

267 
SASS_WARNING
: {

268  
ss_make_wng
(
v
->
wng
.
mesge
);

276 
Sass_Vue
* 
ADDCALL
 
ss_vue_rgify
 (cڡ Sass_Vue* 
v
, 
bo
 
comesd
, 
ecisi
)

278 
Memy_Mag
 
mem
;

279 
Vue
* 
v
 = 
ss_vue_to_a_node
(
mem
, 
v
);

280 
Sass_Ine_Ois
 
tis
(
comesd
 ? 
COMPRESSED
 : 
NESTED
, 
ecisi
);

281 
d
::
rg
 
r
(
v
->
to_rg
(
tis
));

282  
ss_make_qrg
(
r
.
c_r
());

285 
Sass_Vue
* 
ADDCALL
 
ss_vue_
 (
Sass_OP
 

, cڡ Sass_Vue* 
a
, cڡ Sass_Vue* 
b
)

288 
Sass
::
Vue
* 
rv
 = 0;

289 
Memy_Mag
 
mem
;

291 
y
 {

293 
Vue
* 
lhs
 = 
ss_vue_to_a_node
(
mem
, 
a
);

294 
Vue
* 
rhs
 = 
ss_vue_to_a_node
(
mem
, 
b
);

295 
Sass_Ine_Ois
 
tis
(
NESTED
, 5);

298 

) {

299 
Sass_OP
::
EQ
:  
ss_make_boޗn
(
Ev
::
eq
(
lhs
, 
rhs
));

300 
Sass_OP
::
NEQ
:  
ss_make_boޗn
(!
Ev
::
eq
(
lhs
, 
rhs
));

301 
Sass_OP
::
GT
:  
ss_make_boޗn
(!
Ev
::

(
lhs
, 
rhs
, "gt"&& !Ev::
eq
(lhs,hs));

302 
Sass_OP
::
GTE
:  
ss_make_boޗn
(!
Ev
::

(
lhs
, 
rhs
, "gte"));

303 
Sass_OP
::
LT
:  
ss_make_boޗn
(
Ev
::

(
lhs
, 
rhs
, "lt"));

304 
Sass_OP
::
LTE
:  
ss_make_boޗn
(
Ev
::

(
lhs
, 
rhs
, "e"|| Ev::
eq
(lhs,hs));

308 i(
ss_vue_is_numb
(
a
&& sass_vue_is_numb(
b
)) {

309 cڡ 
Numb
* 
l_n
 = 
dymic_
<cڡ Numb*>(
lhs
);

310 cڡ 
Numb
* 
r_n
 = 
dymic_
<cڡ Numb*>(
rhs
);

311 
rv
 = 
Ev
::
_numbs
(
mem
, 

, *
l_n
, *
r_n
, 
tis
);

313 i(
ss_vue_is_numb
(
a
&& 
ss_vue_is_c
(a)) {

314 cڡ 
Numb
* 
l_n
 = 
dymic_
<cڡ Numb*>(
lhs
);

315 cڡ 
C
* 
r_c
 = 
dymic_
<cڡ C*>(
rhs
);

316 
rv
 = 
Ev
::
_numb_c
(
mem
, 

, *
l_n
, *
r_c
, 
tis
);

318 i(
ss_vue_is_c
(
a
&& 
ss_vue_is_numb
(
b
)) {

319 cڡ 
C
* 
l_c
 = 
dymic_
<cڡ C*>(
lhs
);

320 cڡ 
Numb
* 
r_n
 = 
dymic_
<cڡ Numb*>(
rhs
);

321 
rv
 = 
Ev
::
_c_numb
(
mem
, 

, *
l_c
, *
r_n
, 
tis
);

323 i(
ss_vue_is_c
(
a
&& sass_vue_is_c(
b
)) {

324 cڡ 
C
* 
l_c
 = 
dymic_
<cڡ C*>(
lhs
);

325 cڡ 
C
* 
r_c
 = 
dymic_
<cڡ C*>(
rhs
);

326 
rv
 = 
Ev
::
_cs
(
mem
, 

, *
l_c
, *
r_c
, 
tis
);

329 
Vue
* 
l_v
 = 
dymic_
<Vue*>(
lhs
);

330 
Vue
* 
r_v
 = 
dymic_
<Vue*>(
rhs
);

331 
rv
 = 
Ev
::
_rgs
(
mem
, 

, *
l_v
, *
r_v
, 
tis
);

335 i(!
rv
 
ss_make_r
("invalideturn value");

338  
a_node_to_ss_vue
(
rv
);

343 
tch
 (
Exi
::
InvidSass
& 
e
{  
ss_make_r
.
wh
()); }

344 
tch
 (
d
::
bad_loc
&{  
ss_make_r
("memoryxhausted"); }

345 
tch
 (
d
::
exi
& 
e
{  
ss_make_r
.
wh
()); }

346 
tch
 (
d
::
rg
& 
e
{  
ss_make_r
.
c_r
()); }

347 
tch
 (cڡ * 
e
{  
ss_make_r
(e); }

348 
tch
 (...{  
ss_make_r
("unknown"); }

	@node_modules/node-sass/src/libsass/src/sass_values.hpp

1 #ide
SASS_SASS_VALUES_H


2 
	#SASS_SASS_VALUES_H


	)

4 
	~"ss.h
"

6 
	sSass_Unknown
 {

7 
Sass_Tag
 
	mg
;

10 
	sSass_Boޗn
 {

11 
Sass_Tag
 
	mg
;

12 
bo
 
	mvue
;

15 
	sSass_Numb
 {

16 
Sass_Tag
 
	mg
;

17 
	mvue
;

18 * 
	mun
;

21 
	sSass_C
 {

22 
Sass_Tag
 
	mg
;

23 
	mr
;

24 
	mg
;

25 
	mb
;

26 
	ma
;

29 
	sSass_Sg
 {

30 
Sass_Tag
 
	mg
;

31 
bo
 
	mqued
;

32 * 
	mvue
;

35 
	sSass_Li
 {

36 
Sass_Tag
 
	mg
;

37 
Sass_S
 
	mt
;

38 
size_t
 
	mngth
;

40 
Sass_Vue
** 
	mvues
;

43 
	sSass_M
 {

44 
Sass_Tag
 
	mg
;

45 
size_t
 
	mngth
;

46 
Sass_MPa
* 
	ms
;

49 
	sSass_Nu
 {

50 
Sass_Tag
 
	mg
;

53 
	sSass_E
 {

54 
Sass_Tag
 
	mg
;

55 * 
	mmesge
;

58 
	sSass_Wng
 {

59 
Sass_Tag
 
	mg
;

60 * 
	mmesge
;

63 
	uSass_Vue
 {

64 
Sass_Unknown
 
	munknown
;

65 
Sass_Boޗn
 
	mboޗn
;

66 
Sass_Numb
 
	mnumb
;

67 
Sass_C
 
	mc
;

68 
Sass_Sg
 
	mrg
;

69 
Sass_Li
 
	mli
;

70 
Sass_M
 
	mm
;

71 
Sass_Nu
 
	mnu
;

72 
Sass_E
 
	mr
;

73 
Sass_Wng
 
	mwng
;

76 
	sSass_MPa
 {

77 
Sass_Vue
* 
	mkey
;

78 
Sass_Vue
* 
	mvue
;

	@node_modules/node-sass/src/libsass/src/source_map.cpp

1 
	~"ss.h
"

2 
	~<rg
>

3 
	~<sam
>

4 
	~<ioam
>

5 
	~<cddef
>

6 
	~<iom
>

8 
	~"a.h
"

9 
	~"js.h
"

10 
	~"cڋxt.h
"

11 
	~"posi.h
"

12 
	~"sour_m.h
"

14 
mea
 
	gSass
 {

15 
	gSourM
::
SourM
(: 
cut_posi
(0, 0, 0), 
fe
("stdin") { }

16 
	gSourM
::
SourM
(cڡ 
d
::
rg
& 
fe
: 
cut_posi
(0, 0, 0), file(file) { }

18 
	gd
::
rg
 
SourM
::
nd_cm
(
Cڋxt
 &
x
) {

20 cڡ 
bo
 
ude_sours
 = 
x
.
c_tis
.
sour_m_cڋs
;

21 cڡ 
	gd
::
ve
<
d
::
rg
> 
lks
 = 
x
.
cm_lks
;

22 cڡ 
	gd
::
ve
<
Resour
>& 
sours
(
x
.
sours
);

24 
JsNode
* 
	gjs_cm
 = 
js_mkobje
();

26 
js_nd_memb
(
js_cm
, "vsi", 
js_mknumb
(3));

29 i(!
	gx
.
	gsour_m_ro
.
emy
()) {

30 
JsNode
* 
	gro
 = 
js_mkrg
(
x
.
sour_m_ro
.
c_r
());

31 
js_nd_memb
(
js_cm
, "sourRo", 
ro
);

34 cڡ *
	gude
 = 
fe
.
c_r
();

35 
JsNode
 *
	gjs_ude
 = 
js_mkrg
(
ude
);

36 
js_nd_memb
(
js_cm
, "fe", 
js_ude
);

38 
JsNode
 *
	gjs_udes
 = 
js_mky
();

39 
size_t
 
	gi
 = 0; i < 
	gsour_dex
.
size
(); ++i) {

40 cڡ *
	gude
 = 
lks
[
sour_dex
[
i
]].
c_r
();

41 
JsNode
 *
	gjs_ude
 = 
js_mkrg
(
ude
);

42 
js_nd_emt
(
js_udes
, 
js_ude
);

44 
js_nd_memb
(
js_cm
, "sours", 
js_udes
);

46 i(
	gude_sours
) {

47 
JsNode
 *
	gjs_cڋs
 = 
js_mky
();

48 
size_t
 
	gi
 = 0; i < 
	gsour_dex
.
size
(); ++i) {

49 cڡ 
	gResour
& 
sour
(
sours
[
sour_dex
[
i
]]);

50 
JsNode
 *
	gjs_cڋ
 = 
js_mkrg
(
sour
.
cڋs
);

51 
js_nd_emt
(
js_cڋs
, 
js_cڋ
);

53 i(
	gjs_cڋs
->
	gchdn
.
	ghd
)

54 
js_nd_memb
(
js_cm
, "soursCڋ", 
js_cڋs
);

57 
	gd
::
rg
 
mpgs
 = 
rlize_mpgs
();

58 
JsNode
 *
	gjs_mpgs
 = 
js_mkrg
(
mpgs
.
c_r
());

59 
js_nd_memb
(
js_cm
, "mpgs", 
js_mpgs
);

61 
JsNode
 *
	gjs_mes
 = 
js_mky
();

64 
js_nd_memb
(
js_cm
, "mes", 
js_mes
);

66 *
	gr
 = 
js_rgify
(
js_cm
, "\t");

67 
	gd
::
rg
 
su
 = 
d
::rg(
r
);

68 

(
r
);

69 
js_de
(
js_cm
);

70  
	gsu
;

73 
	gd
::
rg
 
SourM
::
rlize_mpgs
() {

74 
d
::
rg
 
su
 = "";

76 
size_t
 
	gevious_ged_le
 = 0;

77 
size_t
 
	gevious_ged_cumn
 = 0;

78 
size_t
 
	gevious_ig_le
 = 0;

79 
size_t
 
	gevious_ig_cumn
 = 0;

80 
size_t
 
	gevious_ig_fe
 = 0;

81 
size_t
 
	gi
 = 0; i < 
	gmpgs
.
size
(); ++i) {

82 cڡ 
size_t
 
	gged_le
 = 
mpgs
[
i
].
ged_posi
.
le
;

83 cڡ 
size_t
 
	gged_cumn
 = 
mpgs
[
i
].
ged_posi
.
cumn
;

84 cڡ 
size_t
 
	gig_le
 = 
mpgs
[
i
].
ig_posi
.
le
;

85 cڡ 
size_t
 
	gig_cumn
 = 
mpgs
[
i
].
ig_posi
.
cumn
;

86 cڡ 
size_t
 
	gig_fe
 = 
mpgs
[
i
].
ig_posi
.
fe
;

88 i(
	gged_le
 !
evious_ged_le
) {

89 
evious_ged_cumn
 = 0;

90 i(
	gged_le
 > 
	gevious_ged_le
) {

91 
	gsu
 +
d
::
rg
(
ged_le
 - 
evious_ged_le
, ';');

92 
	gevious_ged_le
 = 
ged_le
;

95 i(
	gi
 > 0) {

96 
	gsu
 += ",";

100 
	gsu
 +
ba64vlq
.
code
(
ic_
<>(
ged_cumn
- stic_<>(
evious_ged_cumn
));

101 
	gevious_ged_cumn
 = 
ged_cumn
;

103 
	gsu
 +
ba64vlq
.
code
(
ic_
<>(
ig_fe
- stic_<>(
evious_ig_fe
));

104 
	gevious_ig_fe
 = 
ig_fe
;

106 
	gsu
 +
ba64vlq
.
code
(
ic_
<>(
ig_le
- stic_<>(
evious_ig_le
));

107 
	gevious_ig_le
 = 
ig_le
;

109 
	gsu
 +
ba64vlq
.
code
(
ic_
<>(
ig_cumn
- stic_<>(
evious_ig_cumn
));

110 
	gevious_ig_cumn
 = 
ig_cumn
;

113  
	gsu
;

116 
	gSourM
::
d
(cڡ 
OuutBufr
& 
out
)

118 
Offt
 
size
(
out
.
sm
.
cut_posi
);

119 
Mpg
 
	gmpg
 : 
out
.
sm
.
mpgs
) {

120 i(
mpg
.
ged_posi
.
le
 > 
size
.line) {

121 
throw
(
d
::
ruime_r
("prepend sourcemap has illegaline"));

123 i(
	gmpg
.
	gged_posi
.
	gle
 =
size
.
le
) {

124 i(
mpg
.
ged_posi
.
cumn
 > 
size
.column) {

125 
throw
(
d
::
ruime_r
("prepend sourcemap has illegal column"));

130 
d
(
Offt
(
out
.
bufr
));

132 
VECTOR_UNSHIFT
(
mpgs
, 
out
.
sm
.mappings);

135 
	gSourM
::
nd
(cڡ 
OuutBufr
& 
out
)

137 
nd
(
Offt
(
out
.
bufr
));

140 
	gSourM
::
d
(cڡ 
Offt
& 
offt
)

142 i(
offt
.
le
 !0 || offt.
cumn
 != 0) {

143 
Mpg
& 
mpg
 : 
mpgs
) {

145 i(
mpg
.
ged_posi
.
le
 == 0) {

146 
mpg
.
ged_posi
.
cumn
 +
offt
.column;

149 
	gmpg
.
	gged_posi
.
	gle
 +
offt
.
le
;

152 i(
	gcut_posi
.
	gle
 == 0) {

153 
cut_posi
.
cumn
 +
offt
.column;

155 
	gcut_posi
.
	gle
 +
offt
.
le
;

158 
	gSourM
::
nd
(cڡ 
Offt
& 
offt
)

160 
cut_posi
 +
offt
;

163 
	gSourM
::
add_ݒ_mpg
(cڡ 
AST_Node
* 
node
)

165 
mpgs
.
push_back
(
Mpg
(
node
->
pe
(), 
cut_posi
));

168 
	gSourM
::
add_o_mpg
(cڡ 
AST_Node
* 
node
)

170 
mpgs
.
push_back
(
Mpg
(
node
->
pe
(+ode->pe().
offt
, 
cut_posi
));

173 
PrS
 
	gSourM
::
m
(cڡ PrS& 
pe
) {

174 
size_t
 
i
 = 0; 
	gi
 < 
	gmpgs
.
size
(); ++i) {

176 
	gmpgs
[
i
].
	gged_posi
.
	gfe
 =
pe
.
fe
 &&

177 
mpgs
[
i
].
ged_posi
.
le
 =
pe
.line &&

178 
mpgs
[
i
].
ged_posi
.
cumn
 =
pe
.column

179  
PrS
(
pe
.
th
,e.
c
, 
mpgs
[
i
].
ig_posi
,e.
offt
);

181  
PrS
(
pe
.
th
,e.
c
, 
Posi
(-1, -1, -1), 
Offt
(0, 0));

	@node_modules/node-sass/src/libsass/src/source_map.hpp

1 #ide
SASS_SOURCE_MAP_H


2 
	#SASS_SOURCE_MAP_H


	)

4 
	~<rg
>

5 
	~<ve
>

7 
	~"a_fwd_de.h
"

8 
	~"ba64vlq.h
"

9 
	~"posi.h
"

10 
	~"mpg.h
"

12 
	#VECTOR_PUSH
(
vec
, 
s
vec.
	`
(vec.
	`d
(), ins.
	`beg
(), ins.d())

	)

13 
	#VECTOR_UNSHIFT
(
vec
, 
s
vec.
	`
(vec.
	`beg
(), ins.beg(), ins.
	`d
())

	)

15 
mea
 
	gSass
 {

17 
ass
 
	gCڋxt
;

18 
ass
 
	gOuutBufr
;

20 as
	cSourM
 {

22 
	gpublic
:

23 
d
::
ve
<
size_t
> 
sour_dex
;

24 
SourM
();

25 
SourM
(cڡ 
d
::
rg
& 
fe
);

27 
nd
(cڡ 
Offt
& 
offt
);

28 
d
(cڡ 
Offt
& 
offt
);

29 
nd
(cڡ 
OuutBufr
& 
out
);

30 
d
(cڡ 
OuutBufr
& 
out
);

31 
add_ݒ_mpg
(cڡ 
AST_Node
* 
node
);

32 
add_o_mpg
(cڡ 
AST_Node
* 
node
);

34 
	gd
::
rg
 
nd_cm
(
Cڋxt
 &
x
);

35 
PrS
 
m
(cڡ PrS& 
pe
);

37 
	give
:

39 
d
::
rg
 
rlize_mpgs
();

41 
	gd
::
ve
<
Mpg
> 
mpgs
;

42 
Posi
 
	gcut_posi
;

43 
	gpublic
:

44 
d
::
rg
 
fe
;

45 
	give
:

46 
Ba64VLQ
 
ba64vlq
;

49 as
	cOuutBufr
 {

50 
	gpublic
:

51 
OuutBufr
()

52 : 
bufr
(""),

53 
sm
()

55 
	gpublic
:

56 
d
::
rg
 
bufr
;

57 
SourM
 
	gsm
;

	@node_modules/node-sass/src/libsass/src/subset_map.hpp

1 #ide
SASS_SUBSET_MAP_H


2 
	#SASS_SUBSET_MAP_H


	)

4 
	~<m
>

5 
	~<t
>

6 
	~<ve
>

7 
	~<gܙhm
>

8 
	~<
>

57 
mea
 
	gSass
 {

59 
	gme
<
tyme
 
	gF
,ym
	gS
,ym
	gT
>

60 
	s
 {

61 
F
 
	gf
;

62 
S
 
	gcd
;

63 
T
 
	gthd
;

65 

(cڡ 
F
& 
f
, cڡ 
S
& 
s
, cڡ 
T
& 
t
: 
f
(f), 
cd
(s), 
thd
(t) { }

68 
	gme
<
tyme
 
	gF
,ym
	gS
,ym
	gT
>

69 
	g
<
	gF
, 
	gS
, 
	gT
> 
make_
(cڡ 
F
& 
f
, cڡ 
S
& 
s
, cڡ 
T
& 
t
)

70 {  
	g
<
	gF
, 
	gS
, 
	gT
>(
	gf
, 
	gs
, 
	gt
); }

72 
	gme
<
tyme
 
	gK
,ym
	gV
>

73 as
	cSubt_M
 {

74 
	give
:

75 
d
::
ve
<
V
> 
vues_
;

76 
	gd
::
m
<
K
, std::
ve
<

<
d
::ve<K>, std::
t
<K>, 
	gsize_t
> > > 
	ghash_
;

77 
	gpublic
:

78 
put
(cڡ 
d
::
ve
<
K
>& 
s
, cڡ 
V
& 
vue
);

79 
	gd
::
ve
<
d
::

<
V
, std::ve<
K
> > > 
g_kv
(cڡ std::ve<K>& 
s
);

80 
	gd
::
ve
<
V
> 
g_v
(cڡ 
d
::ve<
K
>& 
s
);

81 
bo
 
emy
({  
	gvues_
.empty(); }

82 
r
({ 
	gvues_
.r(); 
	ghash_
.clear(); }

83 cڡ 
	gd
::
ve
<
V
> 
vues
({  
vues_
; }

86 
	gme
<
tyme
 
	gK
,ym
	gV
>

87 
	gSubt_M
<
	gK
, 
	gV
>::
put
(cڡ 
d
::
ve
<
K
>& 
s
, cڡ 
V
& 
vue
)

89 i(
	gs
.
emy
()
	gthrow
 "internalrror: subset map keys mayot bempty";

90 
size_t
 
	gdex
 = 
vues_
.
size
();

91 
	gvues_
.
push_back
(
vue
);

92 
	gd
::
t
<
K
> 
ss
;

93 
size_t
 
	gi
 = 0, 
	gS
 = 
s
.
size
(); i < S; ++i)

94 { 
	gss
.

(
s
[
i
]); }

95 
size_t
 
	gi
 = 0, 
	gS
 = 
s
.
size
(); i < S; ++i)

97 
	ghash_
[
s
[
i
]].
push_back
(
make_
(s, 
ss
, 
dex
));

101 
	gme
<
tyme
 
	gK
,ym
	gV
>

102 
	gd
::
ve
<
d
::

<
V
, std::ve<
K
> > > 
Subt_M
<K, 
	gV
>::
g_kv
(cڡ std::ve<K>& 
s
)

104 
d
::
ve
<
K
> 
s܋d
 = 
s
;

105 
st
(
s܋d
.
beg
(), s܋d.
d
());

106 
	gd
::
ve
<
d
::

<
size_t
, std::ve<
K
> > > 
dis
;

107 
size_t
 
	gi
 = 0, 
	gS
 = 
s
.
size
(); i < S; ++i) {

108 i(!
	ghash_
.
cou
(
s
[
i
])) {

111 
	gd
::
ve
<

<
d
::ve<
K
>, std::
t
<K>, 
	gsize_t
> > 
	gsubts
 = 
hash_
[
s
[
i
]];

113 
size_t
 
	gj
 = 0, 
	gT
 = 
subts
.
size
(); j < T; ++j) {

114 i(!
udes
(
s܋d
.
beg
(), s܋d.
d
(), 
subts
[
j
].
cd
.begin(), subsets[j].second.end())) {

118 
	gdis
.
push_back
(
d
::
make_
(
subts
[
j
].
thd
, subts[j].
f
));

122 
st
(
dis
.
beg
(), indis.
d
());

123 
tyme
 
	gd
::
ve
<
d
::

<
size_t
, std::ve<
K
> > >::

 
dis_d
 = 
unique
(
dis
.
beg
(), indis.
d
());

124 
	gdis
.
size
(
di
(
dis
.
beg
(), 
dis_d
));

126 
	gd
::
ve
<
d
::

<
V
, std::ve<
K
> > > 
sus
;

127 
size_t
 
	gi
 = 0, 
	gS
 = 
dis
.
size
(); i < S; ++i) {

128 
	gsus
.
push_back
(
d
::
make_
(
vues_
[
dis
[
i
].
f
], indis[i].
cd
));

130  
	gsus
;

133 
	gme
<
tyme
 
	gK
,ym
	gV
>

134 
	gd
::
ve
<
V
> 
Subt_M
<
K
, 
	gV
>::
g_v
(cڡ 
d
::ve<K>& 
s
)

136 
d
::
ve
<d::

<
V
, 
	gd
::ve<
K
> > > 
kvs
 = 
g_kv
(
s
);

137 
	gd
::
ve
<
V
> 
sus
;

138 
size_t
 
	gi
 = 0, 
	gS
 = 
kvs
.
size
(); i < S; ++i
	gsus
.
push_back
(kvs[
i
].
f
);

139  
	gsus
;

	@node_modules/node-sass/src/libsass/src/to_c.cpp

1 
	~"ss.h
"

2 
	~"to_c.h
"

3 
	~"a.h
"

5 
mea
 
	gSass
 {

7 
Sass_Vue
* 
	gTo_C
::
back_im
(
AST_Node
* 
n
)

8 {  
ss_make_r
("unknownype for C-API"); }

10 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Boޗn
* 
b
)

11 {  
ss_make_boޗn
(
b
->
vue
()); }

13 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Numb
* 
n
)

14 {  
ss_make_numb
(
n
->
vue
(),->
un
().
c_r
()); }

16 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Cuom_Wng
* 
w
)

17 {  
ss_make_wng
(
w
->
mesge
().
c_r
()); }

19 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Cuom_E
* 
e
)

20 {  
ss_make_r
(
e
->
mesge
().
c_r
()); }

22 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
C
* 
c
)

23 {  
ss_make_c
(
c
->
r
(), c->
g
(), c->
b
(), c->
a
()); }

25 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Sg_Cڡt
* 
s
)

27 i(
s
->
que_mk
()) {

28  
ss_make_qrg
(
s
->
vue
().
c_r
());

30  
ss_make_rg
(
s
->
vue
().
c_r
());

34 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Sg_Qued
* 
s
)

35 {  
ss_make_qrg
(
s
->
vue
().
c_r
()); }

37 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Li
* 
l
)

39 
Sass_Vue
* 
v
 = 
ss_make_li
(
l
->
ngth
(),->
t
());

40 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

41 
ss_li_t_vue
(
v
, 
i
, (*
l
)[i]->
rfm
(
this
));

43  
	gv
;

46 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
M
* 
m
)

48 
Sass_Vue
* 
v
 = 
ss_make_m
(
m
->
ngth
());

49 
	gi
 = 0;

50 aut
	gkey
 : 
m
->
keys
()) {

51 
ss_m_t_key
(
v
, 
i
, 
key
->
rfm
(
this
));

52 
ss_m_t_vue
(
v
, 
i
, 
m
->

(
key
)->
rfm
(
this
));

53 
	gi
++;

55  
	gv
;

58 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Argumts
* 
a
)

60 
Sass_Vue
* 
v
 = 
ss_make_li
(
a
->
ngth
(), 
SASS_COMMA
);

61 
size_t
 
	gi
 = 0, 
	gL
 = 
a
->
ngth
(); i < L; ++i) {

62 
ss_li_t_vue
(
v
, 
i
, (*
a
)[i]->
rfm
(
this
));

64  
	gv
;

67 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Argumt
* 
a
)

68 {  
a
->
vue
()->
rfm
(
this
); }

71 
Sass_Vue
* 
	gTo_C
::
ݔ
()(
Nu
* 
n
)

72 {  
ss_make_nu
(); }

	@node_modules/node-sass/src/libsass/src/to_c.hpp

1 #ide
SASS_TO_C_H


2 
	#SASS_TO_C_H


	)

4 
	~"a_fwd_de.h
"

5 
	~"ݔi.h
"

6 
	~"ss/vues.h
"

8 
mea
 
	gSass
 {

10 
ass
 
	gTo_C
 : 
public
 
Oti_CRTP
<
Sass_Vue
*, To_C> {

12 
Sass_Vue
* 
back_im
(
AST_Node
* 
n
);

14 
	gpublic
:

16 
To_C
() { }

17 ~
To_C
() { }

19 
Sass_Vue
* 
ݔ
()(
Boޗn
*);

20 
Sass_Vue
* 
ݔ
()(
	gNumb
*);

21 
Sass_Vue
* 
ݔ
()(
	gC
*);

22 
Sass_Vue
* 
ݔ
()(
	gSg_Cڡt
*);

23 
Sass_Vue
* 
ݔ
()(
	gSg_Qued
*);

24 
Sass_Vue
* 
ݔ
()(
	gCuom_Wng
*);

25 
Sass_Vue
* 
ݔ
()(
	gCuom_E
*);

26 
Sass_Vue
* 
ݔ
()(
	gLi
*);

27 
Sass_Vue
* 
ݔ
()(
	gM
*);

28 
Sass_Vue
* 
ݔ
()(
	gNu
*);

29 
Sass_Vue
* 
ݔ
()(
	gArgumts
*);

30 
Sass_Vue
* 
ݔ
()(
	gArgumt
*);

33 
Sass_Vue
* 
back
(
AST_Node
* 
x
)

34 {  
back_im
(
x
); }

	@node_modules/node-sass/src/libsass/src/to_value.cpp

1 
	~"ss.h
"

2 
	~"a.h
"

3 
	~"to_vue.h
"

5 
mea
 
	gSass
 {

7 
Vue
* 
	gTo_Vue
::
back_im
(
AST_Node
* 
n
)

11 
throw
 
d
::
ruime_r
("invalidode foro_value");

17 
Vue
* 
	gTo_Vue
::
ݔ
()(
Cuom_E
* 
e
)

19  
e
;

23 
Vue
* 
	gTo_Vue
::
ݔ
()(
Cuom_Wng
* 
w
)

25  
w
;

29 
Vue
* 
	gTo_Vue
::
ݔ
()(
Boޗn
* 
b
)

31  
b
;

35 
Vue
* 
	gTo_Vue
::
ݔ
()(
Numb
* 
n
)

37  
n
;

41 
Vue
* 
	gTo_Vue
::
ݔ
()(
C
* 
c
)

43  
c
;

47 
Vue
* 
	gTo_Vue
::
ݔ
()(
Sg_Cڡt
* 
s
)

49  
s
;

53 
Vue
* 
	gTo_Vue
::
ݔ
()(
Sg_Qued
* 
s
)

55  
s
;

59 
Vue
* 
	gTo_Vue
::
ݔ
()(
Li
* 
l
)

61 
Li
* 

 = 
SASS_MEMORY_NEW
(
mem
, List,

62 
l
->
pe
(),

63 
l
->
ngth
(),

64 
l
->
t
(),

65 
l
->
is_gli
());

66 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

67 *
	g
 << (*
	gl
)[
i
]->
rfm
(
this
);

69  
	g
;

73 
Vue
* 
	gTo_Vue
::
ݔ
()(
M
* 
m
)

75  
m
;

79 
Vue
* 
	gTo_Vue
::
ݔ
()(
Nu
* 
n
)

81  
n
;

85 
Vue
* 
	gTo_Vue
::
ݔ
()(
Argumt
* 
g
)

87 i(!
g
->
me
().
emy
())  0;

88  
	gg
->
vue
()->
rfm
(
this
);

92 
Vue
* 
	gTo_Vue
::
ݔ
()(
Se_Li
* 
s
)

94  
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
,

95 
s
->
pe
(),

96 
s
->
to_rg
(
x
.
c_tis
));

100 
Vue
* 
	gTo_Vue
::
ݔ
()(
By_Exessi
* 
s
)

102  
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
,

103 
s
->
pe
(),

104 
s
->
to_rg
(
x
.
c_tis
));

	@node_modules/node-sass/src/libsass/src/to_value.hpp

1 #ide
SASS_TO_VALUE_H


2 
	#SASS_TO_VALUE_H


	)

4 
	~"ݔi.h
"

5 
	~"ss/vues.h
"

6 
	~"a_fwd_de.h
"

8 
mea
 
	gSass
 {

10 
ass
 
	gTo_Vue
 : 
public
 
Oti_CRTP
<
Vue
*, To_Value> {

12 
Vue
* 
back_im
(
AST_Node
* 
n
);

14 
	give
:

16 
Cڋxt
& 
x
;

17 
	gMemy_Mag
& 
	gmem
;

19 
	gpublic
:

21 
To_Vue
(
Cڋxt
& 
x
, 
Memy_Mag
& 
mem
)

22 : 
x
(x), 
mem
(mem)

24 ~
To_Vue
() { }

25 
usg
 
	gOti
<
	gVue
*>::
ݔ
();

27 
Vue
* 
ݔ
()(
	gArgumt
*);

28 
Vue
* 
ݔ
()(
	gBoޗn
*);

29 
Vue
* 
ݔ
()(
	gNumb
*);

30 
Vue
* 
ݔ
()(
	gC
*);

31 
Vue
* 
ݔ
()(
	gSg_Cڡt
*);

32 
Vue
* 
ݔ
()(
	gSg_Qued
*);

33 
Vue
* 
ݔ
()(
	gCuom_Wng
*);

34 
Vue
* 
ݔ
()(
	gCuom_E
*);

35 
Vue
* 
ݔ
()(
	gLi
*);

36 
Vue
* 
ݔ
()(
	gM
*);

37 
Vue
* 
ݔ
()(
	gNu
*);

40 
Vue
* 
ݔ
()(
	gSe_Li
*);

41 
Vue
* 
ݔ
()(
	gBy_Exessi
*);

44 
	gme
 <
tyme
 
	gU
>

45 
Vue
* 
back
(
U
 
x
{  
back_im
(x); }

	@node_modules/node-sass/src/libsass/src/units.cpp

1 
	~"ss.h
"

2 
	~<dex
>

3 
	~"uns.h
"

5 
mea
 
	gSass
 {

12 cڡ 
	gsize_cvsi_s
[6][6] =

23 cڡ 
	gg_cvsi_s
[4][4] =

26  { 1, 40.0/36.0, 
PI
/180.0, 1.0/360.0 },

27  { 36.0/40.0, 1, 
PI
/200.0, 1.0/400.0 },

28  { 180.0/
PI
, 200.0/PI, 1, 0.5/PI },

29  { 360.0, 400.0, 2.0*
PI
, 1 }

32 cڡ 
	gtime_cvsi_s
[2][2] =

38 cڡ 
	gequcy_cvsi_s
[2][2] =

44 cڡ 
	gsuti_cvsi_s
[3][3] =

52 
UnCss
 
g_un_ty
(
UnTy
 
un
)

54 
	gun
 & 0xFF00)

56 
	gUnCss
::
LENGTH
:  
UnCss
::LENGTH; ;

57 
	gUnCss
::
ANGLE
:  
UnCss
::ANGLE; ;

58 
	gUnCss
::
TIME
:  
UnCss
::TIME; ;

59 
	gUnCss
::
FREQUENCY
:  
UnCss
::FREQUENCY; ;

60 
	gUnCss
::
RESOLUTION
:  
UnCss
::RESOLUTION; ;

61 :  
UnCss
::
INCOMMENSURABLE
; ;

65 
	gd
::
rg
 
g_un_ass
(
UnTy
 
un
)

67 
un
 & 0xFF00)

69 
UnCss
::
LENGTH
:  "LENGTH"; ;

70 
	gUnCss
::
ANGLE
:  "ANGLE"; ;

71 
	gUnCss
::
TIME
:  "TIME"; ;

72 
	gUnCss
::
FREQUENCY
:  "FREQUENCY"; ;

73 
	gUnCss
::
RESOLUTION
:  "RESOLUTION"; ;

78 
UnTy
 
rg_to_un
(cڡ 
d
::
rg
& 
s
)

81 i(
s
 ="px" 
UnTy
::
PX
;

82 i(
	gs
 ="" 
UnTy
::
PT
;

83 i(
	gs
 ="pc" 
UnTy
::
PC
;

84 i(
	gs
 ="mm" 
UnTy
::
MM
;

85 i(
	gs
 ="cm" 
UnTy
::
CM
;

86 i(
	gs
 ="" 
UnTy
::
IN
;

88 i(
	gs
 ="deg" 
UnTy
::
DEG
;

89 i(
	gs
 ="gd" 
UnTy
::
GRAD
;

90 i(
	gs
 ="d" 
UnTy
::
RAD
;

91 i(
	gs
 ="tu" 
UnTy
::
TURN
;

93 i(
	gs
 ="s" 
UnTy
::
SEC
;

94 i(
	gs
 ="ms" 
UnTy
::
MSEC
;

96 i(
	gs
 ="Hz" 
UnTy
::
HERTZ
;

97 i(
	gs
 ="kHz" 
UnTy
::
KHERTZ
;

99 i(
	gs
 ="dpi" 
UnTy
::
DPI
;

100 i(
	gs
 ="dpcm" 
UnTy
::
DPCM
;

101 i(
	gs
 ="dx" 
UnTy
::
DPPX
;

103  
	gUnTy
::
UNKNOWN
;

106 cڡ * 
un_to_rg
(
UnTy
 
un
)

108 
	gun
) {

110 
	gUnTy
::
PX
:  "px"; ;

111 
	gUnTy
::
PT
:  "pt"; ;

112 
	gUnTy
::
PC
:  "pc"; ;

113 
	gUnTy
::
MM
:  "mm"; ;

114 
	gUnTy
::
CM
:  "cm"; ;

115 
	gUnTy
::
IN
:  "in"; ;

117 
	gUnTy
::
DEG
:  "deg"; ;

118 
	gUnTy
::
GRAD
:  "grad"; ;

119 
	gUnTy
::
RAD
:  "rad"; ;

120 
	gUnTy
::
TURN
:  "turn"; ;

122 
	gUnTy
::
SEC
:  "s"; ;

123 
	gUnTy
::
MSEC
:  "ms"; ;

125 
	gUnTy
::
HERTZ
:  "Hz"; ;

126 
	gUnTy
::
KHERTZ
:  "kHz"; ;

128 
	gUnTy
::
DPI
:  "dpi"; ;

129 
	gUnTy
::
DPCM
:  "dpcm"; ;

130 
	gUnTy
::
DPPX
:  "dppx"; ;

136 
	gd
::
rg
 
un_to_ass
(cڡ 
d
::rg& 
s
)

138 i(
s
 == "px")  "LENGTH";

139 i(
	gs
 == "pt")  "LENGTH";

140 i(
	gs
 == "pc")  "LENGTH";

141 i(
	gs
 == "mm")  "LENGTH";

142 i(
	gs
 == "cm")  "LENGTH";

143 i(
	gs
 == "in")  "LENGTH";

145 i(
	gs
 == "deg")  "ANGLE";

146 i(
	gs
 == "grad")  "ANGLE";

147 i(
	gs
 == "rad")  "ANGLE";

148 i(
	gs
 == "turn")  "ANGLE";

150 i(
	gs
 == "s")  "TIME";

151 i(
	gs
 == "ms")  "TIME";

153 i(
	gs
 == "Hz")  "FREQUENCY";

154 i(
	gs
 == "kHz")  "FREQUENCY";

156 i(
	gs
 == "dpi")  "RESOLUTION";

157 i(
	gs
 == "dpcm")  "RESOLUTION";

158 i(
	gs
 == "dppx")  "RESOLUTION";

160  "CUSTOM:" + 
	gs
;

164 
cvsi_
(cڡ 
d
::
rg
& 
s1
, cڡ std::rg& 
s2
, 
bo
 
ri
)

167 i(
	gs1
 =
s2
)  1;

169 
UnTy
 
	gu1
 = 
rg_to_un
(
s1
);

170 
UnTy
 
	gu2
 = 
rg_to_un
(
s2
);

172 
UnCss
 
	gt1
 = 
g_un_ty
(
u1
);

173 
UnCss
 
	gt2
 = 
g_un_ty
(
u2
);

176 
size_t
 
	gi1
 = 
u1
 - 
t1
;

177 
size_t
 
	gi2
 = 
u2
 - 
t2
;

180 i(
	gri
 && 
	gt1
 !
t2

throw
 
comtibUns
(
u1
, 
u2
);

182 i(
	gu1
 !
UNKNOWN
 && 
u2
 != UNKNOWN) {

183 
t1
) {

184 
UnCss
::
LENGTH
:  
size_cvsi_s
[
i1
][
i2
]; ;

185 
	gUnCss
::
ANGLE
:  
g_cvsi_s
[
i1
][
i2
]; ;

186 
	gUnCss
::
TIME
:  
time_cvsi_s
[
i1
][
i2
]; ;

187 
	gUnCss
::
FREQUENCY
:  
equcy_cvsi_s
[
i1
][
i2
]; ;

188 
	gUnCss
::
RESOLUTION
:  
suti_cvsi_s
[
i1
][
i2
]; ;

190 
	gUnCss
::
INCOMMENSURABLE
:  0; ;

	@node_modules/node-sass/src/libsass/src/units.hpp

1 #ide
SASS_UNITS_H


2 
	#SASS_UNITS_H


	)

4 
	~<cmh
>

5 
	~<rg
>

6 
	~<sam
>

8 
mea
 
	gSass
 {

10 cڡ 
	gPI
 = 
d
::
acos
(-1);

12 
	eUnCss
 {

13 
	gLENGTH
 = 0x000,

14 
	gANGLE
 = 0x100,

15 
	gTIME
 = 0x200,

16 
	gFREQUENCY
 = 0x300,

17 
	gRESOLUTION
 = 0x400,

18 
	gINCOMMENSURABLE
 = 0x500

21 
	eUnTy
 {

24 
	gIN
 = 
UnCss
::
LENGTH
,

25 
	gCM
,

26 
	gPC
,

27 
	gMM
,

28 
	gPT
,

29 
	gPX
,

32 
	gDEG
 = 
ANGLE
,

33 
	gGRAD
,

34 
	gRAD
,

35 
	gTURN
,

38 
	gSEC
 = 
TIME
,

39 
	gMSEC
,

42 
	gHERTZ
 = 
FREQUENCY
,

43 
	gKHERTZ
,

46 
	gDPI
 = 
RESOLUTION
,

47 
	gDPCM
,

48 
	gDPPX
,

51 
	gUNKNOWN
 = 
INCOMMENSURABLE


55 cڡ 
size_cvsi_s
[6][6];

56 cڡ 
g_cvsi_s
[4][4];

57 cڡ 
time_cvsi_s
[2][2];

58 cڡ 
equcy_cvsi_s
[2][2];

59 cڡ 
suti_cvsi_s
[3][3];

61 
	gSass
::
UnTy
 
rg_to_un
(cڡ 
d
::
rg
&);

62 cڡ * 
un_to_rg
(
Sass
::
UnTy
 
un
);

63 
	gSass
::
UnCss
 
g_un_ty
(
Sass
::
UnTy
 
un
);

64 
	gd
::
rg
 
g_un_ass
(
Sass
::
UnTy
 
un
);

65 
	gd
::
rg
 
un_to_ass
(cڡ 
d
::string&);

67 
cvsi_
(cڡ 
d
::
rg
&, cڡ std::rg&, 
bo
 = 
ue
);

69 as
	ccomtibUns
: 
public
 
d
::
exi


71 
public
:

72 cڡ * 
msg
;

73 
comtibUns
(
Sass
::
UnTy
 
a
, Sass::UnTy 
b
)

74 : 
exi
()

76 
d
::
rgam
 
ss
;

77 
	gss
 << "Incompatible units: ";

78 
	gss
 << "'" << 
un_to_rg
(
a
) << "'nd ";

79 
	gss
 << "'" << 
un_to_rg
(
b
) << "'";

80 
	gmsg
 = 
ss
.
r
().
c_r
();

82 
vtu
 cڡ * 
wh
(cڡ 
throw
()

84  
	gmsg
;

	@node_modules/node-sass/src/libsass/src/utf8.h

28 #ide
UTF8_FOR_CPP_2675DCD0_9480_4c0c_B92A_CC14C027B731


29 
	#UTF8_FOR_CPP_2675DCD0_9480_4c0c_B92A_CC14C027B731


	)

31 
	~"utf8/checked.h
"

32 
	~"utf8/unchecked.h
"

	@node_modules/node-sass/src/libsass/src/utf8/checked.h

28 #ide
UTF8_FOR_CPP_CHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731


29 
	#UTF8_FOR_CPP_CHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731


	)

31 
	~"ce.h
"

32 
	~<dex
>

34 
mea
 
	gutf8


37 as
	cexi
 : 
public
 ::
d
::
exi
 {

41 as
	cvid_code_pot
 : 
public
 
exi
 {

42 
ut32_t
 

;

43 
	gpublic
:

44 
vid_code_pot
(
ut32_t
 

) : cp(cp) {}

45 
vtu
 cڡ * 
wh
(cڡ 
throw
() {  "Invalid codeoint"; }

46 
ut32_t
 
code_pot
(cڡ { 
	g
;}

49 as
	cvid_utf8
 : 
public
 
exi
 {

50 
ut8_t
 
u8
;

51 
	gpublic
:

52 
vid_utf8
 (
ut8_t
 
u
: 
u8
(u) {}

53 
vtu
 cڡ * 
wh
(cڡ 
throw
() {  "Invalid UTF-8"; }

54 
ut8_t
 
utf8_o
(cڡ { 
	gu8
;}

57 as
	cvid_utf16
 : 
public
 
exi
 {

58 
ut16_t
 
u16
;

59 
	gpublic
:

60 
vid_utf16
 (
ut16_t
 
u
: 
u16
(u) {}

61 
vtu
 cڡ * 
wh
(cڡ 
throw
() {  "Invalid UTF-16"; }

62 
ut16_t
 
utf16_wd
(cڡ { 
	gu16
;}

65 as
	cn_ough_room
 : 
public
 
exi
 {

66 
public
:

67 
vtu
 cڡ * 
wh
(cڡ 
throw
() {  "Notnough space"; }

72 
	gme
 <
tyme
 
	go_
>

73 
o_
 
	$nd
(
ut32_t
 

, 
o_
 
su
)

75 i(!
utf8
::

::
	`is_code_pot_vid
(

))

76 
throw
 
	`vid_code_pot
(

);

78 i(

 < 0x80)

79 *(
su
++
ic_
<
ut8_t
>(

);

80 i(

 < 0x800) {

81 *(
su
++
ic_
<
ut8_t
>((

 >> 6) | 0xc0);

82 *(
su
++
ic_
<
ut8_t
>((

 & 0x3f) | 0x80);

84 i(

 < 0x10000) {

85 *(
su
++
ic_
<
ut8_t
>((

 >> 12) | 0xe0);

86 *(
su
++
ic_
<
ut8_t
>(((

 >> 6) & 0x3f) | 0x80);

87 *(
su
++
ic_
<
ut8_t
>((

 & 0x3f) | 0x80);

90 *(
su
++
ic_
<
ut8_t
>((

 >> 18) | 0xf0);

91 *(
su
++
ic_
<
ut8_t
>(((

 >> 12) & 0x3f) | 0x80);

92 *(
su
++
ic_
<
ut8_t
>(((

 >> 6) & 0x3f) | 0x80);

93 *(
su
++
ic_
<
ut8_t
>((

 & 0x3f) | 0x80);

95  
su
;

96 
	}
}

98 
	gme
 <
tyme
 
	go_
,ym
	gouut_
>

99 
ouut_
 
	$a_vid
(
o_
 
t
, o_ 
d
, 
ouut_
 
out
, 
ut32_t
 
amt
)

101 
t
 !
d
) {

102 
o_
 
qu_t
 = 
t
;

103 

::
utf_r
 
r_code
 = 
utf8
::::
	`vide_xt
(
t
, 
d
);

104 
r_code
) {

105 

::
UTF8_OK
 :

106 
o_
 

 = 
qu_t
; i!
t
; ++it)

107 *
out
++ = *

;

109 

::
NOT_ENOUGH_ROOM
:

110 
throw
 
	`n_ough_room
();

111 

::
INVALID_LEAD
:

112 
out
 = 
utf8
::
	`nd
 (
amt
, out);

113 ++
t
;

115 

::
INCOMPLETE_SEQUENCE
:

116 

::
OVERLONG_SEQUENCE
:

117 

::
INVALID_CODE_POINT
:

118 
out
 = 
utf8
::
	`nd
 (
amt
, out);

119 ++
t
;

121 
t
 !
d
 && 
utf8
::

::
	`is_a
(*start))

122 ++
t
;

126  
out
;

127 
	}
}

129 
	gme
 <
tyme
 
	go_
,ym
	gouut_
>

130 
le
 
ouut_
 
	$a_vid
(
o_
 
t
, o_ 
d
, 
ouut_
 
out
)

132 cڡ 
ut32_t
 
amt_mk
 = 
utf8
::

::
	`mask16
(0xfffd);

133  
utf8
::
	`a_vid
(
t
, 
d
, 
out
, 
amt_mk
);

134 
	}
}

136 
	gme
 <
tyme
 
	go_
>

137 
ut32_t
 
	$xt
(
o_
& 

, o_ 
d
)

139 
ut32_t
 

 = 0;

140 

::
utf_r
 
r_code
 = 
utf8
::::
	`vide_xt
(

, 
d
, 

);

141 
r_code
) {

142 

::
UTF8_OK
 :

144 

::
NOT_ENOUGH_ROOM
 :

145 
throw
 
	`n_ough_room
();

146 

::
INVALID_LEAD
 :

147 

::
INCOMPLETE_SEQUENCE
 :

148 

::
OVERLONG_SEQUENCE
 :

149 
throw
 
	`vid_utf8
(*

);

150 

::
INVALID_CODE_POINT
 :

151 
throw
 
	`vid_code_pot
(

);

153  

;

154 
	}
}

156 
	gme
 <
tyme
 
	go_
>

157 
ut32_t
 
	$ek_xt
(
o_
 

, o_ 
d
)

159  
utf8
::
	`xt
(

, 
d
);

160 
	}
}

162 
	gme
 <
tyme
 
	go_
>

163 
ut32_t
 
	$i
(
o_
& 

, o_ 
t
)

166 i(

 =
t
)

167 
throw
 
	`n_ough_room
();

169 
o_
 
d
 = 

;

171 
utf8
::

::
	`is_a
(*(--

)))

172 i(

 =
t
)

173 
throw
 
	`vid_utf8
(*

);

174  
utf8
::
	`ek_xt
(

, 
d
);

175 
	}
}

178 
	gme
 <
tyme
 
	go_
>

179 
ut32_t
 
	$evious
(
o_
& 

, o_ 
ss_t
)

181 
o_
 
d
 = 

;

182 
utf8
::

::
	`is_a
(*(--

)))

183 i(

 =
ss_t
)

184 
throw
 
	`vid_utf8
(*

);

185 
o_
 
mp
 = 

;

186  
utf8
::
	`xt
(
mp
, 
d
);

187 
	}
}

189 
	gme
 <
tyme
 
	go_
,ym
	gdi_ty
>

190 
	$adv
 (
o_
& 

, 
di_ty
 
n
, o_ 
d
)

192 
di_ty
 
i
 = 0; i < 
n
; ++i)

193 
utf8
::
	`xt
(

, 
d
);

194 
	}
}

196 
	gme
 <
tyme
 
	go_
>

197 
tyme
 
	gd
::
_as
<
o_
>::
difn_ty


198 
	$di
 (
o_
 
f
, o_ 
ϡ
)

200 
tyme
 
d
::
_as
<
o_
>::
difn_ty
 
di
;

201 
di
 = 0; 
f
 < 
ϡ
; ++dist)

202 
utf8
::
	`xt
(
f
, 
ϡ
);

203  
di
;

204 
	}
}

206 
	gme
 <
tyme
 
	gu16b_
,ym
	go_
>

207 
o_
 
	$utf16to8
 (
u16b_
 
t
, u16b_ 
d
, 
o_
 
su
)

209 
t
 !
d
) {

210 
ut32_t
 

 = 
utf8
::

::
	`mask16
(*
t
++);

212 i(
utf8
::

::
	`is_ad_suoge
(

)) {

213 i(
t
 !
d
) {

214 
ut32_t
 
a_suoge
 = 
utf8
::

::
	`mask16
(*
t
++);

215 i(
utf8
::

::
	`is_a_suoge
(
a_suoge
))

216 

 = ( << 10+ 
a_suoge
 + 

::
SURROGATE_OFFSET
;

218 
throw
 
	`vid_utf16
(
ic_
<
ut16_t
>(
a_suoge
));

221 
throw
 
	`vid_utf16
(
ic_
<
ut16_t
>(

));

225 i(
utf8
::

::
	`is_a_suoge
(

))

226 
throw
 
	`vid_utf16
(
ic_
<
ut16_t
>(

));

228 
su
 = 
utf8
::
	`nd
(

,esult);

230  
su
;

231 
	}
}

233 
	gme
 <
tyme
 
	gu16b_
,ym
	go_
>

234 
u16b_
 
	$utf8to16
 (
o_
 
t
, o_ 
d
, 
u16b_
 
su
)

236 
t
 !
d
) {

237 
ut32_t
 

 = 
utf8
::
	`xt
(
t
, 
d
);

238 i(

 > 0xffff) {

239 *
su
++ = 
ic_
<
ut16_t
>((

 >> 10+ 

::
LEAD_OFFSET
);

240 *
su
++ = 
ic_
<
ut16_t
>((

 & 0x3ff+ 

::
TRAIL_SURROGATE_MIN
);

243 *
su
++ = 
ic_
<
ut16_t
>(

);

245  
su
;

246 
	}
}

248 
	gme
 <
tyme
 
	go_
,ym
	gu32b_
>

249 
o_
 
	$utf32to8
 (
u32b_
 
t
, u32b_ 
d
, 
o_
 
su
)

251 
t
 !
d
)

252 
su
 = 
utf8
::
	`nd
(*(
t
++),esult);

254  
su
;

255 
	}
}

257 
	gme
 <
tyme
 
	go_
,ym
	gu32b_
>

258 
u32b_
 
	$utf8to32
 (
o_
 
t
, o_ 
d
, 
u32b_
 
su
)

260 
t
 !
d
)

261 (*
su
++
utf8
::
	`xt
(
t
, 
d
);

263  
su
;

264 
	}
}

267 
	gme
 <
tyme
 
	go_
>

268 
ass
 
	g
 : 
public
 
d
::

 <d::
bideiڮ__g
, 
	gut32_t
> {

269 
o_
 
	g
;

270 
o_
 
	gnge_t
;

271 
o_
 
	gnge_d
;

272 
	gpublic
:

273 

 () {}

274 
exic
 

 (cڡ 
o_
& 
o_
,

275 cڡ 
o_
& 
nge_t
,

276 cڡ 
o_
& 
nge_d
) :

277 

(
o_
), 
nge_t
Ԫge_t), 
nge_d
(range_end)

279 i(
	g
 < 
	gnge_t
 || i> 
	gnge_d
)

280 
throw
 
	gd
::
out_of_nge
("Invalid utf-8 iteratorosition");

283 
o_
 
ba
 (cڡ {  
	g
; }

284 
ut32_t
 
	gݔ
 * () const

286 
o_
 
	gmp
 = 

;

287  
	gutf8
::
xt
(
mp
, 
nge_d
);

289 
bo
 
	gݔ
 =(cڡ 

& 
rhs
) const

291 i(
nge_t
 !
rhs
.nge_|| 
nge_d
 !=hs.range_end)

292 
throw
 
d
::
logic_r
("Comparing utf-8 iterators defined with differentanges");

293  (
	g
 =
rhs
.

);

295 
bo
 
	gݔ
 !(cڡ 

& 
rhs
) const

297  !(
ݔ
 =(
rhs
));

299 
	g
& 
	gݔ
 ++ ()

301 
	gutf8
::
xt
(

, 
nge_d
);

302  *
	gthis
;

304 

 
	gݔ
 ++ ()

306 

 
	gmp
 = *
this
;

307 
	gutf8
::
xt
(

, 
nge_d
);

308  
	gmp
;

310 
	g
& 
	gݔ
 -- ()

312 
	gutf8
::
i
(

, 
nge_t
);

313  *
	gthis
;

315 

 
	gݔ
 -- ()

317 

 
	gmp
 = *
this
;

318 
	gutf8
::
i
(

, 
nge_t
);

319  
	gmp
;

	@node_modules/node-sass/src/libsass/src/utf8/core.h

28 #ide
UTF8_FOR_CPP_CORE_H_2675DCD0_9480_4c0c_B92A_CC14C027B731


29 
	#UTF8_FOR_CPP_CORE_H_2675DCD0_9480_4c0c_B92A_CC14C027B731


	)

31 
	~<
>

33 
mea
 
	gutf8


38 
	tut8_t
;

39 
	tut16_t
;

40 
	tut32_t
;

43 
mea
 
	g


48 cڡ 
ut16_t
 
	gLEAD_SURROGATE_MIN
 = 0xd800u;

49 cڡ 
ut16_t
 
	gLEAD_SURROGATE_MAX
 = 0xdbffu;

50 cڡ 
ut16_t
 
	gTRAIL_SURROGATE_MIN
 = 0xdc00u;

51 cڡ 
ut16_t
 
	gTRAIL_SURROGATE_MAX
 = 0xdfffu;

52 cڡ 
ut16_t
 
	gLEAD_OFFSET
 = 
LEAD_SURROGATE_MIN
 - (0x10000 >> 10);

53 cڡ 
ut32_t
 
	gSURROGATE_OFFSET
 = 0x10000u - (
LEAD_SURROGATE_MIN
 << 10- 
TRAIL_SURROGATE_MIN
;

56 cڡ 
ut32_t
 
	gCODE_POINT_MAX
 = 0x0010ffffu;

58 
	gme
<
tyme
 
	go_ty
>

59 
le
 
ut8_t
 
mask8
(
o_ty
 
oc
)

61  
	gic_
<
	gut8_t
>(0xf& 
	goc
);

63 
	gme
<
tyme
 
	gu16_ty
>

64 
le
 
ut16_t
 
mask16
(
u16_ty
 
oc
)

66  
	gic_
<
	gut16_t
>(0xfff& 
	goc
);

68 
	gme
<
tyme
 
	go_ty
>

69 
le
 
bo
 
is_a
(
o_ty
 
oc
)

71  ((
	gutf8
::

::
mask8
(
oc
) >> 6) == 0x2);

74 
	gme
 <
tyme
 
	gu16
>

75 
le
 
bo
 
is_ad_suoge
(
u16
 

)

77  (
	g
 >
LEAD_SURROGATE_MIN
 && 

 <
LEAD_SURROGATE_MAX
);

80 
	gme
 <
tyme
 
	gu16
>

81 
le
 
bo
 
is_a_suoge
(
u16
 

)

83  (
	g
 >
TRAIL_SURROGATE_MIN
 && 

 <
TRAIL_SURROGATE_MAX
);

86 
	gme
 <
tyme
 
	gu16
>

87 
le
 
bo
 
is_suoge
(
u16
 

)

89  (
	g
 >
LEAD_SURROGATE_MIN
 && 

 <
TRAIL_SURROGATE_MAX
);

92 
	gme
 <
tyme
 
	gu32
>

93 
le
 
bo
 
is_code_pot_vid
(
u32
 

)

95  (
	g
 <
CODE_POINT_MAX
 && !
utf8
::

::
is_suoge
(

));

98 
	gme
 <
tyme
 
	go_
>

99 
le
 
tyme
 
	gd
::
_as
<
o_
>::
difn_ty


100 
qu_ngth
(
o_
 
ad_
)

102 
ut8_t
 
ad
 = 
utf8
::

::
mask8
(*
ad_
);

103 i(
	gad
 < 0x80)

105 i((
	gad
 >> 5) == 0x6)

107 i((
	gad
 >> 4) == 0xe)

109 i((
	gad
 >> 3) == 0x1e)

115 
	gme
 <
tyme
 
	go_difn_ty
>

116 
le
 
bo
 
is_ovlg_qu
(
ut32_t
 

, 
o_difn_ty
 
ngth
)

118 i(
	g
 < 0x80) {

119 i(
	gngth
 != 1)

120  
ue
;

122 i(
	g
 < 0x800) {

123 i(
	gngth
 != 2)

124  
ue
;

126 i(
	g
 < 0x10000) {

127 i(
	gngth
 != 3)

128  
ue
;

131  
	gl
;

134 
	eutf_r
 {
	gUTF8_OK
, 
	gNOT_ENOUGH_ROOM
, 
	gINVALID_LEAD
, 
	gINCOMPLETE_SEQUENCE
, 
	gOVERLONG_SEQUENCE
, 
	gINVALID_CODE_POINT
};

137 
	gme
 <
tyme
 
	go_
>

138 
utf_r
 
_ly
(
o_
& 

, o_ 
d
)

140 i(++
	g
 =
d
)

141  
NOT_ENOUGH_ROOM
;

143 i(!
	gutf8
::

::
is_a
(*

))

144  
INCOMPLETE_SEQUENCE
;

146  
	gUTF8_OK
;

149 
	#UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR
(
IT
, 
END
{
utf_r
 
t
 = 
	`_ly
(IT, END); iԑ !
UTF8_OK
;}

	)

152 
	gme
 <
tyme
 
	go_
>

153 
utf_r
 
g_qu_1
(
o_
& 

, o_ 
d
, 
ut32_t
& 
code_pot
)

155 i(
	g
 =
d
)

156  
NOT_ENOUGH_ROOM
;

158 
	gcode_pot
 = 
utf8
::

::
mask8
(*

);

160  
	gUTF8_OK
;

163 
	gme
 <
tyme
 
	go_
>

164 
utf_r
 
g_qu_2
(
o_
& 

, o_ 
d
, 
ut32_t
& 
code_pot
)

166 i(
	g
 =
d
)

167  
NOT_ENOUGH_ROOM
;

169 
	gcode_pot
 = 
utf8
::

::
mask8
(*

);

171 
UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR
(

, 
d
)

173 
	gcode_pot
 = ((
code_pot
 << 6& 0x7ff+ ((*

) & 0x3f);

175  
	gUTF8_OK
;

178 
	gme
 <
tyme
 
	go_
>

179 
utf_r
 
g_qu_3
(
o_
& 

, o_ 
d
, 
ut32_t
& 
code_pot
)

181 i(
	g
 =
d
)

182  
NOT_ENOUGH_ROOM
;

184 
	gcode_pot
 = 
utf8
::

::
mask8
(*

);

186 
UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR
(

, 
d
)

188 
	gcode_pot
 = ((
code_pot
 << 12& 0xffff+ ((
utf8
::

::
mask8
(*

) << 6) & 0xfff);

190 
UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR
(

, 
d
)

192 
	gcode_pot
 +(*

) & 0x3f;

194  
	gUTF8_OK
;

197 
	gme
 <
tyme
 
	go_
>

198 
utf_r
 
g_qu_4
(
o_
& 

, o_ 
d
, 
ut32_t
& 
code_pot
)

200 i(
	g
 =
d
)

201  
NOT_ENOUGH_ROOM
;

203 
	gcode_pot
 = 
utf8
::

::
mask8
(*

);

205 
UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR
(

, 
d
)

207 
	gcode_pot
 = ((
code_pot
 << 18& 0x1fffff+ ((
utf8
::

::
mask8
(*

) << 12) & 0x3ffff);

209 
UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR
(

, 
d
)

211 
	gcode_pot
 +(
utf8
::

::
mask8
(*

) << 6) & 0xfff;

213 
UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR
(

, 
d
)

215 
	gcode_pot
 +(*

) & 0x3f;

217  
	gUTF8_OK
;

220 #unde
UTF8_CPP_INCREASE_AND_RETURN_ON_ERROR


222 
	gme
 <
tyme
 
	go_
>

223 
utf_r
 
vide_xt
(
o_
& 

, o_ 
d
, 
ut32_t
& 
code_pot
)

227 
o_
 
	gig_
 = 

;

229 
ut32_t
 
	g
 = 0;

231 
tyme
 
	td
::
	t_as
<
	to_
>::
	tdifn_ty
 
	to_difn_ty
;

232 cڡ 
o_difn_ty
 
	gngth
 = 
utf8
::

::
qu_ngth
(

);

235 
utf_r
 
	gr
 = 
UTF8_OK
;

236 
	gngth
) {

238  
INVALID_LEAD
;

240 
r
 = 
utf8
::

::
g_qu_1
(

, 
d
, 

);

243 
r
 = 
utf8
::

::
g_qu_2
(

, 
d
, 

);

246 
r
 = 
utf8
::

::
g_qu_3
(

, 
d
, 

);

249 
r
 = 
utf8
::

::
g_qu_4
(

, 
d
, 

);

253 i(
	gr
 =
UTF8_OK
) {

255 i(
utf8
::

::
is_code_pot_vid
(

)) {

256 i(!
utf8
::

::
is_ovlg_qu
(

, 
ngth
)){

258 
code_pot
 = 

;

259 ++
	g
;

260  
	gUTF8_OK
;

263 
	gr
 = 
OVERLONG_SEQUENCE
;

266 
	gr
 = 
INVALID_CODE_POINT
;

270 
	g
 = 
ig_
;

271  
	gr
;

274 
	gme
 <
tyme
 
	go_
>

275 
le
 
utf_r
 
vide_xt
(
o_
& 

, o_ 
d
) {

276 
ut32_t
 
	gigned
;

277  
	gutf8
::

::
vide_xt
(

, 
d
, 
igned
);

285 cڡ 
ut8_t
 
	gbom
[] = {0xef, 0xbb, 0xbf};

287 
	gme
 <
tyme
 
	go_
>

288 
o_
 
fd_vid
(o_ 
t
, o_ 
d
)

290 
o_
 
	gsu
 = 
t
;

291 
	gsu
 !
d
) {

292 
utf8
::

::
utf_r
 
r_code
 = utf8::::
vide_xt
(
su
, 
d
);

293 i(
	gr_code
 !

::
UTF8_OK
)

294  
su
;

296  
	gsu
;

299 
	gme
 <
tyme
 
	go_
>

300 
le
 
bo
 
is_vid
(
o_
 
t
, o_ 
d
)

302  (
	gutf8
::
fd_vid
(
t
, 
d
) ==nd);

305 
	gme
 <
tyme
 
	go_
>

306 
le
 
bo
 
ts_wh_bom
 (
o_
 

, o_ 
d
)

309 ((
	g
 !
d
&& (
utf8
::

::
mask8
(*

++)=
bom
[0]) &&

310 ((

 !
d
&& (
utf8
::

::
mask8
(*++)=
bom
[1]) &&

311 ((

 !
d
&& (
utf8
::

::
mask8
(*)=
bom
[2])

316 
	gme
 <
tyme
 
	go_
>

317 
le
 
bo
 
is_bom
 (
o_
 

)

320 (
	gutf8
::

::
mask8
(*

++)=
bom
[0] &&

321 (
utf8
::

::
mask8
(*

++)=
bom
[1] &&

322 (
utf8
::

::
mask8
(*

)=
bom
[2]

	@node_modules/node-sass/src/libsass/src/utf8/unchecked.h

28 #ide
UTF8_FOR_CPP_UNCHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731


29 
	#UTF8_FOR_CPP_UNCHECKED_H_2675DCD0_9480_4c0c_B92A_CC14C027B731


	)

31 
	~"ce.h
"

33 
mea
 
	gutf8


35 
mea
 
	gunchecked


37 
	gme
 <
tyme
 
	go_
>

38 
o_
 
nd
(
ut32_t
 

, o_ 
su
)

40 i(
	g
 < 0x80)

41 *(
	gsu
++
ic_
<
ut8_t
>(

);

42 i(
	g
 < 0x800) {

43 *(
	gsu
++
ic_
<
ut8_t
>((

 >> 6) | 0xc0);

44 *(
	gsu
++
ic_
<
ut8_t
>((

 & 0x3f) | 0x80);

46 i(
	g
 < 0x10000) {

47 *(
	gsu
++
ic_
<
ut8_t
>((

 >> 12) | 0xe0);

48 *(
	gsu
++
ic_
<
ut8_t
>(((

 >> 6) & 0x3f) | 0x80);

49 *(
	gsu
++
ic_
<
ut8_t
>((

 & 0x3f) | 0x80);

52 *(
	gsu
++
ic_
<
ut8_t
>((

 >> 18) | 0xf0);

53 *(
	gsu
++
ic_
<
ut8_t
>(((

 >> 12) & 0x3f)| 0x80);

54 *(
	gsu
++
ic_
<
ut8_t
>(((

 >> 6) & 0x3f) | 0x80);

55 *(
	gsu
++
ic_
<
ut8_t
>((

 & 0x3f) | 0x80);

57  
	gsu
;

60 
	gme
 <
tyme
 
	go_
>

61 
ut32_t
 
xt
(
o_
& 

)

63 
ut32_t
 
	g
 = 
utf8
::

::
mask8
(*

);

64 
tyme
 
	gd
::
_as
<
o_
>::
difn_ty
 
ngth
 = 
utf8
::

::
qu_ngth
(

);

65 
	gngth
) {

69 

++;

70 
	g
 = ((

 << 6& 0x7ff+ ((*

) & 0x3f);

73 ++

;

74 
	g
 = ((

 << 12& 0xffff+ ((
utf8
::

::
mask8
(*

) << 6) & 0xfff);

75 ++
	g
;

76 
	g
 +(*

) & 0x3f;

79 ++

;

80 
	g
 = ((

 << 18& 0x1fffff+ ((
utf8
::

::
mask8
(*

) << 12) & 0x3ffff);

81 ++
	g
;

82 
	g
 +(
utf8
::

::
mask8
(*

) << 6) & 0xfff;

83 ++
	g
;

84 
	g
 +(*

) & 0x3f;

87 ++
	g
;

88  
	g
;

91 
	gme
 <
tyme
 
	go_
>

92 
ut32_t
 
ek_xt
(
o_
 

)

94  
	gutf8
::
unchecked
::
xt
(

);

97 
	gme
 <
tyme
 
	go_
>

98 
ut32_t
 
i
(
o_
& 

)

100 
	gutf8
::

::
is_a
(*(--

))) ;

101 
o_
 
	gmp
 = 

;

102  
	gutf8
::
unchecked
::
xt
(
mp
);

106 
	gme
 <
tyme
 
	go_
>

107 
le
 
ut32_t
 
evious
(
o_
& 

)

109  
	gutf8
::
unchecked
::
i
(

);

112 
	gme
 <
tyme
 
	go_
,ym
	gdi_ty
>

113 
adv
 (
o_
& 

, 
di_ty
 
n
)

115 
di_ty
 
	gi
 = 0; i < 
	gn
; ++i)

116 
	gutf8
::
unchecked
::
xt
(

);

119 
	gme
 <
tyme
 
	go_
>

120 
tyme
 
	gd
::
_as
<
o_
>::
difn_ty


121 
di
 (
o_
 
f
, o_ 
ϡ
)

123 
tyme
 
	gd
::
_as
<
o_
>::
difn_ty
 
di
;

124 
	gdi
 = 0; 
	gf
 < 
	gϡ
; ++dist)

125 
	gutf8
::
unchecked
::
xt
(
f
);

126  
	gdi
;

129 
	gme
 <
tyme
 
	gu16b_
,ym
	go_
>

130 
o_
 
utf16to8
 (
u16b_
 
t
, u16b_ 
d
, o_ 
su
)

132 
	gt
 !
d
) {

133 
ut32_t
 

 = 
utf8
::

::
mask16
(*
t
++);

135 i(
	gutf8
::

::
is_ad_suoge
(

)) {

136 
ut32_t
 
a_suoge
 = 
utf8
::

::
mask16
(*
t
++);

137 
	g
 = (

 << 10+ 
a_suoge
 + 

::
SURROGATE_OFFSET
;

139 
	gsu
 = 
utf8
::
unchecked
::
nd
(

, 
su
);

141  
	gsu
;

144 
	gme
 <
tyme
 
	gu16b_
,ym
	go_
>

145 
u16b_
 
utf8to16
 (
o_
 
t
, o_ 
d
, u16b_ 
su
)

147 
	gt
 < 
	gd
) {

148 
ut32_t
 
	g
 = 
utf8
::
unchecked
::
xt
(
t
);

149 i(
	g
 > 0xffff) {

150 *
	gsu
++ = 
ic_
<
ut16_t
>((

 >> 10+ 

::
LEAD_OFFSET
);

151 *
	gsu
++ = 
ic_
<
ut16_t
>((

 & 0x3ff+ 

::
TRAIL_SURROGATE_MIN
);

154 *
	gsu
++ = 
ic_
<
ut16_t
>(

);

156  
	gsu
;

159 
	gme
 <
tyme
 
	go_
,ym
	gu32b_
>

160 
o_
 
utf32to8
 (
u32b_
 
t
, u32b_ 
d
, o_ 
su
)

162 
	gt
 !
d
)

163 
su
 = 
utf8
::
unchecked
::
nd
(*(
t
++),esult);

165  
	gsu
;

168 
	gme
 <
tyme
 
	go_
,ym
	gu32b_
>

169 
u32b_
 
utf8to32
 (
o_
 
t
, o_ 
d
, u32b_ 
su
)

171 
	gt
 < 
	gd
)

172 (*
	gsu
++
utf8
::
unchecked
::
xt
(
t
);

174  
	gsu
;

178 
	gme
 <
tyme
 
	go_
>

179 
ass
 
	g
 : 
public
 
d
::

 <d::
bideiڮ__g
, 
	gut32_t
> {

180 
o_
 
	g
;

181 
	gpublic
:

182 

 () {}

183 
exic
 

 (cڡ 
o_
& 
o_
): 

(octet_it) {}

185 
o_
 
ba
 (cڡ {  

; }

186 
ut32_t
 
	gݔ
 * () const

188 
o_
 
	gmp
 = 

;

189  
	gutf8
::
unchecked
::
xt
(
mp
);

191 
bo
 
	gݔ
 =(cڡ 

& 
rhs
) const

193  (

 =
rhs
.it);

195 
bo
 
	gݔ
 !(cڡ 

& 
rhs
) const

197  !(
ݔ
 =(
rhs
));

199 
	g
& 
	gݔ
 ++ ()

201 ::
d
::
adv
(

, 
utf8
::

::
qu_ngth
(it));

202  *
	gthis
;

204 

 
	gݔ
 ++ ()

206 

 
	gmp
 = *
this
;

207 ::
d
::
adv
(

, 
utf8
::

::
qu_ngth
(it));

208  
	gmp
;

210 
	g
& 
	gݔ
 -- ()

212 
	gutf8
::
unchecked
::
i
(

);

213  *
	gthis
;

215 

 
	gݔ
 -- ()

217 

 
	gmp
 = *
this
;

218 
	gutf8
::
unchecked
::
i
(

);

219  
	gmp
;

	@node_modules/node-sass/src/libsass/src/utf8_string.cpp

1 
	~"ss.h
"

2 
	~<rg
>

3 
	~<ve
>

4 
	~<cdlib
>

5 
	~<cmh
>

7 
	~"utf8.h
"

9 
mea
 
	gSass
 {

10 
mea
 
	gUTF_8
 {

11 
usg
 
	gd
::
rg
;

19 
size_t
 
code_pot_cou
(cڡ 
rg
& 
r
, size_
t
, size_
d
) {

20  
	gutf8
::
di
(
r
.
beg
(+ 
t
, s.beg(+ 
d
);

23 
size_t
 
code_pot_cou
(cڡ 
rg
& 
r
) {

24  
	gutf8
::
di
(
r
.
beg
(), s.
d
());

28 
size_t
 
offt__posi
(cڡ 
rg
& 
r
, size_
posi
) {

29 
	grg
::
cڡ_
 

 = 
r
.
beg
();

30 
	gutf8
::
adv
(

, 
posi
, 
r
.
d
());

31  
di
(
r
.
beg
(), 

);

35 
size_t
 
code_pot_size__offt
(cڡ 
rg
& 
r
, size_
offt
) {

37 
	grg
::
cڡ_
 

 = 
r
.
beg
(+ 
offt
;

39 i(
	g
 =
r
.
d
())  0;

41 
	gutf8
::
adv
(

, 1, 
r
.
d
());

43  
	g
 - 
	gr
.
beg
(- 
	gofft
;

47 
size_t
 
nmize_dex
(
dex
, size_
n
) {

48 
	gsigd_n
 = 
ic_
<>(
n
);

51 i(
	gdex
 > 0 && index <
sigd_n
) {

53  
dex
-1;

55 i(
	gdex
 > 
	gsigd_n
) {

57  
	gn
;

59 i(
	gdex
 == 0) {

62 i(
	gd
::
abs
(()
dex
<
sigd_n
) {

64  
dex
 + 
sigd_n
;

72 #ifde
_WIN32


75 
usg
 
	gd
::
wrg
;

78 
rg
 
cvt_om_utf16
(cڡ 
wrg
& 
utf16
)

80 
rg
 
	gutf8
;

82 
	gutf8
.
rve
((
utf16
)/2);

83 
	gutf8
::
utf16to8
(
utf16
.
beg
(), utf16.
d
(),

84 
back_
(
utf8
));

85  
	gutf8
;

89 
wrg
 
cvt_to_utf16
(cڡ 
rg
& 
utf8
)

91 
wrg
 
	gutf16
;

93 
	gutf16
.
rve
(
code_pot_cou
(
utf8
)*2);

94 
	gutf8
::
utf8to16
(
utf8
.
beg
(), utf8.
d
(),

95 
back_
(
utf16
));

96  
	gutf16
;

	@node_modules/node-sass/src/libsass/src/utf8_string.hpp

1 #ide
SASS_UTF8_STRING_H


2 
	#SASS_UTF8_STRING_H


	)

4 
	~<rg
>

5 
	~"utf8.h
"

7 
mea
 
	gSass
 {

8 
mea
 
	gUTF_8
 {

16 
size_t
 
code_pot_cou
(cڡ 
d
::
rg
& 
r
, size_
t
, size_
d
);

17 
size_t
 
code_pot_cou
(cڡ 
d
::
rg
& 
r
);

20 
size_t
 
offt__posi
(cڡ 
d
::
rg
& 
r
, size_
posi
);

23 
size_t
 
code_pot_size__offt
(cڡ 
d
::
rg
& 
r
, size_
offt
);

26 
size_t
 
nmize_dex
(
dex
, size_
n
);

28 #ifde
_WIN32


30 
	gd
::
rg
 
cvt_om_utf16
(cڡ 
d
::
wrg
& 
wr
);

31 
	gd
::
wrg
 
cvt_to_utf16
(cڡ 
d
::
rg
& 
r
);

	@node_modules/node-sass/src/libsass/src/util.cpp

1 
	~"ss.h
"

2 
	~"ss.h
"

3 
	~"a.h
"

4 
	~"ut.h
"

5 
	~"x.h
"

6 
	~"ex.h
"

7 
	~"cڡts.h
"

8 
	~"utf8/checked.h
"

10 
	~<cmh
>

11 
	~<dt.h
>

13 
mea
 
	gSass
 {

15 
round
(
v
, 
size_t
 
ecisi
)

18 i(
fmod
(
v
, 1- 0.5 > - 
	gd
::
pow
(0.1, 
ecisi
 + 1) std::

(val);

19 i(
fmod
(
v
, 1- 0.5 > 
	gd
::
pow
(0.1, 
ecisi
) std::
o
(val);

22 
usg
 
mea
 
	gd
;

23  ::
round
(
v
);

27 
ss_of
(cڡ *
r
)

29 
	gt
 = *(
locv
()->
decim_pot
);

30 if(
	gt
 != '.'){

34 cڡ *
found
 = 
rchr
(
r
, '.');

35 if(
	gfound
 !
NULL
){

38 *
cy
 = 
ss_cy_c_rg
(
r
);

39 *(
	gcy
 + (
	gfound
 - 
	gr
)
t
;

40 
	gs
 = 
of
(
cy
);

41 

(
cy
);

42  
	gs
;

46  
of
(
r
);

50 cڡ * 
_r
 (cڡ * 
r
, cڡ * 
t
) {

51  
	gr
 =
NULL
 ? 
t
 : 
r
;

54 
_rg_y
(** 
r
) {

55 if(!
	gr
)

58 **
	g
 = 
r
;

59 
	g
 && (*it)) {

60 

(*

);

61 ++
	g
;

64 

(
r
);

67 **
cy_rgs
(cڡ 
d
::
ve
<d::
rg
>& 
rgs
, *** 
y
, 
sk
) {

68 
	gnum
 = 
ic_
<>(
rgs
.
size
()- 
sk
;

69 ** 
	gr
 = (**
oc
(
num
 + 1, (*));

70 i(
	gr
 == 0)

71  *
y
 = (**)
NULL
;

73 
	gi
 = 0; i < 
	gnum
; i++) {

74 
	gr
[
i
] = (*
mloc
((* (
rgs
[+ 
sk
].
size
() + 1));

75 i(
	gr
[
i
] == 0) {

76 
_rg_y
(
r
);

77  *
	gy
 = (**)
NULL
;

79 
	gd
::
cy
(
rgs
[
i
 + 
sk
].
beg
(), sgs[+ sk].
d
(), 
r
[i]);

80 
	gr
[
i
][
rgs
[+ 
sk
].
size
()] = '\0';

83 
	gr
[
num
] = 0;

84  *
	gy
 = 
r
;

88 
	gd
::
rg
 
ad_css_rg
(cڡ 
d
::rg& 
r
)

90 
d
::
rg
 
out
("");

91 
bo
 
	gesc
 = 
l
;

92 aut
	gi
 : 
r
) {

93 i(
i
 == '\\') {

94 
esc
 = !sc;

95 } i(
	gesc
 && 
	gi
 == '\r') {

97 } i(
	gesc
 && 
	gi
 == '\n') {

98 
out
.
size
 (out.
size
 () - 1);

99 
	gesc
 = 
l
;

102 
	gesc
 = 
l
;

104 
	gout
.
push_back
(
i
);

110  
	gout
;

115 
	gd
::
rg
 
evacue_ess
(cڡ 
d
::rg& 
r
)

117 
d
::
rg
 
out
("");

118 
bo
 
	gesc
 = 
l
;

119 aut
	gi
 : 
r
) {

120 i(
i
 ='\\' && !
esc
) {

121 
out
 += '\\';

122 
	gout
 += '\\';

123 
	gesc
 = 
ue
;

124 } i(
	gesc
 && 
	gi
 == '"') {

125 
out
 += '\\';

126 
	gout
 +
i
;

127 
	gesc
 = 
l
;

128 } i(
	gesc
 && 
	gi
 == '\'') {

129 
out
 += '\\';

130 
	gout
 +
i
;

131 
	gesc
 = 
l
;

132 } i(
	gesc
 && 
	gi
 == '\\') {

133 
out
 += '\\';

134 
	gout
 +
i
;

135 
	gesc
 = 
l
;

137 
	gesc
 = 
l
;

138 
	gout
 +
i
;

145  
	gout
;

149 
	gd
::
rg
 
rg_to_ouut
(cڡ 
d
::rg& 
r
)

151 
d
::
rg
 
out
("");

152 
bo
 
	glf
 = 
l
;

153 aut
	gi
 : 
r
) {

154 i(
i
 == 10) {

155 
out
 += ' ';

156 
	glf
 = 
ue
;

157 } i(!(
	glf
 && 
isa
(
i
))) {

158 
	gout
 +
i
;

159 
	glf
 = 
l
;

162  
	gout
;

165 
	gd
::
rg
 
commt_to_rg
(cڡ 
d
::rg& 
xt
)

167 
d
::
rg
 
r
 = "";

168 
size_t
 
	ghas
 = 0;

169 
	gev
 = 0;

170 
bo
 
	gn
 = 
l
;

171 aut
	gi
 : 
xt
) {

172 i(
n
) {

173 i(
i
 ='\n'{ 
has
 = 0; }

174 i(
	gi
 ='\r'{ 
has
 = 0; }

175 i(
	gi
 ='\t'{ ++ 
has
; }

176 i(
	gi
 =' '{ ++ 
has
; }

177 i(
	gi
 == '*') {}

179 
n
 = 
l
;

180 
	gr
 += ' ';

181 i(
	gev
 ='*' && 
i
 ='/'
r
 += "*/";

182 
	gr
 +
i
;

184 } i(
	gi
 == '\n') {

185 
n
 = 
ue
;

186 } i(
	gi
 == '\r') {

187 
n
 = 
ue
;

189 
	gr
 +
i
;

191 
	gev
 = 
i
;

193 i(
	ghas
 
	gr
;

194  
	gxt
;

201 
de_be_quemk
(cڡ * 
s
, 
qm
)

204 
	gque_mk
 = 
qm
 && qm != '*' ? qm : '"';

205 *
	gs
) {

208 i(*
	gs
 == '\'') {  '"'; }

211 i(*
	gs
 ='"'{ 
que_mk
 = '\''; }

212 ++ 
	gs
;

214  
	gque_mk
;

217 
	gd
::
rg
 
unque
(cڡ 
d
::rg& 
s
, * 
qd
, 
bo
 
kp_utf8_qus
)

222 i(
	gs
.
ngth
() < 2)  s;

224 
	gq
;

225 
bo
 
	gskd
 = 
l
;

229 i(*
	gs
.
beg
(='"' && *
s
.
rbeg
(='"'
q
 = '"';

230 i(*
	gs
.
beg
(='\'' && *
s
.
rbeg
(='\''
q
 = '\'';

231  
	gs
;

233 
	gd
::
rg
 
unq
;

234 
	gunq
.
rve
(
s
.
ngth
()-2);

236 
size_t
 
	gi
 = 1, 
	gL
 = 
s
.
ngth
() - 1; i < L; ++i) {

240 i(
	gs
[
i
] ='\\' && !
skd
) {

242 
skd
 = 
ue
;

250 
size_t
 
	gn
 = 1;

254 
	gi
 + 
	gn
 < 
	gL
 && 
	gs
[
i
 + 
n
] && 
isxdig
(
s
[i +en])) ++en;

257 i(
	gkp_utf8_qus
) {

258 
	gunq
.
push_back
(
s
[
i
]);

259 } i(
	gn
 > 1) {

263 
ut32_t
 
	g
 = 

(
s
.
subr
 (
i
 + 1, 
n
 - 1).
c_r
(), 
NULL
, 16);

265 i(
	gs
[
i
 + 
n
] == ' ') ++en;

268 i(
	g
 =0

 = 0xFFFD;

276 
	gu
[5] = {0,0,0,0,0}; 
	gutf8
::
nd
(

, 
u
);

277 
size_t
 
	gm
 = 0; 
	gu
[
m
] && m < 5; m++
	gunq
.
push_back
(
u
[m]);

280 
	gi
 +
n
 - 1; 
	gskd
 = 
l
;

295 
	gskd
 = 
l
;

296 
	gunq
.
push_back
(
s
[
i
]);

300 i(
	gskd
{  
	gs
; }

301 i(
	gqd
*qd = 
q
;

302  
	gunq
;

306 
	gd
::
rg
 
que
(cڡ 
d
::rg& 
s
, 
q
)

310 
	gq
 = 
de_be_quemk
(
s
.
c_r
(), 
q
);

313 i(
	gs
.
emy
() 
	gd
::
rg
(2, 
q
 ? q : '"');

315 
	gd
::
rg
 
qued
;

316 
	gqued
.
rve
(
s
.
ngth
()+2);

317 
	gqued
.
push_back
(
q
);

319 cڡ * 
	g
 = 
s
.
c_r
();

320 cڡ * 
	gd
 = 

 + 

(it) + 1;

321 *
	g
 && i< 
	gd
) {

322 cڡ * 
	gnow
 = 

;

324 i(*
	g
 =
q
) {

325 
qued
.
push_back
('\\');

326 } i(*
	g
 == '\\') {

327 
qued
.
push_back
('\\');

330 
	g
 = 
utf8
::
xt
(

, 
d
);

334 i(
	g
 ='\r' && 

 < 
d
 && 
utf8
::
ek_xt
(it,nd) == '\n') {

335 

 = 
utf8
::
xt
(

, 
d
);

338 i(
	g
 == '\n') {

339 
qued
.
push_back
('\\');

340 
	gqued
.
push_back
('a');

344 
usg
 
mea
 
	gPx
;

345 i(
	gives
 <

346 
	gPx
::
ch_nge
<'a', 'f'>,

347 
	gPx
::
ch_nge
<'A', 'F'>,

348 
	gPx
::
ch_nge
<'0', '9'>,

349 
	ga


350 >(
	g
!
NULL
) {

351 
qued
.
push_back
(' ');

353 } i(
	g
 < 127) {

354 
	gqued
.
push_back
((

);

356 
	gnow
 < 
	g
) {

357 
	gqued
.
push_back
(*
now
);

358 ++ 
	gnow
;

363 
	gqued
.
push_back
(
q
);

364  
	gqued
;

367 
bo
 
is_hex_doubt
(
n
)

369  
	gn
 =0x00 || 
n
 == 0x11 || == 0x22 || == 0x33 ||

370 
n
 == 0x44 || == 0x55 || == 0x66 || == 0x77 ||

371 
n
 == 0x88 || == 0x99 || == 0xAA || == 0xBB ||

372 
n
 == 0xCC || == 0xDD || == 0xEE || == 0xFF ;

375 
bo
 
is_c_doubt
(
r
, 
g
, 
b
)

377  
is_hex_doubt
(
r
&& is_hex_doubt(
g
&& is_hex_doubt(
b
);

380 
bo
 
ek_leed
(cڡ * 
t
)

382 
usg
 
mea
 
	gPx
;

383 
usg
 
mea
 
	gCڡts
;

384  
	gqu
 <

385 
	gzo_us
 <

386 
	gives
 <

387 
	gexaly
 <' '>,

388 
	gexaly
 <'\t'>,

389 
	gle_commt
,

390 
	gblock_commt
,

391 
	gdimed_by
 <

392 
	gash_
,

393 
	g_ash
,

394 
	gl


398 
	g_lebak


399 >(
	gt
) != 0;

402 
mea
 
	gUt
 {

403 
usg
 
	gd
::
rg
;

405 
	gd
::
rg
 
rim
(cڡ 
d
::rg &
r
) {

406 
d
::
rg
 
immed
 = 
r
;

407 
size_t
 
	gpos_ws
 = 
immed
.
fd_ϡ_n_of
(" \t\n\v\f\r");

408 i(
	gpos_ws
 !
d
::
rg
::
os
)

409 { 
immed
.
a
(
pos_ws
 + 1); }

410 { 
	gimmed
.
r
(); }

411  
	gimmed
;

414 
	gd
::
rg
 
nmize_undsces
(cڡ 
d
::rg& 
r
) {

415 
d
::
rg
 
nmized
 = 
r
;

416 
size_t
 
	gi
 = 0, 
	gL
 = 
nmized
.
ngth
(); i < L; ++i) {

417 if(
	gnmized
[
i
] == '_') {

418 
nmized
[
i
] = '-';

421  
	gnmized
;

424 
	gd
::
rg
 
nmize_decims
(cڡ 
d
::rg& 
r
) {

425 
d
::
rg
 
efix
 = "0";

426 
	gd
::
rg
 
nmized
 = 
r
;

428  
	gnmized
[0] ='.' ? 
nmized
.

(0, 
efix
) :ormalized;

433 
	gd
::
rg
 
nmize_sixtu
(cڡ 
d
::rg& 
c
) {

435 
c
.
subr
(1, 1) == col.substr(2, 1) &&

436 
	gc
.
subr
(3, 1=
c
.substr(4, 1) &&

437 
	gc
.
subr
(5, 1=
c
.substr(6, 1)

439  
	gd
::
rg
("#" + 
c
.
subr
(1, 1)

440 + 
c
.
subr
(3, 1)

441 + 
c
.
subr
(5, 1));

443  
	gd
::
rg
(
c
);

447 
bo
 
isPrb
(
Ruˣt
* 
r
, 
Sass_Ouut_Sty
 
y
) {

448 i(
	gr
 =
NULL
) {

449  
l
;

452 
Block
* 
	gb
 = 
r
->
block
();

454 
bo
 
	ghasSes
 = 
ic_
<
Se_Li
*>(
r
->

())->
ngth
() > 0;

456 i(!
	ghasSes
) {

457  
	gl
;

460 
bo
 
	ghasDeis
 = 
l
;

461 
bo
 
	ghasPrbChdBlocks
 = 
l
;

462 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

463 
Smt
* 
	gm
 = (*
b
)[
i
];

464 i(
	gdymic_
<
	gDeive
*>(
	gm
)) {

465  
	gue
;

466 } i(
	gdymic_
<
	gHas_Block
*>(
	gm
)) {

467 
Block
* 
	gpChdBlock
 = ((
Has_Block
*)
m
)->
block
();

468 i(
isPrb
(
pChdBlock
, 
y
)) {

469 
	ghasPrbChdBlocks
 = 
ue
;

471 } i(
Commt
* 
	gc
 = 
dymic_
<Commt*>(
m
)) {

473 i(
y
 !
COMPRESSED
) {

474 
hasDeis
 = 
ue
;

477 i(
	gc
->
is_imp܏
()) {

478 
	ghasDeis
 = 
c
->
is_imp܏
();

480 } i(
Dei
* 
	gd
 = 
dymic_
<Dei*>(
m
)) {

481  
isPrb
(
d
, 
y
);

483 
	ghasDeis
 = 
ue
;

486 i(
	ghasDeis
 || 
	ghasPrbChdBlocks
) {

487  
	gue
;

491  
	gl
;

494 
bo
 
isPrb
(
Sg_Cڡt
* 
s
, 
Sass_Ouut_Sty
 
y
)

496  ! 
	gs
->
vue
().
emy
();

499 
bo
 
isPrb
(
Sg_Qued
* 
s
, 
Sass_Ouut_Sty
 
y
)

501  
	gue
;

504 
bo
 
isPrb
(
Dei
* 
d
, 
Sass_Ouut_Sty
 
y
)

506 
Exessi
* 
	gv
 = 
d
->
vue
();

507 i(
Sg_Qued
* 
	gsq
 = 
dymic_
<Sg_Qued*>(
v
) 
isPrb
(
sq
, 
y
);

508 i(
Sg_Cڡt
* 
	gsc
 = 
dymic_
<Sg_Cڡt*>(
v
) 
isPrb
(
sc
, 
y
);

509  
	gue
;

512 
bo
 
isPrb
(
Suts_Block
* 
f
, 
Sass_Ouut_Sty
 
y
) {

513 i(
	gf
 =
NULL
) {

514  
l
;

517 
Block
* 
	gb
 = 
f
->
block
();

521 
bo
 
	ghasDeis
 = 
l
;

522 
bo
 
	ghasPrbChdBlocks
 = 
l
;

523 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

524 
Smt
* 
	gm
 = (*
b
)[
i
];

525 i(!
	gm
->
is_hoiab
()) {

531 i(
tyid
(*
m
=tyid(
Dei
||yid(*m=tyid(
Deive
)) {

532 
hasDeis
 = 
ue
;

534 i(
	gdymic_
<
	gHas_Block
*>(
	gm
)) {

535 
Block
* 
	gpChdBlock
 = ((
Has_Block
*)
m
)->
block
();

536 i(
isPrb
(
pChdBlock
, 
y
)) {

537 
	ghasPrbChdBlocks
 = 
ue
;

541 i(
	ghasDeis
 || 
	ghasPrbChdBlocks
) {

542  
	gue
;

546  
	gl
;

549 
bo
 
isPrb
(
Med_Block
* 
m
, 
Sass_Ouut_Sty
 
y
)

551 i(
	gm
 =0 
l
;

552 
Block
* 
	gb
 = 
m
->
block
();

553 i(
	gb
 =0 
l
;

554 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

555 
Smt
* 
	gm
 = (*
b
)[
i
];

556 i(
tyid
(*
m
=tyid(
Deive
) 
ue
;

557 i(
tyid
(*
m
=tyid(
Dei
) 
ue
;

558 i(
tyid
(*
m
=tyid(
Commt
)) {

559 
Commt
* 
c
 = (Commt*
m
;

560 i(
isPrb
(
c
, 
y
)) {

561  
	gue
;

564 i(
tyid
(*
m
=tyid(
Ruˣt
)) {

565 
Ruˣt
* 
r
 = (Ruˣt*
m
;

566 i(
isPrb
(
r
, 
y
)) {

567  
	gue
;

570 i(
tyid
(*
m
=tyid(
Suts_Block
)) {

571 
Suts_Block
* 
f
 = (Suts_Block*
m
;

572 i(
isPrb
(
f
, 
y
)) {

573  
	gue
;

576 i(
tyid
(*
m
=tyid(
Med_Block
)) {

577 
Med_Block
* 
m
 = (Med_Block*
m
;

578 i(
isPrb
(
m
, 
y
)) {

579  
	gue
;

582 i(
	gdymic_
<
	gHas_Block
*>(
	gm
&& 
isPrb
(((
Has_Block
*)
m
)->
block
(), 
y
)) {

583  
	gue
;

586  
	gl
;

589 
bo
 
isPrb
(
Commt
* 
c
, 
Sass_Ouut_Sty
 
y
)

592 i(
	gy
 !
COMPRESSED
) {

593  
ue
;

596 i(
	gc
->
is_imp܏
()) {

597  
	gue
;

600  
	gl
;

603 
bo
 
isPrb
(
Block
* 
b
, 
Sass_Ouut_Sty
 
y
) {

604 i(
	gb
 =
NULL
) {

605  
l
;

608 
size_t
 
	gi
 = 0, 
	gL
 = 
b
->
ngth
(); i < L; ++i) {

609 
Smt
* 
	gm
 = (*
b
)[
i
];

610 i(
tyid
(*
m
=tyid(
Dei
||yid(*m=tyid(
Deive
)) {

611  
ue
;

613 i(
tyid
(*
m
=tyid(
Commt
)) {

614 
Commt
* 
c
 = (Commt*
m
;

615 i(
isPrb
(
c
, 
y
)) {

616  
	gue
;

619 i(
tyid
(*
m
=tyid(
Ruˣt
)) {

620 
Ruˣt
* 
r
 = (Ruˣt*
m
;

621 i(
isPrb
(
r
, 
y
)) {

622  
	gue
;

625 i(
tyid
(*
m
=tyid(
Suts_Block
)) {

626 
Suts_Block
* 
f
 = (Suts_Block*
m
;

627 i(
isPrb
(
f
, 
y
)) {

628  
	gue
;

631 i(
tyid
(*
m
=tyid(
Med_Block
)) {

632 
Med_Block
* 
m
 = (Med_Block*
m
;

633 i(
isPrb
(
m
, 
y
)) {

634  
	gue
;

637 i(
	gdymic_
<
	gHas_Block
*>(
	gm
&& 
isPrb
(((
Has_Block
*)
m
)->
block
(), 
y
)) {

638  
	gue
;

642  
	gl
;

645 
	gd
::
rg
 
vecJo
(cڡ 
d
::
ve
<d::rg>& 
vec
, cڡ std::rg& 
p
)

647 
vec
.
size
())

650  
d
::
rg
("");

652  
vec
[0];

654 
d
::
orgam
 
os
;

655 
	gos
 << 
	gvec
[0];

656 
size_t
 
	gi
 = 1; i < 
	gvec
.
size
(); i++) {

657 
	gos
 << 
	gp
 << 
	gvec
[
i
];

659  
	gos
.
r
();

663 
bo
 
isAscii
(cڡ 
chr
) {

664  (
	gchr
) < 128;

	@node_modules/node-sass/src/libsass/src/util.hpp

1 #ide
SASS_UTIL_H


2 
	#SASS_UTIL_H


	)

4 
	~<ve
>

5 
	~<rg
>

6 
	~<as.h
>

7 
	~"ss.h
"

8 
	~"ss/ba.h
"

9 
	~"a_fwd_de.h
"

11 
	#SASS_ASSERT
(
cd
, 
msg

	`as
(cd && msg)

	)

13 
mea
 
	gSass
 {

15 
	#out_of_memy
() do { \

16 
d
::

 << "Out of memory.\n"; \

17 
	`ex
(
EXIT_FAILURE
); \

18 } 0)

	)

20 
round
(
v
, 
size_t
 
ecisi
 = 0);

21 
ss_of
(cڡ * 
r
);

22 cڡ * 
_r
(const *, const * = "");

23 
_rg_y
(**);

24 **
cy_rgs
(cڡ 
d
::
ve
<d::
rg
>&, ***, = 0);

25 
	gd
::
rg
 
ad_css_rg
(cڡ 
d
::rg& 
r
);

26 
	gd
::
rg
 
evacue_ess
(cڡ 
d
::rg& 
r
);

27 
	gd
::
rg
 
rg_to_ouut
(cڡ 
d
::rg& 
r
);

28 
	gd
::
rg
 
commt_to_rg
(cڡ 
d
::rg& 
xt
);

30 
	gd
::
rg
 
que
(cڡ 
d
::rg&, 
q
 = 0);

31 
	gd
::
rg
 
unque
(cڡ 
d
::rg&, * 
q
 = 0, 
bo
 
kp_utf8_qus
 = 
l
);

32 
de_be_quemk
(cڡ * 
s
, 
qm
 = '"');

34 
bo
 
is_hex_doubt
(
n
);

35 
bo
 
is_c_doubt
(
r
, 
g
, 
b
);

37 
bo
 
ek_leed
(cڡ * 
t
);

39 
mea
 
	gUt
 {

41 
	gd
::
rg
 
rim
(cڡ 
d
::rg& 
r
);

43 
	gd
::
rg
 
nmize_undsces
(cڡ 
d
::rg& 
r
);

44 
	gd
::
rg
 
nmize_decims
(cڡ 
d
::rg& 
r
);

45 
	gd
::
rg
 
nmize_sixtu
(cڡ 
d
::rg& 
c
);

47 
	gd
::
rg
 
vecJo
(cڡ 
d
::
ve
<d::rg>& 
vec
, cڡ std::rg& 
p
);

48 
bo
 
cڏsAnyPrbSmts
(
Block
* 
b
);

50 
bo
 
isPrb
(
Ruˣt
* 
r
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

51 
bo
 
isPrb
(
Suts_Block
* 
r
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

52 
bo
 
isPrb
(
Med_Block
* 
r
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

53 
bo
 
isPrb
(
Commt
* 
b
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

54 
bo
 
isPrb
(
Block
* 
b
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

55 
bo
 
isPrb
(
Sg_Cڡt
* 
s
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

56 
bo
 
isPrb
(
Sg_Qued
* 
s
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

57 
bo
 
isPrb
(
Dei
* 
d
, 
Sass_Ouut_Sty
 
y
 = 
NESTED
);

58 
bo
 
isAscii
(cڡ 
chr
);

	@node_modules/node-sass/src/libsass/src/values.cpp

1 
	~"ss.h
"

2 
	~"ss.h
"

3 
	~"vues.h
"

5 
	~<dt.h
>

7 
mea
 
	gSass
 {

10 
Sass_Vue
* 
a_node_to_ss_vue
 (cڡ 
Exessi
* 
v
)

12 i(
	gv
->
ce_ty
(=
Exessi
::
NUMBER
)

14 cڡ 
Numb
* 
s
 = 
dymic_
<cڡ Numb*>(
v
);

15  
ss_make_numb
(
s
->
vue
(),es->
un
().
c_r
());

17 i(
	gv
->
ce_ty
(=
Exessi
::
COLOR
)

19 cڡ 
C
* 
c
 = 
dymic_
<cڡ C*>(
v
);

20  
ss_make_c
(
c
->
r
(), c->
g
(), c->
b
(), c->
a
());

22 i(
	gv
->
ce_ty
(=
Exessi
::
LIST
)

24 cڡ 
Li
* 
l
 = 
dymic_
<cڡ Li*>(
v
);

25 
Sass_Vue
* 
	gli
 = 
ss_make_li
(
l
->
size
(),->
t
());

26 
size_t
 
	gi
 = 0, 
	gL
 = 
l
->
ngth
(); i < L; ++i) {

27 aut
	gv
 = 
a_node_to_ss_vue
((*
l
)[
i
]);

28 
ss_li_t_vue
(
li
, 
i
, 
v
);

30  
	gli
;

32 i(
	gv
->
ce_ty
(=
Exessi
::
MAP
)

34 cڡ 
M
* 
m
 = 
dymic_
<cڡ M*>(
v
);

35 
Sass_Vue
* 
	gm
 = 
ss_make_m
(
m
->
ngth
());

36 
size_t
 
	gi
 = 0; aut
	gkey
 : 
m
->
keys
()) {

37 
ss_m_t_key
(
m
, 
i
, 
a_node_to_ss_vue
(
key
));

38 
ss_m_t_vue
(
m
, 
i
, 
a_node_to_ss_vue
(
m
->

(
key
)));

39 ++ 
	gi
;

41  
	gm
;

43 i(
	gv
->
ce_ty
(=
Exessi
::
NULL_VAL
)

45  
ss_make_nu
();

47 i(
	gv
->
ce_ty
(=
Exessi
::
BOOLEAN
)

49 cڡ 
Boޗn
* 
s
 = 
dymic_
<cڡ Boޗn*>(
v
);

50  
ss_make_boޗn
(
s
->
vue
());

52 i(
	gv
->
ce_ty
(=
Exessi
::
STRING
)

54 i(cڡ 
Sg_Qued
* 
qr
 = 
dymic_
<cڡ Sg_Qued*>(
v
))

56  
ss_make_qrg
(
qr
->
vue
().
c_r
());

58 i(cڡ 
Sg_Cڡt
* 
	gcr
 = 
dymic_
<cڡ Sg_Cڡt*>(
v
))

60  
ss_make_rg
(
cr
->
vue
().
c_r
());

63  
ss_make_r
("unknown sass valueype");

67 
Vue
* 
ss_vue_to_a_node
 (
Memy_Mag
& 
mem
, cڡ 
Sass_Vue
* 
v
)

69 
ss_vue_g_g
(
v
)) {

70 
	gSASS_NUMBER
:

71  
SASS_MEMORY_NEW
(
mem
, 
Numb
,

72 
PrS
("[C-VALUE]"),

73 
ss_numb_g_vue
(
v
),

74 
ss_numb_g_un
(
v
));

76 
	gSASS_BOOLEAN
:

77  
SASS_MEMORY_NEW
(
mem
, 
Boޗn
,

78 
PrS
("[C-VALUE]"),

79 
ss_boޗn_g_vue
(
v
));

81 
	gSASS_COLOR
:

82  
SASS_MEMORY_NEW
(
mem
, 
C
,

83 
PrS
("[C-VALUE]"),

84 
ss_c_g_r
(
v
),

85 
ss_c_g_g
(
v
),

86 
ss_c_g_b
(
v
),

87 
ss_c_g_a
(
v
));

89 
	gSASS_STRING
:

90 i(
ss_rg_is_qued
(
v
)) {

91  
SASS_MEMORY_NEW
(
mem
, 
Sg_Qued
,

92 
PrS
("[C-VALUE]"),

93 
ss_rg_g_vue
(
v
));

95  
SASS_MEMORY_NEW
(
mem
, 
Sg_Cڡt
,

96 
PrS
("[C-VALUE]"),

97 
ss_rg_g_vue
(
v
));

100 
	gSASS_LIST
: {

101 
Li
* 
l
 = 
SASS_MEMORY_NEW
(
mem
, List,

102 
PrS
("[C-VALUE]"),

103 
ss_li_g_ngth
(
v
),

104 
ss_li_g_t
(
v
));

105 
size_t
 
	gi
 = 0, 
	gL
 = 
ss_li_g_ngth
(
v
); i < L; ++i) {

106 *
	gl
 << 
ss_vue_to_a_node
(
mem
, 
ss_li_g_vue
(
v
, 
i
));

108  
	gl
;

111 
	gSASS_MAP
: {

112 
M
* 
m
 = 
SASS_MEMORY_NEW
(
mem
, M, 
PrS
("[C-VALUE]"));

113 
size_t
 
	gi
 = 0, 
	gL
 = 
ss_m_g_ngth
(
v
); i < L; ++i) {

114 *
	gm
 << 
	gd
::
make_
(

115 
ss_vue_to_a_node
(
mem
, 
ss_m_g_key
(
v
, 
i
)),

116 
ss_vue_to_a_node
(
mem
, 
ss_m_g_vue
(
v
, 
i
)));

118  
	gm
;

121 
	gSASS_NULL
:

122  
SASS_MEMORY_NEW
(
mem
, 
Nu
, 
PrS
("[C-VALUE]"));

124 
	gSASS_ERROR
:

125  
SASS_MEMORY_NEW
(
mem
, 
Cuom_E
,

126 
PrS
("[C-VALUE]"),

127 
ss_r_g_mesge
(
v
));

129 
	gSASS_WARNING
:

130  
SASS_MEMORY_NEW
(
mem
, 
Cuom_Wng
,

131 
PrS
("[C-VALUE]"),

132 
ss_wng_g_mesge
(
v
));

	@node_modules/node-sass/src/libsass/src/values.hpp

1 #ide
SASS_VALUES_H


2 
	#SASS_VALUES_H


	)

4 
	~"a.h
"

6 
mea
 
	gSass
 {

8 
Sass_Vue
* 
a_node_to_ss_vue
 (cڡ 
Exessi
* 
v
);

9 
Vue
* 
ss_vue_to_a_node
 (
Memy_Mag
& 
mem
, cڡ 
Sass_Vue
* 
v
);

	@node_modules/node-sass/src/libsass/test/test_node.cpp

1 
	~<as.h
>

2 
	~<sam
>

4 
	~"node.h
"

5 
	~"rr.h
"

8 
	#STATIC_ARRAY_SIZE
(
y
((׼ay))/(׼ay[0])))

	)

11 
mea
 
	gSass
 {

13 
Cڋxt
 
	gx
 = Cڋxt::
Da
();

15 cڡ * cڡ 
	gROUNDTRIP_TESTS
[] = {

16 
NULL
,

30 
Comex_Se
* 
ComexSe
(
d
::
rg
 
c
) {

31 
d
::
rg
 
mp
(
c
);

32 
	gmp
 += ";";

33  (*
	gPr
::
om_c_r
(
mp
.
c_r
(), 
x
, "", 
Posi
()).
r__li
())[0];

37 
roundTe
(cڡ * 
toTe
) {

41 
Comex_Se
* 
	gpOrigSe
 = 
NULL
;

42 i(
	gtoTe
) {

43 
	gpOrigSe
 = 
ComexSe
(
toTe
);

46 
	gd
::
rg
 
exed
(
pOrigSe
 ?OrigSe->
to_rg
() : "NULL");

51 
Node
 
	gnode
 = 
comexSeToNode
(
pOrigSe
, 
x
);

53 
	gd
::
rgam
 
nodeSgSm
;

54 
	gnodeSgSm
 << 
	gnode
;

55 
	gd
::
rg
 
nodeSg
 = 
nodeSgSm
.
r
();

56 
	gcout
 << "ASNODE: " << 
	gnode
 << 
	gdl
;

58 
Comex_Se
* 
	gpNewSe
 = 
nodeToComexSe
(
node
, 
x
);

62 
	gd
::
rg
 
su
(
pNewSe
 ?NewSe->
to_rg
() : "NULL");

64 
	gcout
 << "SELECTOR: " << 
	gexed
 << 
	gdl
;

65 
	gcout
 << "NEW SELECTOR: " << 
	gsu
 << 
	gdl
;

70 
as
(!
pOrigSe
 && !
pNewSe
 ) || (pOrigSelector &&NewSelector) );

71 i(
	gpOrigSe
) {

72 
as
*
pOrigSe
 =*
pNewSe
 );

78 
as
(
exed
 =
su
);

83 
ma
() {

84 
	gdex
 = 0; index < 
STATIC_ARRAY_SIZE
(
ROUNDTRIP_TESTS
); index++) {

85 cڡ * cڡ 
	gtoTe
 = 
ROUNDTRIP_TESTS
[
dex
];

86 
	gcout
 << "\nINPUT STRING: " << (
	gtoTe
 ?oTe : "NULL"<< 
dl
;

87 
roundTe
(
toTe
);

90 
	gcout
 << "\nTesting Done.\n";

	@node_modules/node-sass/src/libsass/test/test_paths.cpp

1 
	~<ioam
>

2 
	~"../ths.h
"

4 
usg
 
mea
 
	gSass
;

6 
	gme
<
tyme
 
	gT
>

7 
	gd
::
ve
<
T
>& 
ݔ
<<(
d
::ve<T>& 
v
, cڡ 
	gT
& 
	ge
)

9 
	gv
.
push_back
(
e
);

10  
	gv
;

13 
	$ma
()

15 
d
::
ve
<> 
v1
, 
v2
, 
v3
;

16 
v1
 << 1 << 2;

17 
v2
 << 3;

18 
v3
 << 4 << 5 << 6;

20 
d
::
ve
<d::ve<> > 
ss
;

21 
ss
 << 
v1
 << 
v2
 << 
v3
;

23 
d
::
ve
<d::ve<> > 
ps
 = 
	`ths
(
ss
);

24 
size_t
 
i
 = 0, 
S
 = 
ps
.
	`size
(); i < S; ++i) {

25 
d
::
cout
 << 
	`ve_to_rg
(
ps
[
i
]<< std::
dl
;

28 
	}
}

	@node_modules/node-sass/src/libsass/test/test_selector_difference.cpp

1 
	~"../a.h
"

2 
	~"../cڋxt.h
"

3 
	~"../rr.h
"

4 
	~<rg
>

5 
	~<ioam
>

7 
usg
 
mea
 
	gSass
;

9 
Cڋxt
 
	gx
 = Cڋxt::
Da
();

11 
Compound_Se
* 
	$
(
d
::
rg
 
c
)

12 {  
Pr
::
	`om_c_r
(
c
.
	`c_r
(), 
x
, "", 
	`Posi
()).
	`r_compound_
(); 
	}
}

14 
	$diff
(
d
::
rg
 
s
, std::rg 
t
)

16 
d
::
cout
 << 
s
 << " - " << 
t
 << " = " << 
	`
(+ ";")->
	`mus
( + ";"), 
x
)->
	`to_rg
(<< std::
dl
;

17 
	}
}

19 
	$ma
()

21 
	`diff
(".a.b.c", ".c.b");

22 
	`diff
(".a.b.c", ".fludge.b");

25 
	}
}

	@node_modules/node-sass/src/libsass/test/test_specificity.cpp

1 
	~"../a.h
"

2 
	~"../cڋxt.h
"

3 
	~"../rr.h
"

4 
	~<rg
>

5 
	~<ioam
>

7 
usg
 
mea
 
	gSass
;

9 
Cڋxt
 
	gx
 = Cڋxt::
Da
();

11 
Se
* 
	$
(
d
::
rg
 
c
)

12 {  
Pr
::
	`om_c_r
(
c
.
	`c_r
(), 
x
, "", 
	`Posi
()).
	`r__li
(); 
	}
}

14 
	$ec
(
d
::
rg
 
l
)

15 { 
d
::
cout
 << 
l
 << "\t::\t" << 
	`
(+ ";")->
	`ecificy
(<< std::
dl
; 
	}
}

17 
	$ma
()

19 
	`ec
("foo bar hux");

20 
	`ec
(".foo .bar hux");

21 
	`ec
("#foo .bar[hux='mux']");

22 
	`ec
("a b c d f");

25 
	}
}

	@node_modules/node-sass/src/libsass/test/test_subset_map.cpp

1 
	~<rg
>

2 
	~<ioam
>

3 
	~<as.h
>

4 
	~"../subt_m.h
"

6 
	gSubt_M
<
	gd
::
rg
, std::rg> 
ssm
;

8 
rg
 
toSg
(
d
::
ve
<d::rg> 
v
);

9 
rg
 
toSg
(
d
::
ve
<d::

<d::rg, std::ve<d::rg>>> 
v
);

10 
asEqu
(
rg
 
d
::
sExed
, std::rg 
sResu
);

12 
	$tup
() {

13 
ssm
.
	`r
();

16 
d
::
ve
<d::
rg
> 
s1
;

17 
s1
.
	`push_back
("1");

18 
s1
.
	`push_back
("2");

19 
ssm
.
	`put
(
s1
, "Foo");

22 
d
::
ve
<d::
rg
> 
s2
;

23 
s2
.
	`push_back
("fizz");

24 
s2
.
	`push_back
("fazz");

25 
ssm
.
	`put
(
s2
, "Bar");

28 
d
::
ve
<d::
rg
> 
s3
;

29 
s3
.
	`push_back
(":foo");

30 
s3
.
	`push_back
(":bar");

31 
ssm
.
	`put
(
s3
, "Baz");

34 
d
::
ve
<d::
rg
> 
s4
;

35 
s4
.
	`push_back
(":foo");

36 
s4
.
	`push_back
(":bar");

37 
s4
.
	`push_back
(":baz");

38 
ssm
.
	`put
(
s4
, "Bang");

41 
d
::
ve
<d::
rg
> 
s5
;

42 
s5
.
	`push_back
(":bip");

43 
s5
.
	`push_back
(":bop");

44 
s5
.
	`push_back
(":blip");

45 
ssm
.
	`put
(
s5
, "Qux");

48 
d
::
ve
<d::
rg
> 
s6
;

49 
s6
.
	`push_back
(":bip");

50 
s6
.
	`push_back
(":bop");

51 
ssm
.
	`put
(
s6
, "Thram");

52 
	}
}

54 
	$EquKeys
() {

55 
d
::
cout
 << "EquKeys" << std::
dl
;

58 
d
::
ve
<d::
rg
> 
k1
;

59 
k1
.
	`push_back
("1");

60 
k1
.
	`push_back
("2");

61 
	`asEqu
("[[Foo, S[1, 2]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

64 
d
::
ve
<d::
rg
> 
k2
;

65 
k2
.
	`push_back
("fizz");

66 
k2
.
	`push_back
("fazz");

67 
	`asEqu
("[[B, S[fizz, fazz]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k2
)));

69 
d
::
cout
 << std::
dl
;

70 
	}
}

72 
	$SubtKeys
() {

73 
d
::
cout
 << "SubtKeys" << std::
dl
;

76 
d
::
ve
<d::
rg
> 
k1
;

77 
k1
.
	`push_back
("1");

78 
k1
.
	`push_back
("2");

79 
k1
.
	`push_back
("fuzz");

80 
	`asEqu
("[[Foo, S[1, 2]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

83 
d
::
ve
<d::
rg
> 
k2
;

84 
k2
.
	`push_back
("fizz");

85 
k2
.
	`push_back
("fazz");

86 
k2
.
	`push_back
("3");

87 
	`asEqu
("[[B, S[fizz, fazz]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k2
)));

89 
d
::
cout
 << std::
dl
;

90 
	}
}

92 
	$SurtKeys
() {

93 
d
::
cout
 << "SurtKeys" << std::
dl
;

96 
d
::
ve
<d::
rg
> 
k1
;

97 
k1
.
	`push_back
("1");

98 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

101 
d
::
ve
<d::
rg
> 
k2
;

102 
k2
.
	`push_back
("2");

103 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k2
)));

106 
d
::
ve
<d::
rg
> 
k3
;

107 
k3
.
	`push_back
("fizz");

108 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k3
)));

111 
d
::
ve
<d::
rg
> 
k4
;

112 
k4
.
	`push_back
("fazz");

113 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k4
)));

115 
d
::
cout
 << std::
dl
;

116 
	}
}

118 
	$DisjotKeys
() {

119 
d
::
cout
 << "DisjotKeys" << std::
dl
;

122 
d
::
ve
<d::
rg
> 
k1
;

123 
k1
.
	`push_back
("3");

124 
k1
.
	`push_back
("4");

125 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

128 
d
::
ve
<d::
rg
> 
k2
;

129 
k2
.
	`push_back
("fuzz");

130 
k2
.
	`push_back
("frizz");

131 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k2
)));

134 
d
::
ve
<d::
rg
> 
k3
;

135 
k3
.
	`push_back
("gran");

136 
k3
.
	`push_back
("15");

137 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k3
)));

139 
d
::
cout
 << std::
dl
;

140 
	}
}

142 
	$SemiDisjotKeys
() {

143 
d
::
cout
 << "SemiDisjotKeys" << std::
dl
;

146 
d
::
ve
<d::
rg
> 
k1
;

147 
k1
.
	`push_back
("2");

148 
k1
.
	`push_back
("3");

149 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

152 
d
::
ve
<d::
rg
> 
k2
;

153 
k2
.
	`push_back
("fizz");

154 
k2
.
	`push_back
("fuzz");

155 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k2
)));

158 
d
::
ve
<d::
rg
> 
k3
;

159 
k3
.
	`push_back
("1");

160 
k3
.
	`push_back
("fazz");

161 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k3
)));

163 
d
::
cout
 << std::
dl
;

164 
	}
}

166 
	$EmyKeyS
() {

167 
d
::
cout
 << "EmyKeyS" << std::
dl
;

170 
d
::
ve
<d::
rg
> 
s1
;

171 
y
 {

172 
ssm
.
	`put
(
s1
, "Fail");

174 
	`tch
 (cڡ * &
e
) {

175 
	`asEqu
(": subm keymay bemy", 
e
);

177 
	}
}

179 
	$EmyKeyG
() {

180 
d
::
cout
 << "EmyKeyG" << std::
dl
;

183 
d
::
ve
<d::
rg
> 
k1
;

184 
	`asEqu
("[]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

186 
d
::
cout
 << std::
dl
;

187 
	}
}

188 
	$MuɝSubts
() {

189 
d
::
cout
 << "MuɝSubts" << std::
dl
;

192 
d
::
ve
<d::
rg
> 
k1
;

193 
k1
.
	`push_back
("1");

194 
k1
.
	`push_back
("2");

195 
k1
.
	`push_back
("fizz");

196 
k1
.
	`push_back
("fazz");

197 
	`asEqu
("[[Foo, S[1, 2]], [B, S[fizz, fazz]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

200 
d
::
ve
<d::
rg
> 
k2
;

201 
k2
.
	`push_back
("1");

202 
k2
.
	`push_back
("2");

203 
k2
.
	`push_back
("3");

204 
k2
.
	`push_back
("fizz");

205 
k2
.
	`push_back
("fazz");

206 
k2
.
	`push_back
("fuzz");

207 
	`asEqu
("[[Foo, S[1, 2]], [B, S[fizz, fazz]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k2
)));

210 
d
::
ve
<d::
rg
> 
k3
;

211 
k3
.
	`push_back
(":foo");

212 
k3
.
	`push_back
(":bar");

213 
	`asEqu
("[[Baz, S[:foo, :b]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k3
)));

216 
d
::
ve
<d::
rg
> 
k4
;

217 
k4
.
	`push_back
(":foo");

218 
k4
.
	`push_back
(":bar");

219 
k4
.
	`push_back
(":baz");

220 
	`asEqu
("[[Baz, S[:foo, :b]], [Bg, S[:foo, :b, :baz]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k4
)));

222 
d
::
cout
 << std::
dl
;

223 
	}
}

224 
	$BckBck
() {

225 
d
::
cout
 << "BckBck" << std::
dl
;

228 
d
::
ve
<d::
rg
> 
k1
;

229 
k1
.
	`push_back
("1");

230 
k1
.
	`push_back
("2");

231 
k1
.
	`push_back
("fuzz");

232 
	`asEqu
("[Foo]", 
	`toSg
(
ssm
.
	`g_v
(
k1
)));

235 
d
::
ve
<d::
rg
> 
k2
;

236 
k2
.
	`push_back
(":foo");

237 
k2
.
	`push_back
(":bar");

238 
k2
.
	`push_back
(":baz");

239 
	`asEqu
("[Baz, Bg]", 
	`toSg
(
ssm
.
	`g_v
(
k2
)));

241 
d
::
cout
 << std::
dl
;

242 
	}
}

244 
	$KeyOrd
() {

245 
d
::
cout
 << "EquKeys" << std::
dl
;

248 
d
::
ve
<d::
rg
> 
k1
;

249 
k1
.
	`push_back
("2");

250 
k1
.
	`push_back
("1");

251 
	`asEqu
("[[Foo, S[1, 2]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

253 
d
::
cout
 << std::
dl
;

254 
	}
}

256 
	$OrdPrved
() {

257 
d
::
cout
 << "OrdPrved" << std::
dl
;

259 
d
::
ve
<d::
rg
> 
s1
;

260 
s1
.
	`push_back
("10");

261 
s1
.
	`push_back
("11");

262 
s1
.
	`push_back
("12");

263 
ssm
.
	`put
(
s1
, "1");

266 
d
::
ve
<d::
rg
> 
s2
;

267 
s2
.
	`push_back
("10");

268 
s2
.
	`push_back
("11");

269 
ssm
.
	`put
(
s2
, "2");

272 
d
::
ve
<d::
rg
> 
s3
;

273 
s3
.
	`push_back
("11");

274 
ssm
.
	`put
(
s3
, "3");

277 
d
::
ve
<d::
rg
> 
s4
;

278 
s4
.
	`push_back
("11");

279 
s4
.
	`push_back
("12");

280 
ssm
.
	`put
(
s4
, "4");

283 
d
::
ve
<d::
rg
> 
s5
;

284 
s5
.
	`push_back
("9");

285 
s5
.
	`push_back
("10");

286 
s5
.
	`push_back
("11");

287 
s5
.
	`push_back
("12");

288 
s5
.
	`push_back
("13");

289 
ssm
.
	`put
(
s5
, "5");

292 
d
::
ve
<d::
rg
> 
s6
;

293 
s6
.
	`push_back
("10");

294 
s6
.
	`push_back
("13");

295 
ssm
.
	`put
(
s6
, "6");

298 
d
::
ve
<d::
rg
> 
k1
;

299 
k1
.
	`push_back
("9");

300 
k1
.
	`push_back
("10");

301 
k1
.
	`push_back
("11");

302 
k1
.
	`push_back
("12");

303 
k1
.
	`push_back
("13");

304 
	`asEqu
("[[1, S[10, 11, 12]], [2, S[10, 11]], [3, S[11]], [4, S[11, 12]], [5, S[9, 10, 11, 12, 13]], [6, S[10, 13]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

306 
d
::
cout
 << std::
dl
;

307 
	}
}

308 
	$MuɝEquVues
() {

309 
d
::
cout
 << "MuɝEquVues" << std::
dl
;

311 
d
::
ve
<d::
rg
> 
s1
;

312 
s1
.
	`push_back
("11");

313 
s1
.
	`push_back
("12");

314 
ssm
.
	`put
(
s1
, "1");

317 
d
::
ve
<d::
rg
> 
s2
;

318 
s2
.
	`push_back
("12");

319 
s2
.
	`push_back
("13");

320 
ssm
.
	`put
(
s2
, "2");

323 
d
::
ve
<d::
rg
> 
s3
;

324 
s3
.
	`push_back
("13");

325 
s3
.
	`push_back
("14");

326 
ssm
.
	`put
(
s3
, "1");

329 
d
::
ve
<d::
rg
> 
s4
;

330 
s4
.
	`push_back
("14");

331 
s4
.
	`push_back
("15");

332 
ssm
.
	`put
(
s4
, "1");

335 
d
::
ve
<d::
rg
> 
k1
;

336 
k1
.
	`push_back
("11");

337 
k1
.
	`push_back
("12");

338 
k1
.
	`push_back
("13");

339 
k1
.
	`push_back
("14");

340 
k1
.
	`push_back
("15");

341 
	`asEqu
("[[1, S[11, 12]], [2, S[12, 13]], [1, S[13, 14]], [1, S[14, 15]]]", 
	`toSg
(
ssm
.
	`g_kv
(
k1
)));

343 
d
::
cout
 << std::
dl
;

344 
	}
}

346 
	$ma
()

348 
d
::
ve
<d::
rg
> 
s1
;

349 
s1
.
	`push_back
("1");

350 
s1
.
	`push_back
("2");

352 
d
::
ve
<d::
rg
> 
s2
;

353 
s2
.
	`push_back
("2");

354 
s2
.
	`push_back
("3");

356 
d
::
ve
<d::
rg
> 
s3
;

357 
s3
.
	`push_back
("3");

358 
s3
.
	`push_back
("4");

360 
ssm
.
	`put
(
s1
, "value1");

361 
ssm
.
	`put
(
s2
, "value2");

362 
ssm
.
	`put
(
s3
, "value3");

364 
d
::
ve
<d::
rg
> 
s4
;

365 
s4
.
	`push_back
("1");

366 
s4
.
	`push_back
("2");

367 
s4
.
	`push_back
("3");

369 
d
::
ve
<d::

<
rg
, std::ve<d::rg> > > 
	`tched
(
ssm
.
	`g_kv
(
s4
));

371 
d
::
cout
 << "PRINTING RESULTS:" << std::
dl
;

372 
size_t
 
i
 = 0, 
S
 = 
tched
.
	`size
(); i < S; ++i) {

373 
d
::
cout
 << 
tched
[
i
].
f
 << std::
dl
;

376 
Subt_M
<
rg
, sg> 
ssm2
;

377 
ssm2
.
	`put
(
s1
, "foo");

378 
ssm2
.
	`put
(
s2
, "bar");

379 
ssm2
.
	`put
(
s4
, "hux");

381 
d
::
ve
<d::

<
rg
, std::ve<d::rg> > > 
	`tched2
(
ssm2
.
	`g_kv
(
s4
));

383 
d
::
cout
 << std::
dl
 << "PRINTING RESULTS:" << std::endl;

384 
size_t
 
i
 = 0, 
S
 = 
tched2
.
	`size
(); i < S; ++i) {

385 
d
::
cout
 << 
tched2
[
i
].
f
 << std::
dl
;

388 
d
::
cout
 << "TRYING ON A SELECTOR-LIKE OBJECT" << std::
dl
;

390 
Subt_M
<
rg
, sg> 
l_ssm
;

391 
d
::
ve
<d::
rg
> 
rg
;

392 
rg
.
	`push_back
("desk");

393 
rg
.
	`push_back
(".wood");

395 
d
::
ve
<d::
rg
> 
au
;

396 
au
.
	`push_back
("desk");

397 
au
.
	`push_back
(".wood");

398 
au
.
	`push_back
(".mine");

400 
l_ssm
.
	`put
(
rg
, "has-aquarium");

401 
d
::
ve
<d::

<
rg
, std::ve<d::rg> > > 
	`tched3
(
l_ssm
.
	`g_kv
(
au
));

402 
d
::
cout
 << "RESULTS:" << std::
dl
;

403 
size_t
 
i
 = 0, 
S
 = 
tched3
.
	`size
(); i < S; ++i) {

404 
d
::
cout
 << 
tched3
[
i
].
f
 << std::
dl
;

407 
d
::
cout
 << std::
dl
;

411 
	`tup
();

412 
	`EquKeys
();

413 
	`SubtKeys
();

414 
	`SurtKeys
();

415 
	`DisjotKeys
();

416 
	`SemiDisjotKeys
();

417 
	`EmyKeyS
();

418 
	`EmyKeyG
();

419 
	`MuɝSubts
();

420 
	`BckBck
();

421 
	`KeyOrd
();

423 
	`tup
();

424 
	`OrdPrved
();

426 
	`tup
();

427 
	`MuɝEquVues
();

430 
	}
}

432 
rg
 
toSg
(
d
::
ve
<d::

<rg, std::ve<d::rg>>> 
v
)

434 
d
::
rgam
 
bufr
;

435 
	gbufr
 << "[";

436 
size_t
 
	gi
 = 0, 
	gS
 = 
v
.
size
(); i < S; ++i) {

437 
	gbufr
 << "[" << 
	gv
[
i
].
	gf
;

438 
	gbufr
 << ", Set[";

439 
size_t
 
	gj
 = 0, 
	gS
 = 
v
[
i
].
cd
.
size
(); j < S; ++j) {

440 
	gbufr
 << 
	gv
[
i
].
	gcd
[
j
];

441 i(
	gj
 < 
	gS
-1) {

442 
	gbufr
 << ", ";

445 
	gbufr
 << "]]";

446 i(
	gi
 < 
	gS
-1) {

447 
	gbufr
 << ", ";

450 
	gbufr
 << "]";

451  
	gbufr
.
r
();

454 
rg
 
toSg
(
d
::
ve
<d::rg> 
v
)

456 
d
::
rgam
 
bufr
;

457 
	gbufr
 << "[";

458 
size_t
 
	gi
 = 0, 
	gS
 = 
v
.
size
(); i < S; ++i) {

459 
	gbufr
 << 
	gv
[
i
];

460 i(
	gi
 < 
	gS
-1) {

461 
	gbufr
 << ", ";

464 
	gbufr
 << "]";

465  
	gbufr
.
r
();

468 
	$asEqu
(
rg
 
sExed
, sg 
sResu
) {

469 
d
::
cout
 << "Exed: " << 
sExed
 << std::
dl
;

470 
d
::
cout
 << "Resu: " << 
sResu
 << std::
dl
;

471 
	`as
(
sExed
 =
sResu
);

472 
	}
}

	@node_modules/node-sass/src/libsass/test/test_superselector.cpp

1 
	~"../a.h
"

2 
	~"../cڋxt.h
"

3 
	~"../rr.h
"

4 
	~<rg
>

6 
usg
 
mea
 
	gSass
;

8 
Cڋxt
 
	gx
 = Cڋxt(Cڋxt::
Da
());

10 
Compound_Se
* 
	$compound_
(
d
::
rg
 
c
)

11 {  
Pr
::
	`om_c_r
(
c
.
	`c_r
(), 
x
, "", 
	`Posi
()).
	`r_compound_
(); 
	}
}

13 
Comex_Se
* 
	$comex_
(
d
::
rg
 
c
)

14 {  
Pr
::
	`om_c_r
(
c
.
	`c_r
(), 
x
, "", 
	`Posi
()).
	`r_comex_
(
l
); 
	}
}

16 
	$check_compound
(
d
::
rg
 
s1
, std::rg 
s2
)

18 
d
::
cout
 << "Is "

19 << 
s1


21 << 
s2


23 << 
	`compound_
(
s1
 + ";")->
	`is_sur_of
(compound_(
s2
 + ";"))

24 << 
d
::
dl
;

25 
	}
}

27 
	$check_comex
(
d
::
rg
 
s1
, std::rg 
s2
)

29 
d
::
cout
 << "Is "

30 << 
s1


32 << 
s2


34 << 
	`comex_
(
s1
 + ";")->
	`is_sur_of
(comex_(
s2
 + ";"))

35 << 
d
::
dl
;

36 
	}
}

38 
	$ma
()

40 
	`check_compound
(".foo", ".foo.bar");

41 
	`check_compound
(".foo.bar", ".foo");

42 
	`check_compound
(".foo.bar", "div.foo");

43 
	`check_compound
(".foo", "div.foo");

44 
	`check_compound
("div.foo", ".foo");

45 
	`check_compound
("div.foo", "div.bar.foo");

46 
	`check_compound
("p.foo", "div.bar.foo");

47 
	`check_compound
(".hux", ".mumble");

49 
d
::
cout
 << std::
dl
;

51 
	`check_comex
(".foo ~ .bar", ".foo + .bar");

52 
	`check_comex
(".foo .bar", ".foo + .bar");

53 
	`check_comex
(".foo .bar", ".foo > .bar");

54 
	`check_comex
(".foo .bar > .hux", ".foo.a .bar.b > .hux");

55 
	`check_comex
(".foo ~ .bar .hux", ".foo.a + .bar.b > .hux");

56 
	`check_comex
(".foo", ".bar .foo");

57 
	`check_comex
(".foo", ".foo.a");

58 
	`check_comex
(".foo.bar", ".foo");

59 
	`check_comex
(".foo .bar .hux", ".bar .hux");

60 
	`check_comex
(".foo ~ .bar .hux.x", ".foo.a + .bar.b > .hux.y");

61 
	`check_comex
(".foo ~ .bar .hux", ".foo.a + .bar.b > .mumble");

62 
	`check_comex
(".foo + .bar", ".foo ~ .bar");

63 
	`check_comex
("a c", "a b c d");

64 
	`check_comex
("c", "a b c d");

67 
	}
}

	@node_modules/node-sass/src/libsass/test/test_unification.cpp

1 
	~"../a.h
"

2 
	~"../cڋxt.h
"

3 
	~"../rr.h
"

4 
	~<rg
>

6 
usg
 
mea
 
	gSass
;

8 
Cڋxt
 
	gx
 = Cڋxt(Cڋxt::
Da
());

10 
Compound_Se
* 
	$
(
d
::
rg
 
c
)

11 {  
Pr
::
	`om_c_r
(
c
.
	`c_r
(), 
x
, "", 
	`Posi
()).
	`r_compound_
(); 
	}
}

13 
	$unify
(
d
::
rg
 
lhs
, std::rg 
rhs
)

15 
Compound_Se
* 
unifd
 = 
	`
(
lhs
 + ";")->
	`unify_wh
((
rhs
 + ";"), 
x
);

16 
d
::
cout
 << 
lhs
 << " UNIFIED WITH " << 
rhs
 << " =\t" << (
unifd
 ? unifd->
	`to_rg
(: "NOTHING"<< std::
dl
;

17 
	}
}

19 
	$ma
()

21 
	`unify
(".foo", ".foo.bar");

22 
	`unify
("div:nth-of-type(odd)", "div:first-child");

23 
	`unify
("div", "span:whatever");

24 
	`unify
("div", "span");

25 
	`unify
("foo:bar::after", "foo:bar::first-letter");

26 
	`unify
(".foo#bar.hux", ".hux.foo#bar");

27 
	`unify
(".foo#bar.hux", ".hux.foo#baz");

28 
	`unify
("*:blah:fudge", "p:fudge:blah");

31 
	}
}

	@node_modules/node-sass/src/sass_context_wrapper.cpp

1 
	~"ss_cڋxt_w.h
"

4 
usg
 
mea
 
d
;

6 
compe_
(
uv_wk_t
* 
q
) {

7 
ss_cڋxt_w
* 
x_w
 = (ss_cڋxt_w*)
q
->
da
;

9 i(
x_w
->
dx
) {

10 
compe_da
(
x_w
->
dx
);

12 i(
x_w
->
fx
) {

13 
compe_fe
(
x_w
->
fx
);

17 
compe_da
(
Sass_Da_Cڋxt
* 
dx
) {

18 
ss_compe_da_cڋxt
(
dx
);

21 
compe_fe
(
Sass_Fe_Cڋxt
* 
fx
) {

22 
ss_compe_fe_cڋxt
(
fx
);

25 
ss_cڋxt_w
* 
ss_make_cڋxt_w
() {

26  (
ss_cڋxt_w
*)
oc
(1, (sass_context_wrapper));

29 
ss__cڋxt_w
(
ss_cڋxt_w
* 
x_w
) {

30 i(
x_w
->
dx
) {

31 
ss_de_da_cڋxt
(
x_w
->
dx
);

33 i(
x_w
->
fx
) {

34 
ss_de_fe_cڋxt
(
x_w
->
fx
);

37 
de
 
x_w
->
r_back
;

38 
de
 
x_w
->
sucss_back
;

40 
x_w
->
su
.
Ret
();

42 

(
x_w
->
ude_th
);

43 

(
x_w
->
leed
);

44 

(
x_w
->
out_fe
);

45 

(
x_w
->
sour_m
);

46 

(
x_w
->
sour_m_ro
);

47 

(
x_w
->
dt
);

49 
d
::
ve
<
CuomImp܋rBridge
 *>::

 
imp_
 = 
x_w
->
imp܋r_bridges
.
beg
();

50 
imp_
 !
x_w
->
imp܋r_bridges
.
d
()) {

51 
CuomImp܋rBridge
* 
p
 = *
imp_
;

52 
imp_
 = 
x_w
->
imp܋r_bridges
.
a
(imp_it);

53 
de
 
p
;

55 
d
::
ve
<
CuomFuniBridge
 *>::

 
func_
 = 
x_w
->
funi_bridges
.
beg
();

56 
func_
 !
x_w
->
funi_bridges
.
d
()) {

57 
CuomFuniBridge
* 
p
 = *
func_
;

58 
func_
 = 
x_w
->
funi_bridges
.
a
(func_it);

59 
de
 
p
;

62 

(
x_w
);

	@node_modules/node-sass/src/sass_context_wrapper.h

1 #ide
SASS_CONTEXT_WRAPPER


2 
	#SASS_CONTEXT_WRAPPER


	)

4 
	~<ve
>

5 
	~<memy
>

6 
	~<n.h
>

7 
	~<dlib.h
>

8 
	~<ss/cڋxt.h
>

9 
	~"cuom_funi_bridge.h
"

10 
	~"cuom_imp܋r_bridge.h
"

12 #ifde
__lulus


16 
compe_da
(
Sass_Da_Cڋxt
* 
dx
);

17 
compe_fe
(
Sass_Fe_Cڋxt
* 
fx
);

18 
compe_
(
uv_wk_t
* 
q
);

20 
	sss_cڋxt_w
 {

22 
bo
 
is_sync
;

23 * 
cook
;

24 * 
fe
;

25 * 
ude_th
;

26 * 
out_fe
;

27 * 
sour_m
;

28 * 
sour_m_ro
;

29 * 
leed
;

30 * 
dt
;

33 
Sass_Da_Cڋxt
* 
dx
;

34 
Sass_Fe_Cڋxt
* 
fx
;

37 
uv_async_t
 
async
;

38 
uv_wk_t
 
que
;

41 
N
::
Psit
<
v8
::
Obje
> 
su
;

42 
N
::
Clback
* 
r_back
;

43 
N
::
Clback
* 
sucss_back
;

45 
d
::
ve
<
CuomFuniBridge
 *> 
funi_bridges
;

46 
d
::
ve
<
CuomImp܋rBridge
 *> 
imp܋r_bridges
;

49 
ss_cڋxt_w
* 
ss_make_cڋxt_w
();

50 
ss__cڋxt_w
(
ss_cڋxt_w
*);

52 #ifde
__lulus


	@node_modules/node-sass/src/sass_types/boolean.cpp

1 
	~<n.h
>

2 
	~"boޗn.h
"

4 
mea
 
	gSassTys


6 
	gN
::
Psit
<
v8
::
Funi
> 
Boޗn
::
cڡru
;

7 
bo
 
	gBoޗn
::
cڡru_locked
 = 
l
;

9 
	gBoޗn
::
Boޗn
(
bo
 
v
: 
vue
(v) {}

11 
Boޗn
& Boޗn::
g_sgt
(
bo
 
v
) {

12 
Boޗn
 
_l
(
l
), 
_ue
(
ue
);

13  
	gv
 ? 
	g_ue
 : 
_l
;

16 
	gv8
::
Lol
<
v8
::
Funi
> 
Boޗn
::
g_cڡru
() {

17 
N
::
EsbHdSce
 
sce
;

18 
	gv8
::
Lol
<
v8
::
Funi
> 
cڦol
;

19 i(
	gcڡru
.
IsEmy
()) {

20 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
l
 = 
N
::
New
<v8::FunctionTemplate>(New);

22 
	gl
->
SCssName
(
N
::
New
("SassBoޗn").
ToLolChecked
());

23 
	gl
->
InTeme
()->
SIlFldCou
(1);

24 
	gN
::
SPryTeme
(
l
, "gVue", 
N
::
New
<
v8
::
FuniTeme
>(
GVue
));

26 
	gcڦol
 = 
N
::
GFuni
(
l
).
ToLolChecked
();

27 
	gcڡru
.
Ret
(
cڦol
);

29 
g_sgt
(
l
).
	gjs_obje
.
Ret
(
N
::
NewIn
(
cڦol
).
ToLolChecked
());

30 
	gN
::
SIlFldPor
(
N
::
New
(
g_sgt
(
l
).
js_obje
), 0, &get_singleton(false));

31 
	gN
::
S
(
cڦol
, 
N
::
New
("FALSE").
ToLolChecked
(), N::New(
g_sgt
(
l
).
js_obje
));

33 
g_sgt
(
ue
).
	gjs_obje
.
Ret
(
N
::
NewIn
(
cڦol
).
ToLolChecked
());

34 
	gN
::
SIlFldPor
(
N
::
New
(
g_sgt
(
ue
).
js_obje
), 0, &get_singleton(true));

35 
	gN
::
S
(
cڦol
, 
N
::
New
("TRUE").
ToLolChecked
(), N::New(
g_sgt
(
ue
).
js_obje
));

37 
	gcڡru_locked
 = 
ue
;

39 
	gcڦol
 = 
N
::
New
(
cڡru
);

42  
	gsce
.
Es
(
cڦol
);

45 
Sass_Vue
* 
	gBoޗn
::
g_ss_vue
() {

46  
ss_make_boޗn
(
vue
);

49 
	gv8
::
Lol
<
v8
::
Obje
> 
Boޗn
::
g_js_obje
() {

50  
N
::
New
(
this
->
js_obje
);

53 
NAN_METHOD
(
Boޗn
::
New
) {

55 i(
fo
.
IsCڡruCl
()) {

56 i(
cڡru_locked
) {

57  
N
::
ThrowTyE
("Cannot instantiate SassBoolean");

61 i(
	gfo
.
Lgth
(!1 || !
fo
[0]->
IsBoޗn
()) {

62  
N
::
ThrowTyE
("Expected one booleanrgument");

65 
	gfo
.
GRuVue
().
S
(
g_sgt
(
N
::
To
<
bo
>(
fo
[0]).
FromJu
()).
g_js_obje
());

69 
NAN_METHOD
(
Boޗn
::
GVue
) {

70 
Boޗn
 *
out
;

71 i((
	gout
 = 
ic_
<
Boޗn
*>(
Fay
::
unwp
(
fo
.
This
())))) {

72 
fo
.
GRuVue
().
S
(
N
::
New
(
out
->
vue
));

	@node_modules/node-sass/src/sass_types/boolean.h

1 #ide
SASS_TYPES_BOOLEAN_H


2 
	#SASS_TYPES_BOOLEAN_H


	)

4 
	~<n.h
>

5 
	~"vue.h
"

6 
	~"ss_vue_w.h
"

8 
mea
 
	gSassTys


10 as
	cBoޗn
 : 
public
 
SassTys
::
Vue
 {

11 
public
:

12 
Boޗn
& 
g_sgt
(
bo
);

13 
	gv8
::
Lol
<
v8
::
Funi
> 
g_cڡru
();

15 
Sass_Vue
* 
g_ss_vue
();

16 
	gv8
::
Lol
<
v8
::
Obje
> 
g_js_obje
();

18 
NAN_METHOD
(
New
);

19 
NAN_METHOD
(
GVue
);

21 
	give
:

22 
Boޗn
(
bo
);

24 
bo
 
	gvue
;

25 
	gN
::
Psit
<
v8
::
Obje
> 
js_obje
;

27 
	gN
::
Psit
<
v8
::
Funi
> 
cڡru
;

28 
bo
 
	gcڡru_locked
;

	@node_modules/node-sass/src/sass_types/color.cpp

1 
	~<n.h
>

2 
	~"c.h
"

4 
mea
 
	gSassTys


6 
	gC
::
C
(
Sass_Vue
* 
v
: 
SassVueW
(v) {}

8 
Sass_Vue
* 
C
::
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
w_v
, Sass_Vu**
out
) {

9 
	ga
 = 1.0, 
	gr
 = 0, 
	gg
 = 0, 
	gb
 = 0;

10 
	ggb
;

12 
	gw_v
.
size
()) {

14 i(!
w_v
[0]->
IsNumb
()) {

15  

("Oyrgumshould b ieg.", 
out
);

18 
	ggb
 = 
N
::
To
<
t32_t
>(
w_v
[0]).
FromJu
();

19 
	ga
 = ()((
gb
 >> 030) & 0xff) / 0xff;

20 
	gr
 = ()((
gb
 >> 020) & 0xff);

21 
	gg
 = ()((
gb
 >> 010) & 0xff);

22 
	gb
 = ()(
gb
 & 0xff);

26 i(!
w_v
[3]->
IsNumb
()) {

27  

("Cڡru܇rgumtshould bnumbexusivy.", 
out
);

30 
	ga
 = 
N
::
To
<>(
w_v
[3]).
FromJu
();

34 i(!
w_v
[0]->
IsNumb
() || !raw_val[1]->IsNumber() || !raw_val[2]->IsNumber()) {

35  

("Cڡru܇rgumtshould bnumbexusivy.", 
out
);

38 
	gr
 = 
N
::
To
<>(
w_v
[0]).
FromJu
();

39 
	gg
 = 
N
::
To
<>(
w_v
[1]).
FromJu
();

40 
	gb
 = 
N
::
To
<>(
w_v
[2]).
FromJu
();

47  

("Cڡru should bvoked whh 0, 1, 3 o4rgumts.", 
out
);

50  *
	gout
 = 
ss_make_c
(
r
, 
g
, 
b
, 
a
);

53 
	gC
::
Pry
(
v8
::
Lol
<v8::
FuniTeme
> 
o
) {

54 
N
::
SPryMhod
(
o
, "gR", 
GR
);

55 
	gN
::
SPryMhod
(
o
, "gG", 
GG
);

56 
	gN
::
SPryMhod
(
o
, "gB", 
GB
);

57 
	gN
::
SPryMhod
(
o
, "gA", 
GA
);

58 
	gN
::
SPryMhod
(
o
, "tR", 
SR
);

59 
	gN
::
SPryMhod
(
o
, "tG", 
SG
);

60 
	gN
::
SPryMhod
(
o
, "tB", 
SB
);

61 
	gN
::
SPryMhod
(
o
, "tA", 
SA
);

64 
NAN_METHOD
(
C
::
GR
) {

65 
fo
.
GRuVue
().
S
(
ss_c_g_r
(
unwp
(fo.
This
())->
vue
));

68 
NAN_METHOD
(
C
::
GG
) {

69 
fo
.
GRuVue
().
S
(
ss_c_g_g
(
unwp
(fo.
This
())->
vue
));

72 
NAN_METHOD
(
C
::
GB
) {

73 
fo
.
GRuVue
().
S
(
ss_c_g_b
(
unwp
(fo.
This
())->
vue
));

76 
NAN_METHOD
(
C
::
GA
) {

77 
fo
.
GRuVue
().
S
(
ss_c_g_a
(
unwp
(fo.
This
())->
vue
));

80 
NAN_METHOD
(
C
::
SR
) {

81 i(
fo
.
Lgth
() != 1) {

82  
N
::
ThrowTyE
("Expected just onergument");

85 i(!
	gfo
[0]->
IsNumb
()) {

86  
	gN
::
ThrowTyE
("Supplied value should beumber");

89 
ss_c_t_r
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<>(fo[0]).
FromJu
());

92 
NAN_METHOD
(
C
::
SG
) {

93 i(
fo
.
Lgth
() != 1) {

94  
N
::
ThrowTyE
("Expected just onergument");

97 i(!
	gfo
[0]->
IsNumb
()) {

98  
	gN
::
ThrowTyE
("Supplied value should beumber");

101 
ss_c_t_g
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<>(fo[0]).
FromJu
());

104 
NAN_METHOD
(
C
::
SB
) {

105 i(
fo
.
Lgth
() != 1) {

106  
N
::
ThrowTyE
("Expected just onergument");

109 i(!
	gfo
[0]->
IsNumb
()) {

110  
	gN
::
ThrowTyE
("Supplied value should beumber");

113 
ss_c_t_b
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<>(fo[0]).
FromJu
());

116 
NAN_METHOD
(
C
::
SA
) {

117 i(
fo
.
Lgth
() != 1) {

118  
N
::
ThrowTyE
("Expected just onergument");

121 i(!
	gfo
[0]->
IsNumb
()) {

122  
	gN
::
ThrowTyE
("Supplied value should beumber");

125 
ss_c_t_a
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<>(fo[0]).
FromJu
());

	@node_modules/node-sass/src/sass_types/color.h

1 #ide
SASS_TYPES_COLOR_H


2 
	#SASS_TYPES_COLOR_H


	)

4 
	~<n.h
>

5 
	~"ss_vue_w.h
"

7 
mea
 
	gSassTys


9 
ass
 
	gC
 : 
public
 
SassVueW
<
C
> {

10 
public
:

11 
C
(
Sass_Vue
*);

12 cڡ* 
g_cڡru_me
() {  "SassColor"; }

13 
Sass_Vue
* 
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>>, Sass_Value **);

15 
Pry
(
v8
::
Lol
<v8::
FuniTeme
>);

17 
NAN_METHOD
(
GR
);

18 
NAN_METHOD
(
GG
);

19 
NAN_METHOD
(
GB
);

20 
NAN_METHOD
(
GA
);

21 
NAN_METHOD
(
SR
);

22 
NAN_METHOD
(
SG
);

23 
NAN_METHOD
(
SB
);

24 
NAN_METHOD
(
SA
);

	@node_modules/node-sass/src/sass_types/error.cpp

1 
	~<n.h
>

2 
	~"r.h
"

3 
	~"../_rg.h
"

5 
mea
 
	gSassTys


7 
	gE
::
E
(
Sass_Vue
* 
v
: 
SassVueW
(v) {}

9 
Sass_Vue
* 
E
::
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
w_v
, Sass_Vu**
out
) {

10 cڡ* 
	gvue
 = "";

12 i(
	gw_v
.
size
() >= 1) {

13 i(!
w_v
[0]->
IsSg
()) {

14  

("Argumshould brg.", 
out
);

17 
	gvue
 = 
_rg
(
w_v
[0]);

20  *
	gout
 = 
ss_make_r
(
vue
);

23 
	gE
::
Pry
(
v8
::
Lol
<v8::
FuniTeme
>) {}

	@node_modules/node-sass/src/sass_types/error.h

1 #ide
SASS_TYPES_ERROR_H


2 
	#SASS_TYPES_ERROR_H


	)

4 
	~<n.h
>

5 
	~"ss_vue_w.h
"

7 
mea
 
	gSassTys


9 
ass
 
	gE
 : 
public
 
SassVueW
<
E
> {

10 
public
:

11 
E
(
Sass_Vue
*);

12 cڡ* 
g_cڡru_me
() {  "SassError"; }

13 
Sass_Vue
* 
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>>, Sass_Value **);

15 
Pry
(
v8
::
Lol
<v8::
FuniTeme
>);

	@node_modules/node-sass/src/sass_types/factory.cpp

1 
	~<n.h
>

2 
	~"y.h
"

3 
	~"vue.h
"

4 
	~"numb.h
"

5 
	~"rg.h
"

6 
	~"c.h
"

7 
	~"boޗn.h
"

8 
	~"li.h
"

9 
	~"m.h
"

10 
	~"nu.h
"

11 
	~"r.h
"

13 
mea
 
	gSassTys


15 
	gSassTys
::
Vue
* 
Fay
::

(
Sass_Vue
* 
v
) {

16 
ss_vue_g_g
(
v
)) {

17 
SASS_NUMBER
:

18  
w
 
Numb
(
v
);

20 
	gSASS_STRING
:

21  
w
 
Sg
(
v
);

23 
	gSASS_COLOR
:

24  
w
 
C
(
v
);

26 
	gSASS_BOOLEAN
:

27  &
Boޗn
::
g_sgt
(
ss_boޗn_g_vue
(
v
));

29 
	gSASS_LIST
:

30  
w
 
Li
(
v
);

32 
	gSASS_MAP
:

33  
w
 
M
(
v
);

35 
	gSASS_NULL
:

36  &
Nu
::
g_sgt
();

38 
	gSASS_ERROR
:

39  
w
 
E
(
v
);

42 cڡ *
msg
 = "Unknownypencountered.";

43 
	gN
::
ThrowTyE
(
msg
);

44  
w
 
E
(
ss_make_r
(
msg
));

48 
NAN_MODULE_INIT
(
Fay
::
Expts
) {

49 
N
::
HdSce
 
sce
;

50 
	gv8
::
Lol
<
v8
::
Obje
> 
tys
 = 
N
::
New
<v8::Object>();

52 
	gN
::
S
(
tys
, 
N
::
New
("Numb").
ToLolChecked
(), 
Numb
::
g_cڡru
());

53 
	gN
::
S
(
tys
, 
N
::
New
("Sg").
ToLolChecked
(), 
Sg
::
g_cڡru
());

54 
	gN
::
S
(
tys
, 
N
::
New
("C").
ToLolChecked
(), 
C
::
g_cڡru
());

55 
	gN
::
S
(
tys
, 
N
::
New
("Boޗn").
ToLolChecked
(), 
Boޗn
::
g_cڡru
());

56 
	gN
::
S
(
tys
, 
N
::
New
("Li").
ToLolChecked
(), 
Li
::
g_cڡru
());

57 
	gN
::
S
(
tys
, 
N
::
New
("M").
ToLolChecked
(), 
M
::
g_cڡru
());

58 
	gN
::
S
(
tys
, 
N
::
New
("Nu").
ToLolChecked
(), 
Nu
::
g_cڡru
());

59 
	gN
::
S
(
tys
, 
N
::
New
("E").
ToLolChecked
(), 
E
::
g_cڡru
());

60 
	gN
::
S
(
rg
, 
N
::
New
<
v8
::
Sg
>("tys").
ToLolChecked
(), 
tys
);

63 
Vue
* 
	gFay
::
unwp
(
v8
::
Lol
<v8::Vue> 
obj
) {

65 i(!
obj
->
IsObje
(|| obj.
As
<
v8
::
Obje
>()->
IlFldCou
() != 1) {

66  
NULL
;

69  
	gic_
<
	gVue
*>(
	gN
::
GIlFldPor
(
obj
.
As
<
v8
::
Obje
>(), 0));

	@node_modules/node-sass/src/sass_types/factory.h

1 #ide
SASS_TYPES_FACTORY_H


2 
	#SASS_TYPES_FACTORY_H


	)

4 
	~<n.h
>

5 
	~<ss/vues.h
>

6 
	~"vue.h
"

8 
mea
 
	gSassTys


12 as
	cFay
 {

13 
	gpublic
:

14 
NAN_MODULE_INIT
(
Expts
);

15 
Vue
* 

(
Sass_Vue
*);

16 
Vue
* 
unwp
(
v8
::
Lol
<v8::Value>);

	@node_modules/node-sass/src/sass_types/list.cpp

1 
	~<n.h
>

2 
	~"li.h
"

4 
mea
 
	gSassTys


6 
	gLi
::
Li
(
Sass_Vue
* 
v
: 
SassVueW
(v) {}

8 
Sass_Vue
* 
Li
::
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
w_v
, Sass_Vu**
out
) {

9 
size_t
 
	gngth
 = 0;

10 
bo
 
	gcomma
 = 
ue
;

12 i(
	gw_v
.
size
() >= 1) {

13 i(!
w_v
[0]->
IsNumb
()) {

14  

("Frgumshould b ieg.", 
out
);

17 
	gngth
 = 
N
::
To
<
ut32_t
>(
w_v
[0]).
FromJu
();

19 i(
	gw_v
.
size
() >= 2) {

20 i(!
w_v
[1]->
IsBoޗn
()) {

21  

("Secdrgumshould bboޗn.", 
out
);

24 
	gcomma
 = 
N
::
To
<
bo
>(
w_v
[1]).
FromJu
();

28  *
	gout
 = 
ss_make_li
(
ngth
, 
comma
 ? 
SASS_COMMA
 : 
SASS_SPACE
);

31 
	gLi
::
Pry
(
v8
::
Lol
<v8::
FuniTeme
> 
o
) {

32 
N
::
SPryMhod
(
o
, "gLgth", 
GLgth
);

33 
	gN
::
SPryMhod
(
o
, "gS", 
GS
);

34 
	gN
::
SPryMhod
(
o
, "tS", 
SS
);

35 
	gN
::
SPryMhod
(
o
, "gVue", 
GVue
);

36 
	gN
::
SPryMhod
(
o
, "tVue", 
SVue
);

39 
NAN_METHOD
(
Li
::
GVue
) {

41 i(
fo
.
Lgth
() != 1) {

42  
N
::
ThrowTyE
("Expected just onergument");

45 i(!
	gfo
[0]->
IsNumb
()) {

46  
	gN
::
ThrowTyE
("Supplied index should ben integer");

49 
Sass_Vue
* 
	gli
 = 
unwp
(
fo
.
This
())->
vue
;

50 
size_t
 
	gdex
 = 
N
::
To
<
ut32_t
>(
fo
[0]).
FromJu
();

53 i(
	gdex
 >
ss_li_g_ngth
(
li
)) {

54  
N
::
ThrowRgeE
(N::
New
("Ouobound index").
ToLolChecked
());

57 
	gfo
.
GRuVue
().
S
(
Fay
::

(
ss_li_g_vue
(
li
, 
N
::
To
<
ut32_t
>(
fo
[0]).
FromJu
()))->
g_js_obje
());

60 
NAN_METHOD
(
Li
::
SVue
) {

61 i(
fo
.
Lgth
() != 2) {

62  
N
::
ThrowTyE
("Expectedworguments");

65 i(!
	gfo
[0]->
IsNumb
()) {

66  
	gN
::
ThrowTyE
("Supplied index should ben integer");

69 i(!
	gfo
[1]->
IsObje
()) {

70  
	gN
::
ThrowTyE
("Supplied value should be SassValue object");

73 
Vue
* 
	gss_vue
 = 
Fay
::
unwp
(
fo
[1]);

74 i(
	gss_vue
) {

75 
ss_li_t_vue
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<
ut32_t
>(fo[0]).
FromJu
(), 
ss_vue
->
g_ss_vue
());

77 
	gN
::
ThrowTyE
("A SassValue isxpectedsheist item");

81 
NAN_METHOD
(
Li
::
GS
) {

82 
fo
.
GRuVue
().
S
(
ss_li_g_t
(
unwp
(fo.
This
())->
vue
=
SASS_COMMA
);

85 
NAN_METHOD
(
Li
::
SS
) {

86 i(
fo
.
Lgth
() != 1) {

87  
N
::
ThrowTyE
("Expected just onergument");

90 i(!
	gfo
[0]->
IsBoޗn
()) {

91  
	gN
::
ThrowTyE
("Supplied value should be boolean");

94 
ss_li_t_t
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<
bo
>(fo[0]).
FromJu
(? 
SASS_COMMA
 : 
SASS_SPACE
);

97 
NAN_METHOD
(
Li
::
GLgth
) {

98 
fo
.
GRuVue
().
S
(
N
::
New
<
v8
::
Numb
>(
ss_li_g_ngth
(
unwp
(fo.
This
())->
vue
)));

	@node_modules/node-sass/src/sass_types/list.h

1 #ide
SASS_TYPES_LIST_H


2 
	#SASS_TYPES_LIST_H


	)

4 
	~<n.h
>

5 
	~"ss_vue_w.h
"

7 
mea
 
	gSassTys


9 
ass
 
	gLi
 : 
public
 
SassVueW
<
Li
> {

10 
public
:

11 
Li
(
Sass_Vue
*);

12 cڡ* 
g_cڡru_me
() {  "SassList"; }

13 
Sass_Vue
* 
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>>, Sass_Value **);

15 
Pry
(
v8
::
Lol
<v8::
FuniTeme
>);

17 
NAN_METHOD
(
GVue
);

18 
NAN_METHOD
(
SVue
);

19 
NAN_METHOD
(
GS
);

20 
NAN_METHOD
(
SS
);

21 
NAN_METHOD
(
GLgth
);

	@node_modules/node-sass/src/sass_types/map.cpp

1 
	~<n.h
>

2 
	~"m.h
"

4 
mea
 
	gSassTys


6 
	gM
::
M
(
Sass_Vue
* 
v
: 
SassVueW
(v) {}

8 
Sass_Vue
* 
M
::
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
w_v
, Sass_Vu**
out
) {

9 
size_t
 
	gngth
 = 0;

11 i(
	gw_v
.
size
() >= 1) {

12 i(!
w_v
[0]->
IsNumb
()) {

13  

("Frgumshould b ieg.", 
out
);

16 
	gngth
 = 
N
::
To
<
ut32_t
>(
w_v
[0]).
FromJu
();

19  *
	gout
 = 
ss_make_m
(
ngth
);

22 
	gM
::
Pry
(
v8
::
Lol
<v8::
FuniTeme
> 
o
) {

23 
N
::
SPryMhod
(
o
, "gLgth", 
GLgth
);

24 
	gN
::
SPryMhod
(
o
, "gKey", 
GKey
);

25 
	gN
::
SPryMhod
(
o
, "tKey", 
SKey
);

26 
	gN
::
SPryMhod
(
o
, "gVue", 
GVue
);

27 
	gN
::
SPryMhod
(
o
, "tVue", 
SVue
);

30 
NAN_METHOD
(
M
::
GVue
) {

32 i(
fo
.
Lgth
() != 1) {

33  
N
::
ThrowTyE
("Expected just onergument");

36 i(!
	gfo
[0]->
IsNumb
()) {

37  
	gN
::
ThrowTyE
("Supplied index should ben integer");

40 
Sass_Vue
* 
	gm
 = 
unwp
(
fo
.
This
())->
vue
;

41 
size_t
 
	gdex
 = 
N
::
To
<
ut32_t
>(
fo
[0]).
FromJu
();

44 i(
	gdex
 >
ss_m_g_ngth
(
m
)) {

45  
N
::
ThrowRgeE
(N::
New
("Ouobound index").
ToLolChecked
());

48 
	gfo
.
GRuVue
().
S
(
Fay
::

(
ss_m_g_vue
(
m
, 
N
::
To
<
ut32_t
>(
fo
[0]).
FromJu
()))->
g_js_obje
());

51 
NAN_METHOD
(
M
::
SVue
) {

52 i(
fo
.
Lgth
() != 2) {

53  
N
::
ThrowTyE
("Expectedworguments");

56 i(!
	gfo
[0]->
IsNumb
()) {

57  
	gN
::
ThrowTyE
("Supplied index should ben integer");

60 i(!
	gfo
[1]->
IsObje
()) {

61  
	gN
::
ThrowTyE
("Supplied value should be SassValue object");

64 
Vue
* 
	gss_vue
 = 
Fay
::
unwp
(
fo
[1]);

65 i(
	gss_vue
) {

66 
ss_m_t_vue
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<
ut32_t
>(fo[0]).
FromJu
(), 
ss_vue
->
g_ss_vue
());

68 
	gN
::
ThrowTyE
("A SassValue isxpecteds map value");

72 
NAN_METHOD
(
M
::
GKey
) {

74 i(
fo
.
Lgth
() != 1) {

75  
N
::
ThrowTyE
("Expected just onergument");

78 i(!
	gfo
[0]->
IsNumb
()) {

79  
	gN
::
ThrowTyE
("Supplied index should ben integer");

82 
Sass_Vue
* 
	gm
 = 
unwp
(
fo
.
This
())->
vue
;

83 
size_t
 
	gdex
 = 
N
::
To
<
ut32_t
>(
fo
[0]).
FromJu
();

86 i(
	gdex
 >
ss_m_g_ngth
(
m
)) {

87  
N
::
ThrowRgeE
(N::
New
("Ouobound index").
ToLolChecked
());

90 
	gfo
.
GRuVue
().
S
(
Fay
::

(
ss_m_g_key
(
m
, 
N
::
To
<
ut32_t
>(
fo
[0]).
FromJu
()))->
g_js_obje
());

93 
NAN_METHOD
(
M
::
SKey
) {

94 i(
fo
.
Lgth
() != 2) {

95  
N
::
ThrowTyE
("Expectedworguments");

98 i(!
	gfo
[0]->
IsNumb
()) {

99  
	gN
::
ThrowTyE
("Supplied index should ben integer");

102 i(!
	gfo
[1]->
IsObje
()) {

103  
	gN
::
ThrowTyE
("Supplied value should be SassValue object");

106 
Vue
* 
	gss_vue
 = 
Fay
::
unwp
(
fo
[1]);

107 i(
	gss_vue
) {

108 
ss_m_t_key
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<
ut32_t
>(fo[0]).
FromJu
(), 
ss_vue
->
g_ss_vue
());

110 
	gN
::
ThrowTyE
("A SassValue isxpecteds map key");

114 
NAN_METHOD
(
M
::
GLgth
) {

115 
fo
.
GRuVue
().
S
(
N
::
New
<
v8
::
Numb
>(
ss_m_g_ngth
(
unwp
(fo.
This
())->
vue
)));

	@node_modules/node-sass/src/sass_types/map.h

1 #ide
SASS_TYPES_MAP_H


2 
	#SASS_TYPES_MAP_H


	)

4 
	~<n.h
>

5 
	~"ss_vue_w.h
"

7 
mea
 
	gSassTys


9 
ass
 
	gM
 : 
public
 
SassVueW
<
M
> {

10 
public
:

11 
M
(
Sass_Vue
*);

12 cڡ* 
g_cڡru_me
() {  "SassMap"; }

13 
Sass_Vue
* 
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>>, Sass_Value **);

15 
Pry
(
v8
::
Lol
<v8::
FuniTeme
>);

17 
NAN_METHOD
(
GVue
);

18 
NAN_METHOD
(
SVue
);

19 
NAN_METHOD
(
GKey
);

20 
NAN_METHOD
(
SKey
);

21 
NAN_METHOD
(
GLgth
);

	@node_modules/node-sass/src/sass_types/null.cpp

1 
	~<n.h
>

2 
	~"nu.h
"

4 
mea
 
	gSassTys


6 
	gN
::
Psit
<
v8
::
Funi
> 
Nu
::
cڡru
;

7 
bo
 
	gNu
::
cڡru_locked
 = 
l
;

9 
	gNu
::
Nu
() {}

11 
Nu
& Nu::
g_sgt
() {

12 
Nu
 
sgt_
;

13  
	gsgt_
;

16 
	gv8
::
Lol
<
v8
::
Funi
> 
Nu
::
g_cڡru
() {

17 
N
::
EsbHdSce
 
sce
;

18 
	gv8
::
Lol
<
v8
::
Funi
> 
cڦol
;

19 i(
	gcڡru
.
IsEmy
()) {

20 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
l
 = 
N
::
New
<v8::FunctionTemplate>(New);

22 
	gl
->
SCssName
(
N
::
New
("SassNu").
ToLolChecked
());

23 
	gl
->
InTeme
()->
SIlFldCou
(1);

25 
	gcڦol
 = 
N
::
GFuni
(
l
).
ToLolChecked
();

26 
	gcڡru
.
Ret
(
cڦol
);

28 
g_sgt
().
	gjs_obje
.
Ret
(
N
::
NewIn
(
cڦol
).
ToLolChecked
());

29 
	gN
::
SIlFldPor
(
N
::
New
(
g_sgt
().
js_obje
), 0, &get_singleton());

30 
	gN
::
S
(
cڦol
, 
N
::
New
("NULL").
ToLolChecked
(), N::New(
g_sgt
().
js_obje
));

32 
	gcڡru_locked
 = 
ue
;

34 
	gcڦol
 = 
N
::
New
(
cڡru
);

37  
	gsce
.
Es
(
cڦol
);

40 
Sass_Vue
* 
	gNu
::
g_ss_vue
() {

41  
ss_make_nu
();

44 
	gv8
::
Lol
<
v8
::
Obje
> 
Nu
::
g_js_obje
() {

45  
N
::
New
(
this
->
js_obje
);

48 
NAN_METHOD
(
Nu
::
New
) {

50 i(
fo
.
IsCڡruCl
()) {

51 i(
cڡru_locked
) {

52  
N
::
ThrowTyE
("Cannot instantiate SassNull");

56 
	gfo
.
GRuVue
().
S
(
g_sgt
().
g_js_obje
());

	@node_modules/node-sass/src/sass_types/null.h

1 #ide
SASS_TYPES_NULL_H


2 
	#SASS_TYPES_NULL_H


	)

4 
	~<n.h
>

5 
	~"vue.h
"

7 
mea
 
	gSassTys


9 as
	cNu
 : 
public
 
SassTys
::
Vue
 {

10 
public
:

11 
Nu
& 
g_sgt
();

12 
	gv8
::
Lol
<
v8
::
Funi
> 
g_cڡru
();

14 
Sass_Vue
* 
g_ss_vue
();

15 
	gv8
::
Lol
<
v8
::
Obje
> 
g_js_obje
();

17 
NAN_METHOD
(
New
);

19 
	give
:

20 
Nu
();

22 
	gN
::
Psit
<
v8
::
Obje
> 
js_obje
;

24 
	gN
::
Psit
<
v8
::
Funi
> 
cڡru
;

25 
bo
 
	gcڡru_locked
;

	@node_modules/node-sass/src/sass_types/number.cpp

1 
	~<n.h
>

2 
	~"numb.h
"

3 
	~"../_rg.h
"

5 
mea
 
	gSassTys


7 
	gNumb
::
Numb
(
Sass_Vue
* 
v
: 
SassVueW
(v) {}

9 
Sass_Vue
* 
Numb
::
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
w_v
, Sass_Vu**
out
) {

10 
	gvue
 = 0;

11 cڡ* 
	gun
 = "";

13 i(
	gw_v
.
size
() >= 1) {

14 i(!
w_v
[0]->
IsNumb
()) {

15  

("Frgumshould bnumb.", 
out
);

18 
	gvue
 = 
N
::
To
<>(
w_v
[0]).
FromJu
();

20 i(
	gw_v
.
size
() >= 2) {

21 i(!
w_v
[1]->
IsSg
()) {

22  

("Secdrgumshould brg.", 
out
);

25 
	gun
 = 
_rg
(
w_v
[1]);

29  *
	gout
 = 
ss_make_numb
(
vue
, 
un
);

32 
	gNumb
::
Pry
(
v8
::
Lol
<v8::
FuniTeme
> 
o
) {

33 
N
::
SPryMhod
(
o
, "gVue", 
GVue
);

34 
	gN
::
SPryMhod
(
o
, "gUn", 
GUn
);

35 
	gN
::
SPryMhod
(
o
, "tVue", 
SVue
);

36 
	gN
::
SPryMhod
(
o
, "tUn", 
SUn
);

39 
NAN_METHOD
(
Numb
::
GVue
) {

40 
fo
.
GRuVue
().
S
(
N
::
New
<
v8
::
Numb
>(
ss_numb_g_vue
(
unwp
(fo.
This
())->
vue
)));

43 
NAN_METHOD
(
Numb
::
GUn
) {

44 
fo
.
GRuVue
().
S
(
N
::
New
<
v8
::
Sg
>(
ss_numb_g_un
(
unwp
(fo.
This
())->
vue
)).
ToLolChecked
());

47 
NAN_METHOD
(
Numb
::
SVue
) {

49 i(
fo
.
Lgth
() != 1) {

50  
N
::
ThrowTyE
("Expected just onergument");

53 i(!
	gfo
[0]->
IsNumb
()) {

54  
	gN
::
ThrowTyE
("Supplied value should beumber");

57 
ss_numb_t_vue
(
unwp
(
fo
.
This
())->
vue
, 
N
::
To
<>(fo[0]).
FromJu
());

60 
NAN_METHOD
(
Numb
::
SUn
) {

61 i(
fo
.
Lgth
() != 1) {

62  
N
::
ThrowTyE
("Expected just onergument");

65 i(!
	gfo
[0]->
IsSg
()) {

66  
	gN
::
ThrowTyE
("Supplied value should be string");

69 
ss_numb_t_un
(
unwp
(
fo
.
This
())->
vue
, 
_rg
(info[0]));

	@node_modules/node-sass/src/sass_types/number.h

1 #ide
SASS_TYPES_NUMBER_H


2 
	#SASS_TYPES_NUMBER_H


	)

4 
	~<n.h
>

5 
	~"ss_vue_w.h
"

7 
mea
 
	gSassTys


10 
ass
 
	gNumb
 : 
public
 
SassVueW
<
Numb
> {

11 
public
:

12 
Numb
(
Sass_Vue
*);

13 cڡ* 
g_cڡru_me
() {  "SassNumber"; }

14 
Sass_Vue
* 
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>>, Sass_Vu**
out
);

16 
Pry
(
v8
::
Lol
<v8::
FuniTeme
>);

18 
NAN_METHOD
(
GVue
);

19 
NAN_METHOD
(
GUn
);

20 
NAN_METHOD
(
SVue
);

21 
NAN_METHOD
(
SUn
);

	@node_modules/node-sass/src/sass_types/sass_value_wrapper.h

1 #ide
SASS_TYPES_SASS_VALUE_WRAPPER_H


2 
	#SASS_TYPES_SASS_VALUE_WRAPPER_H


	)

4 
	~<dex
>

5 
	~<ve
>

6 
	~<n.h
>

7 
	~"vue.h
"

8 
	~"y.h
"

10 
mea
 
	gSassTys


14 
	gme
 <
ass
 
	gT
>

15 as
	cSassVueW
 : 
public
 
SassTys
::
Vue
 {

16 
public
:

17 cڡ* 
g_cڡru_me
() {  "SassValue"; }

19 
SassVueW
(
Sass_Vue
*);

20 
	gvtu
 ~
SassVueW
();

22 
Sass_Vue
* 
g_ss_vue
();

23 
	gv8
::
Lol
<
v8
::
Obje
> 
g_js_obje
();

25 
	gv8
::
Lol
<
v8
::
Funi
> 
g_cڡru
();

26 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
g_cڡru_me
();

27 
NAN_METHOD
(
New
);

28 
Sass_Vue
 *

(const *, Sass_Value **);

30 
	geed
:

31 
Sass_Vue
* 
vue
;

32 
T
* 
unwp
(
v8
::
Lol
<v8::
Obje
>);

34 
	give
:

35 
N
::
Psit
<
v8
::
Funi
> 
cڡru
;

36 
	gN
::
Psit
<
v8
::
Obje
> 
js_obje
;

39 
	gme
 <
ass
 
	gT
>

40 
	gN
::
Psit
<
v8
::
Funi
> 
SassVueW
<
T
>::
cڡru
;

42 
	gme
 <
ass
 
	gT
>

43 
	gSassVueW
<
	gT
>::
	$SassVueW
(
Sass_Vue
* 
v
) {

44 
this
->
vue
 = 
	`ss_e_vue
(
v
);

45 
	}
}

47 
	gme
 <
ass
 
	gT
>

48 
	gSassVueW
<
	gT
>::~
	$SassVueW
() {

49 
this
->
js_obje
.
	`Ret
();

50 
	`ss_de_vue
(
this
->
vue
);

51 
	}
}

53 
	gme
 <
ass
 
	gT
>

54 
Sass_Vue
* 
	gSassVueW
<
	gT
>::
	$g_ss_vue
() {

55  
	`ss_e_vue
(
this
->
vue
);

56 
	}
}

58 
	gme
 <
ass
 
	gT
>

59 
	gv8
::
Lol
<
v8
::
Obje
> 
SassVueW
<
T
>::
	$g_js_obje
() {

60 i(
this
->
js_obje
.
	`IsEmy
()) {

61 
v8
::
Lol
<v8::
Obje
> 
w
 = 
N
::
	`NewIn
(
T
::
	`g_cڡru
()).
	`ToLolChecked
();

62 
de
 
ic_
<
T
*>(
N
::
	`GIlFldPor
(
w
, 0));

63 
N
::
	`SIlFldPor
(
w
, 0, 
this
);

64 
this
->
js_obje
.
	`Ret
(
w
);

67  
N
::
	`New
(
this
->
js_obje
);

68 
	}
}

70 
	gme
 <
ass
 
	gT
>

71 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
SassVueW
<
T
>::
	$g_cڡru_me
() {

72 
N
::
EsbHdSce
 
sce
;

73 
v8
::
Lol
<v8::
FuniTeme
> 
l
 = 
N
::
New
<v8::FunctionTemplate>(New);

74 
l
->
	`SCssName
(
N
::
New
<
v8
::
Sg
>(
T
::
	`g_cڡru_me
()).
	`ToLolChecked
());

75 
l
->
	`InTeme
()->
	`SIlFldCou
(1);

76 
T
::
	`Pry
(
l
);

78  
sce
.
	`Es
(
l
);

79 
	}
}

81 
	gme
 <
ass
 
	gT
>

82 
	gv8
::
Lol
<
v8
::
Funi
> 
SassVueW
<
T
>::
	$g_cڡru
() {

83 i(
cڡru
.
	`IsEmy
()) {

84 
cڡru
.
	`Ret
(
N
::
	`GFuni
(
T
::
	`g_cڡru_me
()).
	`ToLolChecked
());

87  
N
::
	`New
(
cڡru
);

88 
	}
}

90 
	gme
 <
ass
 
	gT
>

91 
NAN_METHOD
(
SassVueW
<
T
>::
New
) {

92 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
lolArgs
(
fo
.
Lgth
());

94 aut
	gi
 = 0; i < 
	gfo
.
Lgth
(); ++i) {

95 
	glolArgs
[
i
] = 
fo
[i];

97 i(
	gfo
.
IsCڡruCl
()) {

98 
Sass_Vue
* 
	gvue
;

99 i(
	gT
::
cڡru
(
lolArgs
, &
vue
!
NULL
) {

100 
T
* 
obj
 = 
w
 T(
vue
);

101 
ss_de_vue
(
vue
);

103 
	gN
::
SIlFldPor
(
fo
.
This
(), 0, 
obj
);

104 
	gobj
->
	gjs_obje
.
Ret
(
fo
.
This
());

106  
	gN
::
ThrowE
(
N
::
New
<
v8
::
Sg
>(
ss_r_g_mesge
(
vue
)).
ToLolChecked
());

109 
	gv8
::
Lol
<
v8
::
Funi
> 
cs
 = 
T
::
g_cڡru
();

110 
	gv8
::
Lol
<
v8
::
Obje
> 

;

111 i(
	gN
::
NewIn
(
cs
, 
fo
.
Lgth
(), &
lolArgs
[0]).
ToLol
(&

)) {

112 
	gfo
.
GRuVue
().
S
(

);

114 
	gfo
.
GRuVue
().
S
(
N
::
Undefed
());

119 
	gme
 <
ass
 
	gT
>

120 
T
* 
	gSassVueW
<
	gT
>::
unwp
(
v8
::
Lol
<v8::
Obje
> 
obj
) {

122  
ic_
<
T
*>(
Fay
::
unwp
(
obj
));

125 
	gme
 <
ass
 
	gT
>

126 
Sass_Vue
 *
	gSassVueW
<
	gT
>::
	$
(cڡ *
as
, 
Sass_Vue
 **
out
) {

127 *
out
 = 
	`ss_make_r
(
as
);

128  
NULL
;

129 
	}
}

	@node_modules/node-sass/src/sass_types/string.cpp

1 
	~<n.h
>

2 
	~"rg.h
"

3 
	~"../_rg.h
"

5 
mea
 
	gSassTys


7 
	gSg
::
Sg
(
Sass_Vue
* 
v
: 
SassVueW
(v) {}

9 
Sass_Vue
* 
Sg
::
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>> 
w_v
, Sass_Vu**
out
) {

10 cڡ* 
	gvue
 = "";

12 i(
	gw_v
.
size
() >= 1) {

13 i(!
w_v
[0]->
IsSg
()) {

14  

("Argumshould brg.", 
out
);

17 
	gvue
 = 
_rg
(
w_v
[0]);

20  *
	gout
 = 
ss_make_rg
(
vue
);

23 
	gSg
::
Pry
(
v8
::
Lol
<v8::
FuniTeme
> 
o
) {

24 
N
::
SPryMhod
(
o
, "gVue", 
GVue
);

25 
	gN
::
SPryMhod
(
o
, "tVue", 
SVue
);

28 
NAN_METHOD
(
Sg
::
GVue
) {

29 
fo
.
GRuVue
().
S
(
N
::
New
<
v8
::
Sg
>(
ss_rg_g_vue
(
unwp
(fo.
This
())->
vue
)).
ToLolChecked
());

32 
NAN_METHOD
(
Sg
::
SVue
) {

33 i(
fo
.
Lgth
() != 1) {

34  
N
::
ThrowTyE
("Expected just onergument");

37 i(!
	gfo
[0]->
IsSg
()) {

38  
	gN
::
ThrowTyE
("Supplied value should be string");

41 
ss_rg_t_vue
(
unwp
(
fo
.
This
())->
vue
, 
_rg
(info[0]));

	@node_modules/node-sass/src/sass_types/string.h

1 #ide
SASS_TYPES_STRING_H


2 
	#SASS_TYPES_STRING_H


	)

4 
	~<n.h
>

5 
	~"ss_vue_w.h
"

7 
mea
 
	gSassTys


9 
ass
 
	gSg
 : 
public
 
SassVueW
<
Sg
> {

10 
public
:

11 
Sg
(
Sass_Vue
*);

12 cڡ* 
g_cڡru_me
() {  "SassString"; }

13 
Sass_Vue
* 
cڡru
(cڡ 
d
::
ve
<
v8
::
Lol
<v8::
Vue
>>, Sass_Value **);

15 
Pry
(
v8
::
Lol
<v8::
FuniTeme
>);

17 
NAN_METHOD
(
GVue
);

18 
NAN_METHOD
(
SVue
);

	@node_modules/node-sass/src/sass_types/value.h

1 #ide
SASS_TYPES_VALUE_H


2 
	#SASS_TYPES_VALUE_H


	)

4 
	~<n.h
>

5 
	~<ss/vues.h
>

7 
mea
 
	gSassTys


10 as
	cVue
 {

11 
	gpublic
:

12 
vtu
 
Sass_Vue
* 
g_ss_vue
() =0;

13 
vtu
 
	gv8
::
Lol
<
v8
::
Obje
> 
g_js_obje
() =0;

	@node_modules/node-uuid/benchmark/benchmark-native.c

7 
	~<dio.h
>

8 
	~<unid.h
>

9 
	~<sys/time.h
>

10 
	~<uuid/uuid.h
>

12 
	$ma
() {

13 
uuid_t
 
myid
;

14 
buf
[36+1];

15 
i
;

16 
timev
 
t
;

17 
t
, 
fish
;

19 
	`gtimeofday
(&
t
, 
NULL
);

20 
t
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

22 
n
 = 2e5;

23 
i
 = 0; i < 
n
; i++) {

24 
	`uuid_ge
(
myid
);

25 
	`uuid_uŬ
(
myid
, 
buf
);

28 
	`gtimeofday
(&
t
, 
NULL
);

29 
fish
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

30 
dur
 = 
fish
 - 
t
;

32 
	`tf
("%d uuids/c", ()(
n
/
dur
));

34 
	}
}

	@node_modules/uuid/benchmark/benchmark-native.c

7 
	~<dio.h
>

8 
	~<unid.h
>

9 
	~<sys/time.h
>

10 
	~<uuid/uuid.h
>

12 
	$ma
() {

13 
uuid_t
 
myid
;

14 
buf
[36+1];

15 
i
;

16 
timev
 
t
;

17 
t
, 
fish
;

19 
	`gtimeofday
(&
t
, 
NULL
);

20 
t
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

22 
n
 = 2e5;

23 
i
 = 0; i < 
n
; i++) {

24 
	`uuid_ge
(
myid
);

25 
	`uuid_uŬ
(
myid
, 
buf
);

28 
	`gtimeofday
(&
t
, 
NULL
);

29 
fish
 = 
t
.
tv_c
 +.
tv_uc
/1e6;

30 
dur
 = 
fish
 - 
t
;

32 
	`tf
("%d uuids/c", ()(
n
/
dur
));

34 
	}
}

	@
1
.
0
201
11485
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/fsevents.cc
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_callbacks.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_callbacks_12_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_callbacks_pre_12_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_converters.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_converters_43_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_converters_pre_43_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_implementation_12_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_implementation_pre_12_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_maybe_43_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_maybe_pre_43_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_new.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_object_wrap.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_persistent_12_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_persistent_pre_12_inl.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_string_bytes.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_typedarray_contents.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/nan/nan_weak.h
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark-native.c
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/async.cc
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/constants.cc
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/locking.cc
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/methods.cc
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/storage.cc
node_modules/browser-sync/node_modules/chokidar/node_modules/fsevents/src/thread.cc
node_modules/browser-sync/node_modules/localtunnel/node_modules/request/node_modules/node-uuid/benchmark/benchmark-native.c
node_modules/fsevents/fsevents.cc
node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark-native.c
node_modules/fsevents/src/async.cc
node_modules/fsevents/src/constants.cc
node_modules/fsevents/src/locking.cc
node_modules/fsevents/src/methods.cc
node_modules/fsevents/src/storage.cc
node_modules/fsevents/src/thread.cc
node_modules/less/node_modules/request/node_modules/node-uuid/benchmark/benchmark-native.c
node_modules/nan/nan.h
node_modules/nan/nan_callbacks.h
node_modules/nan/nan_callbacks_12_inl.h
node_modules/nan/nan_callbacks_pre_12_inl.h
node_modules/nan/nan_converters.h
node_modules/nan/nan_converters_43_inl.h
node_modules/nan/nan_converters_pre_43_inl.h
node_modules/nan/nan_implementation_12_inl.h
node_modules/nan/nan_implementation_pre_12_inl.h
node_modules/nan/nan_maybe_43_inl.h
node_modules/nan/nan_maybe_pre_43_inl.h
node_modules/nan/nan_new.h
node_modules/nan/nan_object_wrap.h
node_modules/nan/nan_persistent_12_inl.h
node_modules/nan/nan_persistent_pre_12_inl.h
node_modules/nan/nan_string_bytes.h
node_modules/nan/nan_typedarray_contents.h
node_modules/nan/nan_weak.h
node_modules/node-gyp/gyp/data/win/large-pdb-shim.cc
node_modules/node-gyp/src/win_delay_load_hook.c
node_modules/node-sass/src/binding.cpp
node_modules/node-sass/src/callback_bridge.h
node_modules/node-sass/src/create_string.cpp
node_modules/node-sass/src/create_string.h
node_modules/node-sass/src/custom_function_bridge.cpp
node_modules/node-sass/src/custom_function_bridge.h
node_modules/node-sass/src/custom_importer_bridge.cpp
node_modules/node-sass/src/custom_importer_bridge.h
node_modules/node-sass/src/libsass/contrib/plugin.cpp
node_modules/node-sass/src/libsass/include/sass.h
node_modules/node-sass/src/libsass/include/sass/base.h
node_modules/node-sass/src/libsass/include/sass/context.h
node_modules/node-sass/src/libsass/include/sass/functions.h
node_modules/node-sass/src/libsass/include/sass/values.h
node_modules/node-sass/src/libsass/include/sass/version.h
node_modules/node-sass/src/libsass/include/sass2scss.h
node_modules/node-sass/src/libsass/src/ast.cpp
node_modules/node-sass/src/libsass/src/ast.hpp
node_modules/node-sass/src/libsass/src/ast_def_macros.hpp
node_modules/node-sass/src/libsass/src/ast_factory.hpp
node_modules/node-sass/src/libsass/src/ast_fwd_decl.hpp
node_modules/node-sass/src/libsass/src/b64/cencode.h
node_modules/node-sass/src/libsass/src/b64/encode.h
node_modules/node-sass/src/libsass/src/backtrace.hpp
node_modules/node-sass/src/libsass/src/base64vlq.cpp
node_modules/node-sass/src/libsass/src/base64vlq.hpp
node_modules/node-sass/src/libsass/src/bind.cpp
node_modules/node-sass/src/libsass/src/bind.hpp
node_modules/node-sass/src/libsass/src/c99func.c
node_modules/node-sass/src/libsass/src/cencode.c
node_modules/node-sass/src/libsass/src/color_maps.cpp
node_modules/node-sass/src/libsass/src/color_maps.hpp
node_modules/node-sass/src/libsass/src/constants.cpp
node_modules/node-sass/src/libsass/src/constants.hpp
node_modules/node-sass/src/libsass/src/context.cpp
node_modules/node-sass/src/libsass/src/context.hpp
node_modules/node-sass/src/libsass/src/cssize.cpp
node_modules/node-sass/src/libsass/src/cssize.hpp
node_modules/node-sass/src/libsass/src/debug.hpp
node_modules/node-sass/src/libsass/src/debugger.hpp
node_modules/node-sass/src/libsass/src/emitter.cpp
node_modules/node-sass/src/libsass/src/emitter.hpp
node_modules/node-sass/src/libsass/src/environment.cpp
node_modules/node-sass/src/libsass/src/environment.hpp
node_modules/node-sass/src/libsass/src/error_handling.cpp
node_modules/node-sass/src/libsass/src/error_handling.hpp
node_modules/node-sass/src/libsass/src/eval.cpp
node_modules/node-sass/src/libsass/src/eval.hpp
node_modules/node-sass/src/libsass/src/expand.cpp
node_modules/node-sass/src/libsass/src/expand.hpp
node_modules/node-sass/src/libsass/src/extend.cpp
node_modules/node-sass/src/libsass/src/extend.hpp
node_modules/node-sass/src/libsass/src/file.cpp
node_modules/node-sass/src/libsass/src/file.hpp
node_modules/node-sass/src/libsass/src/functions.cpp
node_modules/node-sass/src/libsass/src/functions.hpp
node_modules/node-sass/src/libsass/src/inspect.cpp
node_modules/node-sass/src/libsass/src/inspect.hpp
node_modules/node-sass/src/libsass/src/json.cpp
node_modules/node-sass/src/libsass/src/json.hpp
node_modules/node-sass/src/libsass/src/kwd_arg_macros.hpp
node_modules/node-sass/src/libsass/src/lexer.cpp
node_modules/node-sass/src/libsass/src/lexer.hpp
node_modules/node-sass/src/libsass/src/listize.cpp
node_modules/node-sass/src/libsass/src/listize.hpp
node_modules/node-sass/src/libsass/src/mapping.hpp
node_modules/node-sass/src/libsass/src/memory_manager.cpp
node_modules/node-sass/src/libsass/src/memory_manager.hpp
node_modules/node-sass/src/libsass/src/node.cpp
node_modules/node-sass/src/libsass/src/node.hpp
node_modules/node-sass/src/libsass/src/operation.hpp
node_modules/node-sass/src/libsass/src/output.cpp
node_modules/node-sass/src/libsass/src/output.hpp
node_modules/node-sass/src/libsass/src/parser.cpp
node_modules/node-sass/src/libsass/src/parser.hpp
node_modules/node-sass/src/libsass/src/paths.hpp
node_modules/node-sass/src/libsass/src/plugins.cpp
node_modules/node-sass/src/libsass/src/plugins.hpp
node_modules/node-sass/src/libsass/src/position.cpp
node_modules/node-sass/src/libsass/src/position.hpp
node_modules/node-sass/src/libsass/src/prelexer.cpp
node_modules/node-sass/src/libsass/src/prelexer.hpp
node_modules/node-sass/src/libsass/src/remove_placeholders.cpp
node_modules/node-sass/src/libsass/src/remove_placeholders.hpp
node_modules/node-sass/src/libsass/src/sass.cpp
node_modules/node-sass/src/libsass/src/sass.hpp
node_modules/node-sass/src/libsass/src/sass2scss.cpp
node_modules/node-sass/src/libsass/src/sass_context.cpp
node_modules/node-sass/src/libsass/src/sass_context.hpp
node_modules/node-sass/src/libsass/src/sass_functions.cpp
node_modules/node-sass/src/libsass/src/sass_functions.hpp
node_modules/node-sass/src/libsass/src/sass_util.cpp
node_modules/node-sass/src/libsass/src/sass_util.hpp
node_modules/node-sass/src/libsass/src/sass_values.cpp
node_modules/node-sass/src/libsass/src/sass_values.hpp
node_modules/node-sass/src/libsass/src/source_map.cpp
node_modules/node-sass/src/libsass/src/source_map.hpp
node_modules/node-sass/src/libsass/src/subset_map.hpp
node_modules/node-sass/src/libsass/src/to_c.cpp
node_modules/node-sass/src/libsass/src/to_c.hpp
node_modules/node-sass/src/libsass/src/to_value.cpp
node_modules/node-sass/src/libsass/src/to_value.hpp
node_modules/node-sass/src/libsass/src/units.cpp
node_modules/node-sass/src/libsass/src/units.hpp
node_modules/node-sass/src/libsass/src/utf8.h
node_modules/node-sass/src/libsass/src/utf8/checked.h
node_modules/node-sass/src/libsass/src/utf8/core.h
node_modules/node-sass/src/libsass/src/utf8/unchecked.h
node_modules/node-sass/src/libsass/src/utf8_string.cpp
node_modules/node-sass/src/libsass/src/utf8_string.hpp
node_modules/node-sass/src/libsass/src/util.cpp
node_modules/node-sass/src/libsass/src/util.hpp
node_modules/node-sass/src/libsass/src/values.cpp
node_modules/node-sass/src/libsass/src/values.hpp
node_modules/node-sass/src/libsass/test/test_node.cpp
node_modules/node-sass/src/libsass/test/test_paths.cpp
node_modules/node-sass/src/libsass/test/test_selector_difference.cpp
node_modules/node-sass/src/libsass/test/test_specificity.cpp
node_modules/node-sass/src/libsass/test/test_subset_map.cpp
node_modules/node-sass/src/libsass/test/test_superselector.cpp
node_modules/node-sass/src/libsass/test/test_unification.cpp
node_modules/node-sass/src/sass_context_wrapper.cpp
node_modules/node-sass/src/sass_context_wrapper.h
node_modules/node-sass/src/sass_types/boolean.cpp
node_modules/node-sass/src/sass_types/boolean.h
node_modules/node-sass/src/sass_types/color.cpp
node_modules/node-sass/src/sass_types/color.h
node_modules/node-sass/src/sass_types/error.cpp
node_modules/node-sass/src/sass_types/error.h
node_modules/node-sass/src/sass_types/factory.cpp
node_modules/node-sass/src/sass_types/factory.h
node_modules/node-sass/src/sass_types/list.cpp
node_modules/node-sass/src/sass_types/list.h
node_modules/node-sass/src/sass_types/map.cpp
node_modules/node-sass/src/sass_types/map.h
node_modules/node-sass/src/sass_types/null.cpp
node_modules/node-sass/src/sass_types/null.h
node_modules/node-sass/src/sass_types/number.cpp
node_modules/node-sass/src/sass_types/number.h
node_modules/node-sass/src/sass_types/sass_value_wrapper.h
node_modules/node-sass/src/sass_types/string.cpp
node_modules/node-sass/src/sass_types/string.h
node_modules/node-sass/src/sass_types/value.h
node_modules/node-uuid/benchmark/benchmark-native.c
node_modules/uuid/benchmark/benchmark-native.c
